/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../client/src/js/AutoBindMethods.js":
/*!*******************************************!*\
  !*** ../client/src/js/AutoBindMethods.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AutoBindMethods; });
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AutoBindMethods = function AutoBindMethods() {
  var _this = this;

  _classCallCheck(this, AutoBindMethods);

  var functionNames = [];
  var obj = Object.getPrototypeOf(this);

  while (obj) {
    if (obj === Object.prototype || obj === AutoBindMethods.prototype) {
      obj = Object.getPrototypeOf(obj);
      continue;
    }

    functionNames = functionNames.concat(Object.getOwnPropertyNames(obj).filter(function (name) {
      return name !== 'constructor' && functionNames.indexOf(name) === -1 && typeof _this[name] === 'function';
    }));
    obj = Object.getPrototypeOf(obj);
  }

  var _iterator = _createForOfIteratorHelper(functionNames),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var functionName = _step.value;
      this[functionName] = this[functionName].bind(this);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};



/***/ }),

/***/ "../client/src/js/Camera.js":
/*!**********************************!*\
  !*** ../client/src/js/Camera.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Camera; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Camera = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Camera, _AutoBindMethods);

  var _super = _createSuper(Camera);

  /**
   * @param {Scene} scene
   */
  function Camera(scene) {
    var _this;

    _classCallCheck(this, Camera);

    _this = _super.call(this);
    _this.scene = scene;

    var ratio = _this.getWidth() / _this.getHeight();

    _this.camera = new THREE.PerspectiveCamera(45, ratio, 1, 100);

    _this.camera.position.set(5, 3, 15);

    _this.deltaY = 10;
    _this.rotateY = 0.25;
    _this.defaultDistance = 10;
    _this.distance = _this.defaultDistance;
    _this.raycaster = new THREE.Raycaster();
    return _this;
  }

  _createClass(Camera, [{
    key: "update",
    value: function update(gameTime, deltaTime) {
      var input = this.scene.input;
      var player = this.scene.getPlayer();
      if (!player) return; // Enabled if "F" is pressed

      if (input.look.cinematic) {
        this.camera.position.set(-40, 15, 10);
        this.camera.lookAt(new THREE.Vector3(-50, 0, 0));
        return;
      }

      var rotateY = this.rotateY + input.look.sensitivity * input.look.vertical / 2000;

      if (rotateY > -0.75 && rotateY < 1.25) {
        this.rotateY = rotateY;
      }

      if (input.isThirdPerson) {
        this.updateThirdPerson(player);
      } else {
        this.camera.position.copy(player.position.clone().add(new THREE.Vector3(7.5, this.deltaY, 0)));
        this.camera.lookAt(player.position);
      }
    }
  }, {
    key: "addY",
    value: function addY(y) {
      if (this.deltaY + y > 1 && this.deltaY + y < 25) {
        this.deltaY += y;
      }
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      var renderer = this.scene.renderer.renderer;
      return renderer.getContext().canvas.width;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      var renderer = this.scene.renderer.renderer;
      return renderer.getContext().canvas.height;
    }
  }, {
    key: "updateThirdPerson",
    value: function updateThirdPerson(player) {
      var _this2 = this;

      var children = this.scene.scene.children,
          deltaY = this.deltaY,
          playerHeadPosition = player.position.clone().add(new THREE.Vector3(0, 1.5, 0)),
          origin = playerHeadPosition,
          destination = this.camera.position,
          direction = new THREE.Vector3();

      var getChildrenFlat = function getChildrenFlat(objects) {
        var _ref;

        return (_ref = []).concat.apply(_ref, _toConsumableArray(objects.map(function (obj) {
          return obj.children ? [obj].concat(_toConsumableArray(getChildrenFlat(obj.children))) : [obj];
        })));
      };

      var environment = [children.find(function (c) {
        return c.name === 'LEVEL_ENVIRONMENT';
      })];
      var flatChildrenMeshes = getChildrenFlat(environment).filter(function (obj) {
        return obj.type === 'Mesh';
      });
      this.raycaster.set(origin, direction.subVectors(destination, origin).normalize());
      this.raycaster.far = deltaY * 1.5;
      var intersects = this.raycaster.intersectObjects(flatChildrenMeshes);
      var distance = Math.min.apply(Math, [deltaY].concat(_toConsumableArray(intersects.map(function (i) {
        return i.distance - _this2.distance * 0.5;
      }))));
      this.distance += (distance - this.distance) / 2;
      var playerForward = player.getForward().multiplyScalar(this.scene.input.look.back ? 1 : -1);
      playerForward.y = this.rotateY;
      this.camera.position.copy(playerHeadPosition.clone().add(playerForward));
      this.camera.lookAt(playerHeadPosition);
      var cameraForward = new THREE.Vector3(0, 0, -1);
      cameraForward.applyQuaternion(this.camera.quaternion);
      this.camera.position.sub(cameraForward.multiplyScalar(this.distance));
    }
  }, {
    key: "toScreenPosition",
    value: function toScreenPosition(position) {
      var widthHalf = 0.5 * this.getWidth();
      var heightHalf = 0.5 * this.getHeight();
      var copiedProjectVector = position.clone().project(this.camera);
      return {
        x: Math.round((copiedProjectVector.x + 1) * widthHalf),
        y: Math.round((-copiedProjectVector.y + 1) * heightHalf),
        z: copiedProjectVector.z
      };
    }
  }]);

  return Camera;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Colliders.js":
/*!*************************************!*\
  !*** ../client/src/js/Colliders.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Colliders; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Colliders = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Colliders, _AutoBindMethods);

  var _super = _createSuper(Colliders);

  function Colliders(scene) {
    var _this;

    _classCallCheck(this, Colliders);

    _this = _super.call(this);
    _this.scene = scene;
    _this.colliders = [];
    _this.nextId = 0;
    return _this;
  }

  _createClass(Colliders, [{
    key: "checkWay",
    value: function checkWay(position, gameObject) {
      var _iterator = _createForOfIteratorHelper(this.colliders),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var collider = _step.value;

          if (collider.fn(position, gameObject)) {
            return false;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return true;
    }
  }, {
    key: "resetColliders",
    value: function resetColliders() {
      this.colliders = [];
    }
  }, {
    key: "removeCollider",
    value: function removeCollider(id) {
      var idx = this.colliders.findIndex(function (c) {
        return c.id === id;
      });

      if (idx > -1) {
        this.colliders.splice(idx, 1);
      }
    }
  }, {
    key: "addColliderFunction",
    value: function addColliderFunction(fn) {
      this.colliders.push({
        id: this.nextId++,
        fn: fn
      });
      this.scene.pathFinder.rebuildAreas();
    }
  }]);

  return Colliders;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Connection.js":
/*!**************************************!*\
  !*** ../client/src/js/Connection.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Connection; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _GameObjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObjects */ "../client/src/js/GameObjects.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Connection = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Connection, _AutoBindMethods);

  var _super = _createSuper(Connection);

  /**
   * @param {Scene} scene
   * @param {string|number} ip
   * @param {string|number} port
   * @param {boolean} isSecure
   */
  function Connection(scene) {
    var _this;

    var ip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'localhost';
    var port = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '1337';
    var isSecure = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    _classCallCheck(this, Connection);

    _this = _super.call(this);
    _this.scene = scene;
    _this.meta = {};
    _this.networkPlayers = {};
    _this.networkAIs = {};
    var WebSocket = window.WebSocket || window.MozWebSocket;
    _this.connection = new WebSocket("".concat(isSecure ? 'wss' : 'ws', "://").concat(ip, ":").concat(port));

    _this.connection.onopen = function () {
      return console.log('open connection');
    };

    _this.connection.onerror = function (error) {
      return console.log('error connection', error);
    };

    _this.connection.onmessage = _this.onMessage;
    return _this;
  }

  _createClass(Connection, [{
    key: "update",
    value: function update(time, deltaTime) {
      this.sendGameObjects();
    }
  }, {
    key: "onMessage",
    value: function onMessage(_ref) {
      var data = _ref.data;

      /**
       * @param {object} meta
       * @param {any} response
       * @param {string} messageType
       */
      var _JSON$parse = JSON.parse(data),
          meta = _JSON$parse.meta,
          response = _JSON$parse.data,
          messageType = _JSON$parse.messageType;

      if (meta.role && this.meta.role !== meta.role) {
        this.scene.ui.setConnectionRole(meta.role);

        if (this.meta.role && meta.role === 'host') {
          this.hostUnitsFromNetwork();
        } else if (!this.meta.debug) {
          this.clearLocalGameObjects();
        }
      }

      this.meta = meta;

      try {
        switch (messageType) {
          case 'handshake':
            {
              this.processHandshake();
              break;
            }

          case 'restartServer':
            {
              window.location.reload();
              break;
            }

          case 'setUserPlayer':
            {
              var player = this.scene.getPlayer();

              if (player) {
                this.setPlayerParams(player, response);
              } else {
                this.scene.units.setDefaultPlayerParams(response);
              }

              break;
            }

          case 'updateGameObjects':
            {
              this.updateGameObjects(response);
              break;
            }

          case 'disconnected':
            {
              this.removeDisconnectedPlayer(response);
              break;
            }
        }
      } catch (e) {
        console.log('Connection error', e);
      }
    }
  }, {
    key: "takeHost",
    value: function takeHost() {
      this.send('takeHost');
    }
  }, {
    key: "restartServer",
    value: function restartServer() {
      this.send('restartServer');
    } // There is race condition between
    // clearLocalGameObjects and Location.createInteractiveGameObjects

  }, {
    key: "clearLocalGameObjects",
    value: function clearLocalGameObjects() {
      var gameObjectsService = this.scene.gameObjectsService;
      var player = this.scene.getPlayer(); // Clear local gameObjects to replace them by network units (except player)

      gameObjectsService.getUnits().forEach(function (unit) {
        if (!unit.params.fromNetwork && unit !== player) {
          gameObjectsService.destroyGameObject(unit);
        }
      });
    }
  }, {
    key: "send",
    value: function send(messageType, data) {
      var _this$scene$user = this.scene.user,
          userName = _this$scene$user.userName,
          password = _this$scene$user.password;
      var meta = {
        token: this.getHash(userName + password)
      };
      this.connection.send(JSON.stringify({
        messageType: messageType,
        meta: meta,
        data: data
      }));
    }
  }, {
    key: "processHandshake",
    value: function processHandshake() {
      this.send('loadCurrentUser');
    }
  }, {
    key: "updateGameObjects",
    value: function updateGameObjects(gameObjects) {
      var _this2 = this;

      gameObjects.forEach(function (gameObject) {
        switch (gameObject.type) {
          case 'player':
            {
              _this2.updateNetworkPlayer(gameObject);

              break;
            }

          case 'ai':
            {
              _this2.updateNetworkAI(gameObject);

              break;
            }
        }
      });
    }
  }, {
    key: "removeDisconnectedPlayer",
    value: function removeDisconnectedPlayer(_ref2) {
      var connectionId = _ref2.connectionId;
      var gameObjectsService = this.scene.gameObjectsService;
      var disconnectedPlayer = gameObjectsService.getUnits().find(function (unit) {
        return unit instanceof _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"] && unit.params.connectionId === connectionId;
      });
      console.log('Player disconnected', connectionId);

      if (disconnectedPlayer) {
        disconnectedPlayer.die();
      }
    }
    /**
     * @param {String} str
     * @returns {string}
     */

  }, {
    key: "getHash",
    value: function getHash(str) {
      function hash32(str) {
        var i;
        var l;
        var hval = 0x811c9dc5;

        for (i = 0, l = str.length; i < l; i++) {
          hval ^= str.charCodeAt(i);
          hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
        }

        return ("0000000" + (hval >>> 0).toString(16)).substr(-8);
      }

      var h1 = hash32(str);
      return h1 + hash32(h1 + str);
    }
  }, {
    key: "hostUnitsFromNetwork",
    value: function hostUnitsFromNetwork() {
      this.scene.units.getAliveUnits().forEach(function (unit) {
        if (unit.params.fromNetwork) {
          unit.params.fromNetwork = false;
        }
      });
    }
  }, {
    key: "updateNetworkPlayer",
    value: function updateNetworkPlayer(playerData) {
      var _this3 = this;

      var locationName = playerData.locationName,
          position = playerData.position,
          rotation = playerData.rotation,
          animationState = playerData.animationState,
          params = playerData.params;
      var unitNetworkId = playerData.params.unitNetworkId;

      if (unitNetworkId === this.meta.unitNetworkId && !this.meta.debug) {
        return;
      }

      if (locationName !== this.scene.location.getLocationName()) {
        return;
      }
      /**
       * @type Player | string
       */


      var networkPlayer = this.networkPlayers[unitNetworkId];

      if (!networkPlayer) {
        this.networkPlayers[unitNetworkId] = 'loading';
        this.scene.units.createNetworkPlayer(playerData, function (networkPlayer) {
          _this3.networkPlayers[unitNetworkId] = networkPlayer;
        });
      } else if (networkPlayer !== 'loading') {
        this.setPlayerParams(networkPlayer, {
          position: position,
          rotation: rotation,
          animationState: animationState,
          params: params
        });
      }
    }
  }, {
    key: "setPlayerParams",
    value: function setPlayerParams(player, _ref3) {
      var position = _ref3.position,
          rotation = _ref3.rotation,
          animationState = _ref3.animationState,
          params = _ref3.params;
      player.position.set(position.x, position.y, position.z);
      player.rotation.set(rotation.x, rotation.y, rotation.z);
      player.animationState = animationState;

      if (params) {
        var input = params.input,
            acceleration = params.acceleration;
        var playerParams = player.params;
        playerParams.input.vertical = input.vertical;
        playerParams.input.horizontal = input.horizontal;
        playerParams.input.attack1 = input.attack1;
        playerParams.input.attack2 = input.attack2;
        playerParams.hp = params.hp;
        playerParams.hpMax = params.hpMax;
        playerParams.fraction = params.fraction;
        playerParams.damage = params.damage;
        playerParams.speed = params.speed;
        playerParams.money = params.money;
        playerParams.level = params.level;
        playerParams.unspentTalents = params.unspentTalents;
        playerParams.experience = params.experience;
        playerParams.acceleration.set(acceleration.x, acceleration.y, acceleration.z);
      }
    }
  }, {
    key: "updateNetworkAI",
    value: function updateNetworkAI(unitData) {
      var _this4 = this;

      var locationName = unitData.locationName,
          position = unitData.position,
          rotation = unitData.rotation,
          isRunning = unitData.isRunning,
          isAttack = unitData.isAttack,
          animationState = unitData.animationState,
          scale = unitData.scale,
          params = unitData.params;
      var unitNetworkId = params.unitNetworkId;

      if (locationName !== this.scene.location.getLocationName()) {
        return;
      }
      /**
       * @type AI | string
       */


      var networkAI = this.networkAIs[unitNetworkId];

      if (!networkAI) {
        this.networkAIs[unitNetworkId] = 'loading';
        this.scene.units.createNetworkAI(unitData, function (networkAI) {
          _this4.networkAIs[unitNetworkId] = networkAI;
        });
      } else if (networkAI !== 'loading') {
        networkAI.position.set(position.x, position.y, position.z);
        networkAI.rotation.set(rotation.x, rotation.y, rotation.z);
        networkAI.object.scale.set(scale.x, scale.y, scale.z);
        networkAI.isRunning = isRunning;
        networkAI.isAttack = isAttack;
        networkAI.animationState = animationState;

        if (params) {
          var acceleration = params.acceleration;
          var networkAIParams = networkAI.params;
          networkAIParams.hp = params.hp;
          networkAIParams.hpMax = params.hpMax;
          networkAIParams.fraction = params.fraction;
          networkAIParams.damage = params.damage;
          networkAIParams.level = params.level;
          networkAIParams.acceleration.set(acceleration.x, acceleration.y, acceleration.z);
        }
      }
    }
  }, {
    key: "sendGameObjects",
    value: function sendGameObjects() {
      var _this5 = this;

      var connectionId = this.meta.id;

      if (this.connection.readyState !== 1 || !connectionId) {
        return;
      }

      var player = this.scene.getPlayer();
      var units = this.meta.role === 'host' ? [player].concat(_toConsumableArray(this.scene.units.getAliveUnits().filter(function (unit) {
        return !unit.params.fromNetwork;
      }))) : [player];
      var data = [];
      units.forEach(function (unit) {
        var unitData = Connection.unitToNetwork(unit, connectionId, _this5.scene.location.getLocationName());

        if (unitData) {
          data.push(unitData);
        }
      });

      if (this.meta.role === 'host') {
        this.send('updateGameObjects', data);
      } else if (data[0]) {
        this.send('updatePlayer', data[0]);
      }
    }
  }], [{
    key: "unitToNetwork",
    value: function unitToNetwork(unit, connectionId, locationName) {
      if (unit) {
        var unitRotation = unit.object.rotation.toVector3();

        if (!unit.params.unitNetworkId) {
          var getRandomString = function getRandomString() {
            return Math.random().toString(36).substr(2);
          };

          unit.params.unitNetworkId = getRandomString() + getRandomString();
        }

        var unitNetworkId = unit.params.unitNetworkId;
        var isRunning = unit.isRunning,
            isAttack = unit.isAttack;
        var _unit$params = unit.params,
            hp = _unit$params.hp,
            hpMax = _unit$params.hpMax,
            acceleration = _unit$params.acceleration,
            damage = _unit$params.damage,
            level = _unit$params.level,
            experience = _unit$params.experience,
            fraction = _unit$params.fraction,
            name = _unit$params.name,
            speed = _unit$params.speed,
            unspentTalents = _unit$params.unspentTalents,
            money = _unit$params.money;

        var _ref4 = unit.params.input || {},
            vertical = _ref4.vertical,
            horizontal = _ref4.horizontal,
            attack1 = _ref4.attack1,
            attack2 = _ref4.attack2;

        var vectorToObject = function vectorToObject(vector) {
          var eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
          return {
            x: Math.round(vector.x * eps) / eps,
            y: Math.round(vector.y * eps) / eps,
            z: Math.round(vector.z * eps) / eps
          };
        };

        return {
          type: unit instanceof _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"] ? 'player' : 'ai',
          locationName: locationName,
          animationState: unit.animationState,
          isRunning: isRunning,
          isAttack: isAttack,
          position: vectorToObject(unit.position),
          rotation: vectorToObject(unitRotation),
          scale: vectorToObject(unit.object.scale),
          params: {
            connectionId: connectionId,
            unitNetworkId: unitNetworkId,
            name: name,
            hp: hp,
            hpMax: hpMax,
            fraction: fraction,
            damage: damage,
            level: level,
            experience: experience,
            speed: speed,
            money: money,
            unspentTalents: unspentTalents,
            acceleration: vectorToObject(acceleration),
            input: {
              vertical: vertical,
              horizontal: horizontal,
              attack1: attack1,
              attack2: attack2
            }
          }
        };
      }
    }
  }]);

  return Connection;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects.js":
/*!***************************************!*\
  !*** ../client/src/js/GameObjects.js ***!
  \***************************************/
/*! exports provided: AI, Player, Fire, Unit, AnimatedGameObject, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GameObjectsService; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _GameObjects_AI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObjects/AI */ "../client/src/js/GameObjects/AI.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AI", function() { return _GameObjects_AI__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _GameObjects_Player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameObjects/Player */ "../client/src/js/GameObjects/Player.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Player", function() { return _GameObjects_Player__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _GameObjects_Fire__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GameObjects/Fire */ "../client/src/js/GameObjects/Fire.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fire", function() { return _GameObjects_Fire__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _GameObjects_Unit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GameObjects/Unit */ "../client/src/js/GameObjects/Unit.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Unit", function() { return _GameObjects_Unit__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GameObjects/AnimatedGameObject */ "../client/src/js/GameObjects/AnimatedGameObject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimatedGameObject", function() { return _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_5__["default"]; });

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }









var GameObjectsService = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(GameObjectsService, _AutoBindMethods);

  var _super = _createSuper(GameObjectsService);

  /**
   * @param {Scene} scene
   */
  function GameObjectsService(scene) {
    var _this;

    _classCallCheck(this, GameObjectsService);

    _this = _super.call(this);
    _this.gameObjects = [];
    _this.nextGameObjectId = 0;
    _this.scene = scene;
    return _this;
  }

  _createClass(GameObjectsService, [{
    key: "update",
    value: function update(time, deltaTime) {
      this.gameObjects.forEach(function (gameObject) {
        return gameObject.update(time, deltaTime);
      });
    }
    /**
     * @param {Unit} attackingUnit
     */

  }, {
    key: "attack",
    value: function attack(attackingUnit) {
      var _this2 = this;

      if (attackingUnit.isDead()) {
        return;
      }

      this.scene.intervals.setTimeout(function () {
        var gameTime = _this2.scene.intervals.getTimePassed();

        if (attackingUnit.isAttackInterrupted(gameTime)) {
          attackingUnit.releaseAttack(gameTime);
          return;
        }

        var attackedUnits = _this2.getUnits().filter(function (gameObject) {
          return gameObject !== attackingUnit && gameObject.isAlive() && gameObject.isEnemy(attackingUnit) && gameObject.position.distanceTo(attackingUnit.position) < 2;
        });

        attackedUnits.forEach(function (collisionGameObject) {
          collisionGameObject.damageTaken({
            damage: attackingUnit.params.damage,
            unit: attackingUnit
          }, gameTime);
        }); // if (attackedUnits.length) {
        //     this.scene.audio.playSound(attackingUnit.position, 'Attack Soft');
        // }
      }, attackingUnit.getAttackTimeout());
    }
    /**
     * @param {Unit} firingGameObject
     */

  }, {
    key: "fire",
    value: function fire(firingGameObject) {
      var _this3 = this;

      if (firingGameObject.isDead()) {
        return;
      }

      var createLightCube = function createLightCube(left) {
        return _this3.scene.models.createCube({
          x: 0.02,
          y: 0.02,
          z: 0.3,
          emissive: '#ff0000',
          position: new THREE.Vector3(0.05 - Number(left) * 0.1, 0, 0),
          noScene: true
        });
      };

      var object = new THREE.Object3D();
      object.position.copy(firingGameObject.getFireInitialPosition());
      object.quaternion.copy(firingGameObject.getFireInitialRotation());
      object.add(createLightCube(true));
      object.add(createLightCube(false));
      this.scene.add(object);
      var fireGameObject = this.hookGameObject(new _GameObjects_Fire__WEBPACK_IMPORTED_MODULE_3__["default"]({
        object: object,
        throttling: new THREE.Vector3(1, 1, 1),
        speed: firingGameObject.params.fireShellSpeed,
        damage: firingGameObject.params.fireDamage,
        parent: firingGameObject,
        checkWay: this.scene.colliders.checkWay,
        getCollisions: function getCollisions() {
          return _this3.gameObjects.filter(function (gameObject) {
            return gameObject instanceof _GameObjects_Unit__WEBPACK_IMPORTED_MODULE_4__["default"] && gameObject.isAlive() && fireGameObject.params.parent !== gameObject && fireGameObject.position.distanceTo(gameObject.position) < 3;
          });
        },
        destroy: function destroy() {
          return _this3.destroyGameObject(fireGameObject);
        }
      }));
      this.scene.intervals.setTimeout(function () {
        return _this3.destroyGameObject(fireGameObject);
      }, 2000); // this.scene.audio.playSound(firingGameObject.position, 'Lasers');
    }
  }, {
    key: "createItem",
    value: function createItem(_ref) {
      var _this4 = this;

      var _ref$scale = _ref.scale,
          scale = _ref$scale === void 0 ? 1.5 : _ref$scale,
          _ref$model = _ref.model,
          model = _ref$model === void 0 ? 'item-heal' : _ref$model,
          _ref$position = _ref.position,
          position = _ref$position === void 0 ? {} : _ref$position,
          canPickup = _ref.canPickup,
          onPickup = _ref.onPickup;
      this.scene.models.loadGLTF({
        baseUrl: './assets/models/items/' + model,
        noScene: true,
        callback: function callback(loadedObject) {
          var positionVector = new THREE.Vector3(position.x || 0, position.y || 0, position.z || 0);
          loadedObject.scene.scale.set(scale, scale, scale);
          loadedObject.scene.traverse(function (child) {
            if (child.isMesh) {
              child.material.transparent = true;
              child.material.alphaTest = 0.5;
            }
          });
          loadedObject.scene.position.set(positionVector.x, positionVector.y, positionVector.z);

          _this4.scene.scene.add(loadedObject.scene);

          var gameItem = new _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_5__["default"]({
            object: loadedObject.scene,
            animations: loadedObject.animations
          });

          _this4.scene.gameObjectsService.hookGameObject(gameItem);

          var checkPickup = function checkPickup() {
            _this4.scene.intervals.setTimeout(function () {
              var getPriority = function getPriority(unit) {
                return 1 / Math.ceil(positionVector.distanceTo(unit.position));
              };

              var nearUnits = _this4.scene.units.getAliveUnits().filter(function (unit) {
                return (!canPickup || canPickup(unit)) && positionVector.distanceTo(unit.position) < 2;
              }).sort(function (unitA, unitB) {
                return getPriority(unitB) - getPriority(unitA);
              });

              if (nearUnits.length) {
                if (onPickup) {
                  onPickup(nearUnits[0]);
                }

                gameItem.animationState.isDie = true;

                _this4.scene.intervals.setTimeout(function () {
                  return _this4.scene.gameObjectsService.destroyGameObject(gameItem);
                }, 500);
              } else {
                checkPickup();
              }
            }, 1000);
          };

          checkPickup();
        }
      });
    }
    /**
     * @param {GameObject} gameObject
     */

  }, {
    key: "hookGameObject",
    value: function hookGameObject(gameObject) {
      this.gameObjects.push(gameObject);
      gameObject.__game_object_id = this.nextGameObjectId++;
      return gameObject;
    }
  }, {
    key: "removeAll",
    value: function removeAll() {
      while (this.gameObjects.length) {
        this.destroyGameObject(this.gameObjects[0]);
      }
    }
  }, {
    key: "removeAllExceptPlayer",
    value: function removeAllExceptPlayer() {
      var _this5 = this;

      var getNextNonPlayerIndex = function getNextNonPlayerIndex() {
        return _this5.gameObjects.findIndex(function (go) {
          return go !== _this5.scene.getPlayer();
        });
      };

      var removeIdx = getNextNonPlayerIndex();

      while (removeIdx > -1) {
        var gameObject = this.gameObjects[removeIdx];
        this.gameObjects.splice(removeIdx, 1);
        this.removeGameObjectFromScene(gameObject);
        removeIdx = getNextNonPlayerIndex();
      }
    }
    /**
     * @param {GameObject} gameObject
     */

  }, {
    key: "destroyGameObject",
    value: function destroyGameObject(gameObject) {
      var index = this.gameObjects.indexOf(gameObject);

      if (index > -1) {
        this.gameObjects.splice(index, 1);
      }

      this.removeGameObjectFromScene(gameObject);
    }
    /**
     * @param {GameObject} gameObject
     */

  }, {
    key: "removeGameObjectFromScene",
    value: function removeGameObjectFromScene(gameObject) {
      var parent = gameObject.object && gameObject.object.parent || this.scene;

      if (parent.remove) {
        parent.remove(gameObject.object);
      } else {
        console.error('Cannot find object parent to remove the object', gameObject);
      }
    }
  }, {
    key: "getUnits",
    value: function getUnits() {
      return this.gameObjects.filter(function (go) {
        return go instanceof _GameObjects_Unit__WEBPACK_IMPORTED_MODULE_4__["default"];
      });
    }
  }]);

  return GameObjectsService;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/AI.js":
/*!******************************************!*\
  !*** ../client/src/js/GameObjects/AI.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AI; });
/* harmony import */ var _FiringUnit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FiringUnit */ "../client/src/js/GameObjects/FiringUnit.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var AI = /*#__PURE__*/function (_FiringUnit) {
  _inherits(AI, _FiringUnit);

  var _super = _createSuper(AI);

  function AI() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AI);

    _this = _super.call(this, _objectSpread({
      speed: 0.5,
      damage: 10,
      mas: 1,
      hp: 100,
      name: 'Unnamed Unit',
      fraction: 'neutral',
      fireTimeout: 1.5,
      attackTimeout: 1.5,
      jumpTimeout: 1.5,
      startRunTimeout: 1,
      nextPointUpdateTimeout: 0.1,
      updateTargetTimeout: 3
    }, params));
    var _this$params = _this.params,
        hp = _this$params.hp,
        damage = _this$params.damage,
        speed = _this$params.speed;
    _this.params.bounty = hp / 4 + damage + speed * 30;
    _this.lastRun = 0;
    _this.lastTargetUpdate = 0;
    _this.lastNextPointUpdate = 0;
    _this.lastJumpTimestamp = 0;
    _this.isRunning = false;
    _this.isAttack = false;
    return _this;
  }

  _createClass(AI, [{
    key: "update",
    value: function update(time, deltaTime) {
      var _this2 = this;

      _get(_getPrototypeOf(AI.prototype), "update", this).call(this, time, deltaTime);

      if (this.isDead()) {
        return;
      }

      if (this.params.findTarget && this.isUpdateTargetReleased(time)) {
        this.params.target = this.params.findTarget();
      }

      var _this$params2 = this.params,
          object = _this$params2.object,
          target = _this$params2.target,
          acceleration = _this$params2.acceleration,
          speed = _this$params2.speed,
          getNextPoint = _this$params2.getNextPoint;

      if (!this.params.fromNetwork) {
        if (target) {
          if (getNextPoint) {
            if (this.isNextPointUpdateReleased(time)) {
              this.lastNextPointUpdate = time;
              this.nextPoint = getNextPoint(this.position, target.position);
            }
          } else {
            this.nextPoint = target.position;
          }
        }

        var isTargetNear = target && object.position.distanceTo(target.position) < 1.75;
        this.isAttack = isTargetNear && this.isEnemy(target) && target.isAlive();

        if (this.isAttack) {
          this.rotateToPosition(target.position);
        } else if (this.nextPoint) {
          this.rotateToPosition(this.nextPoint);
        }

        var isNextPointNear = !this.nextPoint;
        this.isRunning = target && !isTargetNear && !isNextPointNear && (this.isRunning || this.isRunReleased(time)) && this.isAttackReleased(time) && this.isHitReleased(time);
      }

      if (this.isAttack) {
        this.attack();
      }

      this.animationState.isMovingForward = this.isRunning && this.isAcceleration();

      if (this.isRunning) {
        var checkWay = function checkWay(jumpHeight) {
          var _this2$params$acceler = _this2.params.acceleration,
              dx = _this2$params$acceler.x,
              dy = _this2$params$acceler.y,
              dz = _this2$params$acceler.z;
          return _this2.checkWay(dx, dy + jumpHeight, dz);
        };

        this.lastRun = time;
        acceleration.add(this.getForward().multiplyScalar(speed * 0.1 * (deltaTime * 0.06)));
        var isJumpNeeded = this.isGrounded && (acceleration.x || acceleration.z) && time - this.lastJumpTimestamp > this.params.jumpTimeout * 1000 && !checkWay(0.1) && checkWay(1.5);

        if (isJumpNeeded) {
          this.lastJumpTimestamp = time;
          acceleration.y += 0.25;
        }
      }
    }
  }, {
    key: "rotateToPosition",
    value: function rotateToPosition(position) {
      var object = this.params.object;
      var rotationToTargetRadians = Math.atan2(position.x - object.position.x, position.z - object.position.z); // this.animationState.isRotateLeft = rotationToTargetRadians - object.rotation.y > 0.1;
      // this.animationState.isRotateRight = rotationToTargetRadians - object.rotation.y < -0.1;

      var targetQuaternion = new THREE.Quaternion();
      targetQuaternion.setFromEuler(object.rotation.clone().set(0, rotationToTargetRadians, 0));
      object.quaternion.slerp(targetQuaternion, 0.1);
    }
  }, {
    key: "isAcceleration",
    value: function isAcceleration() {
      return Math.abs(this.params.acceleration.x) + Math.abs(this.params.acceleration.y) + Math.abs(this.params.acceleration.z) > 0.01;
    }
  }, {
    key: "isRunReleased",
    value: function isRunReleased(time) {
      return time - this.lastRun > this.params.startRunTimeout * 1000;
    }
  }, {
    key: "isNextPointUpdateReleased",
    value: function isNextPointUpdateReleased(time) {
      return time - this.lastNextPointUpdate > this.params.nextPointUpdateTimeout * 1000;
    }
  }, {
    key: "isUpdateTargetReleased",
    value: function isUpdateTargetReleased(time) {
      return time - this.lastTargetUpdate > this.params.updateTargetTimeout * 1000;
    }
  }, {
    key: "damageTaken",
    value: function damageTaken() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          damage = _ref.damage,
          attacker = _ref.unit;

      var time = arguments.length > 1 ? arguments[1] : undefined;

      _get(_getPrototypeOf(AI.prototype), "damageTaken", this).call(this, {
        damage: damage,
        unit: attacker
      }, time);

      if (!this.params.target) {
        this.params.target = attacker;
        this.lastTargetUpdate = time;
      }
    }
  }]);

  return AI;
}(_FiringUnit__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/AnimatedGameObject.js":
/*!**********************************************************!*\
  !*** ../client/src/js/GameObjects/AnimatedGameObject.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimatedGameObject; });
/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameObject */ "../client/src/js/GameObjects/GameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var animationNames = {
  stand: 'Stand',
  run: 'Run',
  jump: 'Jump',
  attack: 'Attack',
  rotateLeft: 'Rotate Left',
  rotateRight: 'Rotate Right',
  runLeft: 'Run Left',
  runRight: 'Run Right',
  walkBack: 'Walk Back',
  die: 'Die',
  spawn: 'Spawn',
  hit: 'Hit',
  // Complex animimations
  topRun: 'Top Run',
  bottomRun: 'Bottom Run',
  topWalkBack: 'Top Walk Back',
  bottomWalkBack: 'Bottom Walk Back',
  topAttack: 'Top Attack',
  bottomAttack: 'Bottom Attack',
  topStand: 'Top Stand',
  bottomStand: 'Bottom Stand',
  topRunRight: 'Top Run Right',
  topRunLeft: 'Top Run Left',
  topJump: 'Top Jump',
  topHit: 'Top Hit',
  bottomRunRight: 'Bottom Run Right',
  bottomRunLeft: 'Bottom Run Left',
  bottomJump: 'Bottom Jump',
  bottomHit: 'Bottom Hit',
  topDie: 'Top Die',
  bottomDie: 'Bottom Die',
  topSpawn: 'Top Spawn',
  bottomSpawn: 'Bottom Spawn'
};
var topAnimations = ['topRun', 'topWalkBack', 'topAttack', 'topStand', 'topRunRight', 'topRunLeft', 'topJump', 'topHit', 'topDie'];
var bottomAnimations = ['bottomRun', 'bottomWalkBack', 'bottomAttack', 'bottomStand', 'bottomRunRight', 'bottomRunLeft', 'bottomJump', 'bottomHit', 'bottomDie'];
var topBones = ['Right_Forearm', 'Right_Arm', 'Right_Hand', 'Right_Hand_end', 'Right_Shoulder', 'Left_Shoulder', 'Left_Forearm', 'Left_Arm', 'Left_Hand', 'Left_Hand_end', 'Chest', 'Neck', 'Head', 'Head_end'];
var bottomBones = ['Main_Bone', 'Right_Leg', 'Right_Middle_Foot', 'Right_Foot', 'Right_Foot_end', 'Left_Leg', 'Left_Middle_Foot', 'Left_Foot', 'Left_Foot_end', 'Legs_Rotation'];

var AnimatedGameObject = /*#__PURE__*/function (_GameObject) {
  _inherits(AnimatedGameObject, _GameObject);

  var _super = _createSuper(AnimatedGameObject);

  function AnimatedGameObject() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimatedGameObject);

    _this = _super.call(this, _objectSpread({
      animationNames: _objectSpread({}, animationNames),
      topBones: [].concat(topBones),
      bottomBones: [].concat(bottomBones),
      topAnimations: [].concat(topAnimations),
      bottomAnimations: [].concat(bottomAnimations),
      spawnTimeout: 1
    }, params));
    _this.animationState = {
      isMovingForward: false,
      isMovingRight: false,
      isMovingLeft: false,
      isMovingBackward: false,
      isRotateLeft: false,
      isRotateRight: false,
      isAttack: false,
      isJump: false,
      isDie: false,
      isHit: false,
      isSpawn: true
    };
    _this.playingAnimations = {};
    _this.legsRotationY = 0;
    _this.spawnTime = 0;
    _this.mixer = new THREE.AnimationMixer(_this.params.object);

    _this.initAnimations(_this.params.animationNames);

    return _this;
  }

  _createClass(AnimatedGameObject, [{
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(AnimatedGameObject.prototype), "update", this).call(this, time, deltaTime);

      if (!this.spawnTime) {
        this.spawnTime = time;
      } else if (this.animationState.isSpawn && this.isSpawnFinished(time)) {
        this.animationState.isSpawn = false;
      }

      if (this.mixer) {
        this.mixer.update(deltaTime / 1000);
      }

      if (this.params.complexAnimations) {
        this.updateComplexAnimations();
      } else {
        var animation = this.getCurrentAnimation();
        animation && this.playAnimation(animation);
      }
    }
  }, {
    key: "playAnimation",
    value: function playAnimation(animation) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          force = _ref.force;

      if (!animation || !animation._clip) return;
      var animationName = animation._clip.name;
      var shouldUpdate = this.playingAnimationName !== animationName || force;

      if (shouldUpdate) {
        this.playingAnimationName = animationName;
        animation.reset();
        animation.play();

        if (this.playingAnimation) {
          var from = this.playingAnimation;
          from.enabled = true;
          animation.enabled = true;
          from.crossFadeTo(animation, 0.3);
        }

        this.playingAnimation = animation;
      }
    }
  }, {
    key: "initAnimations",
    value: function initAnimations(animationNames) {
      var _this2 = this;

      var _this$params = this.params,
          topAnimations = _this$params.topAnimations,
          bottomAnimations = _this$params.bottomAnimations,
          topBones = _this$params.topBones,
          bottomBones = _this$params.bottomBones,
          complexAnimations = _this$params.complexAnimations;
      this.animations = Object.keys(animationNames).reduce(function (result, key) {
        var excludedBones = [];

        if (complexAnimations) {
          if (topAnimations.includes(key)) {
            excludedBones = bottomBones;
          } else if (bottomAnimations.includes(key)) {
            excludedBones = topBones;
          }
        }

        var modelAnimation = _this2.findModelAnimation(animationNames[key], {
          excludedBones: excludedBones
        });

        var initedAnimation = _this2.createClipAction(modelAnimation);

        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, key, initedAnimation));
      }, {});
      var _this$animations = this.animations;
      _this$animations = _this$animations === void 0 ? {} : _this$animations;
      var jump = _this$animations.jump,
          attack = _this$animations.attack,
          topAttack = _this$animations.topAttack,
          die = _this$animations.die,
          spawn = _this$animations.spawn,
          topDie = _this$animations.topDie,
          bottomDie = _this$animations.bottomDie,
          topJump = _this$animations.topJump,
          bottomJump = _this$animations.bottomJump,
          bottomAttack = _this$animations.bottomAttack;
      [jump, die, spawn, topDie, bottomDie, topJump, bottomJump].forEach(function (clampAnimation) {
        if (clampAnimation) {
          clampAnimation.setLoop(THREE.LoopOnce, 0);
          clampAnimation.clampWhenFinished = true;
        }
      });
      [attack, topAttack, bottomAttack].forEach(function (attackAnimation) {
        if (attackAnimation) {
          attackAnimation.setDuration(_this2.params.attackTimeout);
        }
      });
    }
  }, {
    key: "createClipAction",
    value: function createClipAction(action) {
      return action && this.mixer.clipAction(action).stop();
    }
  }, {
    key: "findModelAnimation",
    value: function findModelAnimation(name) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$excludedBones = _ref2.excludedBones,
          excludedBones = _ref2$excludedBones === void 0 ? [] : _ref2$excludedBones;

      var _this$params$animatio = this.params.animations,
          animations = _this$params$animatio === void 0 ? [] : _this$params$animatio;
      var animation = animations.find(function (animation) {
        return animation.name === name;
      });

      if (animation && excludedBones.length) {
        return this.clearAnimationBones(animation, excludedBones);
      }

      return animation;
    }
  }, {
    key: "isMoving",
    value: function isMoving() {
      return this.animationState.isMovingLeft || this.animationState.isMovingRight || this.animationState.isMovingForward || this.animationState.isMovingBackward;
    }
  }, {
    key: "isSpawnFinished",
    value: function isSpawnFinished(time) {
      return time - this.spawnTime > this.params.spawnTimeout * 1000;
    }
  }, {
    key: "clearAnimationBones",
    value: function clearAnimationBones(animation, bones) {
      if (animation) {
        var getBoneName = function getBoneName(item) {
          return item.name.split('.')[0];
        },
            isNotExcluded = function isNotExcluded(item) {
          return !bones.includes(getBoneName(item));
        };

        animation.tracks = animation.tracks.filter(isNotExcluded);
        return animation;
      }
    }
  }, {
    key: "updateComplexAnimations",
    value: function updateComplexAnimations() {
      var _this$animations2 = this.animations;
      _this$animations2 = _this$animations2 === void 0 ? {} : _this$animations2;
      var topAttack = _this$animations2.topAttack,
          bottomAttack = _this$animations2.bottomAttack,
          topWalkBack = _this$animations2.topWalkBack,
          bottomWalkBack = _this$animations2.bottomWalkBack,
          topRun = _this$animations2.topRun,
          bottomRun = _this$animations2.bottomRun,
          topRunRight = _this$animations2.topRunRight,
          topRunLeft = _this$animations2.topRunLeft,
          topStand = _this$animations2.topStand,
          bottomStand = _this$animations2.bottomStand,
          topJump = _this$animations2.topJump,
          bottomJump = _this$animations2.bottomJump,
          topHit = _this$animations2.topHit,
          bottomHit = _this$animations2.bottomHit,
          topDie = _this$animations2.topDie,
          bottomDie = _this$animations2.bottomDie,
          topSpawn = _this$animations2.topSpawn,
          bottomSpawn = _this$animations2.bottomSpawn;
      var _this$animationState = this.animationState,
          isAttack = _this$animationState.isAttack,
          isMovingRight = _this$animationState.isMovingRight,
          isMovingLeft = _this$animationState.isMovingLeft,
          isMovingBackward = _this$animationState.isMovingBackward,
          isMovingForward = _this$animationState.isMovingForward,
          isJump = _this$animationState.isJump,
          isDie = _this$animationState.isDie,
          isHit = _this$animationState.isHit,
          isSpawn = _this$animationState.isSpawn;
      var playingAnimations = {
        top: isDie && topDie || isHit && topHit || isAttack && topAttack || isJump && topJump || isMovingBackward && isMovingRight && topRunLeft || isMovingBackward && isMovingLeft && topRunRight || isMovingBackward && topWalkBack || isMovingRight && topRunRight || isMovingLeft && topRunLeft || isMovingForward && topRun || isSpawn && topSpawn || topStand,
        bottom: isDie && bottomDie || isJump && bottomJump || isMovingBackward && isMovingRight && bottomWalkBack || isMovingBackward && isMovingLeft && bottomWalkBack || isMovingBackward && bottomWalkBack || isMovingRight && bottomRun || isMovingLeft && bottomRun || isMovingForward && bottomRun || isAttack && bottomAttack || isHit && bottomHit || isSpawn && bottomSpawn || bottomStand
      };
      var legsRotationBone = this.getChildByName('Legs_Rotation');

      if (legsRotationBone) {
        var rotation = legsRotationBone.rotation;
        var y = -0.3;

        if (isMovingLeft) {
          y = isMovingForward ? 0.5 : isMovingBackward ? -0.7 : 1;
        } else if (isMovingRight) {
          y = isMovingForward ? -1.2 : isMovingBackward ? 0.4 : -1.7;
        }

        this.legsRotationY = this.legsRotationY - (this.legsRotationY - y) / 10;
        rotation.set(rotation.x, this.legsRotationY, rotation.z);
      }

      this.blendAnimations(playingAnimations);
    }
  }, {
    key: "blendAnimations",
    value: function blendAnimations(_ref3) {
      var top = _ref3.top,
          bottom = _ref3.bottom;
      if (!(top && bottom && top._clip && bottom._clip)) return;

      var getAnimationName = function getAnimationName(a) {
        return a._clip.name;
      },
          playAnimation = function playAnimation(fromAnimation, animation) {
        var animationName = getAnimationName(animation);
        var fromAnimationName = fromAnimation && getAnimationName(fromAnimation);

        if (fromAnimationName !== animationName) {
          animation.reset();
          animation.play();

          if (fromAnimation) {
            fromAnimation.crossFadeTo(animation, 0.3);
          }
        }
      };

      playAnimation(this.playingAnimations.top, top);
      playAnimation(this.playingAnimations.bottom, bottom);
      this.playingAnimations.top = top;
      this.playingAnimations.bottom = bottom;
    }
  }, {
    key: "getCurrentAnimation",
    value: function getCurrentAnimation() {
      var _this$animations3 = this.animations;
      _this$animations3 = _this$animations3 === void 0 ? {} : _this$animations3;
      var stand = _this$animations3.stand,
          attack = _this$animations3.attack,
          walkBack = _this$animations3.walkBack,
          runLeft = _this$animations3.runLeft,
          runRight = _this$animations3.runRight,
          run = _this$animations3.run,
          jump = _this$animations3.jump,
          hit = _this$animations3.hit,
          rotateLeft = _this$animations3.rotateLeft,
          rotateRight = _this$animations3.rotateRight,
          die = _this$animations3.die,
          spawn = _this$animations3.spawn;
      var _this$animationState2 = this.animationState,
          isAttack = _this$animationState2.isAttack,
          isMovingForward = _this$animationState2.isMovingForward,
          isJump = _this$animationState2.isJump,
          isMovingLeft = _this$animationState2.isMovingLeft,
          isMovingRight = _this$animationState2.isMovingRight,
          isMovingBackward = _this$animationState2.isMovingBackward,
          isRotateLeft = _this$animationState2.isRotateLeft,
          isRotateRight = _this$animationState2.isRotateRight,
          isDie = _this$animationState2.isDie,
          isHit = _this$animationState2.isHit,
          isSpawn = _this$animationState2.isSpawn;
      return isDie && die || isHit && hit || isAttack && attack || isJump && jump || isMovingBackward && walkBack || isMovingLeft && runLeft || isMovingRight && runRight || isMovingForward && run || isRotateLeft && rotateLeft || isRotateRight && rotateRight || isSpawn && spawn || stand;
    }
  }]);

  return AnimatedGameObject;
}(_GameObject__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/Fire.js":
/*!********************************************!*\
  !*** ../client/src/js/GameObjects/Fire.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Fire; });
/* harmony import */ var _Unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Unit */ "../client/src/js/GameObjects/Unit.js");
/* harmony import */ var _MovingGameObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MovingGameObject */ "../client/src/js/GameObjects/MovingGameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Fire = /*#__PURE__*/function (_MovingGameObject) {
  _inherits(Fire, _MovingGameObject);

  var _super = _createSuper(Fire);

  function Fire() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Fire);

    _this = _super.call(this, params);

    _this.params.acceleration.add(_this.getForward().multiplyScalar(_this.params.speed * 0.1));

    return _this;
  }

  _createClass(Fire, [{
    key: "update",
    value: function update(time, deltaTime) {
      var _this2 = this;

      _get(_getPrototypeOf(Fire.prototype), "update", this).call(this, time, deltaTime);

      if (this.params.getCollisions) {
        var collisions = this.params.getCollisions(this);
        collisions.filter(function (collisionGameObject) {
          return collisionGameObject instanceof _Unit__WEBPACK_IMPORTED_MODULE_0__["default"] && collisionGameObject.isEnemy(_this2.params.parent);
        }).forEach(function (collisionGameObject) {
          return collisionGameObject.damageTaken({
            damage: _this2.params.damage,
            unit: _this2.params.parent
          }, time);
        });

        if (collisions.length && this.params.destroy) {
          this.params.destroy(this);
        }
      }
    }
  }]);

  return Fire;
}(_MovingGameObject__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/FiringUnit.js":
/*!**************************************************!*\
  !*** ../client/src/js/GameObjects/FiringUnit.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FiringUnit; });
/* harmony import */ var _Unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Unit */ "../client/src/js/GameObjects/Unit.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var FiringUnit = /*#__PURE__*/function (_Unit) {
  _inherits(FiringUnit, _Unit);

  var _super = _createSuper(FiringUnit);

  function FiringUnit() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, FiringUnit);

    _this = _super.call(this, _objectSpread({
      fireDamage: 10,
      fireTimeout: 1.5,
      fireShellSpeed: 3
    }, params));
    _this.shouldFire = false;
    _this.latestFire = 0;
    return _this;
  }

  _createClass(FiringUnit, [{
    key: "getFireInitialPosition",
    value: function getFireInitialPosition() {
      return this.position.clone().add(this.getUp().multiplyScalar(1.5).add(this.getForward().multiplyScalar(0.3)));
    }
  }, {
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(FiringUnit.prototype), "update", this).call(this, time, deltaTime);

      if (this.isDead()) {
        return;
      }

      this.isFire = false;

      if (this.shouldFire && this.params.fire && this.isFireReleased(time) && this.isAttackReleased(time)) {
        this.isFire = true;
        this.shouldFire = false;
        this.latestFire = time;
        this.params.fire();
      } else {
        this.shouldFire = false;
      }
    }
  }, {
    key: "isFireReleased",
    value: function isFireReleased(time) {
      return time - this.latestFire >= this.params.fireTimeout * 1000;
    }
  }, {
    key: "fire",
    value: function fire() {
      this.shouldFire = true;
    }
  }]);

  return FiringUnit;
}(_Unit__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/GameObject.js":
/*!**************************************************!*\
  !*** ../client/src/js/GameObjects/GameObject.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GameObject; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var GameObject = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(GameObject, _AutoBindMethods);

  var _super = _createSuper(GameObject);

  function GameObject() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GameObject);

    _this = _super.call(this);
    _this.params = _objectSpread({}, params);
    _this.object = params.object;

    if (params.object) {
      _this.position = params.object.position;
      _this.rotation = params.object.rotation;
    }

    _this.events = {};
    return _this;
  }

  _createClass(GameObject, [{
    key: "update",
    value: function update() {}
    /**
     * @param {string} eventName
     * @param {object[]} args
     */

  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(eventName) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this.events[eventName]) {
        this.events[eventName].forEach(function (callback) {
          return callback.apply(void 0, args);
        });
      }
    }
    /**
     * @param {string} eventName
     * @param {function} callback
     */

  }, {
    key: "addEventListener",
    value: function addEventListener(eventName, callback) {
      if (typeof callback === 'function') {
        if (this.events[eventName]) {
          this.events[eventName].push(callback);
        } else {
          this.events[eventName] = [callback];
        }
      }
    }
  }, {
    key: "getChildByName",
    value: function getChildByName(name) {
      return this.object.getObjectByName(name, true);
    }
  }, {
    key: "getChildDirection",
    value: function getChildDirection(arg) {
      var vector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3(0, 0, 1);
      var child = typeof arg === 'string' ? this.getChildByName(arg) : arg;
      return vector.applyQuaternion(this.getChildRotation(child));
    }
  }, {
    key: "getChildPosition",
    value: function getChildPosition(arg) {
      var child = typeof arg === 'string' ? this.getChildByName(arg) : arg;
      return new THREE.Vector3().setFromMatrixPosition(child.matrixWorld);
    }
  }, {
    key: "getChildRotation",
    value: function getChildRotation(arg) {
      var child = typeof arg === 'string' ? this.getChildByName(arg) : arg;
      var target = new THREE.Quaternion();
      child.getWorldQuaternion(target);
      return target;
    }
  }]);

  return GameObject;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/MovingGameObject.js":
/*!********************************************************!*\
  !*** ../client/src/js/GameObjects/MovingGameObject.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MovingGameObject; });
/* harmony import */ var _AnimatedGameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimatedGameObject */ "../client/src/js/GameObjects/AnimatedGameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var MovingGameObject = /*#__PURE__*/function (_AnimatedGameObject) {
  _inherits(MovingGameObject, _AnimatedGameObject);

  var _super = _createSuper(MovingGameObject);

  function MovingGameObject() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MovingGameObject);

    return _super.call(this, _objectSpread({
      speed: 0.1,
      throttling: new THREE.Vector3(0.5, 0.95, 0.5),
      acceleration: new THREE.Vector3(),
      mas: 0,
      checkWay: function checkWay() {
        return true;
      }
    }, params));
  }

  _createClass(MovingGameObject, [{
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(MovingGameObject.prototype), "update", this).call(this, time, deltaTime);

      var _this$params = this.params,
          acceleration = _this$params.acceleration,
          throttling = _this$params.throttling;

      if (this.params.mas) {
        acceleration.y -= 0.01;
        this.isGrounded = !this.checkWay(0, -0.2, 0);
        this.animationState.isJump = !this.isGrounded;
      }

      var isX = Boolean(acceleration.x) && this.checkWay(acceleration.x, 0, 0);
      var isY = Boolean(acceleration.y) && this.checkWay(0, acceleration.y, 0);
      var isZ = Boolean(acceleration.z) && this.checkWay(0, 0, acceleration.z);

      if (!isX || !isY || !isZ) {
        if (!this.params.mas) {
          // Stop object smoothly because of Collider hit
          acceleration.multiplyScalar(0.75);
        }

        if (!isX) {
          var isClimbing = acceleration.x && acceleration.y <= 0 && this.checkWay(acceleration.x, 0.04, 0);

          if (isClimbing) {
            acceleration.y = 0.04 / throttling.y;
          } else {
            acceleration.x = 0;
          }
        }

        if (!isY) {
          acceleration.y = 0;
        }

        if (!isZ) {
          var _isClimbing = acceleration.z && acceleration.y <= 0 && this.checkWay(0, 0.04, acceleration.z);

          if (_isClimbing) {
            acceleration.y = 0.04 / throttling.y;
          } else {
            acceleration.z = 0;
          }
        }
      }

      acceleration.x *= throttling.x;
      acceleration.y *= throttling.y;
      acceleration.z *= throttling.z;
      var isMoving = Math.abs(acceleration.x) > 0.001 || Math.abs(acceleration.y) > 0.001 || Math.abs(acceleration.z) > 0.001;

      if (isMoving) {
        // acceleration.multiplyScalar(deltaTime * 60)
        this.position.add(acceleration);
      }
    }
  }, {
    key: "checkWay",
    value: function checkWay() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var position = this.position,
          checkWay = this.params.checkWay;
      var nextPosition = new THREE.Vector3(position.x + x, position.y + y + 0.1, position.z + z);
      return checkWay(nextPosition, this);
    }
  }, {
    key: "getLeft",
    value: function getLeft() {
      return this.getDirection(new THREE.Vector3(1, 0, 0));
    }
  }, {
    key: "getUp",
    value: function getUp() {
      return this.getDirection(new THREE.Vector3(0, 1, 0));
    }
  }, {
    key: "getForward",
    value: function getForward() {
      return this.getDirection(new THREE.Vector3(0, 0, 1));
    }
    /**
     * @param {THREE.Vector3} direction
     */

  }, {
    key: "getDirection",
    value: function getDirection(direction) {
      direction.applyQuaternion(this.object.quaternion);
      return direction;
    }
  }, {
    key: "getScalarAcceleration",
    value: function getScalarAcceleration() {
      return this.params.acceleration.toArray().map(Math.abs).reduce(function (r, v) {
        return r + v;
      }, 0);
    }
  }]);

  return MovingGameObject;
}(_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/Player.js":
/*!**********************************************!*\
  !*** ../client/src/js/GameObjects/Player.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Player; });
/* harmony import */ var _FiringUnit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FiringUnit */ "../client/src/js/GameObjects/FiringUnit.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Player = /*#__PURE__*/function (_FiringUnit) {
  _inherits(Player, _FiringUnit);

  var _super = _createSuper(Player);

  function Player() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Player);

    _this = _super.call(this, _objectSpread({
      speed: 0.54,
      fireTimeout: 1,
      fireDamage: 25,
      damage: 50,
      hp: 100,
      experience: 0,
      unspentTalents: 0,
      money: 500,
      isFire: false,
      mas: 1,
      level: 1,
      jumpTimeout: 0.9,
      fraction: 'friendly',
      sensitivity: 1
    }, params));
    _this.lastJumpTimestamp = 0;
    _this.rotationAcceleration = 0; // console.log('Player', this);

    params.onLevelUp && _this.addEventListener('onLevelUp', params.onLevelUp);
    return _this;
  }

  _createClass(Player, [{
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(Player.prototype), "update", this).call(this, time, deltaTime);

      if (this.isDead()) {
        return;
      }

      var _this$params = this.params,
          input = _this$params.input,
          object = _this$params.object,
          acceleration = _this$params.acceleration,
          fromNetwork = _this$params.fromNetwork;
      acceleration.add(this.getMovingAcceleration(time, deltaTime));

      if (input.attack1) {
        this.attack();
      }

      if (input.attack2) {
        this.fire();
      }

      this.animationState.isMovingLeft = input.horizontal === -1;
      this.animationState.isMovingRight = input.horizontal === 1;
      this.animationState.isMovingForward = input.vertical === 1;
      this.animationState.isMovingBackward = input.vertical === -1;

      if (!fromNetwork) {
        if (input.isThirdPerson) {
          if (input.look.horizontal) {
            var horizontalLook = input.look.horizontal;
            this.animationState.isRotateLeft = horizontalLook < 0;
            this.animationState.isRotateRight = horizontalLook > 0;
            this.rotationAcceleration += -horizontalLook / 5000 * input.look.sensitivity;
            input.resetHorizontalLook();
          }

          var CALC_ROTATE_THRESHOLD = 0.0000001;

          if (Math.abs(this.rotationAcceleration) > CALC_ROTATE_THRESHOLD) {
            object.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), this.rotationAcceleration);
            this.rotationAcceleration *= 0.7;
          }
        } else {
          var deltaX = window.innerWidth / 2 - input.cursor.x;
          var deltaY = input.cursor.y - window.innerHeight / 2;
          var rotationY = Math.atan2(deltaY, deltaX);
          this.animationState.isRotateLeft = rotationY > object.rotation.y;
          this.animationState.isRotateRight = rotationY < object.rotation.y;
          object.rotation.set(0, rotationY, 0);
        }
      }
    }
  }, {
    key: "getUnspentTalents",
    value: function getUnspentTalents() {
      return this.params.unspentTalents;
    }
  }, {
    key: "decreaseUnspentTalents",
    value: function decreaseUnspentTalents() {
      return this.params.unspentTalents--;
    }
  }, {
    key: "getFireInitialPosition",
    value: function getFireInitialPosition() {
      var head = this.getChildByName('Head');
      var headForward = this.getChildDirection(head, new THREE.Vector3(0, 0, 1));
      var headUp = new THREE.Vector3(0, 1, 0);
      headUp.applyQuaternion(head.quaternion);
      return this.getChildPosition(head).add(headUp.multiplyScalar(0.15)).add(headForward.multiplyScalar(0.25));
    }
  }, {
    key: "getFireInitialRotation",
    value: function getFireInitialRotation() {
      return this.getChildRotation('Head');
    }
  }, {
    key: "addExperience",
    value: function addExperience(experience) {
      this.params.experience += experience;
      var level = this.getLevel();

      if (this.params.level !== level) {
        var levelsUp = level - this.params.level;
        this.params.level = level;
        this.params.unspentTalents += 3 * levelsUp;
        this.params.hp = this.params.hpMax;
        this.dispatchEvent('onLevelUp', level);
      }
    }
  }, {
    key: "getExperience",
    value: function getExperience() {
      return this.params.experience;
    }
  }, {
    key: "getLevelExperience",
    value: function getLevelExperience() {
      return Math.pow(this.getLevel(), 2) * 100;
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return Math.floor(Math.sqrt(this.params.experience / 100)) + 1;
    }
  }, {
    key: "getMovingAcceleration",
    value: function getMovingAcceleration(time, deltaTime) {
      var _this$params$input = this.params.input,
          horizontal = _this$params$input.horizontal,
          vertical = _this$params$input.vertical,
          jump = _this$params$input.jump;
      var speed = vertical && horizontal ? this.params.speed * 0.1 * 0.7 * (deltaTime * 0.06) : this.params.speed * 0.1 * (deltaTime * 0.06);
      var addForward = vertical === 1 ? speed : vertical === -1 ? -speed * 0.6 : 0;
      var addSide = vertical === -1 ? -horizontal * speed * 0.6 : -horizontal * speed;
      var isJump = time - this.lastJumpTimestamp > this.params.jumpTimeout * 1000 && jump && this.isGrounded;

      if (isJump) {
        this.lastJumpTimestamp = time;
      }

      return this.getDirection(new THREE.Vector3(addSide, Number(isJump) * 0.25, addForward));
    }
  }]);

  return Player;
}(_FiringUnit__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/Unit.js":
/*!********************************************!*\
  !*** ../client/src/js/GameObjects/Unit.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Unit; });
/* harmony import */ var _MovingGameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MovingGameObject */ "../client/src/js/GameObjects/MovingGameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Unit = /*#__PURE__*/function (_MovingGameObject) {
  _inherits(Unit, _MovingGameObject);

  var _super = _createSuper(Unit);

  function Unit() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Unit);

    _this = _super.call(this, _objectSpread({
      hp: 100,
      hpMax: params.hp || 100,
      damage: 10,
      attackTimeout: 0.9,
      hitTime: 0.3,
      attackDamageTimeout: 0.3
    }, params));
    _this.shouldAttack = false;
    _this.latestAttackTimestamp = 0;
    _this.latestHitTimestamp = 0;
    ['onDamageTaken', 'onDamageDeal', 'onKill', 'onDie'].forEach(function (eventName) {
      if (typeof params[eventName] === 'function') {
        _this.addEventListener(eventName, params[eventName]);
      }
    });
    return _this;
  }

  _createClass(Unit, [{
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(Unit.prototype), "update", this).call(this, time, deltaTime);

      if (this.isDead()) {
        return;
      }

      var hitReleased = this.isHitReleased(time);
      this.animationState.isHit = !hitReleased;

      if (this.isAttackReleased(time) && hitReleased) {
        this.animationState.isAttack = false;

        if (this.shouldAttack) {
          this.animationState.isAttack = true;
          this.latestAttackTimestamp = time;
          this.params.attack && this.params.attack();
        }
      } else {
        this.shouldAttack = false;
      }
    }
  }, {
    key: "getFraction",
    value: function getFraction() {
      return this.params.fraction;
    }
  }, {
    key: "getCollider",
    value: function getCollider(position) {
      var diffY = position.y - this.position.y;
      return Math.sqrt(Math.pow(position.x - this.position.x, 2) + Math.pow(position.z - this.position.z, 2)) < 1 && diffY >= 0 && diffY < 1.7;
    }
  }, {
    key: "releaseAttack",
    value: function releaseAttack(time) {
      this.latestAttackTimestamp = time - this.params.attackTimeout * 1000;
      this.animationState.isAttack = false;
    }
  }, {
    key: "isAttackReleased",
    value: function isAttackReleased(time) {
      return time - this.latestAttackTimestamp >= this.params.attackTimeout * 1000;
    }
  }, {
    key: "isAttackInterrupted",
    value: function isAttackInterrupted(time) {
      return time - this.latestHitTimestamp <= this.params.attackDamageTimeout * 1000;
    }
  }, {
    key: "isHitReleased",
    value: function isHitReleased(time) {
      return time - this.latestHitTimestamp >= this.params.hitTime * 1000;
    }
  }, {
    key: "attack",
    value: function attack() {
      this.shouldAttack = true;
    }
  }, {
    key: "isDead",
    value: function isDead() {
      return this.params.hp <= 0;
    }
  }, {
    key: "isAlive",
    value: function isAlive() {
      return !this.isDead();
    }
  }, {
    key: "isEnemy",
    value: function isEnemy(unit) {
      return unit.params.fraction !== this.params.fraction && unit.params.fraction !== 'neutral' && this.params.fraction !== 'neutral';
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this.params.level;
    }
  }, {
    key: "getName",
    value: function getName() {
      return this.params.name;
    }
  }, {
    key: "getAttackTimeout",
    value: function getAttackTimeout() {
      return this.params.attackDamageTimeout * 1000;
    }
  }, {
    key: "damageTaken",
    value: function damageTaken() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          damage = _ref.damage,
          attacker = _ref.unit;

      var time = arguments.length > 1 ? arguments[1] : undefined;

      if (damage && attacker) {
        this.params.hp -= damage;
        this.dispatchEvent('onDamageTaken', attacker);

        if (attacker) {
          attacker.dispatchEvent('onDamageDeal', this);
        }

        var interruptByChance = Math.random() < 0.33;
        var interruptByLevel = attacker.getLevel() - this.getLevel() > 2;
        var shouldBeInterrupted = interruptByLevel || interruptByChance;

        if (shouldBeInterrupted) {
          this.latestHitTimestamp = time;
        }

        if (this.isDead()) {
          this.die(attacker);
        }
      }
    }
  }, {
    key: "die",
    value: function die(killingUnit) {
      this.params.hp = 0;
      this.dispatchEvent('onDie', killingUnit);
      this.animationState.isDie = true;

      if (killingUnit) {
        killingUnit.dispatchEvent('onKill', this);
      }
    }
  }, {
    key: "addSpeed",
    value: function addSpeed(speed) {
      this.params.speed += speed;
    }
  }, {
    key: "addDamage",
    value: function addDamage(damage) {
      this.params.damage += damage;
    }
  }, {
    key: "addHP",
    value: function addHP(hp) {
      if (this.isAlive()) {
        this.params.hp = Math.min(this.params.hp + hp, this.params.hpMax);
      }
    }
  }, {
    key: "getMoney",
    value: function getMoney() {
      return this.params.money;
    }
  }, {
    key: "addMoney",
    value: function addMoney(money) {
      this.params.money += money;
    }
  }, {
    key: "addMaxHP",
    value: function addMaxHP(hp) {
      if (this.isAlive()) {
        this.params.hpMax += hp;
        this.params.hp += hp;
      }
    }
  }, {
    key: "getHP",
    value: function getHP() {
      return this.params.hp;
    }
  }, {
    key: "getMaxHP",
    value: function getMaxHP() {
      return this.params.hpMax;
    }
  }, {
    key: "getSpeed",
    value: function getSpeed() {
      return this.params.speed;
    }
  }, {
    key: "getDamage",
    value: function getDamage() {
      return this.params.damage;
    }
  }]);

  return Unit;
}(_MovingGameObject__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Input.js":
/*!*********************************!*\
  !*** ../client/src/js/Input.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Input; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var KEYS = {
  MOUSE_LEFT: 1,
  MOUSE_RIGHT: 3,
  SPACE: 32,
  ENTER: 13,
  ESC: 27,
  C: 67,
  W: 87,
  A: 65,
  S: 83,
  D: 68,
  X: 88,
  Z: 90,
  Q: 81,
  E: 69,
  R: 82,
  F: 70,
  V: 86,
  1: 49,
  2: 50,
  ARROW_LEFT: 37,
  ARROW_RIGHT: 39,
  ARROW_UP: 38,
  ARROW_DOWN: 40
};

var Input = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Input, _AutoBindMethods);

  var _super = _createSuper(Input);

  function Input(params) {
    var _this;

    _classCallCheck(this, Input);

    _this = _super.call(this);
    _this.params = params;
    _this.vertical = 0;
    _this.horizontal = 0;
    _this.attack1 = false;
    _this.attack2 = false;
    _this.look = {
      vertical: 0,
      horizontal: 0,
      back: false,
      sensitivity: 1
    };

    _this.resetHorizontalLook = function () {
      return _this.look.horizontal = 0;
    };

    _this.isThirdPerson = true;
    _this.cursor = {
      x: 0,
      y: 0
    };
    _this.mouse = {
      x: 0,
      y: 0
    };

    _this.addEventListeners();

    return _this;
  }

  _createClass(Input, [{
    key: "update",
    value: function update() {
      this.look.horizontal = 0;
      this.look.vertical = 0;
    }
  }, {
    key: "addEventListeners",
    value: function addEventListeners() {
      var _this2 = this;

      document.addEventListener('mousedown', function (e) {
        if (e.which === KEYS.MOUSE_LEFT) {
          _this2.attack1 = true;
        }

        if (e.which === KEYS.MOUSE_RIGHT) {
          _this2.attack2 = true;
        }
      });
      document.addEventListener('mouseup', function (e) {
        if (e.which === KEYS.MOUSE_LEFT) {
          _this2.attack1 = false;
        }

        if (e.which === KEYS.MOUSE_RIGHT) {
          _this2.attack2 = false;
        }
      });
      var timeout;
      document.addEventListener('mousemove', function (e) {
        _this2.look.horizontal += e.movementX || 0;
        _this2.look.vertical += e.movementY || 0;
        _this2.mouse.x = e.x;
        _this2.mouse.y = e.y;
        var cursorX = _this2.cursor.x + (e.movementX || 0);
        var cursorY = _this2.cursor.y + (e.movementY || 0);

        if (cursorX > 0 && cursorX < window.innerWidth) {
          _this2.cursor.x = cursorX;
        }

        if (cursorY > 0 && cursorY < window.innerHeight) {
          _this2.cursor.y = cursorY;
        }

        if (timeout !== undefined) {
          window.clearTimeout(timeout);
        }

        timeout = window.setTimeout(function () {
          document.dispatchEvent(new Event('onmousemoveend'));
        }, 100);
      });
      document.addEventListener('onmousemoveend', function (e) {
        // Horizontal look is cleaning by Player.update after rotation is applied
        // this.look.horizontal = 0;
        _this2.look.vertical = 0;
      });
      document.addEventListener('keydown', function (e) {
        switch (e.which) {
          case KEYS.ENTER:
            _this2.params.onAction && _this2.params.onAction();
            break;

          case KEYS.ESC:
            _this2.params.onExit && _this2.params.onExit();
            break;

          case KEYS.C:
            _this2.params.onSwitchCamera && _this2.params.onSwitchCamera();
            break;

          case KEYS.W:
          case KEYS.ARROW_UP:
            _this2.vertical = 1;
            break;

          case KEYS.S:
          case KEYS.ARROW_DOWN:
            _this2.vertical = -1;
            break;

          case KEYS.A:
          case KEYS.ARROW_LEFT:
            _this2.horizontal = -1;
            break;

          case KEYS.D:
          case KEYS.ARROW_RIGHT:
            _this2.horizontal = 1;
            break;

          case KEYS.X:
            _this2.look.back = true;
            break;

          case KEYS.F:
            _this2.look.cinematic = true;
            break;

          case KEYS.SPACE:
            _this2.jump = 1;
            break;
        }
      });
      document.addEventListener('keyup', function (e) {
        switch (e.which) {
          case KEYS.W:
          case KEYS.ARROW_UP:
            if (_this2.vertical === 1) {
              _this2.vertical = 0;
            }

            break;

          case KEYS.S:
          case KEYS.ARROW_DOWN:
            if (_this2.vertical === -1) {
              _this2.vertical = 0;
            }

            break;

          case KEYS.A:
          case KEYS.ARROW_LEFT:
            if (_this2.horizontal === -1) {
              _this2.horizontal = 0;
            }

            break;

          case KEYS.D:
          case KEYS.ARROW_RIGHT:
            if (_this2.horizontal === 1) {
              _this2.horizontal = 0;
            }

            break;

          case KEYS.X:
            _this2.look.back = false;
            break;

          case KEYS.F:
            _this2.look.cinematic = false;
            break;

          case KEYS.SPACE:
            _this2.jump = 0;
            break;
        }
      });
      window.addEventListener('wheel', function (e) {
        return _this2.params.onZoom && _this2.params.onZoom(e.deltaY / 100);
      });
      return this;
    }
  }]);

  return Input;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Intervals.js":
/*!*************************************!*\
  !*** ../client/src/js/Intervals.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Intervals; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Intervals = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Intervals, _AutoBindMethods);

  var _super = _createSuper(Intervals);

  function Intervals(scene) {
    var _this;

    _classCallCheck(this, Intervals);

    _this = _super.call(this);
    _this.scene = scene;
    _this.timePassed = 0;
    _this.lastFrame = 0;
    _this.intervals = [];
    _this.intervalIndex = 0;
    return _this;
  }

  _createClass(Intervals, [{
    key: "update",
    value: function update(now) {
      var _this2 = this;

      if (this.scene.ui && !this.scene.ui.isPause()) {
        this.timePassed += now - this.lastFrame;
        this.intervals.filter(function (i) {
          return _this2.timePassed - i.calledAt > i.interval;
        }).forEach(function (interval) {
          interval.calledAt = _this2.timePassed;
          interval.fn();

          if (interval.loops && --interval.loops === 0) {
            _this2.clearInterval(interval.id);
          }
        });
      }

      this.lastFrame = now;
    }
  }, {
    key: "getTimePassed",
    value: function getTimePassed() {
      return this.timePassed;
    }
  }, {
    key: "getDeltaTime",
    value: function getDeltaTime(now) {
      return now - this.lastFrame;
    }
  }, {
    key: "setInterval",
    value: function setInterval(fn, interval, immediately, loops) {
      if (fn && interval) {
        var calledAt = immediately ? this.timePassed - interval : this.timePassed;
        this.intervals.push({
          fn: fn,
          interval: interval,
          calledAt: calledAt,
          loops: loops,
          id: ++this.intervalIndex
        });
      }
    }
  }, {
    key: "setTimeout",
    value: function setTimeout(fn, timeout) {
      if (fn && timeout) {
        this.intervals.push({
          fn: fn,
          interval: timeout,
          loops: 1,
          calledAt: this.timePassed,
          id: ++this.intervalIndex
        });
      }
    }
  }, {
    key: "clearInterval",
    value: function clearInterval(id) {
      var intervalIdx = this.intervals.findIndex(function (i) {
        return i.id === id;
      });

      if (intervalIdx > -1) {
        this.intervals.splice(intervalIdx, 1);
      }
    }
  }]);

  return Intervals;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Locations/AbstractLocation.js":
/*!******************************************************!*\
  !*** ../client/src/js/Locations/AbstractLocation.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AbstractLocation; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var AbstractLocation = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(AbstractLocation, _AutoBindMethods);

  var _super = _createSuper(AbstractLocation);

  /**
   * @param {Scene} scene
   */
  function AbstractLocation(scene) {
    var _this;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unknown-level';

    _classCallCheck(this, AbstractLocation);

    _this = _super.call(this);
    _this.scene = scene;
    _this.id = id;
    return _this;
  }

  _createClass(AbstractLocation, [{
    key: "update",
    value: function update() {}
  }, {
    key: "startLocation",
    value: function startLocation() {}
  }, {
    key: "restartLocation",
    value: function restartLocation() {}
  }, {
    key: "stopLocation",
    value: function stopLocation() {}
  }, {
    key: "onAction",
    value: function onAction() {}
  }, {
    key: "getLocationName",
    value: function getLocationName() {
      return this.id;
    }
  }, {
    key: "createAmbientLight",
    value: function createAmbientLight() {
      var ambientLight = new THREE.AmbientLight(0x888888);
      ambientLight.castShadow = false;
      return ambientLight;
    }
  }, {
    key: "createShadowLight",
    value: function createShadowLight() {
      var light = new THREE.DirectionalLight(0xffffff, 10, 150);
      light.intensity = 1;
      light.shadow.bias = -0.00001;
      var shadowSize = 25;
      light.castShadow = true;
      light.shadow.camera.left = -shadowSize;
      light.shadow.camera.right = shadowSize;
      light.shadow.camera.top = shadowSize;
      light.shadow.camera.bottom = -shadowSize;
      light.shadow.mapSize.width = 512;
      light.shadow.mapSize.height = 512;
      light.shadow.camera.near = 10;
      light.shadow.camera.far = 150;
      light.shadow.camera.visible = true;
      return light;
    }
  }, {
    key: "createSkybox",
    value: function createSkybox() {
      var materialArray = ['xpos', 'xneg', 'ypos', 'yneg', 'zpos', 'zneg'].map(function (direction) {
        var url = "./assets/textures/sky-nebula/nebula-".concat(direction, ".png");
        return new THREE.MeshBasicMaterial({
          map: new THREE.TextureLoader().load(url),
          side: THREE.BackSide,
          fog: false
        });
      });
      var skyGeometry = new THREE.CubeGeometry(75000, 75000, 75000);
      var skyMaterial = new THREE.MeshFaceMaterial(materialArray);
      return new THREE.Mesh(skyGeometry, skyMaterial);
    }
  }]);

  return AbstractLocation;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Locations/DreamTown/Areas.js":
/*!*****************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/Areas.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var buildArea = function buildArea(areaId, map) {
  var _AreaSizes$areaId = AreaSizes[areaId],
      width = _AreaSizes$areaId.width,
      height = _AreaSizes$areaId.height;

  var waypointXToWorldX = function waypointXToWorldX(position) {
    return position - width / 2;
  };

  var waypointYToWorldZ = function waypointYToWorldZ(position) {
    return position - height / 2;
  };

  var worldXToWaypointX = function worldXToWaypointX(position) {
    var graphX = Math.round(position + width / 2);
    return Math.min(Math.max(graphX, 4), width - 5);
  };

  var worldZToWaypointY = function worldZToWaypointY(position) {
    var graphY = Math.round(position + height / 2);
    return Math.min(Math.max(graphY, 4), height - 5);
  };

  var area = {
    id: areaId,
    waypointXToWorldX: waypointXToWorldX,
    waypointYToWorldZ: waypointYToWorldZ,
    worldXToWaypointX: worldXToWaypointX,
    worldZToWaypointY: worldZToWaypointY,
    width: width,
    height: height
  };
  return map(area);
};

var AreaSizes = {
  FLOOR_0: {
    width: 150,
    height: 150
  },
  FLOOR_1: {
    width: 270,
    height: 270
  },
  FLOOR_2: {
    width: 270,
    height: 270
  }
};
var Areas = {
  FLOOR_0: buildArea('FLOOR_0', function (area) {
    return _objectSpread(_objectSpread({}, area), {}, {
      includesPosition: function includesPosition(position) {
        return position.y < 100;
      },
      getWorldWaypointByXY: function getWorldWaypointByXY(x, y) {
        return {
          x: area.waypointXToWorldX(x),
          y: 0.2,
          z: area.waypointYToWorldZ(y)
        };
      },
      getWaypointPortals: function getWaypointPortals() {
        return [{
          from: {
            x: area.worldXToWaypointX(-49),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-49),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_1'
          }
        }, {
          from: {
            x: area.worldXToWaypointX(-49),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-49),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_2'
          }
        }];
      }
    });
  }),
  FLOOR_1: buildArea('FLOOR_1', function (area) {
    return _objectSpread(_objectSpread({}, area), {}, {
      includesPosition: function includesPosition(position) {
        return position.y < 200;
      },
      getWorldWaypointByXY: function getWorldWaypointByXY(x, y) {
        return {
          x: area.waypointXToWorldX(x),
          y: 100.2,
          z: area.waypointYToWorldZ(y)
        };
      },
      getWaypointPortals: function getWaypointPortals() {
        return [{
          from: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_0'
          }
        }, {
          from: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_2'
          }
        }];
      }
    });
  }),
  FLOOR_2: buildArea('FLOOR_2', function (area) {
    return _objectSpread(_objectSpread({}, area), {}, {
      includesPosition: function includesPosition(position) {
        return position.y >= 200;
      },
      getWorldWaypointByXY: function getWorldWaypointByXY(x, y) {
        return {
          x: area.waypointXToWorldX(x),
          y: 200.2,
          z: area.waypointYToWorldZ(y)
        };
      },
      getWaypointPortals: function getWaypointPortals() {
        return [{
          from: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_0'
          }
        }, {
          from: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_1'
          }
        }];
      }
    });
  })
};
/* harmony default export */ __webpack_exports__["default"] = (Areas);

/***/ }),

/***/ "../client/src/js/Locations/DreamTown/Elevator.js":
/*!********************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/Elevator.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Elevator; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Elevator = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Elevator, _AutoBindMethods);

  var _super = _createSuper(Elevator);

  function Elevator(scene, params) {
    var _this;

    _classCallCheck(this, Elevator);

    _this = _super.call(this);
    _this.scene = scene;
    _this.params = params;
    _this.currentFloor = 1;
    _this.target = 0;
    _this.direction = -1;
    _this.speed = 0.3;
    _this.standTime = 10;
    _this.object = _this.scene.models.createCube(params);
    _this.standAt = _this.scene.intervals.getTimePassed();
    return _this;
  }

  _createClass(Elevator, [{
    key: "isReleased",
    value: function isReleased() {
      return this.scene.intervals.getTimePassed() - this.standAt > this.standTime * 1000;
    }
  }, {
    key: "isCarrying",
    value: function isCarrying(_ref) {
      var x = _ref.x,
          y = _ref.y,
          z = _ref.z;
      var _this$object = this.object,
          position = _this$object.position,
          scale = _this$object.scale;
      return Math.abs(x - position.x) < scale.x / 2 && Math.abs(z - position.z) < scale.z / 2 && y - position.y < scale.y / 2 // && (y + 1.7) - position.y > -scale.y / 2
      ;
    }
  }, {
    key: "getFloor",
    value: function getFloor() {
      return this.direction > 0 ? this.object.position.y >= 200 && 2 || this.object.position.y >= 100 && 1 || 0 : this.object.position.y > 100 && 2 || this.object.position.y > 0 && 1 || 0;
    }
  }, {
    key: "update",
    value: function update() {
      var _this2 = this;

      if (this.isReleased()) {
        var floor = this.getFloor();

        if (floor !== this.currentFloor) {
          this.standAt = this.scene.intervals.getTimePassed();
          this.currentFloor = floor;

          if (floor === 2) {
            this.direction = -1;
          } else if (floor === 0) {
            this.direction = 1;
          }

          this.target = floor + this.direction;
        } else {
          var getCarryingPosition = function getCarryingPosition(unit) {
            return _objectSpread(_objectSpread({}, unit.position), {}, {
              y: unit.position.y - (_this2.direction > 0 ? 2 : 0.1)
            });
          };

          var carryingUnits = this.scene.gameObjectsService.getUnits().filter(function (unit) {
            return _this2.isCarrying(getCarryingPosition(unit));
          });
          var thisAcceleration = this.speed * this.direction;
          carryingUnits.forEach(function (unit) {
            unit.position.y += thisAcceleration;
          });
          this.object.position.y += thisAcceleration;
        }
      }
    }
  }]);

  return Elevator;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Locations/DreamTown/Environment.js":
/*!***********************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/Environment.js ***!
  \***********************************************************/
/*! exports provided: createEnvironment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEnvironment", function() { return createEnvironment; });
var createEnvironment = function createEnvironment(_ref) {
  var load = _ref.load,
      trees = _ref.trees,
      houses = _ref.houses,
      addColliderFunction = _ref.addColliderFunction,
      onLoad = _ref.onLoad;
  var pivot = new THREE.Object3D();
  pivot.matrixAutoUpdate = false;
  pivot.name = 'LEVEL_ENVIRONMENT';
  var isEnvironmentLoaded = false;
  var isTreeLoaded = false;
  var isHouseLoaded = false;

  var checkIsAllLoaded = function checkIsAllLoaded() {
    if (isEnvironmentLoaded && isTreeLoaded && isHouseLoaded) {
      onLoad && onLoad();
    }
  };

  load({
    baseUrl: './assets/models/environment/enviroment',
    noScene: true,
    castShadow: false,
    callback: function callback(object) {
      pivot.add(object.scene);
      object.scene.matrixAutoUpdate = false;
      object.scene.updateMatrix();
      isEnvironmentLoaded = true;
      checkIsAllLoaded();
    }
  });
  load({
    baseUrl: './assets/models/environment/tree',
    noScene: true,
    receiveShadow: false,
    callback: function callback(loadedModel) {
      isTreeLoaded = true;
      checkIsAllLoaded();
      trees.forEach(function (position) {
        var model = loadedModel.scene.clone();
        model.name = 'Tree';
        model.position.set(position.x, position.y, position.z);
        model.matrixAutoUpdate = false;
        model.updateMatrix();
        var _model$position = model.position,
            x = _model$position.x,
            z = _model$position.z;
        addColliderFunction(function (position) {
          return Math.abs(position.x - x) < 2 && Math.abs(position.z - z) < 2;
        });
        pivot.add(model);
      });
    }
  });
  load({
    baseUrl: './assets/models/environment/house1',
    receiveShadow: false,
    noScene: true,
    callback: function callback(loadedModel) {
      isHouseLoaded = true;
      checkIsAllLoaded();
      houses.forEach(function (position) {
        var model = loadedModel.scene.clone();
        model.name = 'House1';
        model.position.set(position.x, position.y, position.z);
        model.rotation.set(position.rx || 0, position.ry || 0, position.rz || 0);
        model.matrixAutoUpdate = false;
        model.updateMatrix();
        var _model$position2 = model.position,
            x = _model$position2.x,
            z = _model$position2.z;
        addColliderFunction(function (unitPosition) {
          return Math.abs(unitPosition.x - x) < (position.ry < -3.13 ? 4 : 3) && Math.abs(unitPosition.z - z) < (position.ry < -3.13 ? 3 : 4);
        });
        pivot.add(model);
      });
    }
  });
  return pivot;
};



/***/ }),

/***/ "../client/src/js/Locations/DreamTown/Location.js":
/*!********************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/Location.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Location; });
/* harmony import */ var _AbstractLocation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AbstractLocation */ "../client/src/js/Locations/AbstractLocation.js");
/* harmony import */ var _GameObjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../GameObjects */ "../client/src/js/GameObjects.js");
/* harmony import */ var _Elevator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Elevator */ "../client/src/js/Locations/DreamTown/Elevator.js");
/* harmony import */ var _Environment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Environment */ "../client/src/js/Locations/DreamTown/Environment.js");
/* harmony import */ var _Areas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Areas */ "../client/src/js/Locations/DreamTown/Areas.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }







var Location = /*#__PURE__*/function (_AbstractLocation) {
  _inherits(Location, _AbstractLocation);

  var _super = _createSuper(Location);

  /**
   * @param {Scene} scene
   */
  function Location(scene) {
    var _this;

    _classCallCheck(this, Location);

    _this = _super.call(this, scene);
    _this.id = 'dream-town';
    _this.shadowLightPosition = new THREE.Vector3(25, 50, 25);

    _this.scene.ui.setLoading(true);

    _this.scene.ui.setPause(true);

    _this.environment = Object(_Environment__WEBPACK_IMPORTED_MODULE_3__["createEnvironment"])({
      load: _this.scene.models.loadGLTF,
      addColliderFunction: _this.scene.colliders.addColliderFunction,
      trees: [{
        x: 0,
        y: 0,
        z: 15
      }, {
        x: 0,
        y: 0,
        z: -15
      }, {
        x: 15,
        y: 0,
        z: 0
      }, {
        x: -15,
        y: 0,
        z: 0
      }, {
        x: 15,
        y: 0,
        z: 15
      }, {
        x: 15,
        y: 0,
        z: -15
      }, {
        x: 30,
        y: 0,
        z: 20
      }, {
        x: 30,
        y: 0,
        z: -20
      }, {
        x: 45,
        y: 0,
        z: -35
      }, {
        x: 45,
        y: 0,
        z: 35
      }],
      houses: [{
        x: 0,
        y: 0,
        z: 40,
        ry: -Math.PI
      }, {
        x: -10,
        y: 0,
        z: 30,
        ry: Math.PI / 2
      }, {
        x: 10,
        y: 0,
        z: 30,
        ry: -Math.PI / 2
      } // { x: 75, y: 100, z: 75 },
      // { x: 75, y: 200, z: 75 },
      ],
      onLoad: function onLoad() {
        _this.scene.ui.setLoading(false);

        _this.scene.ui.setPause(false);

        _this.scene.notify('Dream Town');

        _this.startLocation();
      }
    });
    _this.ambientLight = _this.createAmbientLight();
    _this.shadowLight = _this.createShadowLight();

    _this.scene.add(_this.environment);

    _this.scene.add(_this.ambientLight);

    _this.scene.add(_this.shadowLight);

    _this.elevator = new _Elevator__WEBPACK_IMPORTED_MODULE_2__["default"](scene, {
      position: {
        x: -48,
        y: 100,
        z: 0
      },
      x: 4,
      y: 1,
      z: 4
    });
    var color = 0x000000;
    var near = 10;
    var far = 100;
    _this.scene.scene.fog = new THREE.Fog(color, near, far);

    _this.createLocationColliders();

    return _this;
  }

  _createClass(Location, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Location.prototype), "update", this).call(this);

      var player = this.scene.getPlayer();

      if (player) {
        this.elevator.update();
        this.shadowLight.position.copy(player.position).add(this.shadowLightPosition);

        if (this.shadowLight.target !== player.object) {
          this.shadowLight.target = player.object;
        }
      }
    }
  }, {
    key: "reviveHero",
    value: function reviveHero() {
      var player = this.scene.getPlayer();
      player.params.hp = 10;
      player.position.set(0, 0.3, 30);
      player.animationState.isDie = false;
      this.scene.particles.createEffect({
        effect: 'level-up/level-up',
        scale: 1.5,
        attachTo: player.object
      });
    }
  }, {
    key: "afterClear",
    value: function afterClear() {
      var _this2 = this;

      this.scene.units.createPlayer({
        /**
         * @param {Player} player
         */
        onCreate: function onCreate(player) {
          _this2.scene.camera.player = player;

          _this2.scene.ui.updatePlayerParams();

          player.position.set(0, 0.3, 30);
        },
        onDie: function onDie() {
          return window.setTimeout(function () {
            _this2.scene.ui.setPause(true);
          }, 2500);
        },
        onKill: function onKill(object) {
          var player = _this2.scene.getPlayer();

          player.addExperience(object.params.bounty);
          player.addMoney(object.params.bounty);
        },
        onDamageTaken: function onDamageTaken() {
          return _this2.scene.ui.updatePlayerParams();
        },
        onLocationUp: function onLocationUp() {
          return _this2.scene.ui.updatePlayerParams();
        }
      });
      this.createInteractiveGameObjects();
    }
  }, {
    key: "startLocation",
    value: function startLocation() {
      if (this.interval) {
        clearInterval(this.interval);
      }
    }
  }, {
    key: "restartLocation",
    value: function restartLocation() {
      this.scene.clearScene();
    }
  }, {
    key: "stopLocation",
    value: function stopLocation() {
      this.scene.remove(this.environment); // this.scene.remove(this.skybox);

      this.scene.remove(this.ambientLight);
      this.scene.remove(this.shadowLight);
      this.scene.gameObjectsService.removeAllExceptPlayer();

      if (this.interval) {
        clearInterval(this.interval);
      }
    }
  }, {
    key: "createInteractiveGameObjects",
    value: function createInteractiveGameObjects() {
      var _this3 = this;

      var createHealItem = function createHealItem() {
        return _this3.scene.intervals.setTimeout(function () {
          var itemHealPosition = new THREE.Vector3(-6.5, 0.1, 32.8);

          _this3.scene.gameObjectsService.createItem({
            model: 'item-heal',
            position: itemHealPosition,
            canPickup: function canPickup(unit) {
              return unit.getMaxHP() - unit.getHP() > 0;
            },
            onPickup: function onPickup(unit) {
              unit.addHP(25);
              createHealItem();
            }
          });
        }, 10000);
      };

      createHealItem();

      var getAIParams = function getAIParams(_ref) {
        var level = _ref.level,
            params = _objectWithoutProperties(_ref, ["level"]);

        return _objectSpread(_objectSpread({}, params), {}, {
          level: level,
          scale: 0.7 + level / 10,
          onDie: function onDie() {
            return _this3.scene.units.createAI(getAIParams(_objectSpread(_objectSpread({}, params), {}, {
              level: level + 1 + Math.round(Math.random() * level)
            })));
          }
        });
      };

      var getGoatsParams = function getGoatsParams(level, position) {
        return getAIParams({
          level: level,
          position: position,
          fraction: 'goats',
          name: level <= 10 ? 'Goat Warrior' : level <= 20 ? 'Goat Elite' : 'Goat Destroyer'
        });
      };

      var getFriendlyParams = function getFriendlyParams(level, position, rotation) {
        return getAIParams({
          level: level,
          position: position,
          rotation: rotation,
          fraction: 'friendly',
          name: 'Friendly Citizen'
        });
      };

      this.units = [getGoatsParams(3, {
        x: -17,
        y: 0.2,
        z: -5
      }), getGoatsParams(3, {
        x: 17,
        y: 0.2,
        z: -5
      }), getGoatsParams(2, {
        x: -15,
        y: 0.2,
        z: -30
      }), getGoatsParams(2, {
        x: 15,
        y: 0.2,
        z: -30
      }), getGoatsParams(5, {
        x: -30,
        y: 0.2,
        z: -9
      }), getGoatsParams(5, {
        x: 30,
        y: 0.2,
        z: -9
      }), getGoatsParams(4, {
        x: -45,
        y: 0.2,
        z: -30
      }), getGoatsParams(4, {
        x: 45,
        y: 0.2,
        z: -30
      }), getGoatsParams(1, {
        x: 45,
        y: 0.2,
        z: 45
      }), getGoatsParams(1, {
        x: 45,
        y: 0.2,
        z: -45
      }), getGoatsParams(25, {
        x: 0,
        y: 0.2,
        z: 0
      }), getFriendlyParams(5, {
        x: -0.8,
        y: 0.2,
        z: 40 - 4.03
      }, {
        y: Math.PI
      }), getFriendlyParams(5, {
        x: -10 + 3.5,
        y: 0.2,
        z: 29.2
      }, {
        y: Math.PI / 2
      }), getFriendlyParams(5, {
        x: 10 - 3.5,
        y: 0.2,
        z: 30.8
      }, {
        y: -Math.PI / 2
      })].forEach(this.scene.units.createAI);
    }
  }, {
    key: "createLocationColliders",
    value: function createLocationColliders() {
      var _this4 = this;

      var isBetween = function isBetween(v, min, max) {
        return v > min && v < max;
      };

      this.scene.colliders.addColliderFunction(function (position, gameObject) {
        var x = position.x,
            y = position.y,
            z = position.z;
        var absX = Math.abs(x);
        var absZ = Math.abs(z);

        if (y < 0.1 && absX < 50 && absZ < 50 || // floor 0
        y < (absX - 50) / 1.5 && absX > 50 || y < (absZ - 50) / 1.5 && absZ > 50 // out of floor 0
        || y < 90 && absX > 96 && absZ > 96 // out of floor 0
        || isBetween(y, 90, 100) && (absX > 50 || absZ > 50) // floor 1
        || isBetween(y, 90, 190) && (absX > 135 || absZ > 135) // out of floor 1
        || isBetween(y, 190, 200) && (absX > 50 || absZ > 50) // floor 2
        || y > 190 && (absX > 133 || absZ > 133) // out of floor 2
        || _this4.elevator.isCarrying(position)) {
          return true;
        } // TODO: Check if we need units colliders
        // const units = this.scene.units.getAliveUnits();
        //
        // for(let unit of units) {
        //     if (
        //         unit !== gameObject
        //         && (
        //             !(gameObject instanceof Fire)
        //             || gameObject.params.parent !== unit
        //         )
        //         && unit.getCollider(position)
        //     ) {
        //         return true;
        //     }
        // }


        return false;
      });
    }
  }, {
    key: "getAreas",
    value: function getAreas() {
      var _this5 = this;

      var areas = Object.values(_Areas__WEBPACK_IMPORTED_MODULE_4__["default"]);

      var generateWaypoints = function generateWaypoints(width, height, map) {
        return new Array(width).fill(null).map(function (null1, x) {
          return new Array(height).fill(null).map(function (null2, y) {
            return map(x, y);
          });
        });
      };

      return areas.map(function (area) {
        var result = _objectSpread({}, area);

        result.getWaypoints = function () {
          return generateWaypoints(area.width, area.height, function (x, y) {
            if ( // Elevator
            Math.abs(area.waypointXToWorldX(x) - _this5.elevator.params.position.x) <= 5 && Math.abs(area.waypointYToWorldZ(y) - _this5.elevator.params.position.z) <= 1) {
              return 1;
            }

            if (area.id !== 'FLOOR_0' && ( // Center hole
            Math.abs(area.waypointXToWorldX(x)) < 51 && Math.abs(area.waypointYToWorldZ(y)) < 51 || Math.abs(area.waypointXToWorldX(x)) <= 51 && Math.abs(area.waypointYToWorldZ(y)) <= 51 && Math.abs(area.waypointXToWorldX(x)) >= 50 && Math.abs(area.waypointYToWorldZ(y)) >= 50)) {
              return 0;
            }

            if (area.id === 'FLOOR_0' && ( // Floor out
            Math.abs(area.waypointXToWorldX(x)) >= 49 || Math.abs(area.waypointYToWorldZ(y)) >= 49)) {
              return 1;
            }

            return Number(_this5.checkWayForWaypoint(area.getWorldWaypointByXY(x, y)));
          });
        };

        return result;
      });
    }
  }, {
    key: "checkWayForWaypoint",
    value: function checkWayForWaypoint(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          z = _ref2.z;
      var checkWay = this.scene.colliders.checkWay;

      var checkNear = function checkNear(range, diagonal) {
        return checkWay(new THREE.Vector3(x + range, y, z)) && checkWay(new THREE.Vector3(x - range, y, z)) && checkWay(new THREE.Vector3(x, y, z + range)) && checkWay(new THREE.Vector3(x, y, z - range)) && (!diagonal || checkWay(new THREE.Vector3(x + range, y, z + range)) && checkWay(new THREE.Vector3(x - range, y, z - range)) && checkWay(new THREE.Vector3(x - range, y, z + range)) && checkWay(new THREE.Vector3(x + range, y, z - range)));
      };

      return checkWay(new THREE.Vector3(x, y, z)) && checkNear(1, true) && checkNear(2);
    }
  }]);

  return Location;
}(_AbstractLocation__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Locations/DreamTown/index.js":
/*!*****************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/index.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Location__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Location */ "../client/src/js/Locations/DreamTown/Location.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _Location__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/***/ }),

/***/ "../client/src/js/Models.js":
/*!**********************************!*\
  !*** ../client/src/js/Models.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Models; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Models = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Models, _AutoBindMethods);

  var _super = _createSuper(Models);

  function Models(scene) {
    var _this;

    _classCallCheck(this, Models);

    _this = _super.call(this);
    _this.scene = scene;
    return _this;
  }
  /**
   * @param {Object} params
   * @param {number} params.repeatX
   * @param {number} params.repeatY
   * @param {number} params.emissive
   * @param {THREE.Vector3} params.position
   * @returns {THREE.Mesh}
   */


  _createClass(Models, [{
    key: "createCube",
    value: function createCube(params) {
      params = params || {};
      var materialParams = {};

      if (params.image) {
        var texture = new THREE.TextureLoader().load(params.image);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(params.repeatX || 1, params.repeatY || 1);
        materialParams.map = texture;
      }

      if (params.emissive) {
        materialParams.emissive = new THREE.Color(params.emissive);
        materialParams.emissiveIntensity = 1.0;
        materialParams.emissiveMap = null;
      }

      var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1), new THREE.MeshLambertMaterial(materialParams));
      cube.scale.set(params.x || 1, params.y || 1, params.z || 1);

      if (params.position) {
        cube.position.set(params.position.x || 0, params.position.y || 0, params.position.z || 0);
      }

      if (params.rotation) {
        cube.rotation.set(params.rotation.x || 0, params.rotation.y || 0, params.rotation.z || 0);
      }

      if (!params.noScene) {
        this.scene.add(cube);
      }

      return cube;
    }
  }, {
    key: "loadGLTF",
    value: function loadGLTF(_ref) {
      var _this2 = this;

      var baseUrl = _ref.baseUrl,
          _ref$isGLTF = _ref.isGLTF,
          isGLTF = _ref$isGLTF === void 0 ? false : _ref$isGLTF,
          _ref$noScene = _ref.noScene,
          noScene = _ref$noScene === void 0 ? false : _ref$noScene,
          _ref$callback = _ref.callback,
          callback = _ref$callback === void 0 ? function () {
        return null;
      } : _ref$callback,
          _ref$castShadow = _ref.castShadow,
          castShadow = _ref$castShadow === void 0 ? true : _ref$castShadow,
          _ref$receiveShadow = _ref.receiveShadow,
          receiveShadow = _ref$receiveShadow === void 0 ? true : _ref$receiveShadow;
      var loader = new GLTFLoader();
      var url = "".concat(baseUrl, ".glb").concat(isGLTF ? '.gltf' : '');
      loader.load(url, function (loadedModel) {
        loadedModel.scene.traverse(function (child) {
          if (child instanceof THREE.Mesh) {
            child.castShadow = castShadow;
            child.receiveShadow = receiveShadow;
          }
        });
        callback(loadedModel);

        if (!noScene) {
          _this2.scene.add(loadedModel.scene);
        }
      });
    }
  }]);

  return Models;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Particles.js":
/*!*************************************!*\
  !*** ../client/src/js/Particles.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Particles; });
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scene */ "../client/src/js/Scene.js");
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameObjects/AnimatedGameObject */ "../client/src/js/GameObjects/AnimatedGameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var Particles = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Particles, _AutoBindMethods);

  var _super = _createSuper(Particles);

  /**
   * @param {Scene} scene
   */
  function Particles(scene) {
    var _this;

    _classCallCheck(this, Particles);

    _this = _super.call(this);
    _this.scene = scene;
    _this.particles = [];
    return _this;
  }

  _createClass(Particles, [{
    key: "update",
    value: function update() {
      this.particles.forEach(function (p) {
        return p.update();
      });
    }
  }, {
    key: "createSnow",
    value: function createSnow() {
      var _this2 = this;

      var area = new THREE.Vector3(100, 25, 100);
      this.createParticles({
        particleCount: 10000,
        color: 0x888888,
        blending: THREE.NormalBlending,
        position: new THREE.Vector3(-area.x / 2, 0, -area.z / 2),
        getParticlePosition: function getParticlePosition(i) {
          var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this2.getRandomPosition(area);

          if (position.y < 0) {
            var newPosition = _this2.getRandomPosition(area);

            position.x = newPosition.x;
            position.y = area.y;
            position.z = newPosition.z;
          }

          return position;
        }
      });
    }
  }, {
    key: "createEffect",
    value: function createEffect(_ref) {
      var _this3 = this;

      var _ref$scale = _ref.scale,
          scale = _ref$scale === void 0 ? 1.5 : _ref$scale,
          _ref$effect = _ref.effect,
          effect = _ref$effect === void 0 ? 'level-up-alt/level-up' : _ref$effect,
          _ref$position = _ref.position,
          position = _ref$position === void 0 ? {} : _ref$position,
          attachTo = _ref.attachTo,
          _ref$lifeTime = _ref.lifeTime,
          lifeTime = _ref$lifeTime === void 0 ? 2080 : _ref$lifeTime;
      this.scene.models.loadGLTF({
        baseUrl: './assets/models/effects/' + effect,
        noScene: true,
        castShadow: false,
        receiveShadow: false,
        callback: function callback(loadedObject) {
          loadedObject.scene.scale.set(scale, scale, scale);
          loadedObject.scene.traverse(function (child) {
            if (child.isMesh) {
              child.material.transparent = true;
              child.material.alphaTest = 0.5;
            }
          });
          loadedObject.scene.position.set(position.x || 0, position.y || 0, position.z || 0);

          if (attachTo) {
            attachTo.add(loadedObject.scene);
          }

          var effect = new _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_2__["default"]({
            object: loadedObject.scene,
            animations: loadedObject.animations
          });

          _this3.scene.gameObjectsService.hookGameObject(effect);

          _this3.scene.intervals.setTimeout(function () {
            return _this3.scene.gameObjectsService.destroyGameObject(effect);
          }, lifeTime);
        }
      });
    }
  }, {
    key: "loadEffect",
    value: function loadEffect() {
      var _this4 = this;

      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$particleName = _ref2.particleName,
          particleName = _ref2$particleName === void 0 ? 'blood' : _ref2$particleName,
          _ref2$position = _ref2.position,
          position = _ref2$position === void 0 ? new THREE.Vector3() : _ref2$position,
          _ref2$scale = _ref2.scale,
          scale = _ref2$scale === void 0 ? new THREE.Vector3(1, 1, 1) : _ref2$scale;

      var gameObjectsService = this.scene.gameObjectsService;
      return this.scene.models.loadGLTF({
        baseUrl: "./assets/models/effects/".concat(particleName),
        castShadow: false,
        receiveShadow: false,
        callback: function callback(gltf) {
          gltf.scene.position.copy(position);
          gltf.scene.scale.copy(scale);
          gltf.scene.rotation.set(0, Math.random() * Math.PI, 0);
          var particleSystem = gameObjectsService.hookGameObject(new _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_2__["default"]({
            object: gltf.scene,
            animations: gltf.animations
          }));

          _this4.scene.intervals.setTimeout(function () {
            return _this4.scene.gameObjectsService.destroyGameObject(particleSystem);
          }, 625);
        }
      });
    }
  }, {
    key: "getRandomPosition",
    value: function getRandomPosition(area) {
      var random = function random(from, to) {
        return Math.random() * (to - from) + from;
      };

      return new THREE.Vector3(random(0, area.x), random(0, area.y), random(0, area.z));
    }
  }, {
    key: "createParticles",
    value: function createParticles() {
      var _this5 = this;

      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$particleCount = _ref3.particleCount,
          particleCount = _ref3$particleCount === void 0 ? 1000 : _ref3$particleCount,
          _ref3$noScene = _ref3.noScene,
          noScene = _ref3$noScene === void 0 ? false : _ref3$noScene,
          _ref3$position = _ref3.position,
          position = _ref3$position === void 0 ? new THREE.Vector3(0, 5, 0) : _ref3$position,
          _ref3$size = _ref3.size,
          size = _ref3$size === void 0 ? 0.01 : _ref3$size,
          _ref3$color = _ref3.color,
          color = _ref3$color === void 0 ? 0xFFFFFF : _ref3$color,
          _ref3$blending = _ref3.blending,
          blending = _ref3$blending === void 0 ? THREE.AdditiveBlending : _ref3$blending,
          _ref3$depthTest = _ref3.depthTest,
          depthTest = _ref3$depthTest === void 0 ? true : _ref3$depthTest,
          _ref3$transparent = _ref3.transparent,
          transparent = _ref3$transparent === void 0 ? true : _ref3$transparent,
          _ref3$area = _ref3.area,
          area = _ref3$area === void 0 ? new THREE.Vector3(10, 5, 10) : _ref3$area,
          _ref3$getParticleVelo = _ref3.getParticleVelocity,
          getParticleVelocity = _ref3$getParticleVelo === void 0 ? function () {
        return new THREE.Vector3(-0.01, -0.01, 0);
      } : _ref3$getParticleVelo,
          _ref3$getParticlePosi = _ref3.getParticlePosition,
          getParticlePosition = _ref3$getParticlePosi === void 0 ? function (i) {
        var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this5.getRandomPosition(area);
        return position;
      } : _ref3$getParticlePosi;

      var particles = new THREE.Geometry();
      var material = new THREE.PointCloudMaterial({
        color: color,
        size: size,
        blending: blending,
        depthTest: depthTest,
        transparent: transparent
      });

      for (var i = 0; i < particleCount; i++) {
        var particle = getParticlePosition(i);
        particles.velocity = getParticleVelocity(i, particle);
        particles.vertices.push(particle);
      }

      var particleSystem = new THREE.PointCloud(particles, material);
      particleSystem.position.copy(position);
      this.particles.push({
        object: particleSystem,
        update: function update() {
          var index = particleCount;

          while (index--) {
            var _particle = particles.vertices[index];
            _particle.velocity = getParticleVelocity(index, _particle);
            _particle.x += _particle.velocity.x;
            _particle.y += _particle.velocity.y;
            _particle.z += _particle.velocity.z;
            var particlePosition = getParticlePosition(index, _particle);
            _particle.x = particlePosition.x;
            _particle.y = particlePosition.y;
            _particle.z = particlePosition.z;
          }

          particles.verticesNeedUpdate = true;
        }
      });

      if (!noScene) {
        this.scene.add(particleSystem);
      }

      return particleSystem;
    }
  }]);

  return Particles;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "../client/src/js/PathFinder.js":
/*!**************************************!*\
  !*** ../client/src/js/PathFinder.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Colliders; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _Utils_AStar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils/AStar */ "../client/src/js/Utils/AStar.js");
/* harmony import */ var _Utils_AStar__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Utils_AStar__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Colliders = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Colliders, _AutoBindMethods);

  var _super = _createSuper(Colliders);

  function Colliders(scene) {
    var _this;

    _classCallCheck(this, Colliders);

    _this = _super.call(this);
    _this.scene = scene;
    _this.areas = [];
    return _this;
  }

  _createClass(Colliders, [{
    key: "getNextPoint",
    value: function getNextPoint(from, to) {
      var area = this.getAreaByPosition(from),
          fromX = area.worldXToWaypointX(from.x),
          fromY = area.worldZToWaypointY(from.z),
          areaTo = this.getAreaByPosition(to);
      var toX;
      var toY;
      var portal;

      if (area.id === areaTo.id) {
        toX = area.worldXToWaypointX(to.x);
        toY = area.worldZToWaypointY(to.z);
      } else {
        portal = area.getWaypointPortals().find(function (portal) {
          return portal.to.areaId === areaTo.id;
        });

        if (portal) {
          toX = portal.from.x;
          toY = portal.from.y;
        } else {
          return to;
        }
      }

      var start = this.getFreeGraphPoint(area.graph, fromX, fromY);
      var end = this.getFreeGraphPoint(area.graph, toX, toY);

      if (start && end) {
        var result = _Utils_AStar__WEBPACK_IMPORTED_MODULE_1___default.a.astar.search(area.graph, start, end, {
          heuristic: _Utils_AStar__WEBPACK_IMPORTED_MODULE_1___default.a.astar.heuristics.diagonal
        });
        var nextGraphPoint = result[2] || result[1];

        if (nextGraphPoint) {
          var nextWorldPoint = new THREE.Vector3(area.waypointXToWorldX(nextGraphPoint.x), to.y, area.waypointYToWorldZ(nextGraphPoint.y));
          return nextWorldPoint;
        } else {
          return null;
        }
      }

      return to;
    }
  }, {
    key: "getFreeGraphPoint",
    value: function getFreeGraphPoint(graph, x, y) {
      var grid = graph.grid;

      var getWeight = function getWeight(x, y) {
        return grid[x] && grid[x][y] && grid[x][y].weight;
      };

      var getNearFreePoint = function getNearFreePoint(range) {
        return getWeight(x + range, y) && grid[x + range][y] || getWeight(x - range, y) && grid[x - range][y] || getWeight(x, y + range) && grid[x][y + range] || getWeight(x, y - range) && grid[x][y - range];
      };

      return getWeight(grid[x][y]) && grid[x][y] || getNearFreePoint(1) || getNearFreePoint(2) || getNearFreePoint(3) || getNearFreePoint(4) || null;
    }
  }, {
    key: "rebuildAreas",
    value: function rebuildAreas() {
      if (this.scene.location) {
        this.areas = this.scene.location.getAreas().map(function (area) {
          return _objectSpread(_objectSpread({}, area), {}, {
            graph: new _Utils_AStar__WEBPACK_IMPORTED_MODULE_1___default.a.Graph(area.getWaypoints(), {
              diagonal: true
            })
          });
        });
      }
    }
  }, {
    key: "getAreaByPosition",
    value: function getAreaByPosition(position) {
      return this.areas.find(function (area) {
        return area.includesPosition(position);
      });
    }
  }]);

  return Colliders;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Scene.js":
/*!*********************************!*\
  !*** ../client/src/js/Scene.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Scene; });
/* harmony import */ var _GameObjects__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameObjects */ "../client/src/js/GameObjects.js");
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Camera */ "../client/src/js/Camera.js");
/* harmony import */ var _Connection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Connection */ "../client/src/js/Connection.js");
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Input */ "../client/src/js/Input.js");
/* harmony import */ var _Intervals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Intervals */ "../client/src/js/Intervals.js");
/* harmony import */ var _Locations_DreamTown__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Locations/DreamTown */ "../client/src/js/Locations/DreamTown/index.js");
/* harmony import */ var _Colliders__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Colliders */ "../client/src/js/Colliders.js");
/* harmony import */ var _Models__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Models */ "../client/src/js/Models.js");
/* harmony import */ var _Particles__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Particles */ "../client/src/js/Particles.js");
/* harmony import */ var _PathFinder__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PathFinder */ "../client/src/js/PathFinder.js");
/* harmony import */ var _Units__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Units */ "../client/src/js/Units.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

 // import Audio from './Audio';














var Scene = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Scene, _AutoBindMethods);

  var _super = _createSuper(Scene);

  /**
   * @param {Renderer} renderer
   * @param {{
   *  setRestartButtonVisible: function,
   *  setPause: function,
   *  restartGame: function,
   *  isPause: function,
   *  isThirdPerson: function,
   *  update: function,
   *  updatePlayerParams: function,
   *  clearHpBars: function,
   *  switchCamera: function,
   *  setFps: function,
   *  notify: function,
   * }} ui
   */
  function Scene(renderer, ui) {
    var _this;

    _classCallCheck(this, Scene);

    _this = _super.call(this);
    _this.clock = new THREE.Clock();
    _this.intervals = new _Intervals__WEBPACK_IMPORTED_MODULE_5__["default"](_assertThisInitialized(_this));
    _this.renderer = renderer;
    _this.ui = ui;
    _this.models = new _Models__WEBPACK_IMPORTED_MODULE_8__["default"](_assertThisInitialized(_this));
    _this.scene = new THREE.Scene();
    _this.pathFinder = new _PathFinder__WEBPACK_IMPORTED_MODULE_10__["default"](_assertThisInitialized(_this));
    _this.colliders = new _Colliders__WEBPACK_IMPORTED_MODULE_7__["default"](_assertThisInitialized(_this));
    _this.units = new _Units__WEBPACK_IMPORTED_MODULE_11__["default"](_assertThisInitialized(_this));
    _this.camera = new _Camera__WEBPACK_IMPORTED_MODULE_2__["default"](_assertThisInitialized(_this)); // this.audio = new Audio(this);

    _this.input = new _Input__WEBPACK_IMPORTED_MODULE_4__["default"]({
      onAction: function onAction() {
        return _this.level.onAction();
      },
      onExit: function onExit() {
        return _this.ui.setPause(!_this.ui.isPause());
      },
      onZoom: function onZoom(zoom) {
        return _this.camera.addY(zoom);
      },
      onSwitchCamera: function onSwitchCamera() {
        return _this.ui.switchCamera();
      }
    });
    _this.gameObjectsService = new _GameObjects__WEBPACK_IMPORTED_MODULE_0__["default"](_assertThisInitialized(_this));
    _this.particles = new _Particles__WEBPACK_IMPORTED_MODULE_9__["default"](_assertThisInitialized(_this));
    var connectionHostname = window.location.hostname === 'localhost' ? 'localhost' : 'gohtml.ru';
    var isSSL = window.location.hostname !== 'localhost';
    _this.connection = new _Connection__WEBPACK_IMPORTED_MODULE_3__["default"](_assertThisInitialized(_this), connectionHostname, 1337, isSSL);
    _this.location = new _Locations_DreamTown__WEBPACK_IMPORTED_MODULE_6__["default"](_assertThisInitialized(_this));

    _this.intervals.setInterval(function () {
      _this.ui.setFps(_this.renderer.fps, _this.renderer.targetFps);

      _this.ui.updatePlayerParams();
    }, 1000);

    _this.input.isThirdPerson = ui.isThirdPerson();

    _this.pathFinder.rebuildAreas();

    _this.clearScene();

    _this.animate(); // console.log('Scene', this);


    return _this;
  }

  _createClass(Scene, [{
    key: "clearScene",
    value: function clearScene() {
      this.gameObjectsService.removeAll();
      this.location.afterClear();
    }
  }, {
    key: "animate",
    value: function animate() {
      var now = Date.now();
      var deltaTime = this.intervals.getDeltaTime(now);
      this.intervals.update(now);
      var gameTime = this.intervals.getTimePassed();
      this.gameObjectsService.update(gameTime, deltaTime);

      if (!this.ui.isPause()) {
        this.camera.update(gameTime, deltaTime);
        this.input.update();
      }

      this.ui.update();
      this.location.update();
      this.particles.update();
      this.connection.update(gameTime, deltaTime);
      this.renderer.render(this.scene, this.camera.camera, deltaTime);
      window.requestAnimationFrame(this.animate);
    }
  }, {
    key: "setLoggedUser",
    value: function setLoggedUser(userName, password) {
      this.user = {
        userName: userName,
        password: password
      };
    }
    /**
     * @returns {Player}
     */

  }, {
    key: "getPlayer",
    value: function getPlayer() {
      return this.units.getPlayer();
    }
    /**
     * @param {THREE.Object3D} object
     */

  }, {
    key: "add",
    value: function add(object) {
      this.scene.add(object);
    }
    /**
     * @param {THREE.Object3D} object
     */

  }, {
    key: "remove",
    value: function remove(object) {
      this.scene.remove(object);
    }
  }, {
    key: "notify",
    value: function notify(text) {
      this.ui.notify(text);
    }
  }]);

  return Scene;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "../client/src/js/Units.js":
/*!*********************************!*\
  !*** ../client/src/js/Units.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Units; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _GameObjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObjects */ "../client/src/js/GameObjects.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Units = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Units, _AutoBindMethods);

  var _super = _createSuper(Units);

  function Units(scene) {
    var _this;

    _classCallCheck(this, Units);

    _this = _super.call(this);
    _this.scene = scene;
    _this.player = undefined;
    return _this;
  }

  _createClass(Units, [{
    key: "getUnits",
    value: function getUnits() {
      return this.scene.gameObjectsService.getUnits();
    }
  }, {
    key: "getAliveUnits",
    value: function getAliveUnits() {
      return this.getUnits().filter(function (gameObject) {
        return gameObject.isAlive();
      });
    }
  }, {
    key: "getPlayer",
    value: function getPlayer() {
      return this.player;
    }
  }, {
    key: "setDefaultPlayerParams",
    value: function setDefaultPlayerParams(defaultParams) {
      this.defaultParams = defaultParams;
    }
  }, {
    key: "createPlayer",
    value: function createPlayer() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$onCreate = _ref.onCreate,
          onCreate = _ref$onCreate === void 0 ? function () {
        return null;
      } : _ref$onCreate,
          _ref$onKill = _ref.onKill,
          _onKill = _ref$onKill === void 0 ? function () {
        return null;
      } : _ref$onKill,
          _ref$onDamageDeal = _ref.onDamageDeal,
          _onDamageDeal = _ref$onDamageDeal === void 0 ? function () {
        return null;
      } : _ref$onDamageDeal,
          _ref$onDamageTaken = _ref.onDamageTaken,
          _onDamageTaken = _ref$onDamageTaken === void 0 ? function () {
        return null;
      } : _ref$onDamageTaken,
          _ref$onDie = _ref.onDie,
          _onDie = _ref$onDie === void 0 ? function () {
        return null;
      } : _ref$onDie,
          _ref$onLevelUp = _ref.onLevelUp,
          _onLevelUp = _ref$onLevelUp === void 0 ? function () {
        return null;
      } : _ref$onLevelUp;

      var gameObjectsService = this.scene.gameObjectsService;
      return this.scene.models.loadGLTF({
        baseUrl: './assets/models/units/player',
        callback: function callback(loadedModel) {
          var defaultParams = _this2.defaultParams;
          loadedModel.scene.position.set(0, 0.1, 0);
          /**
           * @type {Player}
           */

          var player = gameObjectsService.hookGameObject(new _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"]({
            animations: loadedModel.animations,
            object: loadedModel.scene,
            input: _this2.scene.input,
            complexAnimations: true,
            checkWay: _this2.scene.colliders.checkWay,
            name: _this2.scene.user ? _this2.scene.user.userName : ' ',
            onDamageDeal: function onDamageDeal(damagedUnit) {
              return _onDamageDeal(damagedUnit);
            },
            onDamageTaken: function onDamageTaken(attacker) {
              _onDamageTaken(attacker);

              _this2.scene.particles.loadEffect({
                position: player.position.clone().add(new THREE.Vector3(0, 0.75, 0))
              });
            },
            onKill: function onKill(object) {
              return _onKill(object);
            },
            onDie: function onDie(killer) {
              return _onDie(killer);
            },
            onLevelUp: function onLevelUp() {
              _this2.scene.particles.createEffect({
                effect: 'level-up-alt/level-up',
                scale: 1.5,
                attachTo: _this2.player.object
              });

              _onLevelUp();
            },
            attack: function attack() {
              return gameObjectsService.attack(player);
            },
            fire: function fire() {
              return gameObjectsService.fire(player);
            },
            destroy: function destroy() {
              return gameObjectsService.destroyGameObject(player);
            }
          }));
          _this2.player = player;
          onCreate(player);

          if (defaultParams && defaultParams.params) {
            var position = defaultParams.position,
                rotation = defaultParams.rotation,
                params = defaultParams.params;
            var playerParams = player.params;
            player.position.set(position.x, position.y, position.z);
            player.rotation.set(rotation.x, rotation.y, rotation.z);
            playerParams.hp = params.hp;
            playerParams.hpMax = params.hpMax;
            playerParams.fraction = params.fraction;
            playerParams.level = params.level;
            playerParams.damage = params.damage;
            playerParams.speed = params.speed;
            playerParams.experience = params.experience;
            playerParams.money = params.money;
            playerParams.unspentTalents = params.unspentTalents;

            if (!playerParams.hp) {
              player.animationState.isDie = true;
            }
          }
        }
      });
    }
  }, {
    key: "createAI",
    value: function createAI(_ref2) {
      var _this3 = this;

      var fraction = _ref2.fraction,
          level = _ref2.level,
          _ref2$position = _ref2.position,
          x = _ref2$position.x,
          y = _ref2$position.y,
          z = _ref2$position.z,
          _ref2$rotation = _ref2.rotation,
          rotation = _ref2$rotation === void 0 ? {} : _ref2$rotation,
          scale = _ref2.scale,
          _onDie2 = _ref2.onDie,
          name = _ref2.name;
      var gameObjectsService = this.scene.gameObjectsService;

      var getPriority = function getPriority(unit, target) {
        return (target instanceof _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"] ? 0.75 : 0) + 1 / Math.ceil(target.position.distanceTo(unit.position));
      };

      this.scene.models.loadGLTF({
        baseUrl: fraction === 'goats' ? './assets/models/units/goat-warrior' : './assets/models/units/enemy',
        callback: function callback(gltf) {
          var networkConnection = _this3.scene.connection;

          if (!networkConnection || !networkConnection.meta || !networkConnection.meta.role || networkConnection.meta.role === 'host') {
            /** @type {AI} */
            var ai = gameObjectsService.hookGameObject(new _GameObjects__WEBPACK_IMPORTED_MODULE_1__["AI"]({
              animations: gltf.animations,
              object: gltf.scene,
              speed: 0.35 + level * 0.025,
              damage: 5 + level * 1.5,
              hp: 70 + level * 30,
              fraction: fraction,
              name: name,
              level: level,
              checkWay: _this3.scene.colliders.checkWay,
              getNextPoint: _this3.scene.pathFinder.getNextPoint,
              attack: function attack() {
                return gameObjectsService.attack(ai);
              },
              onDamageTaken: function onDamageTaken() {
                return _this3.scene.particles.loadEffect({
                  position: ai.position.clone().add(new THREE.Vector3(0, 0.75, 0))
                });
              },
              onDie: function onDie() {
                return _this3.scene.intervals.setTimeout(function () {
                  if (ai.isDead()) {
                    gameObjectsService.destroyGameObject(ai);

                    if (_onDie2) {
                      _onDie2();
                    }
                  }
                }, 10000);
              },
              findTarget: function findTarget() {
                var nearEnemyUnits = _this3.getAliveUnits().filter(function (unit) {
                  return unit !== ai && unit.getFraction() !== fraction && unit.position.distanceTo(ai.position) < 15;
                }).sort(function (unitA, unitB) {
                  return getPriority(ai, unitB) - getPriority(ai, unitA);
                });

                return nearEnemyUnits.length ? nearEnemyUnits[0] : null;
              }
            }));
            ai.position.set(x || 0, y || 0, z || 0);
            ai.rotation.set(rotation.x || 0, rotation.y || 0, rotation.z || 0);

            if (scale) {
              ai.object.scale.set(scale, scale, scale);
            }
          }
        }
      });
    }
  }, {
    key: "createNetworkAI",
    value: function createNetworkAI(_ref3) {
      var _this4 = this;

      var _ref3$params = _ref3.params,
          fraction = _ref3$params.fraction,
          unitNetworkId = _ref3$params.unitNetworkId,
          level = _ref3$params.level,
          name = _ref3$params.name,
          hp = _ref3$params.hp,
          hpMax = _ref3$params.hpMax,
          damage = _ref3$params.damage,
          _ref3$params$fromNetw = _ref3$params.fromNetwork,
          fromNetwork = _ref3$params$fromNetw === void 0 ? true : _ref3$params$fromNetw,
          position = _ref3.position,
          onDie = _ref3.onDie;

      var _callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

      var gameObjectsService = this.scene.gameObjectsService;

      var getPriority = function getPriority(unit, target) {
        return (target instanceof _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"] ? 0.75 : 0) + 1 / Math.ceil(target.position.distanceTo(unit.position));
      };

      return this.scene.models.loadGLTF({
        baseUrl: fraction === 'goats' ? './assets/models/units/goat-warrior' : './assets/models/units/enemy',
        callback: function callback(loadedObject) {
          var ai = gameObjectsService.hookGameObject(new _GameObjects__WEBPACK_IMPORTED_MODULE_1__["AI"]({
            object: loadedObject.scene,
            animations: loadedObject.animations,
            unitNetworkId: unitNetworkId,
            fraction: fraction,
            level: level,
            name: name,
            hp: hp,
            hpMax: hpMax,
            damage: damage,
            fromNetwork: fromNetwork,
            checkWay: _this4.scene.colliders.checkWay,
            getNextPoint: _this4.scene.pathFinder.getNextPoint,
            attack: function attack() {
              return gameObjectsService.attack(ai);
            },
            onDamageTaken: function onDamageTaken() {
              return _this4.scene.particles.loadEffect({
                position: ai.position.clone().add(new THREE.Vector3(0, 0.75, 0))
              });
            },
            onDie: function onDie() {
              return _this4.scene.intervals.setTimeout(function () {
                if (ai.isDead()) {
                  gameObjectsService.destroyGameObject(ai);

                  if (!ai.params.fromNetwork) {
                    _this4.createNetworkAI({
                      fraction: fraction,
                      unitNetworkId: unitNetworkId,
                      name: name,
                      hp: hp,
                      hpMax: hpMax,
                      damage: damage,
                      fromNetwork: false,
                      level: level + 1 + Math.round(Math.random() * level)
                    });
                  }
                }
              }, 10000);
            },
            findTarget: function findTarget() {
              if (!ai.params.fromNetwork) {
                var nearEnemyUnits = _this4.getAliveUnits().filter(function (unit) {
                  return unit !== ai && unit.getFraction() !== fraction && unit.position.distanceTo(ai.position) < 15;
                }).sort(function (unitA, unitB) {
                  return getPriority(ai, unitB) - getPriority(ai, unitA);
                });

                return nearEnemyUnits.length ? nearEnemyUnits[0] : null;
              }
            }
          }));

          _callback(ai);
        }
      });
    }
  }, {
    key: "createNetworkPlayer",
    value: function createNetworkPlayer(_ref4, _callback2) {
      var _this5 = this;

      var _ref4$params = _ref4.params,
          connectionId = _ref4$params.connectionId,
          unitNetworkId = _ref4$params.unitNetworkId,
          name = _ref4$params.name,
          _onDamageDeal2 = _ref4.onDamageDeal,
          _onKill2 = _ref4.onKill,
          _onDie3 = _ref4.onDie,
          _onLevelUp2 = _ref4.onLevelUp,
          _onDamageTaken2 = _ref4.onDamageTaken;
      var gameObjectsService = this.scene.gameObjectsService;
      return this.scene.models.loadGLTF({
        baseUrl: './assets/models/units/network-player',
        callback: function callback(loadedObject) {
          /** @type {Player} */
          var player = gameObjectsService.hookGameObject(new _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"]({
            object: loadedObject.scene,
            animations: loadedObject.animations,
            unitNetworkId: unitNetworkId,
            connectionId: connectionId,
            name: name,
            fromNetwork: true,
            complexAnimations: true,
            checkWay: _this5.scene.colliders.checkWay,
            input: {
              vertical: 0,
              horizontal: 0,
              jump: false,
              cursor: {
                x: 0,
                y: 0
              },
              look: {
                vertical: 0,
                horizontal: 0
              }
            },
            onDie: function onDie(killer) {
              return _this5.scene.intervals.setTimeout(function () {
                if (player.isDead()) {
                  gameObjectsService.destroyGameObject(player);
                }

                _onDie3 && _onDie3(killer);
              }, 10000);
            },
            onDamageDeal: function onDamageDeal(damagedUnit) {
              return _onDamageDeal2 && _onDamageDeal2(damagedUnit);
            },
            onDamageTaken: function onDamageTaken(attacker) {
              _onDamageTaken2 && _onDamageTaken2(attacker);

              _this5.scene.particles.loadEffect({
                position: player.position.clone().add(new THREE.Vector3(0, 0.75, 0))
              });
            },
            onKill: function onKill(object) {
              return _onKill2 && _onKill2(object);
            },
            onLevelUp: function onLevelUp() {
              _this5.scene.particles.createEffect({
                effect: 'level-up-alt/level-up',
                scale: 1.5,
                attachTo: _this5.player.object
              });

              _onLevelUp2 && _onLevelUp2();
            },
            attack: function attack() {
              return gameObjectsService.attack(player);
            },
            fire: function fire() {
              return gameObjectsService.fire(player);
            },
            destroy: function destroy() {
              return gameObjectsService.destroyGameObject(player);
            }
          }));

          _callback2(player);
        }
      });
    }
  }]);

  return Units;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Utils/AStar.js":
/*!***************************************!*\
  !*** ../client/src/js/Utils/AStar.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// javascript-astar 0.4.1
// http://github.com/bgrins/javascript-astar
// Freely distributable under the MIT License.
// Implements the astar search algorithm in javascript using a Binary Heap.
// Includes Binary Heap (with modifications) from Marijn Haverbeke.
// http://eloquentjavascript.net/appendix2.html
(function (definition) {
  /* global module, define */
  if (( false ? undefined : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {
    module.exports = definition();
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var exports; }
})(function () {
  function pathTo(node) {
    var curr = node;
    var path = [];

    while (curr.parent) {
      path.unshift(curr);
      curr = curr.parent;
    }

    return path;
  }

  function getHeap() {
    return new BinaryHeap(function (node) {
      return node.f;
    });
  }

  var astar = {
    /**
     * Perform an A* Search on a graph given a start and end node.
     * @param {Graph} graph
     * @param {GridNode} start
     * @param {GridNode} end
     * @param {Object} [options]
     * @param {bool} [options.closest] Specifies whether to return the
     path to the closest node if the target is unreachable.
     * @param {Function} [options.heuristic] Heuristic function (see
     *          astar.heuristics).
     */
    search: function search(graph, start, end, options) {
      graph.cleanDirty();
      options = options || {};
      var heuristic = options.heuristic || astar.heuristics.manhattan;
      var closest = options.closest || false;
      var openHeap = getHeap();
      var closestNode = start; // set the start node to be the closest if required

      start.h = heuristic(start, end);
      graph.markDirty(start);
      openHeap.push(start);

      while (openHeap.size() > 0) {
        // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
        var currentNode = openHeap.pop(); // End case -- result has been found, return the traced path.

        if (currentNode === end) {
          return pathTo(currentNode);
        } // Normal case -- move currentNode from open to closed, process each of its neighbors.


        currentNode.closed = true; // Find all neighbors for the current node.

        var neighbors = graph.neighbors(currentNode);

        for (var i = 0, il = neighbors.length; i < il; ++i) {
          var neighbor = neighbors[i];

          if (neighbor.closed || neighbor.isWall()) {
            // Not a valid node to process, skip to next neighbor.
            continue;
          } // The g score is the shortest distance from start to current node.
          // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.


          var gScore = currentNode.g + neighbor.getCost(currentNode);
          var beenVisited = neighbor.visited;

          if (!beenVisited || gScore < neighbor.g) {
            // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
            neighbor.visited = true;
            neighbor.parent = currentNode;
            neighbor.h = neighbor.h || heuristic(neighbor, end);
            neighbor.g = gScore;
            neighbor.f = neighbor.g + neighbor.h;
            graph.markDirty(neighbor);

            if (closest) {
              // If the neighbour is closer than the current closestNode or if it's equally close but has
              // a cheaper path than the current closest node then it becomes the closest node
              if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
                closestNode = neighbor;
              }
            }

            if (!beenVisited) {
              // Pushing to heap will put it in proper place based on the 'f' value.
              openHeap.push(neighbor);
            } else {
              // Already seen the node, but since it has been rescored we need to reorder it in the heap
              openHeap.rescoreElement(neighbor);
            }
          }
        }
      }

      if (closest) {
        return pathTo(closestNode);
      } // No result was found - empty array signifies failure to find path.


      return [];
    },
    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    heuristics: {
      manhattan: function manhattan(pos0, pos1) {
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return d1 + d2;
      },
      diagonal: function diagonal(pos0, pos1) {
        var D = 1;
        var D2 = Math.sqrt(2);
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
      }
    },
    cleanNode: function cleanNode(node) {
      node.f = 0;
      node.g = 0;
      node.h = 0;
      node.visited = false;
      node.closed = false;
      node.parent = null;
    }
  };
  /**
   * A graph memory structure
   * @param {Array} gridIn 2D array of input weights
   * @param {Object} [options]
   * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed
   */

  function Graph(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];

    for (var x = 0; x < gridIn.length; x++) {
      this.grid[x] = [];

      for (var y = 0, row = gridIn[x]; y < row.length; y++) {
        var node = new GridNode(x, y, row[y]);
        this.grid[x][y] = node;
        this.nodes.push(node);
      }
    }

    this.init();
  }

  Graph.prototype.init = function () {
    this.dirtyNodes = [];

    for (var i = 0; i < this.nodes.length; i++) {
      astar.cleanNode(this.nodes[i]);
    }
  };

  Graph.prototype.cleanDirty = function () {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
      astar.cleanNode(this.dirtyNodes[i]);
    }

    this.dirtyNodes = [];
  };

  Graph.prototype.markDirty = function (node) {
    this.dirtyNodes.push(node);
  };

  Graph.prototype.neighbors = function (node) {
    var ret = [];
    var x = node.x;
    var y = node.y;
    var grid = this.grid; // West

    if (grid[x - 1] && grid[x - 1][y]) {
      ret.push(grid[x - 1][y]);
    } // East


    if (grid[x + 1] && grid[x + 1][y]) {
      ret.push(grid[x + 1][y]);
    } // South


    if (grid[x] && grid[x][y - 1]) {
      ret.push(grid[x][y - 1]);
    } // North


    if (grid[x] && grid[x][y + 1]) {
      ret.push(grid[x][y + 1]);
    }

    if (this.diagonal) {
      // Southwest
      if (grid[x - 1] && grid[x - 1][y - 1]) {
        ret.push(grid[x - 1][y - 1]);
      } // Southeast


      if (grid[x + 1] && grid[x + 1][y - 1]) {
        ret.push(grid[x + 1][y - 1]);
      } // Northwest


      if (grid[x - 1] && grid[x - 1][y + 1]) {
        ret.push(grid[x - 1][y + 1]);
      } // Northeast


      if (grid[x + 1] && grid[x + 1][y + 1]) {
        ret.push(grid[x + 1][y + 1]);
      }
    }

    return ret;
  };

  Graph.prototype.toString = function () {
    var graphString = [];
    var nodes = this.grid;

    for (var x = 0; x < nodes.length; x++) {
      var rowDebug = [];
      var row = nodes[x];

      for (var y = 0; y < row.length; y++) {
        rowDebug.push(row[y].weight);
      }

      graphString.push(rowDebug.join(" "));
    }

    return graphString.join("\n");
  };

  function GridNode(x, y, weight) {
    this.x = x;
    this.y = y;
    this.weight = weight;
  }

  GridNode.prototype.toString = function () {
    return "[" + this.x + " " + this.y + "]";
  };

  GridNode.prototype.getCost = function (fromNeighbor) {
    // Take diagonal weight into consideration.
    if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {
      return this.weight * 1.41421;
    }

    return this.weight;
  };

  GridNode.prototype.isWall = function () {
    return this.weight === 0;
  };

  function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
  }

  BinaryHeap.prototype = {
    push: function push(element) {
      // Add the new element to the end of the array.
      this.content.push(element); // Allow it to sink down.

      this.sinkDown(this.content.length - 1);
    },
    pop: function pop() {
      // Store the first element so we can return it later.
      var result = this.content[0]; // Get the element at the end of the array.

      var end = this.content.pop(); // If there are any elements left, put the end element at the
      // start, and let it bubble up.

      if (this.content.length > 0) {
        this.content[0] = end;
        this.bubbleUp(0);
      }

      return result;
    },
    remove: function remove(node) {
      var i = this.content.indexOf(node); // When it is found, the process seen in 'pop' is repeated
      // to fill up the hole.

      var end = this.content.pop();

      if (i !== this.content.length - 1) {
        this.content[i] = end;

        if (this.scoreFunction(end) < this.scoreFunction(node)) {
          this.sinkDown(i);
        } else {
          this.bubbleUp(i);
        }
      }
    },
    size: function size() {
      return this.content.length;
    },
    rescoreElement: function rescoreElement(node) {
      this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function sinkDown(n) {
      // Fetch the element that has to be sunk.
      var element = this.content[n]; // When at 0, an element can not sink any further.

      while (n > 0) {
        // Compute the parent element's index, and fetch it.
        var parentN = (n + 1 >> 1) - 1;
        var parent = this.content[parentN]; // Swap the elements if the parent is greater.

        if (this.scoreFunction(element) < this.scoreFunction(parent)) {
          this.content[parentN] = element;
          this.content[n] = parent; // Update 'n' to continue at the new position.

          n = parentN;
        } // Found a parent that is less, no need to sink any further.
        else {
            break;
          }
      }
    },
    bubbleUp: function bubbleUp(n) {
      // Look up the target element and its score.
      var length = this.content.length;
      var element = this.content[n];
      var elemScore = this.scoreFunction(element);

      while (true) {
        // Compute the indices of the child elements.
        var child2N = n + 1 << 1;
        var child1N = child2N - 1; // This is used to store the new position of the element, if any.

        var swap = null;
        var child1Score; // If the first child exists (is inside the array)...

        if (child1N < length) {
          // Look it up and compute its score.
          var child1 = this.content[child1N];
          child1Score = this.scoreFunction(child1); // If the score is less than our element's, we need to swap.

          if (child1Score < elemScore) {
            swap = child1N;
          }
        } // Do the same checks for the other child.


        if (child2N < length) {
          var child2 = this.content[child2N];
          var child2Score = this.scoreFunction(child2);

          if (child2Score < (swap === null ? elemScore : child1Score)) {
            swap = child2N;
          }
        } // If the element needs to be moved, swap it, and continue.


        if (swap !== null) {
          this.content[n] = this.content[swap];
          this.content[swap] = element;
          n = swap;
        } // Otherwise, we are done.
        else {
            break;
          }
      }
    }
  };
  return {
    astar: astar,
    Graph: Graph
  };
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../server/node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _standalone_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./standalone-server */ "./standalone-server.js");

/* harmony default export */ __webpack_exports__["default"] = (new _standalone_server__WEBPACK_IMPORTED_MODULE_0__["default"]());

/***/ }),

/***/ "./node_modules/three/src/constants.js":
/*!*********************************************!*\
  !*** ./node_modules/three/src/constants.js ***!
  \*********************************************/
/*! exports provided: REVISION, MOUSE, TOUCH, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, FrontFaceDirectionCW, FrontFaceDirectionCCW, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, SmoothShading, NoColors, FaceColors, VertexColors, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, Uncharted2ToneMapping, CineonToneMapping, ACESFilmicToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, SphericalReflectionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipMapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedInt248Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, RGBEFormat, DepthFormat, DepthStencilFormat, RedFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, GammaEncoding, RGBEEncoding, LogLuvEncoding, RGBM7Encoding, RGBM16Encoding, RGBDEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, ZeroStencilOp, KeepStencilOp, ReplaceStencilOp, IncrementStencilOp, DecrementStencilOp, IncrementWrapStencilOp, DecrementWrapStencilOp, InvertStencilOp, NeverStencilFunc, LessStencilFunc, EqualStencilFunc, LessEqualStencilFunc, GreaterStencilFunc, NotEqualStencilFunc, GreaterEqualStencilFunc, AlwaysStencilFunc, StaticDrawUsage, DynamicDrawUsage, StreamDrawUsage, StaticReadUsage, DynamicReadUsage, StreamReadUsage, StaticCopyUsage, DynamicCopyUsage, StreamCopyUsage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCW", function() { return FrontFaceDirectionCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCCW", function() { return FrontFaceDirectionCCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSMShadowMap", function() { return VSMShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return FlatShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return SmoothShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return NoColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return FaceColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return VertexColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uncharted2ToneMapping", function() { return Uncharted2ToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACESFilmicToneMapping", function() { return ACESFilmicToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalReflectionMapping", function() { return SphericalReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapNearestFilter", function() { return NearestMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapLinearFilter", function() { return NearestMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapNearestFilter", function() { return LinearMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapLinearFilter", function() { return LinearMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return RGBEFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedFormat", function() { return RedFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function() { return RGBA_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function() { return RGBA_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function() { return RGBA_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function() { return RGBA_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function() { return RGBA_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function() { return RGBA_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function() { return RGBA_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function() { return RGBA_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function() { return RGBA_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function() { return RGBA_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function() { return RGBA_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function() { return RGBA_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function() { return RGBA_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function() { return RGBA_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return sRGBEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return RGBEEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return LogLuvEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function() { return TangentSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function() { return ObjectSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroStencilOp", function() { return ZeroStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeepStencilOp", function() { return KeepStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaceStencilOp", function() { return ReplaceStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementStencilOp", function() { return IncrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementStencilOp", function() { return DecrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementWrapStencilOp", function() { return IncrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementWrapStencilOp", function() { return DecrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InvertStencilOp", function() { return InvertStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverStencilFunc", function() { return NeverStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessStencilFunc", function() { return LessStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualStencilFunc", function() { return EqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualStencilFunc", function() { return LessEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterStencilFunc", function() { return GreaterStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualStencilFunc", function() { return NotEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualStencilFunc", function() { return GreaterEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysStencilFunc", function() { return AlwaysStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticDrawUsage", function() { return StaticDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicDrawUsage", function() { return DynamicDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamDrawUsage", function() { return StreamDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticReadUsage", function() { return StaticReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicReadUsage", function() { return DynamicReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamReadUsage", function() { return StreamReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticCopyUsage", function() { return StaticCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicCopyUsage", function() { return DynamicCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamCopyUsage", function() { return StreamCopyUsage; });
var REVISION = '111';
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var FrontFaceDirectionCW = 0;
var FrontFaceDirectionCCW = 1;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var ACESFilmicToneMapping = 5;

var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipMapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipMapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;

var ZeroStencilOp = 0;
var KeepStencilOp = 7680;
var ReplaceStencilOp = 7681;
var IncrementStencilOp = 7682;
var DecrementStencilOp = 7683;
var IncrementWrapStencilOp = 34055;
var DecrementWrapStencilOp = 34056;
var InvertStencilOp = 5386;

var NeverStencilFunc = 512;
var LessStencilFunc = 513;
var EqualStencilFunc = 514;
var LessEqualStencilFunc = 515;
var GreaterStencilFunc = 516;
var NotEqualStencilFunc = 517;
var GreaterEqualStencilFunc = 518;
var AlwaysStencilFunc = 519;

var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var StreamDrawUsage = 35040;
var StaticReadUsage = 35045;
var DynamicReadUsage = 35049;
var StreamReadUsage = 35041;
var StaticCopyUsage = 35046;
var DynamicCopyUsage = 35050;
var StreamCopyUsage = 35042;


/***/ }),

/***/ "./node_modules/three/src/core/EventDispatcher.js":
/*!********************************************************!*\
  !*** ./node_modules/three/src/core/EventDispatcher.js ***!
  \********************************************************/
/*! exports provided: EventDispatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher() {}

Object.assign( EventDispatcher.prototype, {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = listenerArray.slice( 0 );

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

} );





/***/ }),

/***/ "./node_modules/three/src/core/Layers.js":
/*!***********************************************!*\
  !*** ./node_modules/three/src/core/Layers.js ***!
  \***********************************************/
/*! exports provided: Layers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return Layers; });
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Layers() {

	this.mask = 1 | 0;

}

Object.assign( Layers.prototype, {

	set: function ( channel ) {

		this.mask = 1 << channel | 0;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel | 0;

	},

	enableAll: function () {

		this.mask = 0xffffffff | 0;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel | 0;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	},

	disableAll: function () {

		this.mask = 0;

	},

	test: function ( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

} );





/***/ }),

/***/ "./node_modules/three/src/core/Object3D.js":
/*!*************************************************!*\
  !*** ./node_modules/three/src/core/Object3D.js ***!
  \*************************************************/
/*! exports provided: Object3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return Object3D; });
/* harmony import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "./node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventDispatcher.js */ "./node_modules/three/src/core/EventDispatcher.js");
/* harmony import */ var _math_Euler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Euler.js */ "./node_modules/three/src/math/Euler.js");
/* harmony import */ var _Layers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Layers.js */ "./node_modules/three/src/core/Layers.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Matrix3.js */ "./node_modules/three/src/math/Matrix3.js");
/* harmony import */ var _math_Math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Math.js */ "./node_modules/three/src/math/Math.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../constants.js */ "./node_modules/three/src/constants.js");










var _object3DId = 0;

var _v1 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
var _q1 = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
var _m1 = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
var _target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

var _position = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
var _scale = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
var _quaternion = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

var _xAxis = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 1, 0, 0 );
var _yAxis = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, 1, 0 );
var _zAxis = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, 0, 1 );

var _addedEvent = { type: 'added' };
var _removedEvent = { type: 'removed' };

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

function Object3D() {

	Object.defineProperty( this, 'id', { value: _object3DId ++ } );

	this.uuid = _math_Math_js__WEBPACK_IMPORTED_MODULE_7__["_Math"].generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	var position = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
	var rotation = new _math_Euler_js__WEBPACK_IMPORTED_MODULE_4__["Euler"]();
	var quaternion = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
	var scale = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation._onChange( onRotationChange );
	quaternion._onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			configurable: true,
			enumerable: true,
			value: position
		},
		rotation: {
			configurable: true,
			enumerable: true,
			value: rotation
		},
		quaternion: {
			configurable: true,
			enumerable: true,
			value: quaternion
		},
		scale: {
			configurable: true,
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]()
		},
		normalMatrix: {
			value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__["Matrix3"]()
		}
	} );

	this.matrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
	this.matrixWorld = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new _Layers_js__WEBPACK_IMPORTED_MODULE_5__["Layers"]();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};

}

Object3D.DefaultUp = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype = Object.assign( Object.create( _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__["EventDispatcher"].prototype ), {

	constructor: Object3D,

	isObject3D: true,

	onBeforeRender: function () {},
	onAfterRender: function () {},

	applyMatrix: function ( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	applyQuaternion: function ( q ) {

		this.quaternion.premultiply( q );

		return this;

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function ( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	},

	rotateOnWorldAxis: function ( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	},

	rotateX: function ( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	},

	rotateY: function ( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	},

	rotateZ: function ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	},

	translateOnAxis: function ( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1.multiplyScalar( distance ) );

		return this;

	},

	translateX: function ( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	},

	translateY: function ( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	},

	translateZ: function ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	},

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function ( vector ) {

		return vector.applyMatrix4( _m1.getInverse( this.matrixWorld ) );

	},

	lookAt: function ( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		var parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1.lookAt( _position, _target, this.up );

		} else {

			_m1.lookAt( _target, _position, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1 );

		if ( parent ) {

			_m1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1 );
			this.quaternion.premultiply( _q1.inverse() );

		}

	},

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( ( object && object.isObject3D ) ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	},

	attach: function ( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1.getInverse( this.matrixWorld );

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix( _m1 );

		object.updateWorldMatrix( false, false );

		this.add( object );

		return this;

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
			target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		this.updateMatrixWorld( true );

		return target.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
			target = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

		}

		this.updateMatrixWorld( true );

		this.matrixWorld.decompose( _position, target, _scale );

		return target;

	},

	getWorldScale: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
			target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		this.updateMatrixWorld( true );

		this.matrixWorld.decompose( _position, _quaternion, target );

		return target;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
			target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		this.updateMatrixWorld( true );

		var e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	},

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		var parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	},

	toJSON: function ( meta ) {

		// meta is a string when called from JSON.stringify
		var isRootObject = ( meta === undefined || typeof meta === 'string' );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isMesh && this.drawMode !== _constants_js__WEBPACK_IMPORTED_MODULE_8__["TrianglesDrawMode"] ) object.drawMode = this.drawMode;

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			var parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				var shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( var i = 0, l = shapes.length; i < l; i ++ ) {

						var shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				var uuids = [];

				for ( var i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );
			var shapes = extractFromCache( meta.shapes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}
			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) recursive = true;

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

} );





/***/ }),

/***/ "./node_modules/three/src/math/Euler.js":
/*!**********************************************!*\
  !*** ./node_modules/three/src/math/Euler.js ***!
  \**********************************************/
/*! exports provided: Euler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return Euler; });
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector3.js */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Matrix4.js */ "./node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Math.js */ "./node_modules/three/src/math/Math.js");





/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

var _matrix = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
var _quaternion = new _Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

function Euler( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || Euler.DefaultOrder;

}

Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

Euler.DefaultOrder = 'XYZ';

Object.defineProperties( Euler.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this._onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this._onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this._onChangeCallback();

		}

	},

	order: {

		get: function () {

			return this._order;

		},

		set: function ( value ) {

			this._order = value;
			this._onChangeCallback();

		}

	}

} );

Object.assign( Euler.prototype, {

	isEuler: true,

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order );

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = _Math_js__WEBPACK_IMPORTED_MODULE_3__["_Math"].clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.9999999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.9999999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.9999999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.9999999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.9999999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.9999999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this._onChangeCallback();

		return this;

	},

	setFromQuaternion: function ( q, order, update ) {

		_matrix.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix, order, update );

	},

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function ( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion.setFromEuler( this );

		return this.setFromQuaternion( _quaternion, newOrder );

	},

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( this._x, this._y, this._z );

		}

	},

	_onChange: function ( callback ) {

		this._onChangeCallback = callback;

		return this;

	},

	_onChangeCallback: function () {}

} );





/***/ }),

/***/ "./node_modules/three/src/math/Math.js":
/*!*********************************************!*\
  !*** ./node_modules/three/src/math/Math.js ***!
  \*********************************************/
/*! exports provided: _Math */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_Math", function() { return _Math; });
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _lut = [];

for ( var i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

var _Math = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

		var d0 = Math.random() * 0xffffffff | 0;
		var d1 = Math.random() * 0xffffffff | 0;
		var d2 = Math.random() * 0xffffffff | 0;
		var d3 = Math.random() * 0xffffffff | 0;
		var uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toUpperCase() here flattens concatenated strings to save heap memory space.
		return uuid.toUpperCase();

	},

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function ( degrees ) {

		return degrees * _Math.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * _Math.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	ceilPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	},

	floorPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	}

};





/***/ }),

/***/ "./node_modules/three/src/math/Matrix3.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Matrix3.js ***!
  \************************************************/
/*! exports provided: Matrix3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "./node_modules/three/src/math/Vector3.js");


/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

var _vector = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

function Matrix3() {

	this.elements = [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	];

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Object.assign( Matrix3.prototype, {

	isMatrix3: true,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	},

	setFromMatrix4: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	},

	applyToBufferAttribute: function ( attribute ) {

		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

			_vector.x = attribute.getX( i );
			_vector.y = attribute.getY( i );
			_vector.z = attribute.getZ( i );

			_vector.applyMatrix3( this );

			attribute.setXYZ( i, _vector.x, _vector.y, _vector.z );

		}

		return attribute;

	},

	multiply: function ( m ) {

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnDegenerate ) {

		if ( matrix && matrix.isMatrix4 ) {

			console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

		}

		var me = matrix.elements,
			te = this.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) {

			var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	getNormalMatrix: function ( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

		var c = Math.cos( rotation );
		var s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

	},

	scale: function ( sx, sy ) {

		var te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	},

	rotate: function ( theta ) {

		var c = Math.cos( theta );
		var s = Math.sin( theta );

		var te = this.elements;

		var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	},

	translate: function ( tx, ty ) {

		var te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for ( var i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

} );





/***/ }),

/***/ "./node_modules/three/src/math/Matrix4.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Matrix4.js ***!
  \************************************************/
/*! exports provided: Matrix4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return Matrix4; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "./node_modules/three/src/math/Vector3.js");


var _v1 = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var _m1 = new Matrix4();
var _zero = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( 0, 0, 0 );
var _one = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( 1, 1, 1 );
var _x = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var _y = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var _z = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Matrix4() {

	this.elements = [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	];

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Object.assign( Matrix4.prototype, {

	isMatrix4: true,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	},

	copyPosition: function ( m ) {

		var te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	},

	extractRotation: function ( m ) {

		// this method does not support reflection matrices

		var te = this.elements;
		var me = m.elements;

		var scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
		var scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
		var scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromEuler: function ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromQuaternion: function ( q ) {

		return this.compose( _zero, q, _one );

	},

	lookAt: function ( eye, target, up ) {

		var te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	},

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	applyToBufferAttribute: function ( attribute ) {

		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

			_v1.x = attribute.getX( i );
			_v1.y = attribute.getY( i );
			_v1.z = attribute.getZ( i );

			_v1.applyMatrix4( this );

			attribute.setXYZ( i, _v1.x, _v1.y, _v1.z );

		}

		return attribute;

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	setPosition: function ( x, y, z ) {

		var te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	},

	getInverse: function ( m, throwOnDegenerate ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements,
			me = m.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) {

			var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeShear: function ( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		var te = this.elements;

		var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		var x2 = x + x,	y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		var sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	},

	decompose: function ( position, quaternion, scale ) {

		var te = this.elements;

		var sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		var sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		var sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		var det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1.copy( this );

		var invSX = 1 / sx;
		var invSY = 1 / sy;
		var invSZ = 1 / sz;

		_m1.elements[ 0 ] *= invSX;
		_m1.elements[ 1 ] *= invSX;
		_m1.elements[ 2 ] *= invSX;

		_m1.elements[ 4 ] *= invSY;
		_m1.elements[ 5 ] *= invSY;
		_m1.elements[ 6 ] *= invSY;

		_m1.elements[ 8 ] *= invSZ;
		_m1.elements[ 9 ] *= invSZ;
		_m1.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	},

	makePerspective: function ( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = 1.0 / ( right - left );
		var h = 1.0 / ( top - bottom );
		var p = 1.0 / ( far - near );

		var x = ( right + left ) * w;
		var y = ( top + bottom ) * h;
		var z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for ( var i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

} );





/***/ }),

/***/ "./node_modules/three/src/math/Quaternion.js":
/*!***************************************************!*\
  !*** ./node_modules/three/src/math/Quaternion.js ***!
  \***************************************************/
/*! exports provided: Quaternion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math.js */ "./node_modules/three/src/math/Math.js");
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */



function Quaternion( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

}

Object.assign( Quaternion, {

	slerp: function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	},

	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ],

			x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			var s = 1 - t,

				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			var tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

} );

Object.defineProperties( Quaternion.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this._onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this._onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this._onChangeCallback();

		}

	},

	w: {

		get: function () {

			return this._w;

		},

		set: function ( value ) {

			this._w = value;
			this._onChangeCallback();

		}

	}

} );

Object.assign( Quaternion.prototype, {

	isQuaternion: true,

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var cos = Math.cos;
		var sin = Math.sin;

		var c1 = cos( x / 2 );
		var c2 = cos( y / 2 );
		var c3 = cos( z / 2 );

		var s1 = sin( x / 2 );
		var s2 = sin( y / 2 );
		var s3 = sin( z / 2 );

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	},

	setFromUnitVectors: function ( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		var EPS = 0.000001;

		var r = vFrom.dot( vTo ) + 1;

		if ( r < EPS ) {

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	},

	angleTo: function ( q ) {

		return 2 * Math.acos( Math.abs( _Math_js__WEBPACK_IMPORTED_MODULE_0__["_Math"].clamp( this.dot( q ), - 1, 1 ) ) );

	},

	rotateTowards: function ( q, step ) {

		var angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		var t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	},

	inverse: function () {

		// quaternion is assumed to have unit length

		return this.conjugate();

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	premultiply: function ( q ) {

		return this.multiplyQuaternions( q, this );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			var s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	_onChange: function ( callback ) {

		this._onChangeCallback = callback;

		return this;

	},

	_onChangeCallback: function () {}

} );





/***/ }),

/***/ "./node_modules/three/src/math/Vector3.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Vector3.js ***!
  \************************************************/
/*! exports provided: Vector3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math.js */ "./node_modules/three/src/math/Math.js");
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");



/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

var _vector = new Vector3();
var _quaternion = new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__["Quaternion"]();

function Vector3( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

}

Object.assign( Vector3.prototype, {

	isVector3: true,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

	},

	applyAxisAngle: function ( axis, angle ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

	},

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyNormalMatrix: function ( m ) {

		return this.applyMatrix3( m ).normalize();

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x, y = this.y, z = this.z;
		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		var ix = qw * x + qy * z - qz * y;
		var iy = qw * y + qz * x - qx * z;
		var iz = qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function ( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	},

	unproject: function ( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	},

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function ( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	},

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	// TODO lengthSquared?

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	manhattanLength: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function ( v ) {

		// v cannot be the zero v

		var scalar = v.dot( this ) / v.lengthSq();

		return this.copy( v ).multiplyScalar( scalar );

	},

	projectOnPlane: function ( planeNormal ) {

		_vector.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector );

	},

	reflect: function ( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	},

	angleTo: function ( v ) {

		var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) console.error( 'THREE.Vector3: angleTo() can\'t handle zero length vectors.' );

		var theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( _Math_js__WEBPACK_IMPORTED_MODULE_0__["_Math"].clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	manhattanDistanceTo: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	},

	setFromSpherical: function ( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	},

	setFromSphericalCoords: function ( radius, phi, theta ) {

		var sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	},

	setFromCylindrical: function ( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	},

	setFromCylindricalCoords: function ( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	},

	setFromMatrixPosition: function ( m ) {

		var e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

} );





/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const WebSocket = __webpack_require__(/*! ./lib/websocket */ "./node_modules/ws/lib/websocket.js");

WebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ "./node_modules/ws/lib/stream.js");
WebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ "./node_modules/ws/lib/websocket-server.js");
WebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ "./node_modules/ws/lib/receiver.js");
WebSocket.Sender = __webpack_require__(/*! ./lib/sender */ "./node_modules/ws/lib/sender.js");

module.exports = WebSocket;


/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (let i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

try {
  const bufferUtil = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'bufferutil'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = {
    concat,
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    toArrayBuffer,
    toBuffer,
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
}


/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  EMPTY_BUFFER: Buffer.alloc(0),
  NOOP: () => {}
};


/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Class representing an event.
 *
 * @private
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was dispatched
   */
  constructor(type, target) {
    this.target = target;
    this.type = type;
  }
}

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(data, target) {
    super('message', target);

    this.data = data;
  }
}

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {Number} code The status code explaining why the connection is being closed
   * @param {String} reason A human-readable string explaining why the connection is closing
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  }
}

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event {
  /**
   * Create a new `OpenEvent`.
   *
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(target) {
    super('open', target);
  }
}

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {Object} error The error that generated this event
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  }
}

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @param {Object} options An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} options.once A `Boolean`` indicating that the listener
   *     should be invoked at most once after being added. If `true`, the
   *     listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, listener, options) {
    if (typeof listener !== 'function') return;

    function onMessage(data) {
      listener.call(this, new MessageEvent(data, this));
    }

    function onClose(code, message) {
      listener.call(this, new CloseEvent(code, message, this));
    }

    function onError(error) {
      listener.call(this, new ErrorEvent(error, this));
    }

    function onOpen() {
      listener.call(this, new OpenEvent(this));
    }

    const method = options && options.once ? 'once' : 'on';

    if (type === 'message') {
      onMessage._listener = listener;
      this[method](type, onMessage);
    } else if (type === 'close') {
      onClose._listener = listener;
      this[method](type, onClose);
    } else if (type === 'error') {
      onError._listener = listener;
      this[method](type, onError);
    } else if (type === 'open') {
      onOpen._listener = listener;
      this[method](type, onOpen);
    } else {
      this[method](type, listener);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {Function} listener The listener to remove
   * @public
   */
  removeEventListener(type, listener) {
    const listeners = this.listeners(type);

    for (let i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(type, listeners[i]);
      }
    }
  }
};

module.exports = EventTarget;


/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);

  if (header === undefined || header === '') return offers;

  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ "./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} concurrency The maximum number of jobs allowed to run
   *     concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const zlib = __webpack_require__(/*! zlib */ "zlib");

const bufferUtil = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");
const Limiter = __webpack_require__(/*! ./limiter */ "./node_modules/ws/lib/limiter.js");
const { kStatusCode, NOOP } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling
   *     of server context takeover
   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge
   *     disabling of client context takeover
   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the
   *     use of a custom server window size
   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support
   *     for, or request, a custom client window size
   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate
   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate
   * @param {Number} options.threshold Size (in bytes) below which messages
   *     should not be compressed
   * @param {Number} options.concurrencyLimit The number of concurrent calls to
   *     zlib
   * @param {Boolean} isServer Create the instance in either server or client
   *     mode
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      //
      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
      // `zlib.DeflateRaw` instance is closed while data is being processed.
      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
      // time due to an abnormal WebSocket closure.
      //
      this._deflate.on('error', NOOP);
      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.close();
        this._deflate = null;
      } else {
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { Writable } = __webpack_require__(/*! stream */ "stream");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends stream.Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {String} binaryType The type for binary data
   * @param {Object} extensions An object containing the negotiated extensions
   * @param {Boolean} isServer Specifies whether to operate in client or server
   *     mode
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor(binaryType, extensions, isServer, maxPayload) {
    super();

    this._binaryType = binaryType || BINARY_TYPES[0];
    this[kWebSocket] = undefined;
    this._extensions = extensions || {};
    this._isServer = !!isServer;
    this._maxPayload = maxPayload | 0;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(RangeError, 'RSV1 must be clear', true, 1002);
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(RangeError, 'invalid opcode 0', true, 1002);
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(RangeError, 'FIN must be set', true, 1002);
      }

      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002
        );
      }
    } else {
      this._loop = false;
      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error(RangeError, 'MASK must be set', true, 1002);
      }
    } else if (this._masked) {
      this._loop = false;
      return error(RangeError, 'MASK must be clear', true, 1002);
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(RangeError, 'Max payload size exceeded', false, 1009);
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);
      if (this._masked) unmask(data, this._mask);
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its lenght is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(RangeError, 'Max payload size exceeded', false, 1009)
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        let data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data);
      } else {
        const buf = concat(fragments, messageLength);

        if (!isValidUTF8(buf)) {
          this._loop = false;
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('message', buf.toString());
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, '');
        this.end();
      } else if (data.length === 1) {
        return error(RangeError, 'invalid payload length 1', true, 1002);
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          return error(RangeError, `invalid status code ${code}`, true, 1002);
        }

        const buf = data.slice(2);

        if (!isValidUTF8(buf)) {
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('conclude', code, buf.toString());
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {(Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err[kStatusCode] = statusCode;
  return err;
}


/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { randomFillSync } = __webpack_require__(/*! crypto */ "crypto");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { isValidStatusCode } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");
const { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

const mask = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} extensions An object containing the negotiated extensions
   */
  constructor(socket, extensions) {
    this._extensions = extensions || {};
    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame(data, options) {
    const merge = options.mask && options.readOnly;
    let offset = options.mask ? 6 : 2;
    let payloadLength = data.length;

    if (data.length >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2);
      target.writeUInt32BE(data.length, 6);
    }

    if (!options.mask) return [target, data];

    randomFillSync(mask, 0, 4);

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      applyMask(data, mask, target, offset, data.length);
      return [target];
    }

    applyMask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {(Number|undefined)} code The status code component of the body
   * @param {String} data The message component of the body
   * @param {Boolean} mask Specifies whether or not to mask the message
   * @param {Function} cb Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || data === '') {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);
      buf.write(data, 2);
    }

    if (this._deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @private
   */
  doClose(data, mask, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask,
        readOnly: false
      }),
      cb
    );
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  ping(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPing(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a ping message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPing(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  pong(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPong(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a pong message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPong(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  send(data, options, cb) {
    const buf = toBuffer(data);
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate) {
        rsv1 = buf.length >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        fin: options.fin,
        rsv1,
        opcode,
        mask: options.mask,
        readOnly: toBuffer.readOnly
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
      } else {
        this.dispatch(buf, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a data message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} compress Specifies whether or not to compress `data`
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @param {Function} cb Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const callback = this._queue[i][4];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[1].length;
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[1].length;
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} cb Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { Duplex } = __webpack_require__(/*! stream */ "stream");

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {stream.Duplex} The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} options The options for the `Duplex` constructor
 * @return {stream.Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let resumeOnReceiverDrain = true;

  function receiverOnDrain() {
    if (resumeOnReceiverDrain) ws._socket.resume();
  }

  if (ws.readyState === ws.CONNECTING) {
    ws.once('open', function open() {
      ws._receiver.removeAllListeners('drain');
      ws._receiver.on('drain', receiverOnDrain);
    });
  } else {
    ws._receiver.removeAllListeners('drain');
    ws._receiver.on('drain', receiverOnDrain);
  }

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg) {
    if (!duplex.push(msg)) {
      resumeOnReceiverDrain = false;
      ws._socket.pause();
    }
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function(err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });
    ws.terminate();
  };

  duplex._final = function(callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function() {
    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
      resumeOnReceiverDrain = true;
      if (!ws._receiver._writableState.needDrain) ws._socket.resume();
    }
  };

  duplex._write = function(chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


try {
  const isValidUTF8 = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'utf-8-validate'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

  exports.isValidUTF8 =
    typeof isValidUTF8 === 'object'
      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0
      : isValidUTF8;
} catch (e) /* istanbul ignore next */ {
  exports.isValidUTF8 = () => true;
}

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
exports.isValidStatusCode = (code) => {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
};


/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events");
const { createHash } = __webpack_require__(/*! crypto */ "crypto");
const { createServer, STATUS_CODES } = __webpack_require__(/*! http */ "http");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const WebSocket = __webpack_require__(/*! ./websocket */ "./node_modules/ws/lib/websocket.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");
const { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} options.backlog The maximum length of the queue of pending
   *     connections
   * @param {Boolean} options.clientTracking Specifies whether or not to track
   *     clients
   * @param {Function} options.handleProtocols A hook to handle protocols
   * @param {String} options.host The hostname where to bind the server
   * @param {Number} options.maxPayload The maximum allowed message size
   * @param {Boolean} options.noServer Enable no server mode
   * @param {String} options.path Accept only connections matching this path
   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable
   *     permessage-deflate
   * @param {Number} options.port The port where to bind the server
   * @param {http.Server} options.server A pre-created HTTP/S server to use
   * @param {Function} options.verifyClient A hook to reject connections
   * @param {Function} callback A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      ...options
    };

    if (options.port == null && !options.server && !options.noServer) {
      throw new TypeError(
        'One of the "port", "server", or "noServer" options must be specified'
      );
    }

    if (options.port != null) {
      this._server = createServer((req, res) => {
        const body = STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, (ws) => {
            this.emit('connection', ws, req);
          });
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) this.clients = new Set();
    this.options = options;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Close the server.
   *
   * @param {Function} cb Callback
   * @public
   */
  close(cb) {
    if (cb) this.once('close', cb);

    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) {
        server.close(() => this.emit('close'));
        return;
      }
    }

    process.nextTick(emitClose, this);
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key =
      req.headers['sec-websocket-key'] !== undefined
        ? req.headers['sec-websocket-key'].trim()
        : false;
    const version = +req.headers['sec-websocket-version'];
    const extensions = {};

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !key ||
      !keyRegex.test(key) ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    if (this.options.perMessageDeflate) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = parse(req.headers['sec-websocket-extensions']);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.connection.authorized || req.connection.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(key, extensions, req, socket, head, cb);
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(key, extensions, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Object} extensions The accepted extensions
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(key, extensions, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new WebSocket(null);
    let protocol = req.headers['sec-websocket-protocol'];

    if (protocol) {
      protocol = protocol.trim().split(/ *, */);

      //
      // Optionally call external protocol selection handler.
      //
      if (this.options.handleProtocols) {
        protocol = this.options.handleProtocols(protocol, req);
      } else {
        protocol = protocol[0];
      }

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws.protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => this.clients.delete(ws));
    }

    cb(ws);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server.emit('close');
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {net.Socket} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || STATUS_CODES[code];
    headers = {
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message),
      ...headers
    };

    socket.write(
      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\r\n` +
        Object.keys(headers)
          .map((h) => `${h}: ${headers[h]}`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}


/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events");
const https = __webpack_require__(/*! https */ "https");
const http = __webpack_require__(/*! http */ "http");
const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { randomBytes, createHash } = __webpack_require__(/*! crypto */ "crypto");
const { URL } = __webpack_require__(/*! url */ "url");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const Receiver = __webpack_require__(/*! ./receiver */ "./node_modules/ws/lib/receiver.js");
const Sender = __webpack_require__(/*! ./sender */ "./node_modules/ws/lib/sender.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { addEventListener, removeEventListener } = __webpack_require__(/*! ./event-target */ "./node_modules/ws/lib/event-target.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");
const { toBuffer } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|url.URL)} address The URL to which to connect
   * @param {(String|String[])} protocols The subprotocols
   * @param {Object} options Connection options
   */
  constructor(address, protocols, options) {
    super();

    this.readyState = WebSocket.CONNECTING;
    this.protocol = '';

    this._binaryType = BINARY_TYPES[0];
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = '';
    this._closeTimer = null;
    this._closeCode = 1006;
    this._extensions = {};
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (Array.isArray(protocols)) {
        protocols = protocols.join(', ');
      } else if (typeof protocols === 'object' && protocols !== null) {
        options = protocols;
        protocols = undefined;
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  get CONNECTING() {
    return WebSocket.CONNECTING;
  }
  get CLOSING() {
    return WebSocket.CLOSING;
  }
  get CLOSED() {
    return WebSocket.CLOSED;
  }
  get OPEN() {
    return WebSocket.OPEN;
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    //
    // `socket.bufferSize` is `undefined` if the socket is closed.
    //
    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Number} maxPayload The maximum allowed message size
   * @private
   */
  setSocket(socket, head, maxPayload) {
    const receiver = new Receiver(
      this._binaryType,
      this._extensions,
      this._isServer,
      maxPayload
    );

    this._sender = new Sender(socket, this._extensions);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this.readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this.readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this.readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} code Status code explaining why the connection is closing
   * @param {String} data A string explaining why the connection is closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
      return;
    }

    this.readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;
      if (this._closeFrameReceived) this._socket.end();
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Send a ping.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress
   *     `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this.readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

readyStates.forEach((readyState, i) => {
  WebSocket[readyState] = i;
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    /**
     * Return the listener of the event.
     *
     * @return {(Function|undefined)} The event listener or `undefined`
     * @public
     */
    get() {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        if (listeners[i]._listener) return listeners[i]._listener;
      }

      return undefined;
    },
    /**
     * Add a listener for the event.
     *
     * @param {Function} listener The listener to add
     * @public
     */
    set(listener) {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.addEventListener(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|url.URL)} address The URL to which to connect
 * @param {String} protocols The subprotocols
 * @param {Object} options Connection options
 * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable
 *     permessage-deflate
 * @param {Number} options.handshakeTimeout Timeout in milliseconds for the
 *     handshake request
 * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version`
 *     header
 * @param {String} options.origin Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {Number} options.maxPayload The maximum allowed message size
 * @param {Boolean} options.followRedirects Whether or not to follow redirects
 * @param {Number} options.maxRedirects The maximum number of redirects allowed
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket.url = address.href;
  } else {
    parsedUrl = new URL(address);
    websocket.url = address;
  }

  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
    throw new Error(`Invalid URL: ${websocket.url}`);
  }

  const isSecure =
    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const get = isSecure ? https.get : http.get;
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket',
    ...opts.headers
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols) {
    opts.headers['Sec-WebSocket-Protocol'] = protocols;
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req = (websocket._req = get(opts));

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (websocket._req.aborted) return;

    req = websocket._req = null;
    websocket.readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      const addr = new URL(location, address);

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    const protList = (protocols || '').split(/, */);
    let protError;

    if (!protocols && serverProt) {
      protError = 'Server sent a subprotocol but none was requested';
    } else if (protocols && !serverProt) {
      protError = 'Server sent no subprotocol';
    } else if (serverProt && !protList.includes(serverProt)) {
      protError = 'Server sent an invalid subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket.protocol = serverProt;

    if (perMessageDeflate) {
      try {
        const extensions = parse(res.headers['sec-websocket-extensions']);

        if (extensions[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          websocket._extensions[
            PerMessageDeflate.extensionName
          ] = perMessageDeflate;
        }
      } catch (err) {
        abortHandshake(
          websocket,
          socket,
          'Invalid Sec-WebSocket-Extensions header'
        );
        return;
      }
    }

    websocket.setSocket(socket, head, opts.maxPayload);
  });
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the
 *     socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket.readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();
    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} data The data to send
 * @param {Function} cb Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    cb(err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {String} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);
  websocket._socket.resume();

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  this[kWebSocket]._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);

  websocket.readyState = WebSocket.CLOSING;
  websocket._closeCode = err[kStatusCode];
  websocket.emit('error', err);
  websocket._socket.destroy();
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
 * @private
 */
function receiverOnMessage(data) {
  this[kWebSocket].emit('message', data);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('end', socketOnEnd);

  websocket.readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk and emitted synchronously in a single
  // `'data'` event.
  //
  websocket._socket.read();
  websocket._receiver.end();

  this.removeListener('data', socketOnData);
  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket.readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket.readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ "./src/MockDependencies.js":
/*!*********************************!*\
  !*** ./src/MockDependencies.js ***!
  \*********************************/
/*! exports provided: MockGUI, MockRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MockGUI", function() { return MockGUI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MockRenderer", function() { return MockRenderer; });
/* harmony import */ var three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/src/math/Vector3 */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/src/math/Quaternion */ "./node_modules/three/src/math/Quaternion.js");
/* harmony import */ var three_src_core_Object3D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/src/core/Object3D */ "./node_modules/three/src/core/Object3D.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





global.debug = function () {
  var _console;

  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return (_console = console).log.apply(_console, ["[".concat(new Date().toLocaleTimeString(), "]")].concat(params));
};

var Obj3D = /*#__PURE__*/function (_Object3D) {
  _inherits(Obj3D, _Object3D);

  var _super = _createSuper(Obj3D);

  function Obj3D() {
    var _this;

    _classCallCheck(this, Obj3D);

    for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      props[_key2] = arguments[_key2];
    }

    _this = _super.call.apply(_super, [this].concat(props));
    _this.scene = _assertThisInitialized(_this);
    return _this;
  }

  return Obj3D;
}(three_src_core_Object3D__WEBPACK_IMPORTED_MODULE_2__["Object3D"]);

global.THREE = {
  Vector3: three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_0__["Vector3"],
  Quaternion: three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_1__["Quaternion"],
  Object3D: Obj3D,
  WebGLRenderer: function WebGLRenderer() {
    return {
      render: function render() {
        return {};
      },
      setSize: function setSize() {
        return {};
      },
      getContext: function getContext() {
        return {
          canvas: {
            width: 0,
            height: 0
          }
        };
      },
      shadowMap: {}
    };
  },
  Scene: Obj3D,
  Cache: {},
  Clock: function Clock() {
    return {};
  },
  AnimationMixer: function AnimationMixer() {
    return {
      update: function update() {
        return {};
      },
      clipAction: function clipAction() {
        return {
          stop: function stop() {
            return {};
          }
        };
      }
    };
  },
  PCFSoftShadowMap: function PCFSoftShadowMap() {
    return {};
  },
  PerspectiveCamera: Obj3D,
  Raycaster: function Raycaster() {
    return {};
  },
  TextureLoader: function TextureLoader() {
    return {
      load: function load() {
        return {};
      }
    };
  },
  Fog: function Fog() {
    return {};
  },
  RepeatWrapping: function RepeatWrapping() {
    return {};
  },
  Color: function Color() {
    return {};
  },
  Mesh: Obj3D,
  CubeGeometry: function CubeGeometry() {
    return {};
  },
  MeshLambertMaterial: function MeshLambertMaterial() {
    return {};
  },
  NormalBlending: function NormalBlending() {
    return {};
  },
  AdditiveBlending: function AdditiveBlending() {
    return {};
  },
  Geometry: function Geometry() {
    return {};
  },
  PointCloudMaterial: function PointCloudMaterial() {
    return {};
  },
  PointCloud: function PointCloud() {
    return {};
  },
  AmbientLight: function AmbientLight() {
    return {};
  },
  DirectionalLight: function DirectionalLight() {
    var light = new Obj3D();
    light.shadow = {
      camera: {},
      mapSize: {}
    };
    return light;
  },
  MeshBasicMaterial: function MeshBasicMaterial() {
    return {};
  },
  BackSide: function BackSide() {
    return {};
  },
  MeshFaceMaterial: function MeshFaceMaterial() {
    return {};
  }
};

global.GLTFLoader = function () {
  return {
    load: function load(url, callback) {
      return callback(new Obj3D());
    }
  };
};

global.window = {
  innerWidth: 0,
  innerHeight: 0,
  clearTimeout: 0,
  requestAnimationFrame: function requestAnimationFrame(fn) {
    return setTimeout(fn, 1000 / 60);
  },
  location: {
    reload: function reload() {
      return debug('reload page');
    }
  },
  addEventListener: function addEventListener() {
    for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      params[_key3] = arguments[_key3];
    }

    return debug.apply(void 0, ['window.addEventListener'].concat(params));
  },
  setTimeout: setTimeout,
  WebSocket: function WebSocket() {
    return {
      onopen: function onopen() {
        for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          params[_key4] = arguments[_key4];
        }

        return debug.apply(void 0, ['window.WebSocket.onopen'].concat(params));
      },
      onerror: function onerror() {
        for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          params[_key5] = arguments[_key5];
        }

        return debug.apply(void 0, ['window.WebSocket.onerror'].concat(params));
      },
      onmessage: function onmessage() {
        for (var _len6 = arguments.length, params = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          params[_key6] = arguments[_key6];
        }

        return debug.apply(void 0, ['window.WebSocket.onmessage'].concat(params));
      }
    };
  }
};
global.document = {
  body: {
    addEventListener: function addEventListener() {
      for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        params[_key7] = arguments[_key7];
      }

      return debug.apply(void 0, ['document.body.addEventListener'].concat(params));
    },
    removeEventListener: function removeEventListener() {
      for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        params[_key8] = arguments[_key8];
      }

      return debug.apply(void 0, ['document.body.removeEventListener'].concat(params));
    }
  },
  dispatchEvent: function dispatchEvent() {
    for (var _len9 = arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      params[_key9] = arguments[_key9];
    }

    return debug.apply(void 0, ['document.dispatchEvent'].concat(params));
  },
  getElementById: function getElementById() {
    for (var _len10 = arguments.length, params = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      params[_key10] = arguments[_key10];
    }

    return debug.apply(void 0, ['document.getElementById'].concat(params));
  },
  addEventListener: function addEventListener() {
    for (var _len11 = arguments.length, params = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      params[_key11] = arguments[_key11];
    }

    return debug.apply(void 0, ['document.addEventListener'].concat(params));
  },
  removeEventListener: function removeEventListener() {
    for (var _len12 = arguments.length, params = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      params[_key12] = arguments[_key12];
    }

    return debug.apply(void 0, ['document.removeEventListener'].concat(params));
  }
};
var MockGUI = {
  isServer: true,
  setRestartButtonVisible: function setRestartButtonVisible() {
    return null;
  },
  setPause: function setPause() {
    return null;
  },
  restartGame: function restartGame() {
    return null;
  },
  isPause: function isPause() {
    return false;
  },
  isThirdPerson: function isThirdPerson() {
    return false;
  },
  update: function update() {
    return null;
  },
  setConnectionRole: debug,
  updatePlayerParams: function updatePlayerParams() {
    return null;
  },
  clearHpBars: function clearHpBars() {
    return null;
  },
  switchCamera: function switchCamera() {
    return null;
  },
  setFps: function setFps() {
    return null;
  },
  notify: debug,
  setLoading: function setLoading() {
    return null;
  }
};
var MockRenderer = {
  fps: 1,
  targetFps: 1,
  renderer: new THREE.WebGLRenderer(),
  render: function render() {
    return {};
  }
};

/***/ }),

/***/ "./src/SocketServer.js":
/*!*****************************!*\
  !*** ./src/SocketServer.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ "./node_modules/ws/index.js");
/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var WebSocketServer = ws__WEBPACK_IMPORTED_MODULE_0__["Server"];

var SocketServer = /*#__PURE__*/function () {
  function SocketServer() {
    _classCallCheck(this, SocketServer);

    this.createWebServer = this.createWebServer.bind(this);
    this.createSocketServer = this.createSocketServer.bind(this);
    this.saveUserData = this.saveUserData.bind(this);
    this.loadUserData = this.loadUserData.bind(this);
    this.startSocketServer = this.startSocketServer.bind(this);
    this.getConnectionId = this.getConnectionId.bind(this);
    this.sendGameObjectsToPlayers = this.sendGameObjectsToPlayers.bind(this);
    this.send = this.send.bind(this);
    var isProduction = "development" === 'production';
    this.config = {
      ssl: isProduction,
      port: 1337,
      sslKey: path__WEBPACK_IMPORTED_MODULE_2__["join"](__dirname, './private.pem'),
      sslCertificate: path__WEBPACK_IMPORTED_MODULE_2__["join"](__dirname, './fullchain.pem'),
      sessionsPath: path__WEBPACK_IMPORTED_MODULE_2__["join"](__dirname, './sessions/'),
      debug: false
    };
    console.log(__dirname, fs__WEBPACK_IMPORTED_MODULE_1__["readdirSync"](__dirname));
    this.db = {
      sequenceId: 0,
      hostId: null,
      connections: {},
      players: {},
      gameObjects: []
    };
    var socketServer = this.createSocketServer(this.config);
    this.startSocketServer(socketServer);
  }

  _createClass(SocketServer, [{
    key: "createWebServer",
    value: function createWebServer(config) {
      var processRequest = function processRequest(req, res) {
        res.writeHead(200);
        res.end("All glory to WebSockets!\n");
      };

      if (config.ssl) {
        var sslParams = {
          key: fs__WEBPACK_IMPORTED_MODULE_1__["readFileSync"](config.sslKey),
          cert: fs__WEBPACK_IMPORTED_MODULE_1__["readFileSync"](config.sslCertificate)
        };
        return __webpack_require__(/*! https */ "https").createServer(sslParams, processRequest).listen(config.port);
      } else {
        return __webpack_require__(/*! http */ "http").createServer(processRequest).listen(config.port);
      }
    }
  }, {
    key: "createSocketServer",
    value: function createSocketServer(config) {
      var server = this.createWebServer(config);
      var webSocketServer = new WebSocketServer({
        server: server
      });
      debug("Server is running on port ".concat(config.port, ". SSL is ").concat(config.ssl ? 'enabled' : 'disabled', "."));
      return webSocketServer;
    }
  }, {
    key: "saveUserData",
    value: function saveUserData(token, data) {
      try {
        if (!fs__WEBPACK_IMPORTED_MODULE_1__["existsSync"](this.config.sessionsPath)) {
          fs__WEBPACK_IMPORTED_MODULE_1__["mkdirSync"](this.config.sessionsPath);
        }

        fs__WEBPACK_IMPORTED_MODULE_1__["writeFileSync"]("".concat(this.config.sessionsPath, "/").concat(token), JSON.stringify(data));
        return true;
      } catch (e) {
        debug('Save user data error', e);
        return false;
      }
    }
  }, {
    key: "loadUserData",
    value: function loadUserData(token) {
      var tokenPath = "".concat(this.config.sessionsPath, "/").concat(token);

      try {
        if (fs__WEBPACK_IMPORTED_MODULE_1__["existsSync"](tokenPath)) {
          return JSON.parse(fs__WEBPACK_IMPORTED_MODULE_1__["readFileSync"](tokenPath, 'utf8'));
        }
      } catch (e) {
        debug('Load user data error', e);
      }

      return false;
    }
  }, {
    key: "getConnectionId",
    value: function getConnectionId(c) {
      return c._id;
    }
  }, {
    key: "sendGameObjectsToPlayers",
    value: function sendGameObjectsToPlayers() {
      var _this = this;

      var players = this.db.players;
      var connections = this.db.connections;
      var gameObjects = this.db.gameObjects;
      Object.keys(connections).forEach(function (connectionId) {
        var connection = connections[connectionId];
        var networkPlayers = Object.keys(players).filter(function (playerConnectionId) {
          return playerConnectionId !== connectionId;
        }).map(function (playerConnectionId) {
          return players[playerConnectionId];
        });

        _this.send(connection, 'updateGameObjects', [].concat(_toConsumableArray(gameObjects), _toConsumableArray(networkPlayers)));
      });
    }
  }, {
    key: "send",
    value: function send(connection, messageType, data) {
      connection.send(JSON.stringify({
        meta: {
          server: {
            version: 1
          },
          role: this.getConnectionId(connection) === this.db.hostId ? 'host' : 'client',
          id: this.getConnectionId(connection),
          token: connection._meta.token,
          debug: this.config.debug
        },
        data: data,
        messageType: messageType
      }));
    }
  }, {
    key: "startSocketServer",
    value: function startSocketServer(socketServer) {
      var _this2 = this;

      var db = this.db;
      var loadUserData = this.loadUserData;
      var getConnectionId = this.getConnectionId;
      var send = this.send;

      var getConnectionToken = function getConnectionToken(c) {
        return c._meta.token;
      };

      setInterval(function () {
        Object.values(db.connections).forEach(function (connection) {
          var connectionPlayer = db.players[getConnectionId(connection)];
          var token = getConnectionToken(connection);

          if (connectionPlayer && token) {
            _this2.saveUserData(token, connectionPlayer);
          }
        });
      }, 10000);
      socketServer.on('connection', function (connection) {
        var id = ++db.sequenceId;
        debug('New connection, id:', id);
        db.connections[id] = connection;
        connection._meta = {
          id: id
        };
        connection._id = id;

        var onSocketClose = function onSocketClose() {
          var id = getConnectionId(connection);
          debug('Connection closed, id:', id);
          Object.values(db.connections).forEach(function (c) {
            send(c, 'disconnected', {
              connectionId: id
            });
          });
          delete db.connections[id];
          delete db.players[id];
        };

        var onSocketMessage = function onSocketMessage(message) {
          var _JSON$parse = JSON.parse(message),
              data = _JSON$parse.data,
              messageType = _JSON$parse.messageType,
              meta = _JSON$parse.meta;

          var connectionId = getConnectionId(connection);

          if (meta && meta.token && meta.token !== connection._meta.token) {
            debug("User #".concat(connectionId, " token changed from ").concat(connection._meta.token, " to ").concat(meta.token));
            connection._meta.token = meta.token;
          }

          var sendUserData = function sendUserData() {
            send(connection, 'setUserPlayer', loadUserData(connection._meta.token));
          };

          var updatePlayerData = function updatePlayerData(player) {
            db.players[connectionId] = player;
          };

          switch (messageType) {
            case 'loadCurrentUser':
              {
                sendUserData();
                break;
              }

            case 'updatePlayer':
              {
                updatePlayerData(data);
                break;
              }

            case 'restartServer':
              {
                // restartServer();
                break;
              }
          }
        };

        connection.on('message', onSocketMessage);
        connection.on('close', onSocketClose);
        send(connection, 'handshake');
      });
    }
  }]);

  return SocketServer;
}();

/* harmony default export */ __webpack_exports__["default"] = (SocketServer);

/***/ }),

/***/ "./standalone-server.js":
/*!******************************!*\
  !*** ./standalone-server.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_MockDependencies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/MockDependencies */ "./src/MockDependencies.js");
/* harmony import */ var _src_SocketServer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/SocketServer */ "./src/SocketServer.js");
/* harmony import */ var _client_src_js_Scene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../client/src/js/Scene */ "../client/src/js/Scene.js");
/* harmony import */ var _client_src_js_Connection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../client/src/js/Connection */ "../client/src/js/Connection.js");
/* harmony import */ var _client_src_js_GameObjects__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../client/src/js/GameObjects */ "../client/src/js/GameObjects.js");






function Server() {
  debug('Starting server scene initialization ...');
  var scene = new _client_src_js_Scene__WEBPACK_IMPORTED_MODULE_2__["default"](_src_MockDependencies__WEBPACK_IMPORTED_MODULE_0__["MockRenderer"], _src_MockDependencies__WEBPACK_IMPORTED_MODULE_0__["MockGUI"]);
  debug('Scene is loaded', {
    THREE: Boolean(THREE),
    document: Boolean(document),
    window: Boolean(window),
    GLTFLoader: Boolean(GLTFLoader),
    scene: Boolean(scene),
    sceneLocation: Boolean(scene.location),
    sceneColliders: scene.colliders.colliders.length,
    sceneAreas: scene.pathFinder.areas.length
  });

  var init = function init() {
    var player = scene.getPlayer();

    if (player) {
      player.params.hp = 0;
    }

    debug('Starting socket server ...');
    var socketServer = new _src_SocketServer__WEBPACK_IMPORTED_MODULE_1__["default"]();

    var updateGameObjects = function updateGameObjects() {
      var data = [];
      scene.units.getAliveUnits().filter(function (unit) {
        return !(unit instanceof _client_src_js_GameObjects__WEBPACK_IMPORTED_MODULE_4__["Player"]);
      }).forEach(function (unit) {
        var unitData = _client_src_js_Connection__WEBPACK_IMPORTED_MODULE_3__["default"].unitToNetwork(unit, null, 'dream-town');

        if (unitData) {
          data.push(unitData);
        }
      });
      Object.values(socketServer.db.players).forEach(scene.connection.updateNetworkPlayer);
      socketServer.db.gameObjects = data;
      socketServer.sendGameObjectsToPlayers();
    };

    setInterval(updateGameObjects, 100);
  };

  setTimeout(init, 5000);
}

/* harmony default export */ __webpack_exports__["default"] = (Server);

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvQXV0b0JpbmRNZXRob2RzLmpzIiwid2VicGFjazovLy8uLi9jbGllbnQvc3JjL2pzL0NhbWVyYS5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9Db2xsaWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvQ29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy9BSS5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy9BbmltYXRlZEdhbWVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvR2FtZU9iamVjdHMvRmlyZS5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy9GaXJpbmdVbml0LmpzIiwid2VicGFjazovLy8uLi9jbGllbnQvc3JjL2pzL0dhbWVPYmplY3RzL0dhbWVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvR2FtZU9iamVjdHMvTW92aW5nR2FtZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy9QbGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvR2FtZU9iamVjdHMvVW5pdC5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9JbnRlcnZhbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvTG9jYXRpb25zL0Fic3RyYWN0TG9jYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvTG9jYXRpb25zL0RyZWFtVG93bi9BcmVhcy5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9Mb2NhdGlvbnMvRHJlYW1Ub3duL0VsZXZhdG9yLmpzIiwid2VicGFjazovLy8uLi9jbGllbnQvc3JjL2pzL0xvY2F0aW9ucy9EcmVhbVRvd24vRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvTG9jYXRpb25zL0RyZWFtVG93bi9Mb2NhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9Mb2NhdGlvbnMvRHJlYW1Ub3duL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9jbGllbnQvc3JjL2pzL01vZGVscy5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9QYXJ0aWNsZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvUGF0aEZpbmRlci5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9TY2VuZS5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9Vbml0cy5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9VdGlscy9BU3Rhci5qcyIsIndlYnBhY2s6Ly8vLi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aHJlZS9zcmMvY29yZS9MYXllcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb3JlL09iamVjdDNELmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9FdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvTWF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvTWF0cml4My5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvTWF0cml4NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvUXVhdGVybmlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvVmVjdG9yMy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvZXZlbnQtdGFyZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvZXh0ZW5zaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvc2VuZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvc3RyZWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvdmFsaWRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL01vY2tEZXBlbmRlbmNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvY2tldFNlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9zdGFuZGFsb25lLXNlcnZlci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldmVudHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5ldFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInBhdGhcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzdHJlYW1cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ0bHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1cmxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ6bGliXCIiXSwibmFtZXMiOlsiQXV0b0JpbmRNZXRob2RzIiwiZnVuY3Rpb25OYW1lcyIsIm9iaiIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiY29uY2F0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZpbHRlciIsIm5hbWUiLCJpbmRleE9mIiwiZnVuY3Rpb25OYW1lIiwiYmluZCIsIkNhbWVyYSIsInNjZW5lIiwicmF0aW8iLCJnZXRXaWR0aCIsImdldEhlaWdodCIsImNhbWVyYSIsIlRIUkVFIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJwb3NpdGlvbiIsInNldCIsImRlbHRhWSIsInJvdGF0ZVkiLCJkZWZhdWx0RGlzdGFuY2UiLCJkaXN0YW5jZSIsInJheWNhc3RlciIsIlJheWNhc3RlciIsImdhbWVUaW1lIiwiZGVsdGFUaW1lIiwiaW5wdXQiLCJwbGF5ZXIiLCJnZXRQbGF5ZXIiLCJsb29rIiwiY2luZW1hdGljIiwibG9va0F0IiwiVmVjdG9yMyIsInNlbnNpdGl2aXR5IiwidmVydGljYWwiLCJpc1RoaXJkUGVyc29uIiwidXBkYXRlVGhpcmRQZXJzb24iLCJjb3B5IiwiY2xvbmUiLCJhZGQiLCJ5IiwicmVuZGVyZXIiLCJnZXRDb250ZXh0IiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJjaGlsZHJlbiIsInBsYXllckhlYWRQb3NpdGlvbiIsIm9yaWdpbiIsImRlc3RpbmF0aW9uIiwiZGlyZWN0aW9uIiwiZ2V0Q2hpbGRyZW5GbGF0Iiwib2JqZWN0cyIsIm1hcCIsImVudmlyb25tZW50IiwiZmluZCIsImMiLCJmbGF0Q2hpbGRyZW5NZXNoZXMiLCJ0eXBlIiwic3ViVmVjdG9ycyIsIm5vcm1hbGl6ZSIsImZhciIsImludGVyc2VjdHMiLCJpbnRlcnNlY3RPYmplY3RzIiwiTWF0aCIsIm1pbiIsImkiLCJwbGF5ZXJGb3J3YXJkIiwiZ2V0Rm9yd2FyZCIsIm11bHRpcGx5U2NhbGFyIiwiYmFjayIsImNhbWVyYUZvcndhcmQiLCJhcHBseVF1YXRlcm5pb24iLCJxdWF0ZXJuaW9uIiwic3ViIiwid2lkdGhIYWxmIiwiaGVpZ2h0SGFsZiIsImNvcGllZFByb2plY3RWZWN0b3IiLCJwcm9qZWN0IiwieCIsInJvdW5kIiwieiIsIkNvbGxpZGVycyIsImNvbGxpZGVycyIsIm5leHRJZCIsImdhbWVPYmplY3QiLCJjb2xsaWRlciIsImZuIiwiaWQiLCJpZHgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJwdXNoIiwicGF0aEZpbmRlciIsInJlYnVpbGRBcmVhcyIsIkNvbm5lY3Rpb24iLCJpcCIsInBvcnQiLCJpc1NlY3VyZSIsIm1ldGEiLCJuZXR3b3JrUGxheWVycyIsIm5ldHdvcmtBSXMiLCJXZWJTb2NrZXQiLCJ3aW5kb3ciLCJNb3pXZWJTb2NrZXQiLCJjb25uZWN0aW9uIiwib25vcGVuIiwiY29uc29sZSIsImxvZyIsIm9uZXJyb3IiLCJlcnJvciIsIm9ubWVzc2FnZSIsIm9uTWVzc2FnZSIsInRpbWUiLCJzZW5kR2FtZU9iamVjdHMiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwicmVzcG9uc2UiLCJtZXNzYWdlVHlwZSIsInJvbGUiLCJ1aSIsInNldENvbm5lY3Rpb25Sb2xlIiwiaG9zdFVuaXRzRnJvbU5ldHdvcmsiLCJkZWJ1ZyIsImNsZWFyTG9jYWxHYW1lT2JqZWN0cyIsInByb2Nlc3NIYW5kc2hha2UiLCJsb2NhdGlvbiIsInJlbG9hZCIsInNldFBsYXllclBhcmFtcyIsInVuaXRzIiwic2V0RGVmYXVsdFBsYXllclBhcmFtcyIsInVwZGF0ZUdhbWVPYmplY3RzIiwicmVtb3ZlRGlzY29ubmVjdGVkUGxheWVyIiwiZSIsInNlbmQiLCJnYW1lT2JqZWN0c1NlcnZpY2UiLCJnZXRVbml0cyIsImZvckVhY2giLCJ1bml0IiwicGFyYW1zIiwiZnJvbU5ldHdvcmsiLCJkZXN0cm95R2FtZU9iamVjdCIsInVzZXIiLCJ1c2VyTmFtZSIsInBhc3N3b3JkIiwidG9rZW4iLCJnZXRIYXNoIiwic3RyaW5naWZ5IiwiZ2FtZU9iamVjdHMiLCJ1cGRhdGVOZXR3b3JrUGxheWVyIiwidXBkYXRlTmV0d29ya0FJIiwiY29ubmVjdGlvbklkIiwiZGlzY29ubmVjdGVkUGxheWVyIiwiUGxheWVyIiwiZGllIiwic3RyIiwiaGFzaDMyIiwibCIsImh2YWwiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJzdWJzdHIiLCJoMSIsImdldEFsaXZlVW5pdHMiLCJwbGF5ZXJEYXRhIiwibG9jYXRpb25OYW1lIiwicm90YXRpb24iLCJhbmltYXRpb25TdGF0ZSIsInVuaXROZXR3b3JrSWQiLCJnZXRMb2NhdGlvbk5hbWUiLCJuZXR3b3JrUGxheWVyIiwiY3JlYXRlTmV0d29ya1BsYXllciIsImFjY2VsZXJhdGlvbiIsInBsYXllclBhcmFtcyIsImhvcml6b250YWwiLCJhdHRhY2sxIiwiYXR0YWNrMiIsImhwIiwiaHBNYXgiLCJmcmFjdGlvbiIsImRhbWFnZSIsInNwZWVkIiwibW9uZXkiLCJsZXZlbCIsInVuc3BlbnRUYWxlbnRzIiwiZXhwZXJpZW5jZSIsInVuaXREYXRhIiwiaXNSdW5uaW5nIiwiaXNBdHRhY2siLCJzY2FsZSIsIm5ldHdvcmtBSSIsImNyZWF0ZU5ldHdvcmtBSSIsIm9iamVjdCIsIm5ldHdvcmtBSVBhcmFtcyIsInJlYWR5U3RhdGUiLCJ1bml0VG9OZXR3b3JrIiwidW5pdFJvdGF0aW9uIiwidG9WZWN0b3IzIiwiZ2V0UmFuZG9tU3RyaW5nIiwicmFuZG9tIiwidmVjdG9yVG9PYmplY3QiLCJ2ZWN0b3IiLCJlcHMiLCJHYW1lT2JqZWN0c1NlcnZpY2UiLCJuZXh0R2FtZU9iamVjdElkIiwidXBkYXRlIiwiYXR0YWNraW5nVW5pdCIsImlzRGVhZCIsImludGVydmFscyIsInNldFRpbWVvdXQiLCJnZXRUaW1lUGFzc2VkIiwiaXNBdHRhY2tJbnRlcnJ1cHRlZCIsInJlbGVhc2VBdHRhY2siLCJhdHRhY2tlZFVuaXRzIiwiaXNBbGl2ZSIsImlzRW5lbXkiLCJkaXN0YW5jZVRvIiwiY29sbGlzaW9uR2FtZU9iamVjdCIsImRhbWFnZVRha2VuIiwiZ2V0QXR0YWNrVGltZW91dCIsImZpcmluZ0dhbWVPYmplY3QiLCJjcmVhdGVMaWdodEN1YmUiLCJsZWZ0IiwibW9kZWxzIiwiY3JlYXRlQ3ViZSIsImVtaXNzaXZlIiwiTnVtYmVyIiwibm9TY2VuZSIsIk9iamVjdDNEIiwiZ2V0RmlyZUluaXRpYWxQb3NpdGlvbiIsImdldEZpcmVJbml0aWFsUm90YXRpb24iLCJmaXJlR2FtZU9iamVjdCIsImhvb2tHYW1lT2JqZWN0IiwiRmlyZSIsInRocm90dGxpbmciLCJmaXJlU2hlbGxTcGVlZCIsImZpcmVEYW1hZ2UiLCJwYXJlbnQiLCJjaGVja1dheSIsImdldENvbGxpc2lvbnMiLCJVbml0IiwiZGVzdHJveSIsIm1vZGVsIiwiY2FuUGlja3VwIiwib25QaWNrdXAiLCJsb2FkR0xURiIsImJhc2VVcmwiLCJjYWxsYmFjayIsImxvYWRlZE9iamVjdCIsInBvc2l0aW9uVmVjdG9yIiwidHJhdmVyc2UiLCJjaGlsZCIsImlzTWVzaCIsIm1hdGVyaWFsIiwidHJhbnNwYXJlbnQiLCJhbHBoYVRlc3QiLCJnYW1lSXRlbSIsIkFuaW1hdGVkR2FtZU9iamVjdCIsImFuaW1hdGlvbnMiLCJjaGVja1BpY2t1cCIsImdldFByaW9yaXR5IiwiY2VpbCIsIm5lYXJVbml0cyIsInNvcnQiLCJ1bml0QSIsInVuaXRCIiwiaXNEaWUiLCJfX2dhbWVfb2JqZWN0X2lkIiwiZ2V0TmV4dE5vblBsYXllckluZGV4IiwiZ28iLCJyZW1vdmVJZHgiLCJyZW1vdmVHYW1lT2JqZWN0RnJvbVNjZW5lIiwiaW5kZXgiLCJyZW1vdmUiLCJBSSIsIm1hcyIsImZpcmVUaW1lb3V0IiwiYXR0YWNrVGltZW91dCIsImp1bXBUaW1lb3V0Iiwic3RhcnRSdW5UaW1lb3V0IiwibmV4dFBvaW50VXBkYXRlVGltZW91dCIsInVwZGF0ZVRhcmdldFRpbWVvdXQiLCJib3VudHkiLCJsYXN0UnVuIiwibGFzdFRhcmdldFVwZGF0ZSIsImxhc3ROZXh0UG9pbnRVcGRhdGUiLCJsYXN0SnVtcFRpbWVzdGFtcCIsImZpbmRUYXJnZXQiLCJpc1VwZGF0ZVRhcmdldFJlbGVhc2VkIiwidGFyZ2V0IiwiZ2V0TmV4dFBvaW50IiwiaXNOZXh0UG9pbnRVcGRhdGVSZWxlYXNlZCIsIm5leHRQb2ludCIsImlzVGFyZ2V0TmVhciIsInJvdGF0ZVRvUG9zaXRpb24iLCJpc05leHRQb2ludE5lYXIiLCJpc1J1blJlbGVhc2VkIiwiaXNBdHRhY2tSZWxlYXNlZCIsImlzSGl0UmVsZWFzZWQiLCJhdHRhY2siLCJpc01vdmluZ0ZvcndhcmQiLCJpc0FjY2VsZXJhdGlvbiIsImp1bXBIZWlnaHQiLCJkeCIsImR5IiwiZHoiLCJpc0p1bXBOZWVkZWQiLCJpc0dyb3VuZGVkIiwicm90YXRpb25Ub1RhcmdldFJhZGlhbnMiLCJhdGFuMiIsInRhcmdldFF1YXRlcm5pb24iLCJRdWF0ZXJuaW9uIiwic2V0RnJvbUV1bGVyIiwic2xlcnAiLCJhYnMiLCJhdHRhY2tlciIsIkZpcmluZ1VuaXQiLCJhbmltYXRpb25OYW1lcyIsInN0YW5kIiwicnVuIiwianVtcCIsInJvdGF0ZUxlZnQiLCJyb3RhdGVSaWdodCIsInJ1bkxlZnQiLCJydW5SaWdodCIsIndhbGtCYWNrIiwic3Bhd24iLCJoaXQiLCJ0b3BSdW4iLCJib3R0b21SdW4iLCJ0b3BXYWxrQmFjayIsImJvdHRvbVdhbGtCYWNrIiwidG9wQXR0YWNrIiwiYm90dG9tQXR0YWNrIiwidG9wU3RhbmQiLCJib3R0b21TdGFuZCIsInRvcFJ1blJpZ2h0IiwidG9wUnVuTGVmdCIsInRvcEp1bXAiLCJ0b3BIaXQiLCJib3R0b21SdW5SaWdodCIsImJvdHRvbVJ1bkxlZnQiLCJib3R0b21KdW1wIiwiYm90dG9tSGl0IiwidG9wRGllIiwiYm90dG9tRGllIiwidG9wU3Bhd24iLCJib3R0b21TcGF3biIsInRvcEFuaW1hdGlvbnMiLCJib3R0b21BbmltYXRpb25zIiwidG9wQm9uZXMiLCJib3R0b21Cb25lcyIsInNwYXduVGltZW91dCIsImlzTW92aW5nUmlnaHQiLCJpc01vdmluZ0xlZnQiLCJpc01vdmluZ0JhY2t3YXJkIiwiaXNSb3RhdGVMZWZ0IiwiaXNSb3RhdGVSaWdodCIsImlzSnVtcCIsImlzSGl0IiwiaXNTcGF3biIsInBsYXlpbmdBbmltYXRpb25zIiwibGVnc1JvdGF0aW9uWSIsInNwYXduVGltZSIsIm1peGVyIiwiQW5pbWF0aW9uTWl4ZXIiLCJpbml0QW5pbWF0aW9ucyIsImlzU3Bhd25GaW5pc2hlZCIsImNvbXBsZXhBbmltYXRpb25zIiwidXBkYXRlQ29tcGxleEFuaW1hdGlvbnMiLCJhbmltYXRpb24iLCJnZXRDdXJyZW50QW5pbWF0aW9uIiwicGxheUFuaW1hdGlvbiIsImZvcmNlIiwiX2NsaXAiLCJhbmltYXRpb25OYW1lIiwic2hvdWxkVXBkYXRlIiwicGxheWluZ0FuaW1hdGlvbk5hbWUiLCJyZXNldCIsInBsYXkiLCJwbGF5aW5nQW5pbWF0aW9uIiwiZnJvbSIsImVuYWJsZWQiLCJjcm9zc0ZhZGVUbyIsImtleXMiLCJyZWR1Y2UiLCJyZXN1bHQiLCJrZXkiLCJleGNsdWRlZEJvbmVzIiwiaW5jbHVkZXMiLCJtb2RlbEFuaW1hdGlvbiIsImZpbmRNb2RlbEFuaW1hdGlvbiIsImluaXRlZEFuaW1hdGlvbiIsImNyZWF0ZUNsaXBBY3Rpb24iLCJjbGFtcEFuaW1hdGlvbiIsInNldExvb3AiLCJMb29wT25jZSIsImNsYW1wV2hlbkZpbmlzaGVkIiwiYXR0YWNrQW5pbWF0aW9uIiwic2V0RHVyYXRpb24iLCJhY3Rpb24iLCJjbGlwQWN0aW9uIiwic3RvcCIsImNsZWFyQW5pbWF0aW9uQm9uZXMiLCJib25lcyIsImdldEJvbmVOYW1lIiwiaXRlbSIsInNwbGl0IiwiaXNOb3RFeGNsdWRlZCIsInRyYWNrcyIsInRvcCIsImJvdHRvbSIsImxlZ3NSb3RhdGlvbkJvbmUiLCJnZXRDaGlsZEJ5TmFtZSIsImJsZW5kQW5pbWF0aW9ucyIsImdldEFuaW1hdGlvbk5hbWUiLCJhIiwiZnJvbUFuaW1hdGlvbiIsImZyb21BbmltYXRpb25OYW1lIiwiR2FtZU9iamVjdCIsImNvbGxpc2lvbnMiLCJNb3ZpbmdHYW1lT2JqZWN0Iiwic2hvdWxkRmlyZSIsImxhdGVzdEZpcmUiLCJnZXRVcCIsImlzRmlyZSIsImZpcmUiLCJpc0ZpcmVSZWxlYXNlZCIsImV2ZW50cyIsImV2ZW50TmFtZSIsImFyZ3MiLCJnZXRPYmplY3RCeU5hbWUiLCJhcmciLCJnZXRDaGlsZFJvdGF0aW9uIiwic2V0RnJvbU1hdHJpeFBvc2l0aW9uIiwibWF0cml4V29ybGQiLCJnZXRXb3JsZFF1YXRlcm5pb24iLCJpc1giLCJCb29sZWFuIiwiaXNZIiwiaXNaIiwiaXNDbGltYmluZyIsImlzTW92aW5nIiwibmV4dFBvc2l0aW9uIiwiZ2V0RGlyZWN0aW9uIiwidG9BcnJheSIsInIiLCJ2Iiwicm90YXRpb25BY2NlbGVyYXRpb24iLCJvbkxldmVsVXAiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0TW92aW5nQWNjZWxlcmF0aW9uIiwiaG9yaXpvbnRhbExvb2siLCJyZXNldEhvcml6b250YWxMb29rIiwiQ0FMQ19ST1RBVEVfVEhSRVNIT0xEIiwicm90YXRlT25Xb3JsZEF4aXMiLCJkZWx0YVgiLCJpbm5lcldpZHRoIiwiY3Vyc29yIiwiaW5uZXJIZWlnaHQiLCJyb3RhdGlvblkiLCJoZWFkIiwiaGVhZEZvcndhcmQiLCJnZXRDaGlsZERpcmVjdGlvbiIsImhlYWRVcCIsImdldENoaWxkUG9zaXRpb24iLCJnZXRMZXZlbCIsImxldmVsc1VwIiwiZGlzcGF0Y2hFdmVudCIsInBvdyIsImZsb29yIiwic3FydCIsImFkZEZvcndhcmQiLCJhZGRTaWRlIiwiaGl0VGltZSIsImF0dGFja0RhbWFnZVRpbWVvdXQiLCJzaG91bGRBdHRhY2siLCJsYXRlc3RBdHRhY2tUaW1lc3RhbXAiLCJsYXRlc3RIaXRUaW1lc3RhbXAiLCJoaXRSZWxlYXNlZCIsImRpZmZZIiwiaW50ZXJydXB0QnlDaGFuY2UiLCJpbnRlcnJ1cHRCeUxldmVsIiwic2hvdWxkQmVJbnRlcnJ1cHRlZCIsImtpbGxpbmdVbml0IiwiS0VZUyIsIk1PVVNFX0xFRlQiLCJNT1VTRV9SSUdIVCIsIlNQQUNFIiwiRU5URVIiLCJFU0MiLCJDIiwiVyIsIkEiLCJTIiwiRCIsIlgiLCJaIiwiUSIsIkUiLCJSIiwiRiIsIlYiLCJBUlJPV19MRUZUIiwiQVJST1dfUklHSFQiLCJBUlJPV19VUCIsIkFSUk9XX0RPV04iLCJJbnB1dCIsIm1vdXNlIiwiYWRkRXZlbnRMaXN0ZW5lcnMiLCJkb2N1bWVudCIsIndoaWNoIiwidGltZW91dCIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsImN1cnNvclgiLCJjdXJzb3JZIiwidW5kZWZpbmVkIiwiY2xlYXJUaW1lb3V0IiwiRXZlbnQiLCJvbkFjdGlvbiIsIm9uRXhpdCIsIm9uU3dpdGNoQ2FtZXJhIiwib25ab29tIiwiSW50ZXJ2YWxzIiwidGltZVBhc3NlZCIsImxhc3RGcmFtZSIsImludGVydmFsSW5kZXgiLCJub3ciLCJpc1BhdXNlIiwiY2FsbGVkQXQiLCJpbnRlcnZhbCIsImxvb3BzIiwiY2xlYXJJbnRlcnZhbCIsImltbWVkaWF0ZWx5IiwiaW50ZXJ2YWxJZHgiLCJBYnN0cmFjdExvY2F0aW9uIiwiYW1iaWVudExpZ2h0IiwiQW1iaWVudExpZ2h0IiwiY2FzdFNoYWRvdyIsImxpZ2h0IiwiRGlyZWN0aW9uYWxMaWdodCIsImludGVuc2l0eSIsInNoYWRvdyIsImJpYXMiLCJzaGFkb3dTaXplIiwicmlnaHQiLCJtYXBTaXplIiwibmVhciIsInZpc2libGUiLCJtYXRlcmlhbEFycmF5IiwidXJsIiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJUZXh0dXJlTG9hZGVyIiwibG9hZCIsInNpZGUiLCJCYWNrU2lkZSIsImZvZyIsInNreUdlb21ldHJ5IiwiQ3ViZUdlb21ldHJ5Iiwic2t5TWF0ZXJpYWwiLCJNZXNoRmFjZU1hdGVyaWFsIiwiTWVzaCIsImJ1aWxkQXJlYSIsImFyZWFJZCIsIkFyZWFTaXplcyIsIndheXBvaW50WFRvV29ybGRYIiwid2F5cG9pbnRZVG9Xb3JsZFoiLCJ3b3JsZFhUb1dheXBvaW50WCIsImdyYXBoWCIsIm1heCIsIndvcmxkWlRvV2F5cG9pbnRZIiwiZ3JhcGhZIiwiYXJlYSIsIkZMT09SXzAiLCJGTE9PUl8xIiwiRkxPT1JfMiIsIkFyZWFzIiwiaW5jbHVkZXNQb3NpdGlvbiIsImdldFdvcmxkV2F5cG9pbnRCeVhZIiwiZ2V0V2F5cG9pbnRQb3J0YWxzIiwidG8iLCJFbGV2YXRvciIsImN1cnJlbnRGbG9vciIsInN0YW5kVGltZSIsInN0YW5kQXQiLCJpc1JlbGVhc2VkIiwiZ2V0Rmxvb3IiLCJnZXRDYXJyeWluZ1Bvc2l0aW9uIiwiY2FycnlpbmdVbml0cyIsImlzQ2FycnlpbmciLCJ0aGlzQWNjZWxlcmF0aW9uIiwiY3JlYXRlRW52aXJvbm1lbnQiLCJ0cmVlcyIsImhvdXNlcyIsImFkZENvbGxpZGVyRnVuY3Rpb24iLCJvbkxvYWQiLCJwaXZvdCIsIm1hdHJpeEF1dG9VcGRhdGUiLCJpc0Vudmlyb25tZW50TG9hZGVkIiwiaXNUcmVlTG9hZGVkIiwiaXNIb3VzZUxvYWRlZCIsImNoZWNrSXNBbGxMb2FkZWQiLCJ1cGRhdGVNYXRyaXgiLCJyZWNlaXZlU2hhZG93IiwibG9hZGVkTW9kZWwiLCJyeCIsInJ5IiwicnoiLCJ1bml0UG9zaXRpb24iLCJMb2NhdGlvbiIsInNoYWRvd0xpZ2h0UG9zaXRpb24iLCJzZXRMb2FkaW5nIiwic2V0UGF1c2UiLCJQSSIsIm5vdGlmeSIsInN0YXJ0TG9jYXRpb24iLCJjcmVhdGVBbWJpZW50TGlnaHQiLCJzaGFkb3dMaWdodCIsImNyZWF0ZVNoYWRvd0xpZ2h0IiwiZWxldmF0b3IiLCJjb2xvciIsIkZvZyIsImNyZWF0ZUxvY2F0aW9uQ29sbGlkZXJzIiwicGFydGljbGVzIiwiY3JlYXRlRWZmZWN0IiwiZWZmZWN0IiwiYXR0YWNoVG8iLCJjcmVhdGVQbGF5ZXIiLCJvbkNyZWF0ZSIsInVwZGF0ZVBsYXllclBhcmFtcyIsIm9uRGllIiwib25LaWxsIiwiYWRkRXhwZXJpZW5jZSIsImFkZE1vbmV5Iiwib25EYW1hZ2VUYWtlbiIsIm9uTG9jYXRpb25VcCIsImNyZWF0ZUludGVyYWN0aXZlR2FtZU9iamVjdHMiLCJjbGVhclNjZW5lIiwicmVtb3ZlQWxsRXhjZXB0UGxheWVyIiwiY3JlYXRlSGVhbEl0ZW0iLCJpdGVtSGVhbFBvc2l0aW9uIiwiY3JlYXRlSXRlbSIsImdldE1heEhQIiwiZ2V0SFAiLCJhZGRIUCIsImdldEFJUGFyYW1zIiwiY3JlYXRlQUkiLCJnZXRHb2F0c1BhcmFtcyIsImdldEZyaWVuZGx5UGFyYW1zIiwiaXNCZXR3ZWVuIiwiYWJzWCIsImFic1oiLCJhcmVhcyIsInZhbHVlcyIsImdlbmVyYXRlV2F5cG9pbnRzIiwiQXJyYXkiLCJmaWxsIiwibnVsbDEiLCJudWxsMiIsImdldFdheXBvaW50cyIsImNoZWNrV2F5Rm9yV2F5cG9pbnQiLCJjaGVja05lYXIiLCJyYW5nZSIsImRpYWdvbmFsIiwiTW9kZWxzIiwibWF0ZXJpYWxQYXJhbXMiLCJpbWFnZSIsInRleHR1cmUiLCJ3cmFwUyIsIlJlcGVhdFdyYXBwaW5nIiwid3JhcFQiLCJyZXBlYXQiLCJyZXBlYXRYIiwicmVwZWF0WSIsIkNvbG9yIiwiZW1pc3NpdmVJbnRlbnNpdHkiLCJlbWlzc2l2ZU1hcCIsImN1YmUiLCJNZXNoTGFtYmVydE1hdGVyaWFsIiwiaXNHTFRGIiwibG9hZGVyIiwiR0xURkxvYWRlciIsIlBhcnRpY2xlcyIsInAiLCJjcmVhdGVQYXJ0aWNsZXMiLCJwYXJ0aWNsZUNvdW50IiwiYmxlbmRpbmciLCJOb3JtYWxCbGVuZGluZyIsImdldFBhcnRpY2xlUG9zaXRpb24iLCJnZXRSYW5kb21Qb3NpdGlvbiIsIm5ld1Bvc2l0aW9uIiwibGlmZVRpbWUiLCJwYXJ0aWNsZU5hbWUiLCJnbHRmIiwicGFydGljbGVTeXN0ZW0iLCJzaXplIiwiQWRkaXRpdmVCbGVuZGluZyIsImRlcHRoVGVzdCIsImdldFBhcnRpY2xlVmVsb2NpdHkiLCJHZW9tZXRyeSIsIlBvaW50Q2xvdWRNYXRlcmlhbCIsInBhcnRpY2xlIiwidmVsb2NpdHkiLCJ2ZXJ0aWNlcyIsIlBvaW50Q2xvdWQiLCJwYXJ0aWNsZVBvc2l0aW9uIiwidmVydGljZXNOZWVkVXBkYXRlIiwiZ2V0QXJlYUJ5UG9zaXRpb24iLCJmcm9tWCIsImZyb21ZIiwiYXJlYVRvIiwidG9YIiwidG9ZIiwicG9ydGFsIiwic3RhcnQiLCJnZXRGcmVlR3JhcGhQb2ludCIsImdyYXBoIiwiZW5kIiwiQVN0YXIiLCJhc3RhciIsInNlYXJjaCIsImhldXJpc3RpYyIsImhldXJpc3RpY3MiLCJuZXh0R3JhcGhQb2ludCIsIm5leHRXb3JsZFBvaW50IiwiZ3JpZCIsImdldFdlaWdodCIsIndlaWdodCIsImdldE5lYXJGcmVlUG9pbnQiLCJnZXRBcmVhcyIsIkdyYXBoIiwiU2NlbmUiLCJjbG9jayIsIkNsb2NrIiwiUGF0aEZpbmRlciIsIlVuaXRzIiwiem9vbSIsImFkZFkiLCJzd2l0Y2hDYW1lcmEiLCJjb25uZWN0aW9uSG9zdG5hbWUiLCJob3N0bmFtZSIsImlzU1NMIiwic2V0SW50ZXJ2YWwiLCJzZXRGcHMiLCJmcHMiLCJ0YXJnZXRGcHMiLCJhbmltYXRlIiwicmVtb3ZlQWxsIiwiYWZ0ZXJDbGVhciIsIkRhdGUiLCJnZXREZWx0YVRpbWUiLCJyZW5kZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0ZXh0IiwiZGVmYXVsdFBhcmFtcyIsIm9uRGFtYWdlRGVhbCIsImRhbWFnZWRVbml0IiwibG9hZEVmZmVjdCIsImtpbGxlciIsIm5ldHdvcmtDb25uZWN0aW9uIiwiYWkiLCJuZWFyRW5lbXlVbml0cyIsImdldEZyYWN0aW9uIiwiZGVmaW5pdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZpbmUiLCJwYXRoVG8iLCJub2RlIiwiY3VyciIsInBhdGgiLCJ1bnNoaWZ0IiwiZ2V0SGVhcCIsIkJpbmFyeUhlYXAiLCJmIiwib3B0aW9ucyIsImNsZWFuRGlydHkiLCJtYW5oYXR0YW4iLCJjbG9zZXN0Iiwib3BlbkhlYXAiLCJjbG9zZXN0Tm9kZSIsImgiLCJtYXJrRGlydHkiLCJjdXJyZW50Tm9kZSIsInBvcCIsImNsb3NlZCIsIm5laWdoYm9ycyIsImlsIiwibmVpZ2hib3IiLCJpc1dhbGwiLCJnU2NvcmUiLCJnIiwiZ2V0Q29zdCIsImJlZW5WaXNpdGVkIiwidmlzaXRlZCIsInJlc2NvcmVFbGVtZW50IiwicG9zMCIsInBvczEiLCJkMSIsImQyIiwiRDIiLCJjbGVhbk5vZGUiLCJncmlkSW4iLCJub2RlcyIsInJvdyIsIkdyaWROb2RlIiwiaW5pdCIsImRpcnR5Tm9kZXMiLCJyZXQiLCJncmFwaFN0cmluZyIsInJvd0RlYnVnIiwiam9pbiIsImZyb21OZWlnaGJvciIsInNjb3JlRnVuY3Rpb24iLCJjb250ZW50IiwiZWxlbWVudCIsInNpbmtEb3duIiwiYnViYmxlVXAiLCJuIiwicGFyZW50TiIsImVsZW1TY29yZSIsImNoaWxkMk4iLCJjaGlsZDFOIiwic3dhcCIsImNoaWxkMVNjb3JlIiwiY2hpbGQxIiwiY2hpbGQyIiwiY2hpbGQyU2NvcmUiLCJTZXJ2ZXIiLCJnbG9iYWwiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJPYmozRCIsInByb3BzIiwiV2ViR0xSZW5kZXJlciIsInNldFNpemUiLCJzaGFkb3dNYXAiLCJDYWNoZSIsIlBDRlNvZnRTaGFkb3dNYXAiLCJib2R5IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImdldEVsZW1lbnRCeUlkIiwiTW9ja0dVSSIsImlzU2VydmVyIiwic2V0UmVzdGFydEJ1dHRvblZpc2libGUiLCJyZXN0YXJ0R2FtZSIsImNsZWFySHBCYXJzIiwiTW9ja1JlbmRlcmVyIiwiV2ViU29ja2V0U2VydmVyIiwid3MiLCJTb2NrZXRTZXJ2ZXIiLCJjcmVhdGVXZWJTZXJ2ZXIiLCJjcmVhdGVTb2NrZXRTZXJ2ZXIiLCJzYXZlVXNlckRhdGEiLCJsb2FkVXNlckRhdGEiLCJzdGFydFNvY2tldFNlcnZlciIsImdldENvbm5lY3Rpb25JZCIsInNlbmRHYW1lT2JqZWN0c1RvUGxheWVycyIsImlzUHJvZHVjdGlvbiIsInByb2Nlc3MiLCJjb25maWciLCJzc2wiLCJzc2xLZXkiLCJfX2Rpcm5hbWUiLCJzc2xDZXJ0aWZpY2F0ZSIsInNlc3Npb25zUGF0aCIsImZzIiwiZGIiLCJzZXF1ZW5jZUlkIiwiaG9zdElkIiwiY29ubmVjdGlvbnMiLCJwbGF5ZXJzIiwic29ja2V0U2VydmVyIiwicHJvY2Vzc1JlcXVlc3QiLCJyZXEiLCJyZXMiLCJ3cml0ZUhlYWQiLCJzc2xQYXJhbXMiLCJjZXJ0IiwicmVxdWlyZSIsImNyZWF0ZVNlcnZlciIsImxpc3RlbiIsInNlcnZlciIsIndlYlNvY2tldFNlcnZlciIsInRva2VuUGF0aCIsIl9pZCIsInBsYXllckNvbm5lY3Rpb25JZCIsInZlcnNpb24iLCJfbWV0YSIsImdldENvbm5lY3Rpb25Ub2tlbiIsImNvbm5lY3Rpb25QbGF5ZXIiLCJvbiIsIm9uU29ja2V0Q2xvc2UiLCJvblNvY2tldE1lc3NhZ2UiLCJtZXNzYWdlIiwic2VuZFVzZXJEYXRhIiwidXBkYXRlUGxheWVyRGF0YSIsInNjZW5lTG9jYXRpb24iLCJzY2VuZUNvbGxpZGVycyIsInNjZW5lQXJlYXMiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFD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QTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQU87QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqTFA7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7OztBQUcwQjs7Ozs7Ozs7Ozs7OztBQ3JG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O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFtQixtQkFBbUI7QUFDMUQsb0JBQW9CLG1CQUFtQixtQkFBbUI7QUFDMUQsb0JBQW9CLG1CQUFtQixxQkFBcUI7QUFDNUQsc0JBQXNCLHFCQUFxQixxQkFBcUI7O0FBRWhFOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGlCQUFpQixnQkFBZ0I7QUFDakMsaUJBQWlCLGdCQUFnQjs7QUFFakM7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxlQUFlLGNBQWMsY0FBYztBQUMzQyxlQUFlLGNBQWMsY0FBYztBQUMzQyxlQUFlLGNBQWMsZUFBZTtBQUM1QyxlQUFlLGNBQWMsZUFBZTs7QUFFNUM7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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a0JBQWtCLFFBQVE7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsa0JBQWtCLFFBQVE7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOzs7QUFHa0I7Ozs7Ozs7Ozs7Ozs7QUN6NUJuQjtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsa0NBQWtDLDhDQUFLOztBQUV2QyxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsQ0FBQzs7O0FBR3FCOzs7Ozs7Ozs7Ozs7O0FDM25CdEI7QUFBQTtBQUFBO0FBQUE7QUFBa0M7QUFDVzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix5REFBVTs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsOENBQUs7O0FBRXpCLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFF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UTtBQUNyQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FB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O0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFDQUFxQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzNEJBO0FBQ0E7QUFDQTs7QUFFQUMsTUFB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Qzs7Ozs7Ozs7Ozs7QUNBQSxpQyIsImZpbGUiOiJzZXJ2ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2luZGV4LmpzXCIpO1xuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0b0JpbmRNZXRob2RzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9uTmFtZXMgPSBbXTtcbiAgICAgICAgbGV0IG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcblxuICAgICAgICB3aGlsZSAob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqID09PSBPYmplY3QucHJvdG90eXBlIHx8IG9iaiA9PT0gQXV0b0JpbmRNZXRob2RzLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWVzID0gZnVuY3Rpb25OYW1lcy5jb25jYXQoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5maWx0ZXIobmFtZSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgIT09ICdjb25zdHJ1Y3RvcidcbiAgICAgICAgICAgICAgICAgICAgJiYgZnVuY3Rpb25OYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMVxuICAgICAgICAgICAgICAgICAgICAmJiB0eXBlb2YgdGhpc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGZ1bmN0aW9uTmFtZSBvZiBmdW5jdGlvbk5hbWVzKSB7XG4gICAgICAgICAgICB0aGlzW2Z1bmN0aW9uTmFtZV0gPSB0aGlzW2Z1bmN0aW9uTmFtZV0uYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuIiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYSBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzY2VuZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gdGhpcy5nZXRXaWR0aCgpIC8gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNDUsIHJhdGlvLCAxLCAxMDApO1xuICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXQoNSwgMywgMTUpO1xuICAgICAgICB0aGlzLmRlbHRhWSA9IDEwO1xuICAgICAgICB0aGlzLnJvdGF0ZVkgPSAwLjI1O1xuICAgICAgICB0aGlzLmRlZmF1bHREaXN0YW5jZSA9IDEwO1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gdGhpcy5kZWZhdWx0RGlzdGFuY2U7XG4gICAgICAgIHRoaXMucmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuICAgIH1cblxuICAgIHVwZGF0ZShnYW1lVGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgIGNvbnN0IHsgc2NlbmU6IHsgaW5wdXQgfSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5zY2VuZS5nZXRQbGF5ZXIoKTtcblxuICAgICAgICBpZiAoIXBsYXllcikgcmV0dXJuO1xuICAgIFxuICAgICAgICAvLyBFbmFibGVkIGlmIFwiRlwiIGlzIHByZXNzZWRcbiAgICAgICAgaWYgKGlucHV0Lmxvb2suY2luZW1hdGljKSB7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXQoLTQwLCAxNSwgMTApO1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEubG9va0F0KG5ldyBUSFJFRS5WZWN0b3IzKC01MCwgMCwgMCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGNvbnN0IHJvdGF0ZVkgPSB0aGlzLnJvdGF0ZVkgKyAoaW5wdXQubG9vay5zZW5zaXRpdml0eSAqIGlucHV0Lmxvb2sudmVydGljYWwgLyAyMDAwKTtcblxuICAgICAgICBpZiAocm90YXRlWSA+IC0wLjc1ICYmIHJvdGF0ZVkgPCAxLjI1KSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZVkgPSByb3RhdGVZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0LmlzVGhpcmRQZXJzb24pIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGhpcmRQZXJzb24ocGxheWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmNvcHkoXG4gICAgICAgICAgICAgICAgcGxheWVyLnBvc2l0aW9uLmNsb25lKClcbiAgICAgICAgICAgICAgICAgICAgLmFkZChuZXcgVEhSRUUuVmVjdG9yMyg3LjUsIHRoaXMuZGVsdGFZLCAwKSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLmxvb2tBdChwbGF5ZXIucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkWSh5KSB7XG4gICAgICAgIGlmICh0aGlzLmRlbHRhWSArIHkgPiAxICYmIHRoaXMuZGVsdGFZICsgeSA8IDI1KSB7XG4gICAgICAgICAgICB0aGlzLmRlbHRhWSArPSB5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5zY2VuZS5yZW5kZXJlci5yZW5kZXJlcjtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyLmdldENvbnRleHQoKS5jYW52YXMud2lkdGg7XG4gICAgfVxuXG4gICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuc2NlbmUucmVuZGVyZXIucmVuZGVyZXI7XG4gICAgICAgIHJldHVybiByZW5kZXJlci5nZXRDb250ZXh0KCkuY2FudmFzLmhlaWdodDtcbiAgICB9XG5cbiAgICB1cGRhdGVUaGlyZFBlcnNvbihwbGF5ZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY2VuZTogeyBzY2VuZTogeyBjaGlsZHJlbiB9IH0sIGRlbHRhWSB9ID0gdGhpcyxcbiAgICAgICAgICAgIHBsYXllckhlYWRQb3NpdGlvbiA9IHBsYXllci5wb3NpdGlvbi5jbG9uZSgpLmFkZChuZXcgVEhSRUUuVmVjdG9yMygwLCAxLjUsIDApKSxcbiAgICAgICAgICAgIG9yaWdpbiA9IHBsYXllckhlYWRQb3NpdGlvbixcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gdGhpcy5jYW1lcmEucG9zaXRpb24sXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIGNvbnN0IGdldENoaWxkcmVuRmxhdCA9IG9iamVjdHMgPT4gW10uY29uY2F0KC4uLm9iamVjdHMubWFwKFxuICAgICAgICAgICAgb2JqID0+IG9iai5jaGlsZHJlblxuICAgICAgICAgICAgICAgID8gW29iaiwgLi4uZ2V0Q2hpbGRyZW5GbGF0KG9iai5jaGlsZHJlbildXG4gICAgICAgICAgICAgICAgOiBbb2JqXVxuICAgICAgICApKTtcblxuICAgICAgICBjb25zdCBlbnZpcm9ubWVudCA9IFtjaGlsZHJlbi5maW5kKGMgPT4gYy5uYW1lID09PSAnTEVWRUxfRU5WSVJPTk1FTlQnKV07XG4gICAgICAgIGNvbnN0IGZsYXRDaGlsZHJlbk1lc2hlcyA9IGdldENoaWxkcmVuRmxhdChlbnZpcm9ubWVudCkuZmlsdGVyKG9iaiA9PiBvYmoudHlwZSA9PT0gJ01lc2gnKTtcblxuICAgICAgICB0aGlzLnJheWNhc3Rlci5zZXQob3JpZ2luLCBkaXJlY3Rpb24uc3ViVmVjdG9ycyhkZXN0aW5hdGlvbiwgb3JpZ2luKS5ub3JtYWxpemUoKSk7XG4gICAgICAgIHRoaXMucmF5Y2FzdGVyLmZhciA9IGRlbHRhWSAqIDEuNTtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0cyA9IHRoaXMucmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHMoZmxhdENoaWxkcmVuTWVzaGVzKTtcblxuICAgICAgICBsZXQgZGlzdGFuY2UgPSBNYXRoLm1pbihkZWx0YVksIC4uLmludGVyc2VjdHMubWFwKGkgPT4gaS5kaXN0YW5jZSAtIHRoaXMuZGlzdGFuY2UgKiAwLjUpKTtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSArPSAoZGlzdGFuY2UgLSB0aGlzLmRpc3RhbmNlKSAvIDI7XG5cbiAgICAgICAgY29uc3QgcGxheWVyRm9yd2FyZCA9IHBsYXllci5nZXRGb3J3YXJkKCkubXVsdGlwbHlTY2FsYXIodGhpcy5zY2VuZS5pbnB1dC5sb29rLmJhY2sgPyAxIDogLTEpO1xuXG4gICAgICAgIHBsYXllckZvcndhcmQueSA9IHRoaXMucm90YXRlWTtcbiAgICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uY29weShwbGF5ZXJIZWFkUG9zaXRpb24uY2xvbmUoKS5hZGQocGxheWVyRm9yd2FyZCkpO1xuXG4gICAgICAgIHRoaXMuY2FtZXJhLmxvb2tBdChwbGF5ZXJIZWFkUG9zaXRpb24pO1xuXG4gICAgICAgIGNvbnN0IGNhbWVyYUZvcndhcmQgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAtMSk7XG4gICAgICAgIGNhbWVyYUZvcndhcmQuYXBwbHlRdWF0ZXJuaW9uKHRoaXMuY2FtZXJhLnF1YXRlcm5pb24pO1xuXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnN1YihjYW1lcmFGb3J3YXJkLm11bHRpcGx5U2NhbGFyKHRoaXMuZGlzdGFuY2UpKTtcbiAgICB9XG5cbiAgICB0b1NjcmVlblBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoSGFsZiA9IDAuNSAqIHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0SGFsZiA9IDAuNSAqIHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIGNvbnN0IGNvcGllZFByb2plY3RWZWN0b3IgPSBwb3NpdGlvbi5jbG9uZSgpLnByb2plY3QodGhpcy5jYW1lcmEpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBNYXRoLnJvdW5kKChjb3BpZWRQcm9qZWN0VmVjdG9yLnggKyAxKSAqIHdpZHRoSGFsZiksXG4gICAgICAgICAgICB5OiBNYXRoLnJvdW5kKCgtY29waWVkUHJvamVjdFZlY3Rvci55ICsgMSkgKiBoZWlnaHRIYWxmKSxcbiAgICAgICAgICAgIHo6IGNvcGllZFByb2plY3RWZWN0b3IuelxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xsaWRlcnMgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5jb2xsaWRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0SWQgPSAwO1xuICAgIH1cblxuICAgIGNoZWNrV2F5KHBvc2l0aW9uLCBnYW1lT2JqZWN0KSB7XG4gICAgICAgIGZvcihsZXQgY29sbGlkZXIgb2YgdGhpcy5jb2xsaWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChjb2xsaWRlci5mbihwb3NpdGlvbiwgZ2FtZU9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXNldENvbGxpZGVycygpIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlcnMgPSBbXTtcbiAgICB9XG5cbiAgICByZW1vdmVDb2xsaWRlcihpZCkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmNvbGxpZGVycy5maW5kSW5kZXgoYyA9PiBjLmlkID09PSBpZCk7XG5cbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxpZGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZENvbGxpZGVyRnVuY3Rpb24oZm4pIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlcnMucHVzaCh7XG4gICAgICAgICAgICBpZDogdGhpcy5uZXh0SWQrKyxcbiAgICAgICAgICAgIGZuLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNjZW5lLnBhdGhGaW5kZXIucmVidWlsZEFyZWFzKCk7XG4gICAgfVxufSIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuaW1wb3J0IHsgUGxheWVyLCBBSSB9IGZyb20gJy4vR2FtZU9iamVjdHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25uZWN0aW9uIGV4dGVuZHMgQXV0b0JpbmRNZXRob2RzIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaXBcblx0ICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBwb3J0XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTZWN1cmVcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNjZW5lLCBpcCA9ICdsb2NhbGhvc3QnLCBwb3J0ID0gJzEzMzcnLCBpc1NlY3VyZSA9IHRydWUpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcblx0XHR0aGlzLm1ldGEgPSB7fTtcblx0XHR0aGlzLm5ldHdvcmtQbGF5ZXJzID0ge307XG5cdFx0dGhpcy5uZXR3b3JrQUlzID0ge307XG5cblx0XHRjb25zdCBXZWJTb2NrZXQgPSB3aW5kb3cuV2ViU29ja2V0IHx8IHdpbmRvdy5Nb3pXZWJTb2NrZXQ7XG5cblx0XHR0aGlzLmNvbm5lY3Rpb24gPSBuZXcgV2ViU29ja2V0KGAke2lzU2VjdXJlID8gJ3dzcycgOiAnd3MnfTovLyR7aXB9OiR7cG9ydH1gKTtcblx0XHR0aGlzLmNvbm5lY3Rpb24ub25vcGVuID0gKCkgPT4gY29uc29sZS5sb2coJ29wZW4gY29ubmVjdGlvbicpO1xuXHRcdHRoaXMuY29ubmVjdGlvbi5vbmVycm9yID0gKGVycm9yKSA9PiBjb25zb2xlLmxvZygnZXJyb3IgY29ubmVjdGlvbicsIGVycm9yKTtcblx0XHR0aGlzLmNvbm5lY3Rpb24ub25tZXNzYWdlID0gdGhpcy5vbk1lc3NhZ2U7XG5cdH1cblxuXHR1cGRhdGUodGltZSwgZGVsdGFUaW1lKSB7XG5cdFx0dGhpcy5zZW5kR2FtZU9iamVjdHMoKTtcblx0fVxuXG5cdG9uTWVzc2FnZSh7IGRhdGEgfSkge1xuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhXG5cdFx0ICogQHBhcmFtIHthbnl9IHJlc3BvbnNlXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VUeXBlXG5cdFx0ICovXG5cdFx0Y29uc3QgeyBtZXRhLCBkYXRhOiByZXNwb25zZSwgbWVzc2FnZVR5cGUgfSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cblx0XHRpZiAobWV0YS5yb2xlICYmIHRoaXMubWV0YS5yb2xlICE9PSBtZXRhLnJvbGUpIHtcblx0XHRcdHRoaXMuc2NlbmUudWkuc2V0Q29ubmVjdGlvblJvbGUobWV0YS5yb2xlKTtcblxuXHRcdFx0aWYgKHRoaXMubWV0YS5yb2xlICYmIG1ldGEucm9sZSA9PT0gJ2hvc3QnKSB7XG5cdFx0XHRcdHRoaXMuaG9zdFVuaXRzRnJvbU5ldHdvcmsoKTtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMubWV0YS5kZWJ1Zykge1xuXHRcdFx0XHR0aGlzLmNsZWFyTG9jYWxHYW1lT2JqZWN0cygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMubWV0YSA9IG1ldGE7XG5cblx0XHR0cnkge1xuXHRcdFx0c3dpdGNoIChtZXNzYWdlVHlwZSkge1xuXHRcdFx0XHRjYXNlICdoYW5kc2hha2UnOiB7XG5cdFx0XHRcdFx0dGhpcy5wcm9jZXNzSGFuZHNoYWtlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAncmVzdGFydFNlcnZlcic6IHtcblx0XHRcdFx0XHR3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAnc2V0VXNlclBsYXllcic6IHtcblx0XHRcdFx0XHRjb25zdCBwbGF5ZXIgPSB0aGlzLnNjZW5lLmdldFBsYXllcigpO1xuXG5cdFx0XHRcdFx0aWYgKHBsYXllcikge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRQbGF5ZXJQYXJhbXMocGxheWVyLCByZXNwb25zZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuc2NlbmUudW5pdHMuc2V0RGVmYXVsdFBsYXllclBhcmFtcyhyZXNwb25zZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ3VwZGF0ZUdhbWVPYmplY3RzJzoge1xuXHRcdFx0XHRcdHRoaXMudXBkYXRlR2FtZU9iamVjdHMocmVzcG9uc2UpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6IHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZURpc2Nvbm5lY3RlZFBsYXllcihyZXNwb25zZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBlcnJvcicsIGUpO1xuXHRcdH1cblx0fVxuXG5cdHRha2VIb3N0KCkge1xuXHRcdHRoaXMuc2VuZCgndGFrZUhvc3QnKTtcblx0fVxuXG5cdHJlc3RhcnRTZXJ2ZXIoKSB7XG5cdFx0dGhpcy5zZW5kKCdyZXN0YXJ0U2VydmVyJyk7XG5cdH1cblxuXHQvLyBUaGVyZSBpcyByYWNlIGNvbmRpdGlvbiBiZXR3ZWVuXG5cdC8vIGNsZWFyTG9jYWxHYW1lT2JqZWN0cyBhbmQgTG9jYXRpb24uY3JlYXRlSW50ZXJhY3RpdmVHYW1lT2JqZWN0c1xuXHRjbGVhckxvY2FsR2FtZU9iamVjdHMoKSB7XG5cdFx0Y29uc3QgZ2FtZU9iamVjdHNTZXJ2aWNlID0gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2U7XG5cdFx0Y29uc3QgcGxheWVyID0gdGhpcy5zY2VuZS5nZXRQbGF5ZXIoKTtcblxuXHRcdC8vIENsZWFyIGxvY2FsIGdhbWVPYmplY3RzIHRvIHJlcGxhY2UgdGhlbSBieSBuZXR3b3JrIHVuaXRzIChleGNlcHQgcGxheWVyKVxuXHRcdGdhbWVPYmplY3RzU2VydmljZS5nZXRVbml0cygpLmZvckVhY2goKHVuaXQpID0+IHtcblx0XHRcdGlmICghdW5pdC5wYXJhbXMuZnJvbU5ldHdvcmsgJiYgdW5pdCAhPT0gcGxheWVyKSB7XG5cdFx0XHRcdGdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdCh1bml0KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHNlbmQobWVzc2FnZVR5cGUsIGRhdGEpIHtcblx0XHRjb25zdCB7IHVzZXJOYW1lLCBwYXNzd29yZCB9ID0gdGhpcy5zY2VuZS51c2VyO1xuXG5cdFx0Y29uc3QgbWV0YSA9IHtcblx0XHRcdHRva2VuOiB0aGlzLmdldEhhc2godXNlck5hbWUgKyBwYXNzd29yZCksXG5cdFx0fTtcblxuXHRcdHRoaXMuY29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KHsgbWVzc2FnZVR5cGUsIG1ldGEsIGRhdGEgfSkpXG5cdH1cblxuXHRwcm9jZXNzSGFuZHNoYWtlKCkge1xuXHRcdHRoaXMuc2VuZCgnbG9hZEN1cnJlbnRVc2VyJyk7XG5cdH1cblxuXHR1cGRhdGVHYW1lT2JqZWN0cyhnYW1lT2JqZWN0cykge1xuXHRcdGdhbWVPYmplY3RzLmZvckVhY2goKGdhbWVPYmplY3QpID0+IHtcblx0XHRcdHN3aXRjaCAoZ2FtZU9iamVjdC50eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ3BsYXllcic6IHtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZU5ldHdvcmtQbGF5ZXIoZ2FtZU9iamVjdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAnYWknOiB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGVOZXR3b3JrQUkoZ2FtZU9iamVjdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHJlbW92ZURpc2Nvbm5lY3RlZFBsYXllcih7IGNvbm5lY3Rpb25JZCB9KSB7XG5cdFx0Y29uc3QgZ2FtZU9iamVjdHNTZXJ2aWNlID0gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2U7XG5cdFx0Y29uc3QgZGlzY29ubmVjdGVkUGxheWVyID0gZ2FtZU9iamVjdHNTZXJ2aWNlLmdldFVuaXRzKCkuZmluZCh1bml0ID0+XG5cdFx0XHR1bml0IGluc3RhbmNlb2YgUGxheWVyXG5cdFx0XHQmJiB1bml0LnBhcmFtcy5jb25uZWN0aW9uSWQgPT09IGNvbm5lY3Rpb25JZFxuXHRcdCk7XG5cblx0XHRjb25zb2xlLmxvZygnUGxheWVyIGRpc2Nvbm5lY3RlZCcsIGNvbm5lY3Rpb25JZCk7XG5cblx0XHRpZiAoZGlzY29ubmVjdGVkUGxheWVyKSB7XG5cdFx0XHRkaXNjb25uZWN0ZWRQbGF5ZXIuZGllKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGdldEhhc2goc3RyKSB7XG5cdFx0ZnVuY3Rpb24gaGFzaDMyKHN0cikge1xuXHRcdFx0bGV0IGk7XG5cdFx0XHRsZXQgbDtcblx0XHRcdGxldCBodmFsID0gMHg4MTFjOWRjNTtcblxuXHRcdFx0Zm9yIChpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aHZhbCBePSBzdHIuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0aHZhbCArPSAoaHZhbCA8PCAxKSArIChodmFsIDw8IDQpICsgKGh2YWwgPDwgNykgKyAoaHZhbCA8PCA4KSArIChodmFsIDw8IDI0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIChcIjAwMDAwMDBcIiArIChodmFsID4+PiAwKS50b1N0cmluZygxNikpLnN1YnN0cigtOCk7XG5cdFx0fVxuXG5cdFx0bGV0IGgxID0gaGFzaDMyKHN0cik7XG5cdFx0cmV0dXJuIGgxICsgaGFzaDMyKGgxICsgc3RyKTtcblx0fVxuXG5cdGhvc3RVbml0c0Zyb21OZXR3b3JrKCkge1xuXHRcdHRoaXMuc2NlbmUudW5pdHNcblx0XHRcdC5nZXRBbGl2ZVVuaXRzKClcblx0XHRcdC5mb3JFYWNoKCh1bml0KSA9PiB7XG5cdFx0XHRcdGlmICh1bml0LnBhcmFtcy5mcm9tTmV0d29yaykge1xuXHRcdFx0XHRcdHVuaXQucGFyYW1zLmZyb21OZXR3b3JrID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9XG5cblx0dXBkYXRlTmV0d29ya1BsYXllcihwbGF5ZXJEYXRhKSB7XG5cdFx0Y29uc3QgeyBsb2NhdGlvbk5hbWUsIHBvc2l0aW9uLCByb3RhdGlvbiwgYW5pbWF0aW9uU3RhdGUsIHBhcmFtcyB9ID0gcGxheWVyRGF0YTtcblx0XHRjb25zdCB7IHBhcmFtczogeyB1bml0TmV0d29ya0lkIH0gfSA9IHBsYXllckRhdGE7XG5cblx0XHRpZiAodW5pdE5ldHdvcmtJZCA9PT0gdGhpcy5tZXRhLnVuaXROZXR3b3JrSWQgJiYgIXRoaXMubWV0YS5kZWJ1Zykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChsb2NhdGlvbk5hbWUgIT09IHRoaXMuc2NlbmUubG9jYXRpb24uZ2V0TG9jYXRpb25OYW1lKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSBQbGF5ZXIgfCBzdHJpbmdcblx0XHQgKi9cblx0XHRsZXQgbmV0d29ya1BsYXllciA9IHRoaXMubmV0d29ya1BsYXllcnNbdW5pdE5ldHdvcmtJZF07XG5cblx0XHRpZiAoIW5ldHdvcmtQbGF5ZXIpIHtcblx0XHRcdHRoaXMubmV0d29ya1BsYXllcnNbdW5pdE5ldHdvcmtJZF0gPSAnbG9hZGluZyc7XG5cblx0XHRcdHRoaXMuc2NlbmUudW5pdHMuY3JlYXRlTmV0d29ya1BsYXllcihcblx0XHRcdFx0cGxheWVyRGF0YSxcblx0XHRcdFx0KG5ldHdvcmtQbGF5ZXIpID0+IHtcblx0XHRcdFx0XHR0aGlzLm5ldHdvcmtQbGF5ZXJzW3VuaXROZXR3b3JrSWRdID0gbmV0d29ya1BsYXllcjtcblx0XHRcdFx0fSxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChuZXR3b3JrUGxheWVyICE9PSAnbG9hZGluZycpIHtcblx0XHRcdHRoaXMuc2V0UGxheWVyUGFyYW1zKG5ldHdvcmtQbGF5ZXIsIHsgcG9zaXRpb24sIHJvdGF0aW9uLCBhbmltYXRpb25TdGF0ZSwgcGFyYW1zIH0pO1xuXHRcdH1cblx0fVxuXG5cdHNldFBsYXllclBhcmFtcyhwbGF5ZXIsIHsgcG9zaXRpb24sIHJvdGF0aW9uLCBhbmltYXRpb25TdGF0ZSwgcGFyYW1zIH0pIHtcblx0XHRwbGF5ZXIucG9zaXRpb24uc2V0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuXHRcdHBsYXllci5yb3RhdGlvbi5zZXQocm90YXRpb24ueCwgcm90YXRpb24ueSwgcm90YXRpb24ueik7XG5cdFx0cGxheWVyLmFuaW1hdGlvblN0YXRlID0gYW5pbWF0aW9uU3RhdGU7XG5cblx0XHRpZiAocGFyYW1zKSB7XG5cdFx0XHRjb25zdCB7IGlucHV0LCBhY2NlbGVyYXRpb24gfSA9IHBhcmFtcztcblx0XHRcdGNvbnN0IHBsYXllclBhcmFtcyA9IHBsYXllci5wYXJhbXM7XG5cblx0XHRcdHBsYXllclBhcmFtcy5pbnB1dC52ZXJ0aWNhbCA9IGlucHV0LnZlcnRpY2FsO1xuXHRcdFx0cGxheWVyUGFyYW1zLmlucHV0Lmhvcml6b250YWwgPSBpbnB1dC5ob3Jpem9udGFsO1xuXHRcdFx0cGxheWVyUGFyYW1zLmlucHV0LmF0dGFjazEgPSBpbnB1dC5hdHRhY2sxO1xuXHRcdFx0cGxheWVyUGFyYW1zLmlucHV0LmF0dGFjazIgPSBpbnB1dC5hdHRhY2syO1xuXHRcdFx0cGxheWVyUGFyYW1zLmhwID0gcGFyYW1zLmhwO1xuXHRcdFx0cGxheWVyUGFyYW1zLmhwTWF4ID0gcGFyYW1zLmhwTWF4O1xuXHRcdFx0cGxheWVyUGFyYW1zLmZyYWN0aW9uID0gcGFyYW1zLmZyYWN0aW9uO1xuXHRcdFx0cGxheWVyUGFyYW1zLmRhbWFnZSA9IHBhcmFtcy5kYW1hZ2U7XG5cdFx0XHRwbGF5ZXJQYXJhbXMuc3BlZWQgPSBwYXJhbXMuc3BlZWQ7XG5cdFx0XHRwbGF5ZXJQYXJhbXMubW9uZXkgPSBwYXJhbXMubW9uZXk7XG5cdFx0XHRwbGF5ZXJQYXJhbXMubGV2ZWwgPSBwYXJhbXMubGV2ZWw7XG5cdFx0XHRwbGF5ZXJQYXJhbXMudW5zcGVudFRhbGVudHMgPSBwYXJhbXMudW5zcGVudFRhbGVudHM7XG5cdFx0XHRwbGF5ZXJQYXJhbXMuZXhwZXJpZW5jZSA9IHBhcmFtcy5leHBlcmllbmNlO1xuXHRcdFx0cGxheWVyUGFyYW1zLmFjY2VsZXJhdGlvbi5zZXQoYWNjZWxlcmF0aW9uLngsIGFjY2VsZXJhdGlvbi55LCBhY2NlbGVyYXRpb24ueik7XG5cdFx0fVxuXHR9XG5cblx0dXBkYXRlTmV0d29ya0FJKHVuaXREYXRhKSB7XG5cdFx0Y29uc3QgeyBsb2NhdGlvbk5hbWUsIHBvc2l0aW9uLCByb3RhdGlvbiwgaXNSdW5uaW5nLCBpc0F0dGFjaywgYW5pbWF0aW9uU3RhdGUsIHNjYWxlLCBwYXJhbXMgfSA9IHVuaXREYXRhO1xuXHRcdGNvbnN0IHsgdW5pdE5ldHdvcmtJZCB9ID0gcGFyYW1zO1xuXG5cdFx0aWYgKGxvY2F0aW9uTmFtZSAhPT0gdGhpcy5zY2VuZS5sb2NhdGlvbi5nZXRMb2NhdGlvbk5hbWUoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIEFJIHwgc3RyaW5nXG5cdFx0ICovXG5cdFx0bGV0IG5ldHdvcmtBSSA9IHRoaXMubmV0d29ya0FJc1t1bml0TmV0d29ya0lkXTtcblxuXHRcdGlmICghbmV0d29ya0FJKSB7XG5cdFx0XHR0aGlzLm5ldHdvcmtBSXNbdW5pdE5ldHdvcmtJZF0gPSAnbG9hZGluZyc7XG5cblx0XHRcdHRoaXMuc2NlbmUudW5pdHMuY3JlYXRlTmV0d29ya0FJKHVuaXREYXRhLCAobmV0d29ya0FJKSA9PiB7XG5cdFx0XHRcdHRoaXMubmV0d29ya0FJc1t1bml0TmV0d29ya0lkXSA9IG5ldHdvcmtBSTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAobmV0d29ya0FJICE9PSAnbG9hZGluZycpIHtcblx0XHRcdG5ldHdvcmtBSS5wb3NpdGlvbi5zZXQocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XG5cdFx0XHRuZXR3b3JrQUkucm90YXRpb24uc2V0KHJvdGF0aW9uLngsIHJvdGF0aW9uLnksIHJvdGF0aW9uLnopO1xuXHRcdFx0bmV0d29ya0FJLm9iamVjdC5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSwgc2NhbGUueik7XG5cdFx0XHRuZXR3b3JrQUkuaXNSdW5uaW5nID0gaXNSdW5uaW5nO1xuXHRcdFx0bmV0d29ya0FJLmlzQXR0YWNrID0gaXNBdHRhY2s7XG5cdFx0XHRuZXR3b3JrQUkuYW5pbWF0aW9uU3RhdGUgPSBhbmltYXRpb25TdGF0ZTtcblxuXHRcdFx0aWYgKHBhcmFtcykge1xuXHRcdFx0XHRjb25zdCB7IGFjY2VsZXJhdGlvbiB9ID0gcGFyYW1zO1xuXHRcdFx0XHRjb25zdCBuZXR3b3JrQUlQYXJhbXMgPSBuZXR3b3JrQUkucGFyYW1zO1xuXG5cdFx0XHRcdG5ldHdvcmtBSVBhcmFtcy5ocCA9IHBhcmFtcy5ocDtcblx0XHRcdFx0bmV0d29ya0FJUGFyYW1zLmhwTWF4ID0gcGFyYW1zLmhwTWF4O1xuXHRcdFx0XHRuZXR3b3JrQUlQYXJhbXMuZnJhY3Rpb24gPSBwYXJhbXMuZnJhY3Rpb247XG5cdFx0XHRcdG5ldHdvcmtBSVBhcmFtcy5kYW1hZ2UgPSBwYXJhbXMuZGFtYWdlO1xuXHRcdFx0XHRuZXR3b3JrQUlQYXJhbXMubGV2ZWwgPSBwYXJhbXMubGV2ZWw7XG5cdFx0XHRcdG5ldHdvcmtBSVBhcmFtcy5hY2NlbGVyYXRpb24uc2V0KGFjY2VsZXJhdGlvbi54LCBhY2NlbGVyYXRpb24ueSwgYWNjZWxlcmF0aW9uLnopO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHNlbmRHYW1lT2JqZWN0cygpIHtcblx0XHRjb25zdCBjb25uZWN0aW9uSWQgPSB0aGlzLm1ldGEuaWQ7XG5cblx0XHRpZiAodGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGUgIT09IDEgfHwgIWNvbm5lY3Rpb25JZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IHBsYXllciA9IHRoaXMuc2NlbmUuZ2V0UGxheWVyKCk7XG5cdFx0Y29uc3QgdW5pdHMgPSAoXG5cdFx0XHR0aGlzLm1ldGEucm9sZSA9PT0gJ2hvc3QnXG5cdFx0XHRcdD8gW1xuXHRcdFx0XHRcdHBsYXllcixcblx0XHRcdFx0XHQuLi50aGlzLnNjZW5lLnVuaXRzXG5cdFx0XHRcdFx0XHQuZ2V0QWxpdmVVbml0cygpXG5cdFx0XHRcdFx0XHQuZmlsdGVyKHVuaXQgPT4gIXVuaXQucGFyYW1zLmZyb21OZXR3b3JrKVxuXHRcdFx0XHRdXG5cdFx0XHRcdDogW3BsYXllcl1cblx0XHQpO1xuXG5cdFx0Y29uc3QgZGF0YSA9IFtdO1xuXG5cdFx0dW5pdHMuZm9yRWFjaCgodW5pdCkgPT4ge1xuXHRcdFx0Y29uc3QgdW5pdERhdGEgPSBDb25uZWN0aW9uLnVuaXRUb05ldHdvcmsoXG5cdFx0XHRcdHVuaXQsXG5cdFx0XHRcdGNvbm5lY3Rpb25JZCxcblx0XHRcdFx0dGhpcy5zY2VuZS5sb2NhdGlvbi5nZXRMb2NhdGlvbk5hbWUoKSxcblx0XHRcdCk7XG5cblx0XHRcdGlmICh1bml0RGF0YSkge1xuXHRcdFx0XHRkYXRhLnB1c2godW5pdERhdGEpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMubWV0YS5yb2xlID09PSAnaG9zdCcpIHtcblx0XHRcdHRoaXMuc2VuZCgndXBkYXRlR2FtZU9iamVjdHMnLCBkYXRhKTtcblx0XHR9IGVsc2UgaWYgKGRhdGFbMF0pIHtcblx0XHRcdHRoaXMuc2VuZCgndXBkYXRlUGxheWVyJywgZGF0YVswXSk7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIHVuaXRUb05ldHdvcmsodW5pdCwgY29ubmVjdGlvbklkLCBsb2NhdGlvbk5hbWUpIHtcblx0XHRpZiAodW5pdCkge1xuXHRcdFx0Y29uc3QgdW5pdFJvdGF0aW9uID0gdW5pdC5vYmplY3Qucm90YXRpb24udG9WZWN0b3IzKCk7XG5cblx0XHRcdGlmICghdW5pdC5wYXJhbXMudW5pdE5ldHdvcmtJZCkge1xuXHRcdFx0XHRjb25zdCBnZXRSYW5kb21TdHJpbmcgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMik7XG5cdFx0XHRcdHVuaXQucGFyYW1zLnVuaXROZXR3b3JrSWQgPSBnZXRSYW5kb21TdHJpbmcoKSArIGdldFJhbmRvbVN0cmluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB1bml0TmV0d29ya0lkID0gdW5pdC5wYXJhbXMudW5pdE5ldHdvcmtJZDtcblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0aXNSdW5uaW5nLFxuXHRcdFx0XHRpc0F0dGFjayxcblx0XHRcdH0gPSB1bml0O1xuXHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRocCxcblx0XHRcdFx0aHBNYXgsXG5cdFx0XHRcdGFjY2VsZXJhdGlvbixcblx0XHRcdFx0ZGFtYWdlLFxuXHRcdFx0XHRsZXZlbCxcblx0XHRcdFx0ZXhwZXJpZW5jZSxcblx0XHRcdFx0ZnJhY3Rpb24sXG5cdFx0XHRcdG5hbWUsXG5cdFx0XHRcdHNwZWVkLFxuXHRcdFx0XHR1bnNwZW50VGFsZW50cyxcblx0XHRcdFx0bW9uZXksXG5cdFx0XHR9ID0gdW5pdC5wYXJhbXM7XG5cblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0dmVydGljYWwsXG5cdFx0XHRcdGhvcml6b250YWwsXG5cdFx0XHRcdGF0dGFjazEsXG5cdFx0XHRcdGF0dGFjazIsXG5cdFx0XHR9ID0gdW5pdC5wYXJhbXMuaW5wdXQgfHwge307XG5cblx0XHRcdGNvbnN0IHZlY3RvclRvT2JqZWN0ID0gKHZlY3RvciwgZXBzID0gMTAwMCkgPT4gKHtcblx0XHRcdFx0eDogTWF0aC5yb3VuZCh2ZWN0b3IueCAqIGVwcykgLyBlcHMsXG5cdFx0XHRcdHk6IE1hdGgucm91bmQodmVjdG9yLnkgKiBlcHMpIC8gZXBzLFxuXHRcdFx0XHR6OiBNYXRoLnJvdW5kKHZlY3Rvci56ICogZXBzKSAvIGVwcyxcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gKHtcblx0XHRcdFx0dHlwZTogdW5pdCBpbnN0YW5jZW9mIFBsYXllciA/ICdwbGF5ZXInIDogJ2FpJyxcblx0XHRcdFx0bG9jYXRpb25OYW1lLFxuXHRcdFx0XHRhbmltYXRpb25TdGF0ZTogdW5pdC5hbmltYXRpb25TdGF0ZSxcblx0XHRcdFx0aXNSdW5uaW5nLFxuXHRcdFx0XHRpc0F0dGFjayxcblx0XHRcdFx0cG9zaXRpb246IHZlY3RvclRvT2JqZWN0KHVuaXQucG9zaXRpb24pLFxuXHRcdFx0XHRyb3RhdGlvbjogdmVjdG9yVG9PYmplY3QodW5pdFJvdGF0aW9uKSxcblx0XHRcdFx0c2NhbGU6IHZlY3RvclRvT2JqZWN0KHVuaXQub2JqZWN0LnNjYWxlKSxcblx0XHRcdFx0cGFyYW1zOiB7XG5cdFx0XHRcdFx0Y29ubmVjdGlvbklkLFxuXHRcdFx0XHRcdHVuaXROZXR3b3JrSWQsXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRocCxcblx0XHRcdFx0XHRocE1heCxcblx0XHRcdFx0XHRmcmFjdGlvbixcblx0XHRcdFx0XHRkYW1hZ2UsXG5cdFx0XHRcdFx0bGV2ZWwsXG5cdFx0XHRcdFx0ZXhwZXJpZW5jZSxcblx0XHRcdFx0XHRzcGVlZCxcblx0XHRcdFx0XHRtb25leSxcblx0XHRcdFx0XHR1bnNwZW50VGFsZW50cyxcblx0XHRcdFx0XHRhY2NlbGVyYXRpb246IHZlY3RvclRvT2JqZWN0KGFjY2VsZXJhdGlvbiksXG5cdFx0XHRcdFx0aW5wdXQ6IHtcblx0XHRcdFx0XHRcdHZlcnRpY2FsLCBob3Jpem9udGFsLFxuXHRcdFx0XHRcdFx0YXR0YWNrMSwgYXR0YWNrMixcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59IiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5pbXBvcnQgQUkgZnJvbSAnLi9HYW1lT2JqZWN0cy9BSSc7XG5pbXBvcnQgUGxheWVyIGZyb20gJy4vR2FtZU9iamVjdHMvUGxheWVyJztcbmltcG9ydCBGaXJlIGZyb20gJy4vR2FtZU9iamVjdHMvRmlyZSc7XG5pbXBvcnQgVW5pdCBmcm9tICcuL0dhbWVPYmplY3RzL1VuaXQnO1xuaW1wb3J0IEFuaW1hdGVkR2FtZU9iamVjdCBmcm9tICcuL0dhbWVPYmplY3RzL0FuaW1hdGVkR2FtZU9iamVjdCc7XG5cbmV4cG9ydCB7XG4gICAgQUksXG4gICAgUGxheWVyLFxuICAgIEZpcmUsXG4gICAgVW5pdCxcbiAgICBBbmltYXRlZEdhbWVPYmplY3QsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lT2JqZWN0c1NlcnZpY2UgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2NlbmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0cyA9IFtdO1xuICAgICAgICB0aGlzLm5leHRHYW1lT2JqZWN0SWQgPSAwO1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICB0aGlzLmdhbWVPYmplY3RzLmZvckVhY2goZ2FtZU9iamVjdCA9PiBnYW1lT2JqZWN0LnVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VuaXR9IGF0dGFja2luZ1VuaXRcbiAgICAgKi9cbiAgICBhdHRhY2soYXR0YWNraW5nVW5pdCkge1xuICAgICAgICBpZiAoYXR0YWNraW5nVW5pdC5pc0RlYWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnYW1lVGltZSA9IHRoaXMuc2NlbmUuaW50ZXJ2YWxzLmdldFRpbWVQYXNzZWQoKTtcblxuICAgICAgICAgICAgaWYgKGF0dGFja2luZ1VuaXQuaXNBdHRhY2tJbnRlcnJ1cHRlZChnYW1lVGltZSkpIHtcbiAgICAgICAgICAgICAgICBhdHRhY2tpbmdVbml0LnJlbGVhc2VBdHRhY2soZ2FtZVRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYXR0YWNrZWRVbml0cyA9IHRoaXMuZ2V0VW5pdHMoKS5maWx0ZXIoZ2FtZU9iamVjdCA9PiAoXG4gICAgICAgICAgICAgICAgZ2FtZU9iamVjdCAhPT0gYXR0YWNraW5nVW5pdFxuICAgICAgICAgICAgICAgICYmIGdhbWVPYmplY3QuaXNBbGl2ZSgpXG4gICAgICAgICAgICAgICAgJiYgZ2FtZU9iamVjdC5pc0VuZW15KGF0dGFja2luZ1VuaXQpXG4gICAgICAgICAgICAgICAgJiYgZ2FtZU9iamVjdC5wb3NpdGlvbi5kaXN0YW5jZVRvKGF0dGFja2luZ1VuaXQucG9zaXRpb24pIDwgMlxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIGF0dGFja2VkVW5pdHMuZm9yRWFjaCgoY29sbGlzaW9uR2FtZU9iamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkdhbWVPYmplY3QuZGFtYWdlVGFrZW4oe1xuICAgICAgICAgICAgICAgICAgICBkYW1hZ2U6IGF0dGFja2luZ1VuaXQucGFyYW1zLmRhbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgdW5pdDogYXR0YWNraW5nVW5pdCxcbiAgICAgICAgICAgICAgICB9LCBnYW1lVGltZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBpZiAoYXR0YWNrZWRVbml0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnNjZW5lLmF1ZGlvLnBsYXlTb3VuZChhdHRhY2tpbmdVbml0LnBvc2l0aW9uLCAnQXR0YWNrIFNvZnQnKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfSwgYXR0YWNraW5nVW5pdC5nZXRBdHRhY2tUaW1lb3V0KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VW5pdH0gZmlyaW5nR2FtZU9iamVjdFxuICAgICAqL1xuICAgIGZpcmUoZmlyaW5nR2FtZU9iamVjdCkge1xuICAgICAgICBpZiAoZmlyaW5nR2FtZU9iamVjdC5pc0RlYWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3JlYXRlTGlnaHRDdWJlID0gbGVmdCA9PiB0aGlzLnNjZW5lLm1vZGVscy5jcmVhdGVDdWJlKHtcbiAgICAgICAgICAgIHg6IDAuMDIsXG4gICAgICAgICAgICB5OiAwLjAyLFxuICAgICAgICAgICAgejogMC4zLFxuICAgICAgICAgICAgZW1pc3NpdmU6ICcjZmYwMDAwJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygwLjA1IC0gTnVtYmVyKGxlZnQpICogMC4xLCAwLCAwKSxcbiAgICAgICAgICAgIG5vU2NlbmU6IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG9iamVjdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gICAgICAgIG9iamVjdC5wb3NpdGlvbi5jb3B5KGZpcmluZ0dhbWVPYmplY3QuZ2V0RmlyZUluaXRpYWxQb3NpdGlvbigpKTtcbiAgICAgICAgb2JqZWN0LnF1YXRlcm5pb24uY29weShmaXJpbmdHYW1lT2JqZWN0LmdldEZpcmVJbml0aWFsUm90YXRpb24oKSk7XG5cbiAgICAgICAgb2JqZWN0LmFkZChjcmVhdGVMaWdodEN1YmUodHJ1ZSkpO1xuICAgICAgICBvYmplY3QuYWRkKGNyZWF0ZUxpZ2h0Q3ViZShmYWxzZSkpO1xuXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKG9iamVjdCk7XG5cbiAgICAgICAgY29uc3QgZmlyZUdhbWVPYmplY3QgPSB0aGlzLmhvb2tHYW1lT2JqZWN0KG5ldyBGaXJlKHtcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIHRocm90dGxpbmc6IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDEsIDEpLFxuICAgICAgICAgICAgc3BlZWQ6IGZpcmluZ0dhbWVPYmplY3QucGFyYW1zLmZpcmVTaGVsbFNwZWVkLFxuICAgICAgICAgICAgZGFtYWdlOiBmaXJpbmdHYW1lT2JqZWN0LnBhcmFtcy5maXJlRGFtYWdlLFxuICAgICAgICAgICAgcGFyZW50OiBmaXJpbmdHYW1lT2JqZWN0LFxuICAgICAgICAgICAgY2hlY2tXYXk6IHRoaXMuc2NlbmUuY29sbGlkZXJzLmNoZWNrV2F5LFxuICAgICAgICAgICAgZ2V0Q29sbGlzaW9uczogKCkgPT4gdGhpcy5nYW1lT2JqZWN0cy5maWx0ZXIoZ2FtZU9iamVjdCA9PiAoXG4gICAgICAgICAgICAgICAgZ2FtZU9iamVjdCBpbnN0YW5jZW9mIFVuaXRcbiAgICAgICAgICAgICAgICAmJiBnYW1lT2JqZWN0LmlzQWxpdmUoKVxuICAgICAgICAgICAgICAgICYmIGZpcmVHYW1lT2JqZWN0LnBhcmFtcy5wYXJlbnQgIT09IGdhbWVPYmplY3RcbiAgICAgICAgICAgICAgICAmJiBmaXJlR2FtZU9iamVjdC5wb3NpdGlvbi5kaXN0YW5jZVRvKGdhbWVPYmplY3QucG9zaXRpb24pIDwgM1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBkZXN0cm95OiAoKSA9PiB0aGlzLmRlc3Ryb3lHYW1lT2JqZWN0KGZpcmVHYW1lT2JqZWN0KSxcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRoaXMuc2NlbmUuaW50ZXJ2YWxzLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5kZXN0cm95R2FtZU9iamVjdChmaXJlR2FtZU9iamVjdCksIDIwMDApO1xuXG4gICAgICAgIC8vIHRoaXMuc2NlbmUuYXVkaW8ucGxheVNvdW5kKGZpcmluZ0dhbWVPYmplY3QucG9zaXRpb24sICdMYXNlcnMnKTtcbiAgICB9XG4gICAgXG4gICAgY3JlYXRlSXRlbSh7XG4gICAgICAgIHNjYWxlID0gMS41LFxuICAgICAgICBtb2RlbCA9ICdpdGVtLWhlYWwnLFxuICAgICAgICBwb3NpdGlvbiA9IHt9LFxuICAgICAgICBjYW5QaWNrdXAsXG4gICAgICAgIG9uUGlja3VwLFxuICAgIH0pIHtcbiAgICAgICAgdGhpcy5zY2VuZS5tb2RlbHMubG9hZEdMVEYoe1xuICAgICAgICAgICAgYmFzZVVybDogJy4vYXNzZXRzL21vZGVscy9pdGVtcy8nICsgbW9kZWwsXG4gICAgICAgICAgICBub1NjZW5lOiB0cnVlLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGxvYWRlZE9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25WZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMyhwb3NpdGlvbi54IHx8IDAsIHBvc2l0aW9uLnkgfHwgMCwgcG9zaXRpb24ueiB8fCAwKTtcbiAgICAgICAgICAgICAgICBsb2FkZWRPYmplY3Quc2NlbmUuc2NhbGUuc2V0KHNjYWxlLCBzY2FsZSwgc2NhbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbG9hZGVkT2JqZWN0LnNjZW5lLnRyYXZlcnNlKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNNZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC5hbHBoYVRlc3QgPSAwLjU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxvYWRlZE9iamVjdC5zY2VuZS5wb3NpdGlvbi5zZXQocG9zaXRpb25WZWN0b3IueCwgcG9zaXRpb25WZWN0b3IueSwgcG9zaXRpb25WZWN0b3Iueik7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5zY2VuZS5hZGQobG9hZGVkT2JqZWN0LnNjZW5lKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGdhbWVJdGVtID0gbmV3IEFuaW1hdGVkR2FtZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogbG9hZGVkT2JqZWN0LnNjZW5lLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBsb2FkZWRPYmplY3QuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlLmhvb2tHYW1lT2JqZWN0KGdhbWVJdGVtKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrUGlja3VwID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmludGVydmFscy5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldFByaW9yaXR5ID0gdW5pdCA9PiAxIC8gTWF0aC5jZWlsKHBvc2l0aW9uVmVjdG9yLmRpc3RhbmNlVG8odW5pdC5wb3NpdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lYXJVbml0cyA9IHRoaXMuc2NlbmUudW5pdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEFsaXZlVW5pdHMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh1bml0KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIWNhblBpY2t1cCB8fCBjYW5QaWNrdXAodW5pdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBwb3NpdGlvblZlY3Rvci5kaXN0YW5jZVRvKHVuaXQucG9zaXRpb24pIDwgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgodW5pdEEsIHVuaXRCKSA9PiBnZXRQcmlvcml0eSh1bml0QikgLSBnZXRQcmlvcml0eSh1bml0QSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lYXJVbml0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uUGlja3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblBpY2t1cChuZWFyVW5pdHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhbWVJdGVtLmFuaW1hdGlvblN0YXRlLmlzRGllID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlLmRlc3Ryb3lHYW1lT2JqZWN0KGdhbWVJdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDUwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1BpY2t1cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDAwLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjaGVja1BpY2t1cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0dhbWVPYmplY3R9IGdhbWVPYmplY3RcbiAgICAgKi9cbiAgICBob29rR2FtZU9iamVjdChnYW1lT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdHMucHVzaChnYW1lT2JqZWN0KTtcbiAgICAgICAgZ2FtZU9iamVjdC5fX2dhbWVfb2JqZWN0X2lkID0gdGhpcy5uZXh0R2FtZU9iamVjdElkKys7XG5cbiAgICAgICAgcmV0dXJuIGdhbWVPYmplY3Q7XG4gICAgfVxuXG4gICAgcmVtb3ZlQWxsKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5nYW1lT2JqZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUdhbWVPYmplY3QodGhpcy5nYW1lT2JqZWN0c1swXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVBbGxFeGNlcHRQbGF5ZXIoKSB7XG4gICAgICAgIGNvbnN0IGdldE5leHROb25QbGF5ZXJJbmRleCA9ICgpID0+IHRoaXMuZ2FtZU9iamVjdHMuZmluZEluZGV4KGdvID0+IGdvICE9PSB0aGlzLnNjZW5lLmdldFBsYXllcigpKTtcbiAgICAgICAgbGV0IHJlbW92ZUlkeCA9IGdldE5leHROb25QbGF5ZXJJbmRleCgpO1xuXG4gICAgICAgIHdoaWxlIChyZW1vdmVJZHggPiAtMSkge1xuICAgICAgICAgICAgY29uc3QgZ2FtZU9iamVjdCA9IHRoaXMuZ2FtZU9iamVjdHNbcmVtb3ZlSWR4XTtcbiAgICAgICAgICAgIHRoaXMuZ2FtZU9iamVjdHMuc3BsaWNlKHJlbW92ZUlkeCwgMSk7XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlR2FtZU9iamVjdEZyb21TY2VuZShnYW1lT2JqZWN0KTtcblxuICAgICAgICAgICAgcmVtb3ZlSWR4ID0gZ2V0TmV4dE5vblBsYXllckluZGV4KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0dhbWVPYmplY3R9IGdhbWVPYmplY3RcbiAgICAgKi9cbiAgICBkZXN0cm95R2FtZU9iamVjdChnYW1lT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nYW1lT2JqZWN0cy5pbmRleE9mKGdhbWVPYmplY3QpO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmdhbWVPYmplY3RzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbW92ZUdhbWVPYmplY3RGcm9tU2NlbmUoZ2FtZU9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtHYW1lT2JqZWN0fSBnYW1lT2JqZWN0XG4gICAgICovXG4gICAgcmVtb3ZlR2FtZU9iamVjdEZyb21TY2VuZShnYW1lT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IChnYW1lT2JqZWN0Lm9iamVjdCAmJiBnYW1lT2JqZWN0Lm9iamVjdC5wYXJlbnQpIHx8IHRoaXMuc2NlbmU7XG5cbiAgICAgICAgaWYgKHBhcmVudC5yZW1vdmUpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmUoZ2FtZU9iamVjdC5vYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IGZpbmQgb2JqZWN0IHBhcmVudCB0byByZW1vdmUgdGhlIG9iamVjdCcsIGdhbWVPYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VW5pdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdhbWVPYmplY3RzLmZpbHRlcihnbyA9PiBnbyBpbnN0YW5jZW9mIFVuaXQpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IEZpcmluZ1VuaXQgZnJvbSAnLi9GaXJpbmdVbml0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUkgZXh0ZW5kcyBGaXJpbmdVbml0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBzcGVlZDogMC41LFxuICAgICAgICAgICAgZGFtYWdlOiAxMCxcbiAgICAgICAgICAgIG1hczogMSxcbiAgICAgICAgICAgIGhwOiAxMDAsXG4gICAgICAgICAgICBuYW1lOiAnVW5uYW1lZCBVbml0JyxcbiAgICAgICAgICAgIGZyYWN0aW9uOiAnbmV1dHJhbCcsXG4gICAgICAgICAgICBmaXJlVGltZW91dDogMS41LFxuICAgICAgICAgICAgYXR0YWNrVGltZW91dDogMS41LFxuICAgICAgICAgICAganVtcFRpbWVvdXQ6IDEuNSxcbiAgICAgICAgICAgIHN0YXJ0UnVuVGltZW91dDogMSxcbiAgICAgICAgICAgIG5leHRQb2ludFVwZGF0ZVRpbWVvdXQ6IDAuMSxcbiAgICAgICAgICAgIHVwZGF0ZVRhcmdldFRpbWVvdXQ6IDMsXG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgaHAsIGRhbWFnZSwgc3BlZWQgfSA9IHRoaXMucGFyYW1zO1xuXG4gICAgICAgIHRoaXMucGFyYW1zLmJvdW50eSA9IGhwIC8gNCArIGRhbWFnZSArIHNwZWVkICogMzA7XG4gICAgICAgIHRoaXMubGFzdFJ1biA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRhcmdldFVwZGF0ZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdE5leHRQb2ludFVwZGF0ZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEp1bXBUaW1lc3RhbXAgPSAwO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQXR0YWNrID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICBzdXBlci51cGRhdGUodGltZSwgZGVsdGFUaW1lKTtcblxuICAgICAgICBpZiAodGhpcy5pc0RlYWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmZpbmRUYXJnZXQgJiYgdGhpcy5pc1VwZGF0ZVRhcmdldFJlbGVhc2VkKHRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy50YXJnZXQgPSB0aGlzLnBhcmFtcy5maW5kVGFyZ2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IG9iamVjdCwgdGFyZ2V0LCBhY2NlbGVyYXRpb24sIHNwZWVkLCBnZXROZXh0UG9pbnQgfSA9IHRoaXMucGFyYW1zO1xuXG4gICAgICAgIGlmICghdGhpcy5wYXJhbXMuZnJvbU5ldHdvcmspIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0TmV4dFBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTmV4dFBvaW50VXBkYXRlUmVsZWFzZWQodGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE5leHRQb2ludFVwZGF0ZSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRQb2ludCA9IGdldE5leHRQb2ludCh0aGlzLnBvc2l0aW9uLCB0YXJnZXQucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0UG9pbnQgPSB0YXJnZXQucG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpc1RhcmdldE5lYXIgPSB0YXJnZXQgJiYgb2JqZWN0LnBvc2l0aW9uLmRpc3RhbmNlVG8odGFyZ2V0LnBvc2l0aW9uKSA8IDEuNzU7XG5cbiAgICAgICAgICAgIHRoaXMuaXNBdHRhY2sgPSAoXG4gICAgICAgICAgICAgICBpc1RhcmdldE5lYXJcbiAgICAgICAgICAgICAgICYmIHRoaXMuaXNFbmVteSh0YXJnZXQpXG4gICAgICAgICAgICAgICAmJiB0YXJnZXQuaXNBbGl2ZSgpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0F0dGFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlVG9Qb3NpdGlvbih0YXJnZXQucG9zaXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHRQb2ludCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlVG9Qb3NpdGlvbih0aGlzLm5leHRQb2ludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGlzTmV4dFBvaW50TmVhciA9ICF0aGlzLm5leHRQb2ludDtcblxuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSAoXG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgICAgJiYgIWlzVGFyZ2V0TmVhclxuICAgICAgICAgICAgICAgICYmICFpc05leHRQb2ludE5lYXJcbiAgICAgICAgICAgICAgICAmJiAodGhpcy5pc1J1bm5pbmcgfHwgdGhpcy5pc1J1blJlbGVhc2VkKHRpbWUpKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuaXNBdHRhY2tSZWxlYXNlZCh0aW1lKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuaXNIaXRSZWxlYXNlZCh0aW1lKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNrKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ0ZvcndhcmQgPSB0aGlzLmlzUnVubmluZyAmJiB0aGlzLmlzQWNjZWxlcmF0aW9uKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVja1dheSA9IChqdW1wSGVpZ2h0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXJhbXM6IHsgYWNjZWxlcmF0aW9uOiB7IHg6IGR4LCB5OiBkeSwgejogZHogfSB9IH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrV2F5KGR4LCBkeSArIGp1bXBIZWlnaHQsIGR6KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMubGFzdFJ1biA9IHRpbWU7XG4gICAgICAgICAgICBhY2NlbGVyYXRpb24uYWRkKHRoaXMuZ2V0Rm9yd2FyZCgpLm11bHRpcGx5U2NhbGFyKChzcGVlZCAqIDAuMSkgKiAoZGVsdGFUaW1lICogMC4wNikpKTtcblxuICAgICAgICAgICAgY29uc3QgaXNKdW1wTmVlZGVkID0gKFxuICAgICAgICAgICAgICAgIHRoaXMuaXNHcm91bmRlZFxuICAgICAgICAgICAgICAgICYmIChhY2NlbGVyYXRpb24ueCB8fCBhY2NlbGVyYXRpb24ueilcbiAgICAgICAgICAgICAgICAmJiB0aW1lIC0gdGhpcy5sYXN0SnVtcFRpbWVzdGFtcCA+IHRoaXMucGFyYW1zLmp1bXBUaW1lb3V0ICogMTAwMFxuICAgICAgICAgICAgICAgICYmICFjaGVja1dheSgwLjEpXG4gICAgICAgICAgICAgICAgJiYgY2hlY2tXYXkoMS41KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKGlzSnVtcE5lZWRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEp1bXBUaW1lc3RhbXAgPSB0aW1lO1xuICAgICAgICAgICAgICAgIGFjY2VsZXJhdGlvbi55ICs9IDAuMjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByb3RhdGVUb1Bvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgb2JqZWN0IH0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgICBjb25zdCByb3RhdGlvblRvVGFyZ2V0UmFkaWFucyA9IE1hdGguYXRhbjIoXG4gICAgICAgICAgICBwb3NpdGlvbi54IC0gb2JqZWN0LnBvc2l0aW9uLngsXG4gICAgICAgICAgICBwb3NpdGlvbi56IC0gb2JqZWN0LnBvc2l0aW9uLnpcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB0aGlzLmFuaW1hdGlvblN0YXRlLmlzUm90YXRlTGVmdCA9IHJvdGF0aW9uVG9UYXJnZXRSYWRpYW5zIC0gb2JqZWN0LnJvdGF0aW9uLnkgPiAwLjE7XG4gICAgICAgIC8vIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNSb3RhdGVSaWdodCA9IHJvdGF0aW9uVG9UYXJnZXRSYWRpYW5zIC0gb2JqZWN0LnJvdGF0aW9uLnkgPCAtMC4xO1xuXG4gICAgICAgIGNvbnN0IHRhcmdldFF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAgICAgICB0YXJnZXRRdWF0ZXJuaW9uLnNldEZyb21FdWxlcihvYmplY3Qucm90YXRpb24uY2xvbmUoKS5zZXQoMCwgcm90YXRpb25Ub1RhcmdldFJhZGlhbnMsIDApKTtcbiAgICAgICAgb2JqZWN0LnF1YXRlcm5pb24uc2xlcnAodGFyZ2V0UXVhdGVybmlvbiwgMC4xKTtcbiAgICB9XG5cbiAgICBpc0FjY2VsZXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMucGFyYW1zLmFjY2VsZXJhdGlvbi54KVxuICAgICAgICAgICAgKyBNYXRoLmFicyh0aGlzLnBhcmFtcy5hY2NlbGVyYXRpb24ueSlcbiAgICAgICAgICAgICsgTWF0aC5hYnModGhpcy5wYXJhbXMuYWNjZWxlcmF0aW9uLnopXG4gICAgICAgICkgPiAwLjAxO1xuICAgIH1cblxuICAgIGlzUnVuUmVsZWFzZWQodGltZSkge1xuICAgICAgICByZXR1cm4gdGltZSAtIHRoaXMubGFzdFJ1biA+IHRoaXMucGFyYW1zLnN0YXJ0UnVuVGltZW91dCAqIDEwMDA7XG4gICAgfVxuXG4gICAgaXNOZXh0UG9pbnRVcGRhdGVSZWxlYXNlZCh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aW1lIC0gdGhpcy5sYXN0TmV4dFBvaW50VXBkYXRlID4gdGhpcy5wYXJhbXMubmV4dFBvaW50VXBkYXRlVGltZW91dCAqIDEwMDA7XG4gICAgfVxuXG4gICAgaXNVcGRhdGVUYXJnZXRSZWxlYXNlZCh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aW1lIC0gdGhpcy5sYXN0VGFyZ2V0VXBkYXRlID4gdGhpcy5wYXJhbXMudXBkYXRlVGFyZ2V0VGltZW91dCAqIDEwMDA7XG4gICAgfVxuXG4gICAgZGFtYWdlVGFrZW4oeyBkYW1hZ2UsIHVuaXQ6IGF0dGFja2VyIH0gPSB7fSwgdGltZSkge1xuICAgICAgICBzdXBlci5kYW1hZ2VUYWtlbih7IGRhbWFnZSwgdW5pdDogYXR0YWNrZXIgfSwgdGltZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnBhcmFtcy50YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLnRhcmdldCA9IGF0dGFja2VyO1xuICAgICAgICAgICAgdGhpcy5sYXN0VGFyZ2V0VXBkYXRlID0gdGltZTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgR2FtZU9iamVjdCBmcm9tICcuL0dhbWVPYmplY3QnO1xuXG5jb25zdCBhbmltYXRpb25OYW1lcyA9IHtcbiAgICBzdGFuZDogJ1N0YW5kJyxcbiAgICBydW46ICdSdW4nLFxuICAgIGp1bXA6ICdKdW1wJyxcbiAgICBhdHRhY2s6ICdBdHRhY2snLFxuICAgIHJvdGF0ZUxlZnQ6ICdSb3RhdGUgTGVmdCcsXG4gICAgcm90YXRlUmlnaHQ6ICdSb3RhdGUgUmlnaHQnLFxuICAgIHJ1bkxlZnQ6ICdSdW4gTGVmdCcsXG4gICAgcnVuUmlnaHQ6ICdSdW4gUmlnaHQnLFxuICAgIHdhbGtCYWNrOiAnV2FsayBCYWNrJyxcbiAgICBkaWU6ICdEaWUnLFxuICAgIHNwYXduOiAnU3Bhd24nLFxuICAgIGhpdDogJ0hpdCcsXG5cbiAgICAvLyBDb21wbGV4IGFuaW1pbWF0aW9uc1xuICAgIHRvcFJ1bjogJ1RvcCBSdW4nLFxuICAgIGJvdHRvbVJ1bjogJ0JvdHRvbSBSdW4nLFxuICAgIHRvcFdhbGtCYWNrOiAnVG9wIFdhbGsgQmFjaycsXG4gICAgYm90dG9tV2Fsa0JhY2s6ICdCb3R0b20gV2FsayBCYWNrJyxcbiAgICB0b3BBdHRhY2s6ICdUb3AgQXR0YWNrJyxcbiAgICBib3R0b21BdHRhY2s6ICdCb3R0b20gQXR0YWNrJyxcbiAgICB0b3BTdGFuZDogJ1RvcCBTdGFuZCcsXG4gICAgYm90dG9tU3RhbmQ6ICdCb3R0b20gU3RhbmQnLFxuICAgIHRvcFJ1blJpZ2h0OiAnVG9wIFJ1biBSaWdodCcsXG4gICAgdG9wUnVuTGVmdDogJ1RvcCBSdW4gTGVmdCcsXG4gICAgdG9wSnVtcDogJ1RvcCBKdW1wJyxcbiAgICB0b3BIaXQ6ICdUb3AgSGl0JyxcbiAgICBib3R0b21SdW5SaWdodDogJ0JvdHRvbSBSdW4gUmlnaHQnLFxuICAgIGJvdHRvbVJ1bkxlZnQ6ICdCb3R0b20gUnVuIExlZnQnLFxuICAgIGJvdHRvbUp1bXA6ICdCb3R0b20gSnVtcCcsXG4gICAgYm90dG9tSGl0OiAnQm90dG9tIEhpdCcsXG4gICAgdG9wRGllOiAnVG9wIERpZScsXG4gICAgYm90dG9tRGllOiAnQm90dG9tIERpZScsXG4gICAgdG9wU3Bhd246ICdUb3AgU3Bhd24nLFxuICAgIGJvdHRvbVNwYXduOiAnQm90dG9tIFNwYXduJyxcbn07XG5cbmNvbnN0IHRvcEFuaW1hdGlvbnMgPSBbXG4gICAgJ3RvcFJ1bicsXG4gICAgJ3RvcFdhbGtCYWNrJyxcbiAgICAndG9wQXR0YWNrJyxcbiAgICAndG9wU3RhbmQnLFxuICAgICd0b3BSdW5SaWdodCcsXG4gICAgJ3RvcFJ1bkxlZnQnLFxuICAgICd0b3BKdW1wJyxcbiAgICAndG9wSGl0JyxcbiAgICAndG9wRGllJyxcbl07XG5cbmNvbnN0IGJvdHRvbUFuaW1hdGlvbnMgPSBbXG4gICAgJ2JvdHRvbVJ1bicsXG4gICAgJ2JvdHRvbVdhbGtCYWNrJyxcbiAgICAnYm90dG9tQXR0YWNrJyxcbiAgICAnYm90dG9tU3RhbmQnLFxuICAgICdib3R0b21SdW5SaWdodCcsXG4gICAgJ2JvdHRvbVJ1bkxlZnQnLFxuICAgICdib3R0b21KdW1wJyxcbiAgICAnYm90dG9tSGl0JyxcbiAgICAnYm90dG9tRGllJyxcbl07XG5cbmNvbnN0IHRvcEJvbmVzID0gW1xuICAgICdSaWdodF9Gb3JlYXJtJyxcbiAgICAnUmlnaHRfQXJtJyxcbiAgICAnUmlnaHRfSGFuZCcsXG4gICAgJ1JpZ2h0X0hhbmRfZW5kJyxcbiAgICAnUmlnaHRfU2hvdWxkZXInLFxuICAgICdMZWZ0X1Nob3VsZGVyJyxcbiAgICAnTGVmdF9Gb3JlYXJtJyxcbiAgICAnTGVmdF9Bcm0nLFxuICAgICdMZWZ0X0hhbmQnLFxuICAgICdMZWZ0X0hhbmRfZW5kJyxcbiAgICAnQ2hlc3QnLFxuICAgICdOZWNrJyxcbiAgICAnSGVhZCcsXG4gICAgJ0hlYWRfZW5kJ1xuXTtcblxuY29uc3QgYm90dG9tQm9uZXMgPSBbXG4gICAgJ01haW5fQm9uZScsXG4gICAgJ1JpZ2h0X0xlZycsXG4gICAgJ1JpZ2h0X01pZGRsZV9Gb290JyxcbiAgICAnUmlnaHRfRm9vdCcsXG4gICAgJ1JpZ2h0X0Zvb3RfZW5kJyxcbiAgICAnTGVmdF9MZWcnLFxuICAgICdMZWZ0X01pZGRsZV9Gb290JyxcbiAgICAnTGVmdF9Gb290JyxcbiAgICAnTGVmdF9Gb290X2VuZCcsXG4gICAgJ0xlZ3NfUm90YXRpb24nLFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0ZWRHYW1lT2JqZWN0IGV4dGVuZHMgR2FtZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZXM6IHsgLi4uYW5pbWF0aW9uTmFtZXMgfSxcbiAgICAgICAgICAgIHRvcEJvbmVzOiBbLi4udG9wQm9uZXNdLFxuICAgICAgICAgICAgYm90dG9tQm9uZXM6IFsuLi5ib3R0b21Cb25lc10sXG4gICAgICAgICAgICB0b3BBbmltYXRpb25zOiBbLi4udG9wQW5pbWF0aW9uc10sXG4gICAgICAgICAgICBib3R0b21BbmltYXRpb25zOiBbLi4uYm90dG9tQW5pbWF0aW9uc10sXG4gICAgICAgICAgICBzcGF3blRpbWVvdXQ6IDEsXG4gICAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgICAgIGlzTW92aW5nRm9yd2FyZDogZmFsc2UsXG4gICAgICAgICAgICBpc01vdmluZ1JpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzTW92aW5nTGVmdDogZmFsc2UsXG4gICAgICAgICAgICBpc01vdmluZ0JhY2t3YXJkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUm90YXRlTGVmdDogZmFsc2UsXG4gICAgICAgICAgICBpc1JvdGF0ZVJpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzQXR0YWNrOiBmYWxzZSxcbiAgICAgICAgICAgIGlzSnVtcDogZmFsc2UsXG4gICAgICAgICAgICBpc0RpZTogZmFsc2UsXG4gICAgICAgICAgICBpc0hpdDogZmFsc2UsXG4gICAgICAgICAgICBpc1NwYXduOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucGxheWluZ0FuaW1hdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5sZWdzUm90YXRpb25ZID0gMDtcbiAgICAgICAgdGhpcy5zcGF3blRpbWUgPSAwO1xuXG4gICAgICAgIHRoaXMubWl4ZXIgPSBuZXcgVEhSRUUuQW5pbWF0aW9uTWl4ZXIodGhpcy5wYXJhbXMub2JqZWN0KTtcblxuICAgICAgICB0aGlzLmluaXRBbmltYXRpb25zKHRoaXMucGFyYW1zLmFuaW1hdGlvbk5hbWVzKTtcbiAgICB9XG5cbiAgICB1cGRhdGUodGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF0aGlzLnNwYXduVGltZSkge1xuICAgICAgICAgICAgdGhpcy5zcGF3blRpbWUgPSB0aW1lO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNTcGF3biAmJiB0aGlzLmlzU3Bhd25GaW5pc2hlZCh0aW1lKSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc1NwYXduID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5taXhlcikge1xuICAgICAgICAgICAgdGhpcy5taXhlci51cGRhdGUoZGVsdGFUaW1lIC8gMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wYXJhbXMuY29tcGxleEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29tcGxleEFuaW1hdGlvbnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuZ2V0Q3VycmVudEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgYW5pbWF0aW9uICYmIHRoaXMucGxheUFuaW1hdGlvbihhbmltYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGxheUFuaW1hdGlvbihhbmltYXRpb24sIHsgZm9yY2UgfSA9IHt9KSB7XG4gICAgICAgIGlmICghYW5pbWF0aW9uIHx8ICFhbmltYXRpb24uX2NsaXApIHJldHVybjtcblxuICAgICAgICBjb25zdCBhbmltYXRpb25OYW1lID0gYW5pbWF0aW9uLl9jbGlwLm5hbWU7XG4gICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9IHRoaXMucGxheWluZ0FuaW1hdGlvbk5hbWUgIT09IGFuaW1hdGlvbk5hbWUgfHwgZm9yY2U7XG5cbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5wbGF5aW5nQW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbk5hbWU7XG4gICAgICAgICAgICBhbmltYXRpb24ucmVzZXQoKTtcbiAgICAgICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBsYXlpbmdBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMucGxheWluZ0FuaW1hdGlvbjtcblxuICAgICAgICAgICAgICAgIGZyb20uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgZnJvbS5jcm9zc0ZhZGVUbyhhbmltYXRpb24sIDAuMyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGxheWluZ0FuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluaXRBbmltYXRpb25zKGFuaW1hdGlvbk5hbWVzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRvcEFuaW1hdGlvbnMsXG4gICAgICAgICAgICBib3R0b21BbmltYXRpb25zLFxuICAgICAgICAgICAgdG9wQm9uZXMsXG4gICAgICAgICAgICBib3R0b21Cb25lcyxcbiAgICAgICAgICAgIGNvbXBsZXhBbmltYXRpb25zLFxuICAgICAgICB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gT2JqZWN0LmtleXMoYW5pbWF0aW9uTmFtZXMpLnJlZHVjZShcbiAgICAgICAgICAgIChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBleGNsdWRlZEJvbmVzID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxleEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcEFuaW1hdGlvbnMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZWRCb25lcyA9IGJvdHRvbUJvbmVzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJvdHRvbUFuaW1hdGlvbnMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZWRCb25lcyA9IHRvcEJvbmVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxBbmltYXRpb24gPSB0aGlzLmZpbmRNb2RlbEFuaW1hdGlvbihhbmltYXRpb25OYW1lc1trZXldLCB7IGV4Y2x1ZGVkQm9uZXMgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGluaXRlZEFuaW1hdGlvbiA9IHRoaXMuY3JlYXRlQ2xpcEFjdGlvbihtb2RlbEFuaW1hdGlvbik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQsIFtrZXldOiBpbml0ZWRBbmltYXRpb24gfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7fVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBqdW1wLFxuICAgICAgICAgICAgICAgIGF0dGFjayxcbiAgICAgICAgICAgICAgICB0b3BBdHRhY2ssXG4gICAgICAgICAgICAgICAgZGllLFxuICAgICAgICAgICAgICAgIHNwYXduLFxuICAgICAgICAgICAgICAgIHRvcERpZSxcbiAgICAgICAgICAgICAgICBib3R0b21EaWUsXG4gICAgICAgICAgICAgICAgdG9wSnVtcCxcbiAgICAgICAgICAgICAgICBib3R0b21KdW1wLFxuICAgICAgICAgICAgICAgIGJvdHRvbUF0dGFja1xuICAgICAgICAgICAgfSA9IHt9XG4gICAgICAgIH0gPSB0aGlzO1xuXG4gICAgICAgIFtqdW1wLCBkaWUsIHNwYXduLCB0b3BEaWUsIGJvdHRvbURpZSwgdG9wSnVtcCwgYm90dG9tSnVtcF0uZm9yRWFjaCgoY2xhbXBBbmltYXRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChjbGFtcEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGNsYW1wQW5pbWF0aW9uLnNldExvb3AoVEhSRUUuTG9vcE9uY2UsIDApO1xuICAgICAgICAgICAgICAgIGNsYW1wQW5pbWF0aW9uLmNsYW1wV2hlbkZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgW2F0dGFjaywgdG9wQXR0YWNrLCBib3R0b21BdHRhY2tdLmZvckVhY2goKGF0dGFja0FuaW1hdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKGF0dGFja0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGF0dGFja0FuaW1hdGlvbi5zZXREdXJhdGlvbih0aGlzLnBhcmFtcy5hdHRhY2tUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xpcEFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbiAmJiB0aGlzLm1peGVyLmNsaXBBY3Rpb24oYWN0aW9uKS5zdG9wKCk7XG4gICAgfVxuXG4gICAgZmluZE1vZGVsQW5pbWF0aW9uKG5hbWUsIHsgZXhjbHVkZWRCb25lcyA9IFtdIH0gPSB7fSkge1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbnMgPSBbXSB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgICAgbGV0IGFuaW1hdGlvbiA9IGFuaW1hdGlvbnMuZmluZChhbmltYXRpb24gPT4gYW5pbWF0aW9uLm5hbWUgPT09IG5hbWUpO1xuXG4gICAgICAgIGlmIChhbmltYXRpb24gJiYgZXhjbHVkZWRCb25lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsZWFyQW5pbWF0aW9uQm9uZXMoYW5pbWF0aW9uLCBleGNsdWRlZEJvbmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgfVxuXG4gICAgaXNNb3ZpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLmlzTW92aW5nTGVmdFxuICAgICAgICAgICAgfHwgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ1JpZ2h0XG4gICAgICAgICAgICB8fCB0aGlzLmFuaW1hdGlvblN0YXRlLmlzTW92aW5nRm9yd2FyZFxuICAgICAgICAgICAgfHwgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ0JhY2t3YXJkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaXNTcGF3bkZpbmlzaGVkKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRpbWUgLSB0aGlzLnNwYXduVGltZSA+IHRoaXMucGFyYW1zLnNwYXduVGltZW91dCAqIDEwMDA7XG4gICAgfVxuXG4gICAgY2xlYXJBbmltYXRpb25Cb25lcyhhbmltYXRpb24sIGJvbmVzKSB7XG4gICAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGdldEJvbmVOYW1lID0gaXRlbSA9PiBpdGVtLm5hbWUuc3BsaXQoJy4nKVswXSxcbiAgICAgICAgICAgICAgICBpc05vdEV4Y2x1ZGVkID0gaXRlbSA9PiAhYm9uZXMuaW5jbHVkZXMoZ2V0Qm9uZU5hbWUoaXRlbSkpO1xuXG4gICAgICAgICAgICBhbmltYXRpb24udHJhY2tzID0gYW5pbWF0aW9uLnRyYWNrcy5maWx0ZXIoaXNOb3RFeGNsdWRlZCk7XG5cbiAgICAgICAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDb21wbGV4QW5pbWF0aW9ucygpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgIHRvcEF0dGFjaywgYm90dG9tQXR0YWNrLFxuICAgICAgICAgICAgICAgIHRvcFdhbGtCYWNrLCBib3R0b21XYWxrQmFjayxcbiAgICAgICAgICAgICAgICB0b3BSdW4sIGJvdHRvbVJ1bixcbiAgICAgICAgICAgICAgICB0b3BSdW5SaWdodCxcbiAgICAgICAgICAgICAgICB0b3BSdW5MZWZ0LFxuICAgICAgICAgICAgICAgIHRvcFN0YW5kLCBib3R0b21TdGFuZCxcbiAgICAgICAgICAgICAgICB0b3BKdW1wLCBib3R0b21KdW1wLFxuICAgICAgICAgICAgICAgIHRvcEhpdCwgYm90dG9tSGl0LFxuICAgICAgICAgICAgICAgIHRvcERpZSwgYm90dG9tRGllLFxuICAgICAgICAgICAgICAgIHRvcFNwYXduLCBib3R0b21TcGF3bixcbiAgICAgICAgICAgIH0gPSB7fVxuICAgICAgICB9ID0gdGhpcztcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpc0F0dGFjayxcbiAgICAgICAgICAgIGlzTW92aW5nUmlnaHQsXG4gICAgICAgICAgICBpc01vdmluZ0xlZnQsXG4gICAgICAgICAgICBpc01vdmluZ0JhY2t3YXJkLFxuICAgICAgICAgICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgICAgICAgaXNKdW1wLFxuICAgICAgICAgICAgaXNEaWUsXG4gICAgICAgICAgICBpc0hpdCxcbiAgICAgICAgICAgIGlzU3Bhd24sXG4gICAgICAgIH0gPSB0aGlzLmFuaW1hdGlvblN0YXRlO1xuXG4gICAgICAgIGNvbnN0IHBsYXlpbmdBbmltYXRpb25zID0ge1xuICAgICAgICAgICAgdG9wOiAoXG4gICAgICAgICAgICAgICAgKGlzRGllICYmIHRvcERpZSlcbiAgICAgICAgICAgICAgICB8fCAoaXNIaXQgJiYgdG9wSGl0KVxuICAgICAgICAgICAgICAgIHx8IChpc0F0dGFjayAmJiB0b3BBdHRhY2spXG4gICAgICAgICAgICAgICAgfHwgKGlzSnVtcCAmJiB0b3BKdW1wKVxuICAgICAgICAgICAgICAgIHx8IChpc01vdmluZ0JhY2t3YXJkICYmIGlzTW92aW5nUmlnaHQgJiYgdG9wUnVuTGVmdClcbiAgICAgICAgICAgICAgICB8fCAoaXNNb3ZpbmdCYWNrd2FyZCAmJiBpc01vdmluZ0xlZnQgJiYgdG9wUnVuUmlnaHQpXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nQmFja3dhcmQgJiYgdG9wV2Fsa0JhY2spXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nUmlnaHQgJiYgdG9wUnVuUmlnaHQpXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nTGVmdCAmJiB0b3BSdW5MZWZ0KVxuICAgICAgICAgICAgICAgIHx8IChpc01vdmluZ0ZvcndhcmQgJiYgdG9wUnVuKVxuICAgICAgICAgICAgICAgIHx8IChpc1NwYXduICYmIHRvcFNwYXduKVxuICAgICAgICAgICAgICAgIHx8ICh0b3BTdGFuZClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBib3R0b206IChcbiAgICAgICAgICAgICAgICAoaXNEaWUgJiYgYm90dG9tRGllKVxuICAgICAgICAgICAgICAgIHx8IChpc0p1bXAgJiYgYm90dG9tSnVtcClcbiAgICAgICAgICAgICAgICB8fCAoaXNNb3ZpbmdCYWNrd2FyZCAmJiBpc01vdmluZ1JpZ2h0ICYmIGJvdHRvbVdhbGtCYWNrKVxuICAgICAgICAgICAgICAgIHx8IChpc01vdmluZ0JhY2t3YXJkICYmIGlzTW92aW5nTGVmdCAmJiBib3R0b21XYWxrQmFjaylcbiAgICAgICAgICAgICAgICB8fCAoaXNNb3ZpbmdCYWNrd2FyZCAmJiBib3R0b21XYWxrQmFjaylcbiAgICAgICAgICAgICAgICB8fCAoaXNNb3ZpbmdSaWdodCAmJiBib3R0b21SdW4pXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nTGVmdCAmJiBib3R0b21SdW4pXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nRm9yd2FyZCAmJiBib3R0b21SdW4pXG4gICAgICAgICAgICAgICAgfHwgKGlzQXR0YWNrICYmIGJvdHRvbUF0dGFjaylcbiAgICAgICAgICAgICAgICB8fCAoaXNIaXQgJiYgYm90dG9tSGl0KVxuICAgICAgICAgICAgICAgIHx8IChpc1NwYXduICYmIGJvdHRvbVNwYXduKVxuICAgICAgICAgICAgICAgIHx8IChib3R0b21TdGFuZClcbiAgICAgICAgICAgICksXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbGVnc1JvdGF0aW9uQm9uZSA9IHRoaXMuZ2V0Q2hpbGRCeU5hbWUoJ0xlZ3NfUm90YXRpb24nKTtcbiAgICAgICAgaWYgKGxlZ3NSb3RhdGlvbkJvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcm90YXRpb24gfSA9IGxlZ3NSb3RhdGlvbkJvbmU7XG4gICAgICAgICAgICBsZXQgeSA9IC0wLjM7XG5cbiAgICAgICAgICAgIGlmIChpc01vdmluZ0xlZnQpIHtcbiAgICAgICAgICAgICAgICB5ID0gaXNNb3ZpbmdGb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgID8gMC41XG4gICAgICAgICAgICAgICAgICAgIDogaXNNb3ZpbmdCYWNrd2FyZCA/IC0wLjcgOiAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01vdmluZ1JpZ2h0KSB7XG4gICAgICAgICAgICAgICAgeSA9IGlzTW92aW5nRm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICA/IC0xLjJcbiAgICAgICAgICAgICAgICAgICAgOiBpc01vdmluZ0JhY2t3YXJkID8gMC40IDogLTEuNztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sZWdzUm90YXRpb25ZID0gdGhpcy5sZWdzUm90YXRpb25ZIC0gKHRoaXMubGVnc1JvdGF0aW9uWSAtIHkpIC8gMTA7XG4gICAgICAgICAgICByb3RhdGlvbi5zZXQocm90YXRpb24ueCwgdGhpcy5sZWdzUm90YXRpb25ZLCByb3RhdGlvbi56KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmxlbmRBbmltYXRpb25zKHBsYXlpbmdBbmltYXRpb25zKTtcbiAgICB9XG5cbiAgICBibGVuZEFuaW1hdGlvbnMoeyB0b3AsIGJvdHRvbSB9KSB7XG4gICAgICAgIGlmICghKHRvcCAmJiBib3R0b20gJiYgdG9wLl9jbGlwICYmIGJvdHRvbS5fY2xpcCkpIHJldHVybjtcblxuICAgICAgICBjb25zdCBnZXRBbmltYXRpb25OYW1lID0gYSA9PiBhLl9jbGlwLm5hbWUsXG4gICAgICAgICAgICBwbGF5QW5pbWF0aW9uID0gKGZyb21BbmltYXRpb24sIGFuaW1hdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbk5hbWUgPSBnZXRBbmltYXRpb25OYW1lKGFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbUFuaW1hdGlvbk5hbWUgPSBmcm9tQW5pbWF0aW9uICYmIGdldEFuaW1hdGlvbk5hbWUoZnJvbUFuaW1hdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoZnJvbUFuaW1hdGlvbk5hbWUgIT09IGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21BbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21BbmltYXRpb24uY3Jvc3NGYWRlVG8oYW5pbWF0aW9uLCAwLjMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBwbGF5QW5pbWF0aW9uKHRoaXMucGxheWluZ0FuaW1hdGlvbnMudG9wLCB0b3ApO1xuICAgICAgICBwbGF5QW5pbWF0aW9uKHRoaXMucGxheWluZ0FuaW1hdGlvbnMuYm90dG9tLCBib3R0b20pO1xuXG4gICAgICAgIHRoaXMucGxheWluZ0FuaW1hdGlvbnMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLnBsYXlpbmdBbmltYXRpb25zLmJvdHRvbSA9IGJvdHRvbTtcbiAgICB9XG5cbiAgICBnZXRDdXJyZW50QW5pbWF0aW9uKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgc3RhbmQsXG4gICAgICAgICAgICAgICAgYXR0YWNrLFxuICAgICAgICAgICAgICAgIHdhbGtCYWNrLFxuICAgICAgICAgICAgICAgIHJ1bkxlZnQsXG4gICAgICAgICAgICAgICAgcnVuUmlnaHQsXG4gICAgICAgICAgICAgICAgcnVuLFxuICAgICAgICAgICAgICAgIGp1bXAsXG4gICAgICAgICAgICAgICAgaGl0LFxuICAgICAgICAgICAgICAgIHJvdGF0ZUxlZnQsXG4gICAgICAgICAgICAgICAgcm90YXRlUmlnaHQsXG4gICAgICAgICAgICAgICAgZGllLFxuICAgICAgICAgICAgICAgIHNwYXduLFxuICAgICAgICAgICAgfSA9IHt9XG4gICAgICAgIH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlzQXR0YWNrLFxuICAgICAgICAgICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgICAgICAgaXNKdW1wLFxuICAgICAgICAgICAgaXNNb3ZpbmdMZWZ0LFxuICAgICAgICAgICAgaXNNb3ZpbmdSaWdodCxcbiAgICAgICAgICAgIGlzTW92aW5nQmFja3dhcmQsXG4gICAgICAgICAgICBpc1JvdGF0ZUxlZnQsXG4gICAgICAgICAgICBpc1JvdGF0ZVJpZ2h0LFxuICAgICAgICAgICAgaXNEaWUsXG4gICAgICAgICAgICBpc0hpdCxcbiAgICAgICAgICAgIGlzU3Bhd24sXG4gICAgICAgIH0gPSB0aGlzLmFuaW1hdGlvblN0YXRlO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoaXNEaWUgJiYgZGllKVxuICAgICAgICAgICAgfHwgKGlzSGl0ICYmIGhpdClcbiAgICAgICAgICAgIHx8IChpc0F0dGFjayAmJiBhdHRhY2spXG4gICAgICAgICAgICB8fCAoaXNKdW1wICYmIGp1bXApXG4gICAgICAgICAgICB8fCAoaXNNb3ZpbmdCYWNrd2FyZCAmJiB3YWxrQmFjaylcbiAgICAgICAgICAgIHx8IChpc01vdmluZ0xlZnQgJiYgcnVuTGVmdClcbiAgICAgICAgICAgIHx8IChpc01vdmluZ1JpZ2h0ICYmIHJ1blJpZ2h0KVxuICAgICAgICAgICAgfHwgKGlzTW92aW5nRm9yd2FyZCAmJiBydW4pXG4gICAgICAgICAgICB8fCAoaXNSb3RhdGVMZWZ0ICYmIHJvdGF0ZUxlZnQpXG4gICAgICAgICAgICB8fCAoaXNSb3RhdGVSaWdodCAmJiByb3RhdGVSaWdodClcbiAgICAgICAgICAgIHx8IChpc1NwYXduICYmIHNwYXduKVxuICAgICAgICAgICAgfHwgc3RhbmRcbiAgICAgICAgKTtcbiAgICB9XG59IiwiaW1wb3J0IFVuaXQgZnJvbSAnLi9Vbml0JztcbmltcG9ydCBNb3ZpbmdHYW1lT2JqZWN0IGZyb20gJy4vTW92aW5nR2FtZU9iamVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpcmUgZXh0ZW5kcyBNb3ZpbmdHYW1lT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbXMpO1xuXG4gICAgICAgIHRoaXMucGFyYW1zLmFjY2VsZXJhdGlvbi5hZGQoXG4gICAgICAgICAgICB0aGlzLmdldEZvcndhcmQoKS5tdWx0aXBseVNjYWxhcih0aGlzLnBhcmFtcy5zcGVlZCAqIDAuMSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB1cGRhdGUodGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpO1xuXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5nZXRDb2xsaXNpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xsaXNpb25zID0gdGhpcy5wYXJhbXMuZ2V0Q29sbGlzaW9ucyh0aGlzKTtcblxuICAgICAgICAgICAgY29sbGlzaW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGNvbGxpc2lvbkdhbWVPYmplY3QpID0+IChcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uR2FtZU9iamVjdCBpbnN0YW5jZW9mIFVuaXRcbiAgICAgICAgICAgICAgICAgICAgJiYgY29sbGlzaW9uR2FtZU9iamVjdC5pc0VuZW15KHRoaXMucGFyYW1zLnBhcmVudClcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGNvbGxpc2lvbkdhbWVPYmplY3QgPT4gKFxuICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25HYW1lT2JqZWN0LmRhbWFnZVRha2VuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhbWFnZTogdGhpcy5wYXJhbXMuZGFtYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pdDogdGhpcy5wYXJhbXMucGFyZW50LFxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lKVxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICBpZiAoY29sbGlzaW9ucy5sZW5ndGggJiYgdGhpcy5wYXJhbXMuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IFVuaXQgZnJvbSAnLi9Vbml0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlyaW5nVW5pdCBleHRlbmRzIFVuaXQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGZpcmVEYW1hZ2U6IDEwLFxuICAgICAgICAgICAgZmlyZVRpbWVvdXQ6IDEuNSxcbiAgICAgICAgICAgIGZpcmVTaGVsbFNwZWVkOiAzLFxuICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2hvdWxkRmlyZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhdGVzdEZpcmUgPSAwO1xuICAgIH1cblxuICAgIGdldEZpcmVJbml0aWFsUG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLmNsb25lKCkuYWRkKFxuICAgICAgICAgICAgdGhpcy5nZXRVcCgpXG4gICAgICAgICAgICAgICAgLm11bHRpcGx5U2NhbGFyKDEuNSlcbiAgICAgICAgICAgICAgICAuYWRkKHRoaXMuZ2V0Rm9yd2FyZCgpLm11bHRpcGx5U2NhbGFyKDAuMykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICBzdXBlci51cGRhdGUodGltZSwgZGVsdGFUaW1lKTtcblxuICAgICAgICBpZiAodGhpcy5pc0RlYWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0ZpcmUgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5zaG91bGRGaXJlICYmIHRoaXMucGFyYW1zLmZpcmUgJiYgdGhpcy5pc0ZpcmVSZWxlYXNlZCh0aW1lKSAmJiB0aGlzLmlzQXR0YWNrUmVsZWFzZWQodGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGaXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkRmlyZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RGaXJlID0gdGltZTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLmZpcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkRmlyZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNGaXJlUmVsZWFzZWQodGltZSkge1xuICAgICAgICByZXR1cm4gdGltZSAtIHRoaXMubGF0ZXN0RmlyZSA+PSB0aGlzLnBhcmFtcy5maXJlVGltZW91dCAqIDEwMDA7XG4gICAgfVxuXG4gICAgZmlyZSgpIHtcbiAgICAgICAgdGhpcy5zaG91bGRGaXJlID0gdHJ1ZTtcbiAgICB9XG59IiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuLi9BdXRvQmluZE1ldGhvZHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lT2JqZWN0IGV4dGVuZHMgQXV0b0JpbmRNZXRob2RzIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHsgLi4ucGFyYW1zIH07XG4gICAgICAgIHRoaXMub2JqZWN0ID0gcGFyYW1zLm9iamVjdDtcblxuICAgICAgICBpZiAocGFyYW1zLm9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBhcmFtcy5vYmplY3QucG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gcGFyYW1zLm9iamVjdC5yb3RhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSBhcmdzXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayguLi5hcmdzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENoaWxkQnlOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0LmdldE9iamVjdEJ5TmFtZShuYW1lLCB0cnVlKTtcbiAgICB9XG5cbiAgICBnZXRDaGlsZERpcmVjdGlvbihhcmcsIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gdGhpcy5nZXRDaGlsZEJ5TmFtZShhcmcpXG4gICAgICAgICAgICA6IGFyZztcblxuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbih0aGlzLmdldENoaWxkUm90YXRpb24oY2hpbGQpKTtcbiAgICB9XG5cbiAgICBnZXRDaGlsZFBvc2l0aW9uKGFyZykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHRoaXMuZ2V0Q2hpbGRCeU5hbWUoYXJnKVxuICAgICAgICAgICAgOiBhcmc7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGNoaWxkLm1hdHJpeFdvcmxkKTtcbiAgICB9XG5cbiAgICBnZXRDaGlsZFJvdGF0aW9uKGFyZykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHRoaXMuZ2V0Q2hpbGRCeU5hbWUoYXJnKVxuICAgICAgICAgICAgOiBhcmc7XG5cbiAgICAgICAgbGV0IHRhcmdldCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gICAgICAgIGNoaWxkLmdldFdvcmxkUXVhdGVybmlvbih0YXJnZXQpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxufSIsImltcG9ydCBBbmltYXRlZEdhbWVPYmplY3QgZnJvbSAnLi9BbmltYXRlZEdhbWVPYmplY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3ZpbmdHYW1lT2JqZWN0IGV4dGVuZHMgQW5pbWF0ZWRHYW1lT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBzcGVlZDogMC4xLFxuICAgICAgICAgICAgdGhyb3R0bGluZzogbmV3IFRIUkVFLlZlY3RvcjMoMC41LCAwLjk1LCAwLjUpLFxuICAgICAgICAgICAgYWNjZWxlcmF0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgbWFzOiAwLFxuICAgICAgICAgICAgY2hlY2tXYXk6ICgpID0+IHRydWUsXG4gICAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICBzdXBlci51cGRhdGUodGltZSwgZGVsdGFUaW1lKTtcbiAgICAgICAgY29uc3QgeyBwYXJhbXM6IHsgYWNjZWxlcmF0aW9uLCB0aHJvdHRsaW5nIH0gfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLm1hcykge1xuICAgICAgICAgICAgYWNjZWxlcmF0aW9uLnkgLT0gMC4wMTtcblxuICAgICAgICAgICAgdGhpcy5pc0dyb3VuZGVkID0gIXRoaXMuY2hlY2tXYXkoMCwgLTAuMiwgMCk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLmlzSnVtcCA9ICF0aGlzLmlzR3JvdW5kZWQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGlzWCA9IEJvb2xlYW4oYWNjZWxlcmF0aW9uLngpICYmIHRoaXMuY2hlY2tXYXkoYWNjZWxlcmF0aW9uLngsIDAsIDApO1xuICAgICAgICBjb25zdCBpc1kgPSBCb29sZWFuKGFjY2VsZXJhdGlvbi55KSAmJiB0aGlzLmNoZWNrV2F5KDAsIGFjY2VsZXJhdGlvbi55LCAwKTtcbiAgICAgICAgY29uc3QgaXNaID0gQm9vbGVhbihhY2NlbGVyYXRpb24ueikgJiYgdGhpcy5jaGVja1dheSgwLCAwLCBhY2NlbGVyYXRpb24ueik7XG5cbiAgICAgICAgaWYgKCFpc1ggfHwgIWlzWSB8fCAhaXNaKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyYW1zLm1hcykge1xuICAgICAgICAgICAgICAgIC8vIFN0b3Agb2JqZWN0IHNtb290aGx5IGJlY2F1c2Ugb2YgQ29sbGlkZXIgaGl0XG4gICAgICAgICAgICAgICAgYWNjZWxlcmF0aW9uLm11bHRpcGx5U2NhbGFyKDAuNzUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzWCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2xpbWJpbmcgPSAoYWNjZWxlcmF0aW9uLnggJiYgYWNjZWxlcmF0aW9uLnkgPD0gMCAmJiB0aGlzLmNoZWNrV2F5KGFjY2VsZXJhdGlvbi54LCAwLjA0LCAwKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNDbGltYmluZykge1xuICAgICAgICAgICAgICAgICAgICBhY2NlbGVyYXRpb24ueSA9IDAuMDQgLyB0aHJvdHRsaW5nLnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZWxlcmF0aW9uLnggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc1kpIHsgYWNjZWxlcmF0aW9uLnkgPSAwOyB9XG5cbiAgICAgICAgICAgIGlmICghaXNaKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDbGltYmluZyA9IChhY2NlbGVyYXRpb24ueiAmJiBhY2NlbGVyYXRpb24ueSA8PSAwICYmIHRoaXMuY2hlY2tXYXkoMCwgMC4wNCwgYWNjZWxlcmF0aW9uLnopKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0NsaW1iaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VsZXJhdGlvbi55ID0gMC4wNCAvIHRocm90dGxpbmcueTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2NlbGVyYXRpb24ueiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWNjZWxlcmF0aW9uLnggKj0gdGhyb3R0bGluZy54O1xuICAgICAgICBhY2NlbGVyYXRpb24ueSAqPSB0aHJvdHRsaW5nLnk7XG4gICAgICAgIGFjY2VsZXJhdGlvbi56ICo9IHRocm90dGxpbmcuejtcblxuICAgICAgICBjb25zdCBpc01vdmluZyA9IChcbiAgICAgICAgICAgIE1hdGguYWJzKGFjY2VsZXJhdGlvbi54KSA+IDAuMDAxXG4gICAgICAgICAgICB8fCBNYXRoLmFicyhhY2NlbGVyYXRpb24ueSkgPiAwLjAwMVxuICAgICAgICAgICAgfHwgTWF0aC5hYnMoYWNjZWxlcmF0aW9uLnopID4gMC4wMDFcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNNb3ZpbmcpIHtcbiAgICAgICAgICAgIC8vIGFjY2VsZXJhdGlvbi5tdWx0aXBseVNjYWxhcihkZWx0YVRpbWUgKiA2MClcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkKGFjY2VsZXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja1dheSh4ID0gMCwgeSA9IDAsIHogPSAwKSB7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb24sIHBhcmFtczogeyBjaGVja1dheSB9IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhwb3NpdGlvbi54ICsgeCwgcG9zaXRpb24ueSArIHkgKyAwLjEsIHBvc2l0aW9uLnogKyB6KTtcblxuICAgICAgICByZXR1cm4gY2hlY2tXYXkobmV4dFBvc2l0aW9uLCB0aGlzKTtcbiAgICB9XG5cbiAgICBnZXRMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREaXJlY3Rpb24obmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMCkpO1xuICAgIH1cblxuICAgIGdldFVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREaXJlY3Rpb24obmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCkpO1xuICAgIH1cblxuICAgIGdldEZvcndhcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERpcmVjdGlvbihuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICBnZXREaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgICAgIGRpcmVjdGlvbi5hcHBseVF1YXRlcm5pb24odGhpcy5vYmplY3QucXVhdGVybmlvbik7XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfVxuXG4gICAgZ2V0U2NhbGFyQWNjZWxlcmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuYWNjZWxlcmF0aW9uLnRvQXJyYXkoKVxuICAgICAgICAgICAgLm1hcChNYXRoLmFicylcbiAgICAgICAgICAgIC5yZWR1Y2UoKHIsIHYpID0+IHIgKyB2LCAwKVxuICAgIH1cbn0iLCJpbXBvcnQgRmlyaW5nVW5pdCBmcm9tICcuL0ZpcmluZ1VuaXQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF5ZXIgZXh0ZW5kcyBGaXJpbmdVbml0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBzcGVlZDogMC41NCxcbiAgICAgICAgICAgIGZpcmVUaW1lb3V0OiAxLFxuICAgICAgICAgICAgZmlyZURhbWFnZTogMjUsXG4gICAgICAgICAgICBkYW1hZ2U6IDUwLFxuICAgICAgICAgICAgaHA6IDEwMCxcbiAgICAgICAgICAgIGV4cGVyaWVuY2U6IDAsXG4gICAgICAgICAgICB1bnNwZW50VGFsZW50czogMCxcbiAgICAgICAgICAgIG1vbmV5OiA1MDAsXG4gICAgICAgICAgICBpc0ZpcmU6IGZhbHNlLFxuICAgICAgICAgICAgbWFzOiAxLFxuICAgICAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgICAgICBqdW1wVGltZW91dDogMC45LFxuICAgICAgICAgICAgZnJhY3Rpb246ICdmcmllbmRseScsXG4gICAgICAgICAgICBzZW5zaXRpdml0eTogMSxcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sYXN0SnVtcFRpbWVzdGFtcCA9IDA7XG4gICAgICAgIHRoaXMucm90YXRpb25BY2NlbGVyYXRpb24gPSAwO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdQbGF5ZXInLCB0aGlzKTtcblxuICAgICAgICBwYXJhbXMub25MZXZlbFVwICYmIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignb25MZXZlbFVwJywgcGFyYW1zLm9uTGV2ZWxVcCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICBzdXBlci51cGRhdGUodGltZSwgZGVsdGFUaW1lKTtcblxuICAgICAgICBpZiAodGhpcy5pc0RlYWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBpbnB1dCwgb2JqZWN0LCBhY2NlbGVyYXRpb24sIGZyb21OZXR3b3JrIH0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgICBhY2NlbGVyYXRpb24uYWRkKHRoaXMuZ2V0TW92aW5nQWNjZWxlcmF0aW9uKHRpbWUsIGRlbHRhVGltZSkpO1xuXG4gICAgICAgIGlmIChpbnB1dC5hdHRhY2sxKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0LmF0dGFjazIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ0xlZnQgPSBpbnB1dC5ob3Jpem9udGFsID09PSAtMTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ1JpZ2h0ID0gaW5wdXQuaG9yaXpvbnRhbCA9PT0gMTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ0ZvcndhcmQgPSBpbnB1dC52ZXJ0aWNhbCA9PT0gMTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ0JhY2t3YXJkID0gaW5wdXQudmVydGljYWwgPT09IC0xO1xuXG4gICAgICAgIGlmICghZnJvbU5ldHdvcmspIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5pc1RoaXJkUGVyc29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Lmxvb2suaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3Jpem9udGFsTG9vayA9IGlucHV0Lmxvb2suaG9yaXpvbnRhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc1JvdGF0ZUxlZnQgPSBob3Jpem9udGFsTG9vayA8IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNSb3RhdGVSaWdodCA9IGhvcml6b250YWxMb29rID4gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbkFjY2VsZXJhdGlvbiArPSAoLWhvcml6b250YWxMb29rIC8gNTAwMCkgKiBpbnB1dC5sb29rLnNlbnNpdGl2aXR5O1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5yZXNldEhvcml6b250YWxMb29rKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgQ0FMQ19ST1RBVEVfVEhSRVNIT0xEID0gMC4wMDAwMDAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMucm90YXRpb25BY2NlbGVyYXRpb24pID4gQ0FMQ19ST1RBVEVfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5yb3RhdGVPbldvcmxkQXhpcyhuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSwgdGhpcy5yb3RhdGlvbkFjY2VsZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb25BY2NlbGVyYXRpb24gKj0gMC43O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFYID0gd2luZG93LmlubmVyV2lkdGggLyAyIC0gaW5wdXQuY3Vyc29yLng7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFZID0gaW5wdXQuY3Vyc29yLnkgLSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdGF0aW9uWSA9IE1hdGguYXRhbjIoZGVsdGFZLCBkZWx0YVgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc1JvdGF0ZUxlZnQgPSByb3RhdGlvblkgPiBvYmplY3Qucm90YXRpb24ueTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLmlzUm90YXRlUmlnaHQgPSByb3RhdGlvblkgPCBvYmplY3Qucm90YXRpb24ueTtcblxuICAgICAgICAgICAgICAgIG9iamVjdC5yb3RhdGlvbi5zZXQoMCwgcm90YXRpb25ZLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFVuc3BlbnRUYWxlbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMudW5zcGVudFRhbGVudHM7XG4gICAgfVxuXG4gICAgZGVjcmVhc2VVbnNwZW50VGFsZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLnVuc3BlbnRUYWxlbnRzLS07XG4gICAgfVxuXG4gICAgZ2V0RmlyZUluaXRpYWxQb3NpdGlvbigpIHtcbiAgICAgICAgY29uc3QgaGVhZCA9IHRoaXMuZ2V0Q2hpbGRCeU5hbWUoJ0hlYWQnKTtcbiAgICAgICAgY29uc3QgaGVhZEZvcndhcmQgPSB0aGlzLmdldENoaWxkRGlyZWN0aW9uKGhlYWQsIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpKTtcbiAgICAgICAgY29uc3QgaGVhZFVwID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCk7XG4gICAgICAgIGhlYWRVcC5hcHBseVF1YXRlcm5pb24oaGVhZC5xdWF0ZXJuaW9uKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZFBvc2l0aW9uKGhlYWQpXG4gICAgICAgICAgICAuYWRkKGhlYWRVcC5tdWx0aXBseVNjYWxhcigwLjE1KSlcbiAgICAgICAgICAgIC5hZGQoaGVhZEZvcndhcmQubXVsdGlwbHlTY2FsYXIoMC4yNSkpO1xuICAgIH1cblxuICAgIGdldEZpcmVJbml0aWFsUm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENoaWxkUm90YXRpb24oJ0hlYWQnKTtcbiAgICB9XG5cbiAgICBhZGRFeHBlcmllbmNlKGV4cGVyaWVuY2UpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMuZXhwZXJpZW5jZSArPSBleHBlcmllbmNlO1xuXG4gICAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5nZXRMZXZlbCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5sZXZlbCAhPT0gbGV2ZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsc1VwID0gbGV2ZWwgLSB0aGlzLnBhcmFtcy5sZXZlbDtcblxuICAgICAgICAgICAgdGhpcy5wYXJhbXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLnVuc3BlbnRUYWxlbnRzICs9IDMgKiBsZXZlbHNVcDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLmhwID0gdGhpcy5wYXJhbXMuaHBNYXg7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ29uTGV2ZWxVcCcsIGxldmVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEV4cGVyaWVuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5leHBlcmllbmNlO1xuICAgIH1cblxuICAgIGdldExldmVsRXhwZXJpZW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHRoaXMuZ2V0TGV2ZWwoKSwgMikgKiAxMDA7XG4gICAgfVxuXG4gICAgZ2V0TGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGguc3FydCh0aGlzLnBhcmFtcy5leHBlcmllbmNlIC8gMTAwKSkgKyAxO1xuICAgIH1cblxuICAgIGdldE1vdmluZ0FjY2VsZXJhdGlvbih0aW1lLCBkZWx0YVRpbWUpIHtcbiAgICAgICAgY29uc3QgeyBpbnB1dDogeyBob3Jpem9udGFsLCB2ZXJ0aWNhbCwganVtcCB9IH0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgICBjb25zdCBzcGVlZCA9IHZlcnRpY2FsICYmIGhvcml6b250YWxcbiAgICAgICAgICAgID8gdGhpcy5wYXJhbXMuc3BlZWQgKiAwLjEgKiAwLjcgKiAoZGVsdGFUaW1lICogMC4wNilcbiAgICAgICAgICAgIDogdGhpcy5wYXJhbXMuc3BlZWQgKiAwLjEgKiAoZGVsdGFUaW1lICogMC4wNik7XG5cbiAgICAgICAgY29uc3QgYWRkRm9yd2FyZCA9IHZlcnRpY2FsID09PSAxXG4gICAgICAgICAgICA/IHNwZWVkXG4gICAgICAgICAgICA6ICh2ZXJ0aWNhbCA9PT0gLTEgPyAtc3BlZWQgKiAwLjYgOiAwKTtcblxuICAgICAgICBjb25zdCBhZGRTaWRlID0gdmVydGljYWwgPT09IC0xXG4gICAgICAgICAgICA/ICgtaG9yaXpvbnRhbCAqIHNwZWVkICogMC42KVxuICAgICAgICAgICAgOiAoLWhvcml6b250YWwgKiBzcGVlZCApO1xuXG4gICAgICAgIGNvbnN0IGlzSnVtcCA9IChcbiAgICAgICAgICAgIHRpbWUgLSB0aGlzLmxhc3RKdW1wVGltZXN0YW1wID4gdGhpcy5wYXJhbXMuanVtcFRpbWVvdXQgKiAxMDAwXG4gICAgICAgICAgICAmJiBqdW1wXG4gICAgICAgICAgICAmJiB0aGlzLmlzR3JvdW5kZWRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNKdW1wKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RKdW1wVGltZXN0YW1wID0gdGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldERpcmVjdGlvbihuZXcgVEhSRUUuVmVjdG9yMyhhZGRTaWRlLCBOdW1iZXIoaXNKdW1wKSAqIDAuMjUsIGFkZEZvcndhcmQpKTtcbiAgICB9XG59IiwiaW1wb3J0IE1vdmluZ0dhbWVPYmplY3QgZnJvbSAnLi9Nb3ZpbmdHYW1lT2JqZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5pdCBleHRlbmRzIE1vdmluZ0dhbWVPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGhwOiAxMDAsXG4gICAgICAgICAgICBocE1heDogcGFyYW1zLmhwIHx8IDEwMCxcbiAgICAgICAgICAgIGRhbWFnZTogMTAsXG4gICAgICAgICAgICBhdHRhY2tUaW1lb3V0OiAwLjksXG4gICAgICAgICAgICBoaXRUaW1lOiAwLjMsXG4gICAgICAgICAgICBhdHRhY2tEYW1hZ2VUaW1lb3V0OiAwLjMsXG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2hvdWxkQXR0YWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGF0ZXN0QXR0YWNrVGltZXN0YW1wID0gMDtcbiAgICAgICAgdGhpcy5sYXRlc3RIaXRUaW1lc3RhbXAgPSAwO1xuXG4gICAgICAgIFsnb25EYW1hZ2VUYWtlbicsICdvbkRhbWFnZURlYWwnLCAnb25LaWxsJywgJ29uRGllJ10uZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1tldmVudE5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcGFyYW1zW2V2ZW50TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGUodGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRGVhZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoaXRSZWxlYXNlZCA9IHRoaXMuaXNIaXRSZWxlYXNlZCh0aW1lKTtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLmlzSGl0ID0gIWhpdFJlbGVhc2VkO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNrUmVsZWFzZWQodGltZSkgJiYgaGl0UmVsZWFzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNBdHRhY2sgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkQXR0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc0F0dGFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RBdHRhY2tUaW1lc3RhbXAgPSB0aW1lO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLmF0dGFjayAmJiB0aGlzLnBhcmFtcy5hdHRhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQXR0YWNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGcmFjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmZyYWN0aW9uO1xuICAgIH1cblxuICAgIGdldENvbGxpZGVyKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IGRpZmZZID0gcG9zaXRpb24ueSAtIHRoaXMucG9zaXRpb24ueTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgIE1hdGgucG93KHBvc2l0aW9uLnggLSB0aGlzLnBvc2l0aW9uLngsIDIpXG4gICAgICAgICAgICAgICAgKyBNYXRoLnBvdyhwb3NpdGlvbi56IC0gdGhpcy5wb3NpdGlvbi56LCAyKVxuICAgICAgICAgICAgKSA8IDFcbiAgICAgICAgICAgICYmIGRpZmZZID49IDBcbiAgICAgICAgICAgICYmIGRpZmZZIDwgMS43XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVsZWFzZUF0dGFjayh0aW1lKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0QXR0YWNrVGltZXN0YW1wID0gdGltZSAtIHRoaXMucGFyYW1zLmF0dGFja1RpbWVvdXQgKiAxMDAwO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLmlzQXR0YWNrID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaXNBdHRhY2tSZWxlYXNlZCh0aW1lKSB7XG4gICAgICAgIHJldHVybiAodGltZSAtIHRoaXMubGF0ZXN0QXR0YWNrVGltZXN0YW1wID49IHRoaXMucGFyYW1zLmF0dGFja1RpbWVvdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBpc0F0dGFja0ludGVycnVwdGVkKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aW1lIC0gdGhpcy5sYXRlc3RIaXRUaW1lc3RhbXAgPD0gdGhpcy5wYXJhbXMuYXR0YWNrRGFtYWdlVGltZW91dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGlzSGl0UmVsZWFzZWQodGltZSkge1xuICAgICAgICByZXR1cm4gKHRpbWUgLSB0aGlzLmxhdGVzdEhpdFRpbWVzdGFtcCA+PSB0aGlzLnBhcmFtcy5oaXRUaW1lICogMTAwMCk7XG4gICAgfVxuXG4gICAgYXR0YWNrKCkge1xuICAgICAgICB0aGlzLnNob3VsZEF0dGFjayA9IHRydWU7XG4gICAgfVxuXG4gICAgaXNEZWFkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuaHAgPD0gMDtcbiAgICB9XG5cbiAgICBpc0FsaXZlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNEZWFkKCk7XG4gICAgfVxuICAgIFxuICAgIGlzRW5lbXkodW5pdCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdW5pdC5wYXJhbXMuZnJhY3Rpb24gIT09IHRoaXMucGFyYW1zLmZyYWN0aW9uXG4gICAgICAgICAgICAmJiB1bml0LnBhcmFtcy5mcmFjdGlvbiAhPT0gJ25ldXRyYWwnXG4gICAgICAgICAgICAmJiB0aGlzLnBhcmFtcy5mcmFjdGlvbiAhPT0gJ25ldXRyYWwnXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0TGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5sZXZlbDtcbiAgICB9XG5cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMubmFtZTtcbiAgICB9XG5cbiAgICBnZXRBdHRhY2tUaW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuYXR0YWNrRGFtYWdlVGltZW91dCAqIDEwMDA7XG4gICAgfVxuXG4gICAgZGFtYWdlVGFrZW4oeyBkYW1hZ2UsIHVuaXQ6IGF0dGFja2VyIH0gPSB7fSwgdGltZSkge1xuICAgICAgICBpZiAoZGFtYWdlICYmIGF0dGFja2VyKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5ocCAtPSBkYW1hZ2U7XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnb25EYW1hZ2VUYWtlbicsIGF0dGFja2VyKTtcblxuICAgICAgICAgICAgaWYgKGF0dGFja2VyKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNrZXIuZGlzcGF0Y2hFdmVudCgnb25EYW1hZ2VEZWFsJywgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGludGVycnVwdEJ5Q2hhbmNlID0gTWF0aC5yYW5kb20oKSA8IDAuMzM7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnJ1cHRCeUxldmVsID0gYXR0YWNrZXIuZ2V0TGV2ZWwoKSAtIHRoaXMuZ2V0TGV2ZWwoKSA+IDI7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUludGVycnVwdGVkID0gaW50ZXJydXB0QnlMZXZlbCB8fCBpbnRlcnJ1cHRCeUNoYW5jZTtcblxuICAgICAgICAgICAgaWYgKHNob3VsZEJlSW50ZXJydXB0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEhpdFRpbWVzdGFtcCA9IHRpbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGVhZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWUoYXR0YWNrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGllKGtpbGxpbmdVbml0KSB7XG4gICAgICAgIHRoaXMucGFyYW1zLmhwID0gMDtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdvbkRpZScsIGtpbGxpbmdVbml0KTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc0RpZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGtpbGxpbmdVbml0KSB7XG4gICAgICAgICAgICBraWxsaW5nVW5pdC5kaXNwYXRjaEV2ZW50KCdvbktpbGwnLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFNwZWVkKHNwZWVkKSB7XG4gICAgICAgIHRoaXMucGFyYW1zLnNwZWVkICs9IHNwZWVkO1xuICAgIH1cblxuICAgIGFkZERhbWFnZShkYW1hZ2UpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMuZGFtYWdlICs9IGRhbWFnZTtcbiAgICB9XG5cbiAgICBhZGRIUChocCkge1xuICAgICAgICBpZiAodGhpcy5pc0FsaXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLmhwID0gTWF0aC5taW4odGhpcy5wYXJhbXMuaHAgKyBocCwgdGhpcy5wYXJhbXMuaHBNYXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TW9uZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5tb25leTtcbiAgICB9XG5cbiAgICBhZGRNb25leShtb25leSkge1xuICAgICAgICB0aGlzLnBhcmFtcy5tb25leSArPSBtb25leTtcbiAgICB9XG5cbiAgICBhZGRNYXhIUChocCkge1xuICAgICAgICBpZiAodGhpcy5pc0FsaXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLmhwTWF4ICs9IGhwO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMuaHAgKz0gaHA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRIUCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmhwO1xuICAgIH1cblxuICAgIGdldE1heEhQKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuaHBNYXg7XG4gICAgfVxuXG4gICAgZ2V0U3BlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5zcGVlZDtcbiAgICB9XG5cbiAgICBnZXREYW1hZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5kYW1hZ2U7XG4gICAgfVxufSIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuXG5jb25zdCBLRVlTID0ge1xuICAgIE1PVVNFX0xFRlQ6IDEsXG4gICAgTU9VU0VfUklHSFQ6IDMsXG4gICAgU1BBQ0U6IDMyLFxuICAgIEVOVEVSOiAxMyxcbiAgICBFU0M6IDI3LFxuICAgIEM6IDY3LFxuICAgIFc6IDg3LFxuICAgIEE6IDY1LFxuICAgIFM6IDgzLFxuICAgIEQ6IDY4LFxuICAgIFg6IDg4LFxuICAgIFo6IDkwLFxuICAgIFE6IDgxLFxuICAgIEU6IDY5LFxuICAgIFI6IDgyLFxuICAgIEY6IDcwLFxuICAgIFY6IDg2LFxuICAgIDE6IDQ5LFxuICAgIDI6IDUwLFxuICAgIEFSUk9XX0xFRlQ6IDM3LFxuICAgIEFSUk9XX1JJR0hUOiAzOSxcbiAgICBBUlJPV19VUDogMzgsXG4gICAgQVJST1dfRE9XTjogNDAsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dCBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnZlcnRpY2FsID0gMDtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gMDtcbiAgICAgICAgdGhpcy5hdHRhY2sxID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXR0YWNrMiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvb2sgPSB7XG4gICAgICAgICAgICB2ZXJ0aWNhbDogMCxcbiAgICAgICAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICAgICAgICBiYWNrOiBmYWxzZSxcbiAgICAgICAgICAgIHNlbnNpdGl2aXR5OiAxLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc2V0SG9yaXpvbnRhbExvb2sgPSAoKSA9PiB0aGlzLmxvb2suaG9yaXpvbnRhbCA9IDA7XG4gICAgICAgIHRoaXMuaXNUaGlyZFBlcnNvbiA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5jdXJzb3IgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm1vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5sb29rLmhvcml6b250YWwgPSAwO1xuICAgICAgICB0aGlzLmxvb2sudmVydGljYWwgPSAwO1xuICAgIH1cblxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IEtFWVMuTU9VU0VfTEVGVCkgeyB0aGlzLmF0dGFjazEgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gS0VZUy5NT1VTRV9SSUdIVCkgeyB0aGlzLmF0dGFjazIgPSB0cnVlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IEtFWVMuTU9VU0VfTEVGVCkgeyB0aGlzLmF0dGFjazEgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IEtFWVMuTU9VU0VfUklHSFQpIHsgdGhpcy5hdHRhY2syID0gZmFsc2U7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHRpbWVvdXQ7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvb2suaG9yaXpvbnRhbCArPSBlLm1vdmVtZW50WCB8fCAwO1xuICAgICAgICAgICAgdGhpcy5sb29rLnZlcnRpY2FsICs9IGUubW92ZW1lbnRZIHx8IDA7XG5cbiAgICAgICAgICAgIHRoaXMubW91c2UueCA9IGUueDtcbiAgICAgICAgICAgIHRoaXMubW91c2UueSA9IGUueTtcblxuICAgICAgICAgICAgY29uc3QgY3Vyc29yWCA9IHRoaXMuY3Vyc29yLnggKyAoZS5tb3ZlbWVudFggfHwgMCk7XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JZID0gdGhpcy5jdXJzb3IueSArIChlLm1vdmVtZW50WSB8fCAwKTtcblxuICAgICAgICAgICAgaWYgKGN1cnNvclggPiAwICYmIGN1cnNvclggPCB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnggPSBjdXJzb3JYO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3Vyc29yWSA+IDAgJiYgY3Vyc29yWSA8IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnkgPSBjdXJzb3JZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnb25tb3VzZW1vdmVlbmQnKSk7XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdvbm1vdXNlbW92ZWVuZCcsIChlKSA9PiB7XG4gICAgICAgICAgICAvLyBIb3Jpem9udGFsIGxvb2sgaXMgY2xlYW5pbmcgYnkgUGxheWVyLnVwZGF0ZSBhZnRlciByb3RhdGlvbiBpcyBhcHBsaWVkXG4gICAgICAgICAgICAvLyB0aGlzLmxvb2suaG9yaXpvbnRhbCA9IDA7XG4gICAgICAgICAgICB0aGlzLmxvb2sudmVydGljYWwgPSAwO1xuICAgICAgICB9KTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5FTlRFUjogdGhpcy5wYXJhbXMub25BY3Rpb24gJiYgdGhpcy5wYXJhbXMub25BY3Rpb24oKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkVTQzogdGhpcy5wYXJhbXMub25FeGl0ICYmIHRoaXMucGFyYW1zLm9uRXhpdCgpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuQzogdGhpcy5wYXJhbXMub25Td2l0Y2hDYW1lcmEgJiYgdGhpcy5wYXJhbXMub25Td2l0Y2hDYW1lcmEoKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLlc6IGNhc2UgS0VZUy5BUlJPV19VUDogdGhpcy52ZXJ0aWNhbCA9IDE7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5TOiBjYXNlIEtFWVMuQVJST1dfRE9XTjogdGhpcy52ZXJ0aWNhbCA9IC0xOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuQTogY2FzZSBLRVlTLkFSUk9XX0xFRlQ6IHRoaXMuaG9yaXpvbnRhbCA9IC0xOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuRDogY2FzZSBLRVlTLkFSUk9XX1JJR0hUOiB0aGlzLmhvcml6b250YWwgPSAxOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuWDogdGhpcy5sb29rLmJhY2sgPSB0cnVlOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuRjogdGhpcy5sb29rLmNpbmVtYXRpYyA9IHRydWU7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5TUEFDRTogdGhpcy5qdW1wID0gMTsgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGUpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5XOlxuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5BUlJPV19VUDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmVydGljYWwgPT09IDEpIHsgdGhpcy52ZXJ0aWNhbCA9IDA7IH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLlM6XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkFSUk9XX0RPV046XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2FsID09PSAtMSkgeyB0aGlzLnZlcnRpY2FsID0gMDsgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuQTpcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuQVJST1dfTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCA9PT0gLTEpIHsgdGhpcy5ob3Jpem9udGFsID0gMDsgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuRDpcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuQVJST1dfUklHSFQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhvcml6b250YWwgPT09IDEpIHsgdGhpcy5ob3Jpem9udGFsID0gMDsgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuWDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb29rLmJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9vay5jaW5lbWF0aWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLlNQQUNFOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmp1bXAgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgZSA9PiB0aGlzLnBhcmFtcy5vblpvb20gJiYgdGhpcy5wYXJhbXMub25ab29tKGUuZGVsdGFZIC8gMTAwKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVydmFscyBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgY29uc3RydWN0b3Ioc2NlbmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLnRpbWVQYXNzZWQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RGcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzID0gW107XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgdXBkYXRlKG5vdykge1xuICAgICAgICBpZiAodGhpcy5zY2VuZS51aSAmJiAhdGhpcy5zY2VuZS51aS5pc1BhdXNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGltZVBhc3NlZCArPSBub3cgLSB0aGlzLmxhc3RGcmFtZTtcblxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGkgPT4gdGhpcy50aW1lUGFzc2VkIC0gaS5jYWxsZWRBdCA+IGkuaW50ZXJ2YWwpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGludGVydmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsLmNhbGxlZEF0ID0gdGhpcy50aW1lUGFzc2VkO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbC5mbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnZhbC5sb29wcyAmJiAtLWludGVydmFsLmxvb3BzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3RGcmFtZSA9IG5vdztcbiAgICB9XG5cbiAgICBnZXRUaW1lUGFzc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lUGFzc2VkO1xuICAgIH1cblxuICAgIGdldERlbHRhVGltZShub3cpIHtcbiAgICAgICAgcmV0dXJuIG5vdyAtIHRoaXMubGFzdEZyYW1lO1xuICAgIH1cblxuICAgIHNldEludGVydmFsKGZuLCBpbnRlcnZhbCwgaW1tZWRpYXRlbHksIGxvb3BzKSB7XG4gICAgICAgIGlmIChmbiAmJiBpbnRlcnZhbCkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGVkQXQgPSBpbW1lZGlhdGVseSA/IHRoaXMudGltZVBhc3NlZCAtIGludGVydmFsIDogdGhpcy50aW1lUGFzc2VkO1xuXG4gICAgICAgICAgICB0aGlzLmludGVydmFscy5wdXNoKHtcbiAgICAgICAgICAgICAgICBmbixcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCxcbiAgICAgICAgICAgICAgICBjYWxsZWRBdCxcbiAgICAgICAgICAgICAgICBsb29wcyxcbiAgICAgICAgICAgICAgICBpZDogKyt0aGlzLmludGVydmFsSW5kZXgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoZm4sIHRpbWVvdXQpIHtcbiAgICAgICAgaWYgKGZuICYmIHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIGZuLFxuICAgICAgICAgICAgICAgIGludGVydmFsOiB0aW1lb3V0LFxuICAgICAgICAgICAgICAgIGxvb3BzOiAxLFxuICAgICAgICAgICAgICAgIGNhbGxlZEF0OiB0aGlzLnRpbWVQYXNzZWQsXG4gICAgICAgICAgICAgICAgaWQ6ICsrdGhpcy5pbnRlcnZhbEluZGV4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhckludGVydmFsKGlkKSB7XG4gICAgICAgIGNvbnN0IGludGVydmFsSWR4ID0gdGhpcy5pbnRlcnZhbHMuZmluZEluZGV4KGkgPT4gaS5pZCA9PT0gaWQpO1xuXG4gICAgICAgIGlmIChpbnRlcnZhbElkeCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmludGVydmFscy5zcGxpY2UoaW50ZXJ2YWxJZHgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi4vQXV0b0JpbmRNZXRob2RzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWJzdHJhY3RMb2NhdGlvbiBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzY2VuZSwgaWQgPSAndW5rbm93bi1sZXZlbCcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge31cblxuICAgIHN0YXJ0TG9jYXRpb24oKSB7fVxuICAgIHJlc3RhcnRMb2NhdGlvbigpIHt9XG4gICAgc3RvcExvY2F0aW9uKCkge31cbiAgICBvbkFjdGlvbigpIHt9XG5cbiAgICBnZXRMb2NhdGlvbk5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgIH1cblxuICAgIGNyZWF0ZUFtYmllbnRMaWdodCgpIHtcbiAgICAgICAgY29uc3QgYW1iaWVudExpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCgweDg4ODg4OCk7XG4gICAgICAgIGFtYmllbnRMaWdodC5jYXN0U2hhZG93ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhbWJpZW50TGlnaHQ7XG4gICAgfVxuXG4gICAgY3JlYXRlU2hhZG93TGlnaHQoKSB7XG4gICAgICAgIGNvbnN0IGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIDEwLCAxNTApO1xuICAgICAgICBsaWdodC5pbnRlbnNpdHkgPSAxO1xuICAgICAgICBsaWdodC5zaGFkb3cuYmlhcyA9IC0wLjAwMDAxO1xuICAgICAgICBjb25zdCBzaGFkb3dTaXplID0gMjU7XG4gICAgICAgIGxpZ2h0LmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICBsaWdodC5zaGFkb3cuY2FtZXJhLmxlZnQgPSAtc2hhZG93U2l6ZTtcbiAgICAgICAgbGlnaHQuc2hhZG93LmNhbWVyYS5yaWdodCA9IHNoYWRvd1NpemU7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5jYW1lcmEudG9wID0gc2hhZG93U2l6ZTtcbiAgICAgICAgbGlnaHQuc2hhZG93LmNhbWVyYS5ib3R0b20gPSAtc2hhZG93U2l6ZTtcbiAgICAgICAgbGlnaHQuc2hhZG93Lm1hcFNpemUud2lkdGggPSA1MTI7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IDUxMjtcbiAgICAgICAgbGlnaHQuc2hhZG93LmNhbWVyYS5uZWFyID0gMTA7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5jYW1lcmEuZmFyID0gMTUwO1xuICAgICAgICBsaWdodC5zaGFkb3cuY2FtZXJhLnZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBsaWdodDtcbiAgICB9XG5cblxuICAgIGNyZWF0ZVNreWJveCgpIHtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWxBcnJheSA9IFsneHBvcycsICd4bmVnJywgJ3lwb3MnLCAneW5lZycsICd6cG9zJywgJ3puZWcnXS5tYXAoZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYC4vYXNzZXRzL3RleHR1cmVzL3NreS1uZWJ1bGEvbmVidWxhLSR7ZGlyZWN0aW9ufS5wbmdgO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgICAgICAgICAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQodXJsKSxcbiAgICAgICAgICAgICAgICBzaWRlOiBUSFJFRS5CYWNrU2lkZSxcbiAgICAgICAgICAgICAgICBmb2c6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc2t5R2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KDc1MDAwLCA3NTAwMCwgNzUwMDApO1xuICAgICAgICBjb25zdCBza3lNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsKG1hdGVyaWFsQXJyYXkpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWVzaChza3lHZW9tZXRyeSwgc2t5TWF0ZXJpYWwpO1xuICAgIH1cbn0iLCJjb25zdCBidWlsZEFyZWEgPSAoYXJlYUlkLCBtYXApID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IEFyZWFTaXplc1thcmVhSWRdO1xuXG4gICAgY29uc3Qgd2F5cG9pbnRYVG9Xb3JsZFggPSBwb3NpdGlvbiA9PiBwb3NpdGlvbiAtIHdpZHRoIC8gMjtcbiAgICBjb25zdCB3YXlwb2ludFlUb1dvcmxkWiA9IHBvc2l0aW9uID0+IHBvc2l0aW9uIC0gaGVpZ2h0IC8gMjtcblxuICAgIGNvbnN0IHdvcmxkWFRvV2F5cG9pbnRYID0gKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGdyYXBoWCA9IE1hdGgucm91bmQocG9zaXRpb24gKyB3aWR0aCAvIDIpO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZ3JhcGhYLCA0KSwgd2lkdGggLSA1KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgd29ybGRaVG9XYXlwb2ludFkgPSAocG9zaXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgZ3JhcGhZID0gTWF0aC5yb3VuZChwb3NpdGlvbiArIGhlaWdodCAvIDIpO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZ3JhcGhZLCA0KSwgaGVpZ2h0IC0gNSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFyZWEgPSB7XG4gICAgICAgIGlkOiBhcmVhSWQsXG4gICAgICAgIHdheXBvaW50WFRvV29ybGRYLFxuICAgICAgICB3YXlwb2ludFlUb1dvcmxkWixcbiAgICAgICAgd29ybGRYVG9XYXlwb2ludFgsXG4gICAgICAgIHdvcmxkWlRvV2F5cG9pbnRZLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgIH07XG5cbiAgICByZXR1cm4gbWFwKGFyZWEpO1xufTtcblxuY29uc3QgQXJlYVNpemVzID0ge1xuICAgIEZMT09SXzA6IHtcbiAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgaGVpZ2h0OiAxNTAsXG4gICAgfSxcbiAgICBGTE9PUl8xOiB7XG4gICAgICAgIHdpZHRoOiAyNzAsXG4gICAgICAgIGhlaWdodDogMjcwLFxuICAgIH0sXG4gICAgRkxPT1JfMjoge1xuICAgICAgICB3aWR0aDogMjcwLFxuICAgICAgICBoZWlnaHQ6IDI3MCxcbiAgICB9XG59O1xuXG5jb25zdCBBcmVhcyA9IHtcbiAgICBGTE9PUl8wOiBidWlsZEFyZWEoJ0ZMT09SXzAnLCBhcmVhID0+ICh7XG4gICAgICAgIC4uLmFyZWEsXG4gICAgICAgIGluY2x1ZGVzUG9zaXRpb246IHBvc2l0aW9uID0+IHBvc2l0aW9uLnkgPCAxMDAsXG4gICAgICAgIGdldFdvcmxkV2F5cG9pbnRCeVhZOiAoeCwgeSkgPT4gKHsgeDogYXJlYS53YXlwb2ludFhUb1dvcmxkWCh4KSwgeTogMC4yLCB6OiBhcmVhLndheXBvaW50WVRvV29ybGRaKHkpIH0pLFxuICAgICAgICBnZXRXYXlwb2ludFBvcnRhbHM6ICgpID0+IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcm9tOiB7IHg6IGFyZWEud29ybGRYVG9XYXlwb2ludFgoLTQ5KSwgeTogYXJlYS53b3JsZFpUb1dheXBvaW50WSgwKSB9LFxuICAgICAgICAgICAgICAgIHRvOiB7IHg6IGFyZWEud29ybGRYVG9XYXlwb2ludFgoLTQ5KSwgeTogYXJlYS53b3JsZFpUb1dheXBvaW50WSgwKSwgYXJlYUlkOiAnRkxPT1JfMScgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcm9tOiB7IHg6IGFyZWEud29ybGRYVG9XYXlwb2ludFgoLTQ5KSwgeTogYXJlYS53b3JsZFpUb1dheXBvaW50WSgwKSB9LFxuICAgICAgICAgICAgICAgIHRvOiB7IHg6IGFyZWEud29ybGRYVG9XYXlwb2ludFgoLTQ5KSwgeTogYXJlYS53b3JsZFpUb1dheXBvaW50WSgwKSwgYXJlYUlkOiAnRkxPT1JfMicgfVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgIH0pKSxcblxuICAgIEZMT09SXzE6IGJ1aWxkQXJlYSgnRkxPT1JfMScsIGFyZWEgPT4gKHtcbiAgICAgICAgLi4uYXJlYSxcbiAgICAgICAgaW5jbHVkZXNQb3NpdGlvbjogcG9zaXRpb24gPT4gcG9zaXRpb24ueSA8IDIwMCxcbiAgICAgICAgZ2V0V29ybGRXYXlwb2ludEJ5WFk6ICh4LCB5KSA9PiAoeyB4OiBhcmVhLndheXBvaW50WFRvV29ybGRYKHgpLCB5OiAxMDAuMiwgejogYXJlYS53YXlwb2ludFlUb1dvcmxkWih5KSB9KSxcbiAgICAgICAgZ2V0V2F5cG9pbnRQb3J0YWxzOiAoKSA9PiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogeyB4OiBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKC00OCksIHk6IGFyZWEud29ybGRaVG9XYXlwb2ludFkoMCkgfSxcbiAgICAgICAgICAgICAgICB0bzogeyB4OiBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKC00OCksIHk6IGFyZWEud29ybGRaVG9XYXlwb2ludFkoMCksIGFyZWFJZDogJ0ZMT09SXzAnIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogeyB4OiBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKC00OCksIHk6IGFyZWEud29ybGRaVG9XYXlwb2ludFkoMCkgfSxcbiAgICAgICAgICAgICAgICB0bzogeyB4OiBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKC00OCksIHk6IGFyZWEud29ybGRaVG9XYXlwb2ludFkoMCksIGFyZWFJZDogJ0ZMT09SXzInIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICB9KSksXG5cbiAgICBGTE9PUl8yOiBidWlsZEFyZWEoJ0ZMT09SXzInLCBhcmVhID0+ICh7XG4gICAgICAgIC4uLmFyZWEsXG4gICAgICAgIGluY2x1ZGVzUG9zaXRpb246IHBvc2l0aW9uID0+IHBvc2l0aW9uLnkgPj0gMjAwLFxuICAgICAgICBnZXRXb3JsZFdheXBvaW50QnlYWTogKHgsIHkpID0+ICh7IHg6IGFyZWEud2F5cG9pbnRYVG9Xb3JsZFgoeCksIHk6IDIwMC4yLCB6OiBhcmVhLndheXBvaW50WVRvV29ybGRaKHkpIH0pLFxuICAgICAgICBnZXRXYXlwb2ludFBvcnRhbHM6ICgpID0+IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcm9tOiB7IHg6IGFyZWEud29ybGRYVG9XYXlwb2ludFgoLTQ4KSwgeTogYXJlYS53b3JsZFpUb1dheXBvaW50WSgwKSB9LFxuICAgICAgICAgICAgICAgIHRvOiB7IHg6IGFyZWEud29ybGRYVG9XYXlwb2ludFgoLTQ4KSwgeTogYXJlYS53b3JsZFpUb1dheXBvaW50WSgwKSwgYXJlYUlkOiAnRkxPT1JfMCcgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcm9tOiB7IHg6IGFyZWEud29ybGRYVG9XYXlwb2ludFgoLTQ4KSwgeTogYXJlYS53b3JsZFpUb1dheXBvaW50WSgwKSB9LFxuICAgICAgICAgICAgICAgIHRvOiB7IHg6IGFyZWEud29ybGRYVG9XYXlwb2ludFgoLTQ4KSwgeTogYXJlYS53b3JsZFpUb1dheXBvaW50WSgwKSwgYXJlYUlkOiAnRkxPT1JfMScgfVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgIH0pKSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFyZWFzOyIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi4vLi4vQXV0b0JpbmRNZXRob2RzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxldmF0b3IgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lLCBwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuXG4gICAgICAgIHRoaXMuY3VycmVudEZsb29yID0gMTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSAwO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IC0xO1xuICAgICAgICB0aGlzLnNwZWVkID0gMC4zO1xuICAgICAgICB0aGlzLnN0YW5kVGltZSA9IDEwO1xuXG4gICAgICAgIHRoaXMub2JqZWN0ID0gdGhpcy5zY2VuZS5tb2RlbHMuY3JlYXRlQ3ViZShwYXJhbXMpO1xuICAgICAgICB0aGlzLnN0YW5kQXQgPSB0aGlzLnNjZW5lLmludGVydmFscy5nZXRUaW1lUGFzc2VkKCk7XG4gICAgfVxuXG4gICAgaXNSZWxlYXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuaW50ZXJ2YWxzLmdldFRpbWVQYXNzZWQoKSAtIHRoaXMuc3RhbmRBdCA+IHRoaXMuc3RhbmRUaW1lICogMTAwMFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlzQ2FycnlpbmcoeyB4LCB5LCB6IH0pIHtcbiAgICAgICAgY29uc3QgeyBvYmplY3Q6IHsgcG9zaXRpb24sIHNjYWxlIH0gfSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIE1hdGguYWJzKHggLSBwb3NpdGlvbi54KSA8IHNjYWxlLnggLyAyXG4gICAgICAgICAgICAmJiBNYXRoLmFicyh6IC0gcG9zaXRpb24ueikgPCBzY2FsZS56IC8gMlxuICAgICAgICAgICAgJiYgKHkgLSBwb3NpdGlvbi55IDwgc2NhbGUueSAvIDIpXG4gICAgICAgICAgICAvLyAmJiAoeSArIDEuNykgLSBwb3NpdGlvbi55ID4gLXNjYWxlLnkgLyAyXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIGdldEZsb29yKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPiAwXG4gICAgICAgICAgICAgICAgPyAoXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLm9iamVjdC5wb3NpdGlvbi55ID49IDIwMCAmJiAyKVxuICAgICAgICAgICAgICAgICAgICB8fCAodGhpcy5vYmplY3QucG9zaXRpb24ueSA+PSAxMDAgJiYgMSlcbiAgICAgICAgICAgICAgICAgICAgfHwgMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMub2JqZWN0LnBvc2l0aW9uLnkgPiAxMDAgJiYgMilcbiAgICAgICAgICAgICAgICAgICAgfHwgKHRoaXMub2JqZWN0LnBvc2l0aW9uLnkgPiAwICYmIDEpXG4gICAgICAgICAgICAgICAgICAgIHx8IDBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5pc1JlbGVhc2VkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsb29yID0gdGhpcy5nZXRGbG9vcigpO1xuXG4gICAgICAgICAgICBpZiAoZmxvb3IgIT09IHRoaXMuY3VycmVudEZsb29yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFuZEF0ID0gdGhpcy5zY2VuZS5pbnRlcnZhbHMuZ2V0VGltZVBhc3NlZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEZsb29yID0gZmxvb3I7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmxvb3IgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZsb29yID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IGZsb29yICsgdGhpcy5kaXJlY3Rpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldENhcnJ5aW5nUG9zaXRpb24gPSB1bml0ID0+ICh7IC4uLnVuaXQucG9zaXRpb24sIHk6IHVuaXQucG9zaXRpb24ueSAtICh0aGlzLmRpcmVjdGlvbiA+IDAgPyAyIDogMC4xKSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXJyeWluZ1VuaXRzID0gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2UuZ2V0VW5pdHMoKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgIHVuaXQgPT4gKHRoaXMuaXNDYXJyeWluZyhnZXRDYXJyeWluZ1Bvc2l0aW9uKHVuaXQpKSksXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNBY2NlbGVyYXRpb24gPSB0aGlzLnNwZWVkICogdGhpcy5kaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgY2FycnlpbmdVbml0cy5mb3JFYWNoKCh1bml0KSA9PiB7IHVuaXQucG9zaXRpb24ueSArPSB0aGlzQWNjZWxlcmF0aW9uOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdC5wb3NpdGlvbi55ICs9IHRoaXNBY2NlbGVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSIsIlxuY29uc3QgY3JlYXRlRW52aXJvbm1lbnQgPSBmdW5jdGlvbiAoe1xuICAgIGxvYWQsXG4gICAgdHJlZXMsXG4gICAgaG91c2VzLFxuICAgIGFkZENvbGxpZGVyRnVuY3Rpb24sXG4gICAgb25Mb2FkLFxufSkge1xuICAgIGNvbnN0IHBpdm90ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG4gICAgcGl2b3QubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIHBpdm90Lm5hbWUgPSAnTEVWRUxfRU5WSVJPTk1FTlQnO1xuXG4gICAgbGV0IGlzRW52aXJvbm1lbnRMb2FkZWQgPSBmYWxzZTtcbiAgICBsZXQgaXNUcmVlTG9hZGVkID0gZmFsc2U7XG4gICAgbGV0IGlzSG91c2VMb2FkZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGNoZWNrSXNBbGxMb2FkZWQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChpc0Vudmlyb25tZW50TG9hZGVkXG4gICAgICAgICAgICAmJiBpc1RyZWVMb2FkZWRcbiAgICAgICAgICAgICYmIGlzSG91c2VMb2FkZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvbkxvYWQgJiYgb25Mb2FkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbG9hZCh7XG4gICAgICAgIGJhc2VVcmw6ICcuL2Fzc2V0cy9tb2RlbHMvZW52aXJvbm1lbnQvZW52aXJvbWVudCcsXG4gICAgICAgIG5vU2NlbmU6IHRydWUsXG4gICAgICAgIGNhc3RTaGFkb3c6IGZhbHNlLFxuICAgICAgICBjYWxsYmFjazogb2JqZWN0ID0+IHtcbiAgICAgICAgICAgIHBpdm90LmFkZChvYmplY3Quc2NlbmUpO1xuICAgICAgICAgICAgb2JqZWN0LnNjZW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIG9iamVjdC5zY2VuZS51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgICAgIGlzRW52aXJvbm1lbnRMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2hlY2tJc0FsbExvYWRlZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBsb2FkKHtcbiAgICAgICAgYmFzZVVybDogJy4vYXNzZXRzL21vZGVscy9lbnZpcm9ubWVudC90cmVlJyxcbiAgICAgICAgbm9TY2VuZTogdHJ1ZSxcbiAgICAgICAgcmVjZWl2ZVNoYWRvdzogZmFsc2UsXG4gICAgICAgIGNhbGxiYWNrOiAobG9hZGVkTW9kZWwpID0+IHtcbiAgICAgICAgICAgIGlzVHJlZUxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBjaGVja0lzQWxsTG9hZGVkKCk7XG5cbiAgICAgICAgICAgIHRyZWVzLmZvckVhY2goKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBsb2FkZWRNb2RlbC5zY2VuZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG1vZGVsLm5hbWUgPSAnVHJlZSc7XG4gICAgICAgICAgICAgICAgbW9kZWwucG9zaXRpb24uc2V0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuICAgICAgICAgICAgICAgIG1vZGVsLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtb2RlbC51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgeCwgeiB9ID0gbW9kZWwucG9zaXRpb247XG5cbiAgICAgICAgICAgICAgICBhZGRDb2xsaWRlckZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAocG9zaXRpb24pID0+IE1hdGguYWJzKHBvc2l0aW9uLnggLSB4KSA8IDIgJiYgTWF0aC5hYnMocG9zaXRpb24ueiAtIHopIDwgMlxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBwaXZvdC5hZGQobW9kZWwpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbG9hZCh7XG4gICAgICAgIGJhc2VVcmw6ICcuL2Fzc2V0cy9tb2RlbHMvZW52aXJvbm1lbnQvaG91c2UxJyxcbiAgICAgICAgcmVjZWl2ZVNoYWRvdzogZmFsc2UsXG4gICAgICAgIG5vU2NlbmU6IHRydWUsXG4gICAgICAgIGNhbGxiYWNrOiAobG9hZGVkTW9kZWwpID0+IHtcbiAgICAgICAgICAgIGlzSG91c2VMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2hlY2tJc0FsbExvYWRlZCgpO1xuXG4gICAgICAgICAgICBob3VzZXMuZm9yRWFjaCgocG9zaXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IGxvYWRlZE1vZGVsLnNjZW5lLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgbW9kZWwubmFtZSA9ICdIb3VzZTEnO1xuICAgICAgICAgICAgICAgIG1vZGVsLnBvc2l0aW9uLnNldChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcbiAgICAgICAgICAgICAgICBtb2RlbC5yb3RhdGlvbi5zZXQocG9zaXRpb24ucnggfHwgMCwgcG9zaXRpb24ucnkgfHwgMCwgcG9zaXRpb24ucnogfHwgMCk7XG4gICAgICAgICAgICAgICAgbW9kZWwubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG1vZGVsLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyB4LCB6IH0gPSBtb2RlbC5wb3NpdGlvbjtcblxuICAgICAgICAgICAgICAgIGFkZENvbGxpZGVyRnVuY3Rpb24odW5pdFBvc2l0aW9uID0+IChcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnModW5pdFBvc2l0aW9uLnggLSB4KSA8IChwb3NpdGlvbi5yeSA8IC0zLjEzID8gNCA6IDMpXG4gICAgICAgICAgICAgICAgICAgICYmIE1hdGguYWJzKHVuaXRQb3NpdGlvbi56IC0geikgPCAocG9zaXRpb24ucnkgPCAtMy4xMyA/IDMgOiA0KVxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgcGl2b3QuYWRkKG1vZGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGl2b3Q7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVFbnZpcm9ubWVudCB9O1xuIiwiaW1wb3J0IEFic3RyYWN0TG9jYXRpb24gZnJvbSAnLi4vQWJzdHJhY3RMb2NhdGlvbic7XG5pbXBvcnQgeyBQbGF5ZXIsIEZpcmUgfSBmcm9tICcuLi8uLi9HYW1lT2JqZWN0cyc7XG5pbXBvcnQgRWxldmF0b3IgZnJvbSAnLi9FbGV2YXRvcic7XG5pbXBvcnQgeyBjcmVhdGVFbnZpcm9ubWVudCB9IGZyb20gJy4vRW52aXJvbm1lbnQnO1xuaW1wb3J0IEFyZWFzIGZyb20gJy4vQXJlYXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhdGlvbiBleHRlbmRzIEFic3RyYWN0TG9jYXRpb24ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2NlbmUpIHtcbiAgICAgICAgc3VwZXIoc2NlbmUpO1xuICAgICAgICB0aGlzLmlkID0gJ2RyZWFtLXRvd24nO1xuXG4gICAgICAgIHRoaXMuc2hhZG93TGlnaHRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDI1LCA1MCwgMjUpO1xuXG4gICAgICAgIHRoaXMuc2NlbmUudWkuc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgdGhpcy5zY2VuZS51aS5zZXRQYXVzZSh0cnVlKTtcblxuICAgICAgICB0aGlzLmVudmlyb25tZW50ID0gY3JlYXRlRW52aXJvbm1lbnQoe1xuICAgICAgICAgICAgbG9hZDogdGhpcy5zY2VuZS5tb2RlbHMubG9hZEdMVEYsXG4gICAgICAgICAgICBhZGRDb2xsaWRlckZ1bmN0aW9uOiB0aGlzLnNjZW5lLmNvbGxpZGVycy5hZGRDb2xsaWRlckZ1bmN0aW9uLFxuICAgICAgICAgICAgdHJlZXM6IFtcbiAgICAgICAgICAgICAgICB7IHg6IDAsIHk6IDAsIHo6IDE1IH0sXG4gICAgICAgICAgICAgICAgeyB4OiAwLCB5OiAwLCB6OiAtMTUgfSxcbiAgICAgICAgICAgICAgICB7IHg6IDE1LCB5OiAwLCB6OiAwIH0sXG4gICAgICAgICAgICAgICAgeyB4OiAtMTUsIHk6IDAsIHo6IDAgfSxcbiAgICBcbiAgICBcbiAgICAgICAgICAgICAgICB7IHg6IDE1LCB5OiAwLCB6OiAxNSB9LFxuICAgICAgICAgICAgICAgIHsgeDogMTUsIHk6IDAsIHo6IC0xNSB9LFxuICAgICAgICAgICAgICAgIHsgeDogMzAsIHk6IDAsIHo6IDIwIH0sXG4gICAgICAgICAgICAgICAgeyB4OiAzMCwgeTogMCwgejogLTIwIH0sXG4gICAgXG4gICAgICAgICAgICAgICAgeyB4OiA0NSwgeTogMCwgejogLTM1IH0sXG4gICAgICAgICAgICAgICAgeyB4OiA0NSwgeTogMCwgejogMzUgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBob3VzZXM6IFtcbiAgICAgICAgICAgICAgICB7IHg6IDAsIHk6IDAsIHo6IDQwLCByeTogLU1hdGguUEkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IC0xMCwgeTogMCwgejogMzAsIHJ5OiBNYXRoLlBJIC8gMiB9LFxuICAgICAgICAgICAgICAgIHsgeDogMTAsIHk6IDAsIHo6IDMwLCByeTogLU1hdGguUEkgLyAyIH0sXG4gICAgICAgICAgICAgICAgLy8geyB4OiA3NSwgeTogMTAwLCB6OiA3NSB9LFxuICAgICAgICAgICAgICAgIC8vIHsgeDogNzUsIHk6IDIwMCwgejogNzUgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBvbkxvYWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnVpLnNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUudWkuc2V0UGF1c2UoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUubm90aWZ5KCdEcmVhbSBUb3duJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydExvY2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYW1iaWVudExpZ2h0ID0gdGhpcy5jcmVhdGVBbWJpZW50TGlnaHQoKTtcbiAgICAgICAgdGhpcy5zaGFkb3dMaWdodCA9IHRoaXMuY3JlYXRlU2hhZG93TGlnaHQoKTtcblxuICAgICAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLmVudmlyb25tZW50KTtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQodGhpcy5hbWJpZW50TGlnaHQpO1xuICAgICAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLnNoYWRvd0xpZ2h0KTtcblxuICAgICAgICB0aGlzLmVsZXZhdG9yID0gbmV3IEVsZXZhdG9yKHNjZW5lLCB7XG4gICAgICAgICAgICBwb3NpdGlvbjogeyB4OiAtNDgsIHk6IDEwMCwgejogMCB9LFxuICAgICAgICAgICAgeDogNCxcbiAgICAgICAgICAgIHk6IDEsXG4gICAgICAgICAgICB6OiA0LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjb2xvciA9IDB4MDAwMDAwO1xuICAgICAgICBjb25zdCBuZWFyID0gMTA7XG4gICAgICAgIGNvbnN0IGZhciA9IDEwMDtcbiAgICAgICAgdGhpcy5zY2VuZS5zY2VuZS5mb2cgPSBuZXcgVEhSRUUuRm9nKGNvbG9yLCBuZWFyLCBmYXIpO1xuXG4gICAgICAgIHRoaXMuY3JlYXRlTG9jYXRpb25Db2xsaWRlcnMoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZSgpO1xuXG4gICAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMuc2NlbmUuZ2V0UGxheWVyKCk7XG5cbiAgICAgICAgaWYgKHBsYXllcikge1xuICAgICAgICAgICAgdGhpcy5lbGV2YXRvci51cGRhdGUoKTtcblxuICAgICAgICAgICAgdGhpcy5zaGFkb3dMaWdodC5wb3NpdGlvblxuICAgICAgICAgICAgICAgIC5jb3B5KHBsYXllci5wb3NpdGlvbilcbiAgICAgICAgICAgICAgICAuYWRkKHRoaXMuc2hhZG93TGlnaHRQb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvd0xpZ2h0LnRhcmdldCAhPT0gcGxheWVyLm9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93TGlnaHQudGFyZ2V0ID0gcGxheWVyLm9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldml2ZUhlcm8oKSB7XG4gICAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMuc2NlbmUuZ2V0UGxheWVyKCk7XG4gICAgICAgIHBsYXllci5wYXJhbXMuaHAgPSAxMDtcbiAgICAgICAgcGxheWVyLnBvc2l0aW9uLnNldCgwLCAwLjMsIDMwKTtcbiAgICAgICAgcGxheWVyLmFuaW1hdGlvblN0YXRlLmlzRGllID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NlbmUucGFydGljbGVzLmNyZWF0ZUVmZmVjdCh7XG4gICAgICAgICAgICBlZmZlY3Q6ICdsZXZlbC11cC9sZXZlbC11cCcsXG4gICAgICAgICAgICBzY2FsZTogMS41LFxuICAgICAgICAgICAgYXR0YWNoVG86IHBsYXllci5vYmplY3QsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFmdGVyQ2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc2NlbmUudW5pdHMuY3JlYXRlUGxheWVyKHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvbkNyZWF0ZTogKHBsYXllcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuY2FtZXJhLnBsYXllciA9IHBsYXllcjtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnVpLnVwZGF0ZVBsYXllclBhcmFtcygpO1xuICAgICAgICAgICAgICAgIHBsYXllci5wb3NpdGlvbi5zZXQoMCwgMC4zLCAzMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EaWU6ICgpID0+IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnVpLnNldFBhdXNlKHRydWUpO1xuICAgICAgICAgICAgfSwgMjUwMCksXG4gICAgICAgICAgICBvbktpbGw6IChvYmplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLnNjZW5lLmdldFBsYXllcigpO1xuICAgICAgICAgICAgICAgIHBsYXllci5hZGRFeHBlcmllbmNlKG9iamVjdC5wYXJhbXMuYm91bnR5KTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuYWRkTW9uZXkob2JqZWN0LnBhcmFtcy5ib3VudHkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRGFtYWdlVGFrZW46ICgpID0+IHRoaXMuc2NlbmUudWkudXBkYXRlUGxheWVyUGFyYW1zKCksXG4gICAgICAgICAgICBvbkxvY2F0aW9uVXA6ICgpID0+IHRoaXMuc2NlbmUudWkudXBkYXRlUGxheWVyUGFyYW1zKCksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY3JlYXRlSW50ZXJhY3RpdmVHYW1lT2JqZWN0cygpO1xuICAgIH1cblxuICAgIHN0YXJ0TG9jYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzdGFydExvY2F0aW9uKCkge1xuICAgICAgICB0aGlzLnNjZW5lLmNsZWFyU2NlbmUoKTtcbiAgICB9XG5cbiAgICBzdG9wTG9jYXRpb24oKSB7XG4gICAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMuZW52aXJvbm1lbnQpO1xuICAgICAgICAvLyB0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLnNreWJveCk7XG4gICAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMuYW1iaWVudExpZ2h0KTtcbiAgICAgICAgdGhpcy5zY2VuZS5yZW1vdmUodGhpcy5zaGFkb3dMaWdodCk7XG4gICAgICAgIHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlLnJlbW92ZUFsbEV4Y2VwdFBsYXllcigpO1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjcmVhdGVJbnRlcmFjdGl2ZUdhbWVPYmplY3RzKCkge1xuICAgICAgICBjb25zdCBjcmVhdGVIZWFsSXRlbSA9ICgpID0+IChcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuaW50ZXJ2YWxzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1IZWFsUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygtNi41LCAwLjEsIDMyLjgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2UuY3JlYXRlSXRlbSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiAnaXRlbS1oZWFsJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGl0ZW1IZWFsUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNhblBpY2t1cDogKHVuaXQpID0+ICh1bml0LmdldE1heEhQKCkgLSB1bml0LmdldEhQKCkgPiAwKSxcbiAgICAgICAgICAgICAgICAgICAgb25QaWNrdXA6ICh1bml0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bml0LmFkZEhQKDI1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUhlYWxJdGVtKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAxMDAwMClcbiAgICAgICAgKTtcbiAgICBcbiAgICAgICAgY3JlYXRlSGVhbEl0ZW0oKTtcblxuICAgICAgICBjb25zdCBnZXRBSVBhcmFtcyA9ICh7IGxldmVsLCAuLi5wYXJhbXMgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgc2NhbGU6IDAuNyArIGxldmVsIC8gMTAsXG4gICAgICAgICAgICAgICAgb25EaWU6ICgpID0+IHRoaXMuc2NlbmUudW5pdHMuY3JlYXRlQUkoZ2V0QUlQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbCArIDEgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBsZXZlbCksXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBnZXRHb2F0c1BhcmFtcyA9IChsZXZlbCwgcG9zaXRpb24pID0+IGdldEFJUGFyYW1zKHtcbiAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBmcmFjdGlvbjogJ2dvYXRzJyxcbiAgICAgICAgICAgIG5hbWU6IGxldmVsIDw9IDEwXG4gICAgICAgICAgICAgICA/ICdHb2F0IFdhcnJpb3InXG4gICAgICAgICAgICAgICA6IChsZXZlbCA8PSAyMCA/ICdHb2F0IEVsaXRlJyA6ICdHb2F0IERlc3Ryb3llcicpLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBnZXRGcmllbmRseVBhcmFtcyA9IChsZXZlbCwgcG9zaXRpb24sIHJvdGF0aW9uKSA9PiBnZXRBSVBhcmFtcyh7XG4gICAgICAgICAgICBsZXZlbCwgcG9zaXRpb24sIHJvdGF0aW9uLCBmcmFjdGlvbjogJ2ZyaWVuZGx5JywgbmFtZTogJ0ZyaWVuZGx5IENpdGl6ZW4nLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnVuaXRzID0gW1xuICAgICAgICAgICAgZ2V0R29hdHNQYXJhbXMoMywgeyB4OiAtMTcsIHk6IDAuMiwgejogLTUgfSksXG4gICAgICAgICAgICBnZXRHb2F0c1BhcmFtcygzLCB7IHg6IDE3ICwgeTogMC4yLCB6OiAtNSB9KSxcbiAgICAgICAgICAgIGdldEdvYXRzUGFyYW1zKDIsIHsgeDogLTE1LCB5OiAwLjIsIHo6IC0zMCB9KSxcbiAgICAgICAgICAgIGdldEdvYXRzUGFyYW1zKDIsIHsgeDogMTUsIHk6IDAuMiwgejogLTMwIH0pLFxuXG4gICAgICAgICAgICBnZXRHb2F0c1BhcmFtcyg1LCB7IHg6IC0zMCwgeTogMC4yLCB6OiAtOSB9KSxcbiAgICAgICAgICAgIGdldEdvYXRzUGFyYW1zKDUsIHsgeDogMzAgLCB5OiAwLjIsIHo6IC05IH0pLFxuICAgICAgICAgICAgZ2V0R29hdHNQYXJhbXMoNCwgeyB4OiAtNDUsIHk6IDAuMiwgejogLTMwIH0pLFxuICAgICAgICAgICAgZ2V0R29hdHNQYXJhbXMoNCwgeyB4OiA0NSwgeTogMC4yLCB6OiAtMzAgfSksXG5cbiAgICAgICAgICAgIGdldEdvYXRzUGFyYW1zKDEsIHsgeDogNDUsIHk6IDAuMiwgejogNDUgfSksXG4gICAgICAgICAgICBnZXRHb2F0c1BhcmFtcygxLCB7IHg6IDQ1LCB5OiAwLjIsIHo6IC00NSB9KSxcblxuICAgICAgICAgICAgZ2V0R29hdHNQYXJhbXMoMjUsIHsgeDogMCwgeTogMC4yLCB6OiAwIH0pLFxuXG4gICAgICAgICAgICBnZXRGcmllbmRseVBhcmFtcyg1LCB7IHg6IC0wLjgsIHk6IDAuMiwgejogNDAgLSA0LjAzIH0sIHsgeTogTWF0aC5QSSB9KSxcbiAgICAgICAgICAgIGdldEZyaWVuZGx5UGFyYW1zKDUsIHsgeDogLTEwICsgMy41LCB5OiAwLjIsIHo6IDI5LjIgfSwgeyB5OiBNYXRoLlBJIC8gMiB9KSxcbiAgICAgICAgICAgIGdldEZyaWVuZGx5UGFyYW1zKDUsIHsgeDogMTAgLSAzLjUsIHk6IDAuMiwgejogMzAuOCB9LCB7IHk6IC1NYXRoLlBJIC8gMiB9KSxcbiAgICAgICAgXS5mb3JFYWNoKHRoaXMuc2NlbmUudW5pdHMuY3JlYXRlQUkpO1xuICAgIH1cblxuICAgIGNyZWF0ZUxvY2F0aW9uQ29sbGlkZXJzKCkge1xuICAgICAgICBjb25zdCBpc0JldHdlZW4gPSAodiwgbWluLCBtYXgpID0+IHYgPiBtaW4gJiYgdiA8IG1heDtcblxuICAgICAgICB0aGlzLnNjZW5lLmNvbGxpZGVycy5hZGRDb2xsaWRlckZ1bmN0aW9uKChwb3NpdGlvbiwgZ2FtZU9iamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB6IH0gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGFic1ggPSBNYXRoLmFicyh4KTtcbiAgICAgICAgICAgIGNvbnN0IGFic1ogPSBNYXRoLmFicyh6KTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh5IDwgMC4xICYmIGFic1ggPCA1MCAmJiBhYnNaIDwgNTApIC8vIGZsb29yIDBcbiAgICAgICAgICAgICAgICB8fCAoKCh5IDwgKGFic1ggLSA1MCkgLyAxLjUpICYmIGFic1ggPiA1MCkgfHwgKCh5IDwgKGFic1ogLSA1MCkgLyAxLjUpICYmIGFic1ogPiA1MCkpIC8vIG91dCBvZiBmbG9vciAwXG4gICAgICAgICAgICAgICAgfHwgKHkgPCA5MCAmJiBhYnNYID4gOTYgJiYgYWJzWiA+IDk2KSAvLyBvdXQgb2YgZmxvb3IgMFxuICAgICAgICAgICAgICAgIHx8IChpc0JldHdlZW4oeSwgOTAsIDEwMCkgJiYgKGFic1ggPiA1MCB8fCBhYnNaID4gNTApKSAvLyBmbG9vciAxXG4gICAgICAgICAgICAgICAgfHwgKGlzQmV0d2Vlbih5LCA5MCwgMTkwKSAmJiAoYWJzWCA+IDEzNSB8fCBhYnNaID4gMTM1KSkgLy8gb3V0IG9mIGZsb29yIDFcbiAgICAgICAgICAgICAgICB8fCAoaXNCZXR3ZWVuKHksIDE5MCwgMjAwKSAmJiAoYWJzWCA+IDUwIHx8IGFic1ogPiA1MCkpIC8vIGZsb29yIDJcbiAgICAgICAgICAgICAgICB8fCAoeSA+IDE5MCAmJiAoYWJzWCA+IDEzMyB8fCBhYnNaID4gMTMzKSkgLy8gb3V0IG9mIGZsb29yIDJcbiAgICAgICAgICAgICAgICB8fCB0aGlzLmVsZXZhdG9yLmlzQ2FycnlpbmcocG9zaXRpb24pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgd2UgbmVlZCB1bml0cyBjb2xsaWRlcnNcbiAgICAgICAgICAgIC8vIGNvbnN0IHVuaXRzID0gdGhpcy5zY2VuZS51bml0cy5nZXRBbGl2ZVVuaXRzKCk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gZm9yKGxldCB1bml0IG9mIHVuaXRzKSB7XG4gICAgICAgICAgICAvLyAgICAgaWYgKFxuICAgICAgICAgICAgLy8gICAgICAgICB1bml0ICE9PSBnYW1lT2JqZWN0XG4gICAgICAgICAgICAvLyAgICAgICAgICYmIChcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICEoZ2FtZU9iamVjdCBpbnN0YW5jZW9mIEZpcmUpXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICB8fCBnYW1lT2JqZWN0LnBhcmFtcy5wYXJlbnQgIT09IHVuaXRcbiAgICAgICAgICAgIC8vICAgICAgICAgKVxuICAgICAgICAgICAgLy8gICAgICAgICAmJiB1bml0LmdldENvbGxpZGVyKHBvc2l0aW9uKVxuICAgICAgICAgICAgLy8gICAgICkge1xuICAgICAgICAgICAgLy8gICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0QXJlYXMoKSB7XG4gICAgICAgIGNvbnN0IGFyZWFzID0gT2JqZWN0LnZhbHVlcyhBcmVhcyk7XG5cbiAgICAgICAgY29uc3QgZ2VuZXJhdGVXYXlwb2ludHMgPSAod2lkdGgsIGhlaWdodCwgbWFwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5KHdpZHRoKS5maWxsKG51bGwpLm1hcChcbiAgICAgICAgICAgICAgICAobnVsbDEsIHgpID0+IG5ldyBBcnJheShoZWlnaHQpLmZpbGwobnVsbCkubWFwKFxuICAgICAgICAgICAgICAgICAgICAobnVsbDIsIHkpID0+IG1hcCh4LCB5KSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYXJlYXMubWFwKChhcmVhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IC4uLmFyZWEgfTtcblxuICAgICAgICAgICAgcmVzdWx0LmdldFdheXBvaW50cyA9ICgpID0+IGdlbmVyYXRlV2F5cG9pbnRzKFxuICAgICAgICAgICAgICAgIGFyZWEud2lkdGgsXG4gICAgICAgICAgICAgICAgYXJlYS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgKHgsIHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWxldmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGFyZWEud2F5cG9pbnRYVG9Xb3JsZFgoeCkgLSB0aGlzLmVsZXZhdG9yLnBhcmFtcy5wb3NpdGlvbi54KSA8PSA1XG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLmFicyhhcmVhLndheXBvaW50WVRvV29ybGRaKHkpIC0gdGhpcy5lbGV2YXRvci5wYXJhbXMucG9zaXRpb24ueikgPD0gMVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJlYS5pZCAhPT0gJ0ZMT09SXzAnICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgaG9sZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoYXJlYS53YXlwb2ludFhUb1dvcmxkWCh4KSkgPCA1MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLmFicyhhcmVhLndheXBvaW50WVRvV29ybGRaKHkpKSA8IDUxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoYXJlYS53YXlwb2ludFhUb1dvcmxkWCh4KSkgPD0gNTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5hYnMoYXJlYS53YXlwb2ludFlUb1dvcmxkWih5KSkgPD0gNTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5hYnMoYXJlYS53YXlwb2ludFhUb1dvcmxkWCh4KSkgPj0gNTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5hYnMoYXJlYS53YXlwb2ludFlUb1dvcmxkWih5KSkgPj0gNTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhLmlkID09PSAnRkxPT1JfMCdcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGbG9vciBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhhcmVhLndheXBvaW50WFRvV29ybGRYKHgpKSA+PSA0OVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IE1hdGguYWJzKGFyZWEud2F5cG9pbnRZVG9Xb3JsZFooeSkpID49IDQ5XG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMuY2hlY2tXYXlGb3JXYXlwb2ludChhcmVhLmdldFdvcmxkV2F5cG9pbnRCeVhZKHgsIHkpKSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2hlY2tXYXlGb3JXYXlwb2ludCh7IHgsIHksIHogfSkge1xuICAgICAgICBjb25zdCBjaGVja1dheSA9IHRoaXMuc2NlbmUuY29sbGlkZXJzLmNoZWNrV2F5O1xuICAgICAgICBjb25zdCBjaGVja05lYXIgPSAocmFuZ2UsIGRpYWdvbmFsKSA9PiAoXG4gICAgICAgICAgICBjaGVja1dheShuZXcgVEhSRUUuVmVjdG9yMyh4ICsgcmFuZ2UsIHksIHopKVxuICAgICAgICAgICAgJiYgKGNoZWNrV2F5KG5ldyBUSFJFRS5WZWN0b3IzKHggLSByYW5nZSwgeSwgeikpKVxuICAgICAgICAgICAgJiYgKGNoZWNrV2F5KG5ldyBUSFJFRS5WZWN0b3IzKHgsIHksIHogKyByYW5nZSkpKVxuICAgICAgICAgICAgJiYgKGNoZWNrV2F5KG5ldyBUSFJFRS5WZWN0b3IzKHgsIHksIHogLSByYW5nZSkpKVxuICAgICAgICAgICAgJiYgKFxuICAgICAgICAgICAgICAgICFkaWFnb25hbCB8fCAoXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrV2F5KG5ldyBUSFJFRS5WZWN0b3IzKHggKyByYW5nZSwgeSwgeiArIHJhbmdlKSlcbiAgICAgICAgICAgICAgICAgICAgJiYgY2hlY2tXYXkobmV3IFRIUkVFLlZlY3RvcjMoeCAtIHJhbmdlLCB5LCB6IC0gcmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAmJiBjaGVja1dheShuZXcgVEhSRUUuVmVjdG9yMyh4IC0gcmFuZ2UsIHksIHogKyByYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgICYmIGNoZWNrV2F5KG5ldyBUSFJFRS5WZWN0b3IzKHggKyByYW5nZSwgeSwgeiAtIHJhbmdlKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNoZWNrV2F5KG5ldyBUSFJFRS5WZWN0b3IzKHgsIHksIHopKVxuICAgICAgICAgICAgJiYgY2hlY2tOZWFyKDEsIHRydWUpXG4gICAgICAgICAgICAmJiBjaGVja05lYXIoMilcbiAgICAgICAgKTtcbiAgICB9XG59XG4iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9Mb2NhdGlvbic7IiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVscyBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgY29uc3RydWN0b3Ioc2NlbmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnJlcGVhdFhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnJlcGVhdFlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVtaXNzaXZlXG4gICAgICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBwYXJhbXMucG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7VEhSRUUuTWVzaH1cbiAgICAgKi9cbiAgICBjcmVhdGVDdWJlKHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICAgICAgY29uc3QgbWF0ZXJpYWxQYXJhbXMgPSB7fTtcblxuICAgICAgICBpZiAocGFyYW1zLmltYWdlKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKHBhcmFtcy5pbWFnZSk7XG4gICAgICAgICAgICB0ZXh0dXJlLndyYXBTID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG4gICAgICAgICAgICB0ZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG4gICAgICAgICAgICB0ZXh0dXJlLnJlcGVhdC5zZXQocGFyYW1zLnJlcGVhdFggfHwgMSwgcGFyYW1zLnJlcGVhdFkgfHwgMSk7XG4gICAgICAgICAgICBtYXRlcmlhbFBhcmFtcy5tYXAgPSB0ZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5lbWlzc2l2ZSkge1xuICAgICAgICAgICAgbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IocGFyYW1zLmVtaXNzaXZlKTtcbiAgICAgICAgICAgIG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuICAgICAgICAgICAgbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmVNYXAgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3ViZSA9IG5ldyBUSFJFRS5NZXNoKFxuICAgICAgICAgICAgbmV3IFRIUkVFLkN1YmVHZW9tZXRyeSgxLCAxLCAxKSxcbiAgICAgICAgICAgIG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKG1hdGVyaWFsUGFyYW1zKVxuICAgICAgICApO1xuXG4gICAgICAgIGN1YmUuc2NhbGUuc2V0KHBhcmFtcy54IHx8IDEsIHBhcmFtcy55IHx8IDEsIHBhcmFtcy56IHx8IDEpO1xuXG4gICAgICAgIGlmIChwYXJhbXMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIGN1YmUucG9zaXRpb24uc2V0KFxuICAgICAgICAgICAgICAgIHBhcmFtcy5wb3NpdGlvbi54IHx8IDAsXG4gICAgICAgICAgICAgICAgcGFyYW1zLnBvc2l0aW9uLnkgfHwgMCxcbiAgICAgICAgICAgICAgICBwYXJhbXMucG9zaXRpb24ueiB8fCAwXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5yb3RhdGlvbikge1xuICAgICAgICAgICAgY3ViZS5yb3RhdGlvbi5zZXQoXG4gICAgICAgICAgICAgICAgcGFyYW1zLnJvdGF0aW9uLnggfHwgMCxcbiAgICAgICAgICAgICAgICBwYXJhbXMucm90YXRpb24ueSB8fCAwLFxuICAgICAgICAgICAgICAgIHBhcmFtcy5yb3RhdGlvbi56IHx8IDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcmFtcy5ub1NjZW5lKSB7XG4gICAgICAgICAgICB0aGlzLnNjZW5lLmFkZChjdWJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdWJlO1xuICAgIH1cblxuICAgIGxvYWRHTFRGKHtcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgaXNHTFRGID0gZmFsc2UsXG4gICAgICAgIG5vU2NlbmUgPSBmYWxzZSxcbiAgICAgICAgY2FsbGJhY2sgPSAoKSA9PiBudWxsLFxuICAgICAgICBjYXN0U2hhZG93ID0gdHJ1ZSxcbiAgICAgICAgcmVjZWl2ZVNoYWRvdyA9IHRydWUsXG4gICAgfSkge1xuICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgR0xURkxvYWRlcigpO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHtiYXNlVXJsfS5nbGIke2lzR0xURiA/ICcuZ2x0ZicgOiAnJ31gO1xuICAgICAgICBcbiAgICAgICAgbG9hZGVyLmxvYWQodXJsLCAobG9hZGVkTW9kZWwpID0+IHtcbiAgICAgICAgICAgIGxvYWRlZE1vZGVsLnNjZW5lLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY2FzdFNoYWRvdyA9IGNhc3RTaGFkb3c7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnJlY2VpdmVTaGFkb3cgPSByZWNlaXZlU2hhZG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYWxsYmFjayhsb2FkZWRNb2RlbCk7XG5cbiAgICAgICAgICAgIGlmICghbm9TY2VuZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuYWRkKGxvYWRlZE1vZGVsLnNjZW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSIsImltcG9ydCBTY2VuZSBmcm9tICcuL1NjZW5lJztcbmltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuaW1wb3J0IEFuaW1hdGVkR2FtZU9iamVjdCBmcm9tICcuL0dhbWVPYmplY3RzL0FuaW1hdGVkR2FtZU9iamVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnRpY2xlcyBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzY2VuZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMucGFydGljbGVzID0gW107XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKHAgPT4gcC51cGRhdGUoKSk7XG4gICAgfVxuXG4gICAgY3JlYXRlU25vdygpIHtcbiAgICAgICAgY29uc3QgYXJlYSA9IG5ldyBUSFJFRS5WZWN0b3IzKDEwMCwgMjUsIDEwMCk7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVQYXJ0aWNsZXMoe1xuICAgICAgICAgICAgcGFydGljbGVDb3VudDogMTAwMDAsXG4gICAgICAgICAgICBjb2xvcjogMHg4ODg4ODgsXG4gICAgICAgICAgICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoLWFyZWEueCAvIDIsIDAsIC1hcmVhLnogLyAyKSxcbiAgICAgICAgICAgIGdldFBhcnRpY2xlUG9zaXRpb246IChpLCBwb3NpdGlvbiA9IHRoaXMuZ2V0UmFuZG9tUG9zaXRpb24oYXJlYSkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24ueSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLmdldFJhbmRvbVBvc2l0aW9uKGFyZWEpO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi54ID0gbmV3UG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24ueSA9IGFyZWEueTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24ueiA9IG5ld1Bvc2l0aW9uLno7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgY3JlYXRlRWZmZWN0KHtcbiAgICAgICAgc2NhbGUgPSAxLjUsXG4gICAgICAgIGVmZmVjdCA9ICdsZXZlbC11cC1hbHQvbGV2ZWwtdXAnLFxuICAgICAgICBwb3NpdGlvbiA9IHt9LFxuICAgICAgICBhdHRhY2hUbyxcbiAgICAgICAgbGlmZVRpbWUgPSAyMDgwLFxuICAgIH0pIHtcbiAgICAgICAgdGhpcy5zY2VuZS5tb2RlbHMubG9hZEdMVEYoe1xuICAgICAgICAgICAgYmFzZVVybDogJy4vYXNzZXRzL21vZGVscy9lZmZlY3RzLycgKyBlZmZlY3QsXG4gICAgICAgICAgICBub1NjZW5lOiB0cnVlLFxuICAgICAgICAgICAgY2FzdFNoYWRvdzogZmFsc2UsXG4gICAgICAgICAgICByZWNlaXZlU2hhZG93OiBmYWxzZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBsb2FkZWRPYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgIGxvYWRlZE9iamVjdC5zY2VuZS5zY2FsZS5zZXQoc2NhbGUsIHNjYWxlLCBzY2FsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsb2FkZWRPYmplY3Quc2NlbmUudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pc01lc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLm1hdGVyaWFsLmFscGhhVGVzdCA9IDAuNTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbG9hZGVkT2JqZWN0LnNjZW5lLnBvc2l0aW9uLnNldChwb3NpdGlvbi54IHx8IDAsIHBvc2l0aW9uLnkgfHwgMCwgcG9zaXRpb24ueiB8fCAwKTtcblxuICAgICAgICAgICAgICAgIGlmIChhdHRhY2hUbykge1xuICAgICAgICAgICAgICAgICAgICBhdHRhY2hUby5hZGQobG9hZGVkT2JqZWN0LnNjZW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBlZmZlY3QgPSBuZXcgQW5pbWF0ZWRHYW1lT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBsb2FkZWRPYmplY3Quc2NlbmUsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IGxvYWRlZE9iamVjdC5hbmltYXRpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2UuaG9va0dhbWVPYmplY3QoZWZmZWN0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuaW50ZXJ2YWxzLnNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgICgpID0+IHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlLmRlc3Ryb3lHYW1lT2JqZWN0KGVmZmVjdCksXG4gICAgICAgICAgICAgICAgICAgIGxpZmVUaW1lLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBcbiAgICBcblxuICAgIGxvYWRFZmZlY3Qoe1xuICAgICAgICBwYXJ0aWNsZU5hbWUgPSAnYmxvb2QnLFxuICAgICAgICBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICAgIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoMSwgMSwgMSlcbiAgICB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZ2FtZU9iamVjdHNTZXJ2aWNlID0gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmUubW9kZWxzLmxvYWRHTFRGKHtcbiAgICAgICAgICAgIGJhc2VVcmw6IGAuL2Fzc2V0cy9tb2RlbHMvZWZmZWN0cy8ke3BhcnRpY2xlTmFtZX1gLFxuICAgICAgICAgICAgY2FzdFNoYWRvdzogZmFsc2UsXG4gICAgICAgICAgICByZWNlaXZlU2hhZG93OiBmYWxzZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoZ2x0ZikgPT4ge1xuICAgICAgICAgICAgICAgIGdsdGYuc2NlbmUucG9zaXRpb24uY29weShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgZ2x0Zi5zY2VuZS5zY2FsZS5jb3B5KHNjYWxlKTtcbiAgICAgICAgICAgICAgICBnbHRmLnNjZW5lLnJvdGF0aW9uLnNldCgwLCBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSwgMCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWNsZVN5c3RlbSA9IGdhbWVPYmplY3RzU2VydmljZS5ob29rR2FtZU9iamVjdChuZXcgQW5pbWF0ZWRHYW1lT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBnbHRmLnNjZW5lLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBnbHRmLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2UuZGVzdHJveUdhbWVPYmplY3QocGFydGljbGVTeXN0ZW0pLFxuICAgICAgICAgICAgICAgICAgICA2MjVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRSYW5kb21Qb3NpdGlvbihhcmVhKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbSA9IChmcm9tLCB0bykgPT4gTWF0aC5yYW5kb20oKSAqICh0byAtIGZyb20pICsgZnJvbTtcblxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgICAgICByYW5kb20oMCwgYXJlYS54KSxcbiAgICAgICAgICAgIHJhbmRvbSgwLCBhcmVhLnkpLFxuICAgICAgICAgICAgcmFuZG9tKDAsIGFyZWEueiksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgY3JlYXRlUGFydGljbGVzKHtcbiAgICAgICAgcGFydGljbGVDb3VudCA9IDEwMDAsXG4gICAgICAgIG5vU2NlbmUgPSBmYWxzZSxcbiAgICAgICAgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygwLCA1LCAwKSxcbiAgICAgICAgc2l6ZSA9IDAuMDEsXG4gICAgICAgIGNvbG9yID0gMHhGRkZGRkYsXG4gICAgICAgIGJsZW5kaW5nID0gVEhSRUUuQWRkaXRpdmVCbGVuZGluZyxcbiAgICAgICAgZGVwdGhUZXN0ID0gdHJ1ZSxcbiAgICAgICAgdHJhbnNwYXJlbnQgPSB0cnVlLFxuICAgICAgICBhcmVhID0gbmV3IFRIUkVFLlZlY3RvcjMoMTAsIDUsIDEwKSxcbiAgICAgICAgZ2V0UGFydGljbGVWZWxvY2l0eSA9ICgpID0+IG5ldyBUSFJFRS5WZWN0b3IzKC0wLjAxLCAtMC4wMSwgMCksXG4gICAgICAgIGdldFBhcnRpY2xlUG9zaXRpb24gPSAoaSwgcG9zaXRpb24gPSB0aGlzLmdldFJhbmRvbVBvc2l0aW9uKGFyZWEpKSA9PiBwb3NpdGlvbixcbiAgICB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcGFydGljbGVzID0gbmV3IFRIUkVFLkdlb21ldHJ5O1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoeyBjb2xvciwgc2l6ZSwgYmxlbmRpbmcsIGRlcHRoVGVzdCwgdHJhbnNwYXJlbnQgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWNsZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpY2xlID0gZ2V0UGFydGljbGVQb3NpdGlvbihpKTtcbiAgICAgICAgICAgIHBhcnRpY2xlcy52ZWxvY2l0eSA9IGdldFBhcnRpY2xlVmVsb2NpdHkoaSwgcGFydGljbGUpO1xuICAgICAgICAgICAgcGFydGljbGVzLnZlcnRpY2VzLnB1c2gocGFydGljbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFydGljbGVTeXN0ZW0gPSBuZXcgVEhSRUUuUG9pbnRDbG91ZChwYXJ0aWNsZXMsIG1hdGVyaWFsKTtcbiAgICAgICAgcGFydGljbGVTeXN0ZW0ucG9zaXRpb24uY29weShwb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMucHVzaCh7XG4gICAgICAgICAgICBvYmplY3Q6IHBhcnRpY2xlU3lzdGVtLFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gcGFydGljbGVDb3VudDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpY2xlID0gcGFydGljbGVzLnZlcnRpY2VzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eSA9IGdldFBhcnRpY2xlVmVsb2NpdHkoaW5kZXgsIHBhcnRpY2xlKTtcblxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS54ICs9IHBhcnRpY2xlLnZlbG9jaXR5Lng7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnkgKz0gcGFydGljbGUudmVsb2NpdHkueTtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUueiArPSBwYXJ0aWNsZS52ZWxvY2l0eS56O1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpY2xlUG9zaXRpb24gPSBnZXRQYXJ0aWNsZVBvc2l0aW9uKGluZGV4LCBwYXJ0aWNsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUueCA9IHBhcnRpY2xlUG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUueSA9IHBhcnRpY2xlUG9zaXRpb24ueTtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUueiA9IHBhcnRpY2xlUG9zaXRpb24uejtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJ0aWNsZXMudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbm9TY2VuZSkge1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5hZGQocGFydGljbGVTeXN0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRpY2xlU3lzdGVtO1xuICAgIH1cbn0iLCJpbXBvcnQgQXV0b0JpbmRNZXRob2RzIGZyb20gJy4vQXV0b0JpbmRNZXRob2RzJztcbmltcG9ydCBBU3RhciBmcm9tICcuL1V0aWxzL0FTdGFyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sbGlkZXJzIGV4dGVuZHMgQXV0b0JpbmRNZXRob2RzIHtcbiAgICBjb25zdHJ1Y3RvcihzY2VuZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMuYXJlYXMgPSBbXTtcbiAgICB9XG5cbiAgICBnZXROZXh0UG9pbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgY29uc3QgYXJlYSA9IHRoaXMuZ2V0QXJlYUJ5UG9zaXRpb24oZnJvbSksXG4gICAgICAgICAgICBmcm9tWCA9IGFyZWEud29ybGRYVG9XYXlwb2ludFgoZnJvbS54KSxcbiAgICAgICAgICAgIGZyb21ZID0gYXJlYS53b3JsZFpUb1dheXBvaW50WShmcm9tLnopLFxuICAgICAgICAgICAgYXJlYVRvID0gdGhpcy5nZXRBcmVhQnlQb3NpdGlvbih0byk7XG5cbiAgICAgICAgbGV0IHRvWDtcbiAgICAgICAgbGV0IHRvWTtcbiAgICAgICAgbGV0IHBvcnRhbDtcblxuICAgICAgICBpZiAoYXJlYS5pZCA9PT0gYXJlYVRvLmlkKSB7XG4gICAgICAgICAgICB0b1ggPSBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKHRvLngpO1xuICAgICAgICAgICAgdG9ZID0gYXJlYS53b3JsZFpUb1dheXBvaW50WSh0by56KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcnRhbCA9IGFyZWEuZ2V0V2F5cG9pbnRQb3J0YWxzKCkuZmluZChwb3J0YWwgPT4gcG9ydGFsLnRvLmFyZWFJZCA9PT0gYXJlYVRvLmlkKTtcblxuICAgICAgICAgICAgaWYgKHBvcnRhbCkge1xuICAgICAgICAgICAgICAgIHRvWCA9IHBvcnRhbC5mcm9tLng7XG4gICAgICAgICAgICAgICAgdG9ZID0gcG9ydGFsLmZyb20ueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5nZXRGcmVlR3JhcGhQb2ludChhcmVhLmdyYXBoLCBmcm9tWCwgZnJvbVkpO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5nZXRGcmVlR3JhcGhQb2ludChhcmVhLmdyYXBoLCB0b1gsIHRvWSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IEFTdGFyLmFzdGFyLnNlYXJjaChcbiAgICAgICAgICAgICAgICBhcmVhLmdyYXBoLFxuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgICB7IGhldXJpc3RpYzogQVN0YXIuYXN0YXIuaGV1cmlzdGljcy5kaWFnb25hbCB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCBuZXh0R3JhcGhQb2ludCA9IHJlc3VsdFsyXSB8fCByZXN1bHRbMV07XG5cbiAgICAgICAgICAgIGlmIChuZXh0R3JhcGhQb2ludCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRXb3JsZFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgICAgICAgICAgICAgIGFyZWEud2F5cG9pbnRYVG9Xb3JsZFgobmV4dEdyYXBoUG9pbnQueCksXG4gICAgICAgICAgICAgICAgICAgIHRvLnksXG4gICAgICAgICAgICAgICAgICAgIGFyZWEud2F5cG9pbnRZVG9Xb3JsZFoobmV4dEdyYXBoUG9pbnQueSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRXb3JsZFBvaW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICBnZXRGcmVlR3JhcGhQb2ludChncmFwaCwgeCwgeSkge1xuICAgICAgICBjb25zdCBncmlkID0gZ3JhcGguZ3JpZDtcblxuICAgICAgICBjb25zdCBnZXRXZWlnaHQgPSAoeCwgeSkgPT4gZ3JpZFt4XSAmJiBncmlkW3hdW3ldICYmIGdyaWRbeF1beV0ud2VpZ2h0O1xuXG4gICAgICAgIGNvbnN0IGdldE5lYXJGcmVlUG9pbnQgPSByYW5nZSA9PiAoXG4gICAgICAgICAgICAoZ2V0V2VpZ2h0KHggKyByYW5nZSwgeSkgJiYgZ3JpZFt4ICsgcmFuZ2VdW3ldKVxuICAgICAgICAgICAgfHwgKGdldFdlaWdodCh4IC0gcmFuZ2UsIHkpICYmIGdyaWRbeCAtIHJhbmdlXVt5XSlcbiAgICAgICAgICAgIHx8IChnZXRXZWlnaHQoeCwgeSArIHJhbmdlKSAmJiBncmlkW3hdW3kgKyByYW5nZV0pXG4gICAgICAgICAgICB8fCAoZ2V0V2VpZ2h0KHgsIHkgLSByYW5nZSkgJiYgZ3JpZFt4XVt5IC0gcmFuZ2VdKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZ2V0V2VpZ2h0KGdyaWRbeF1beV0pICYmIGdyaWRbeF1beV0pXG4gICAgICAgICAgICB8fCBnZXROZWFyRnJlZVBvaW50KDEpXG4gICAgICAgICAgICB8fCBnZXROZWFyRnJlZVBvaW50KDIpXG4gICAgICAgICAgICB8fCBnZXROZWFyRnJlZVBvaW50KDMpXG4gICAgICAgICAgICB8fCBnZXROZWFyRnJlZVBvaW50KDQpXG4gICAgICAgICAgICB8fCBudWxsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVidWlsZEFyZWFzKCkge1xuICAgICAgICBpZiAodGhpcy5zY2VuZS5sb2NhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hcmVhcyA9IHRoaXMuc2NlbmUubG9jYXRpb24uZ2V0QXJlYXMoKS5tYXAoYXJlYSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLmFyZWEsXG4gICAgICAgICAgICAgICAgZ3JhcGg6IG5ldyBBU3Rhci5HcmFwaChhcmVhLmdldFdheXBvaW50cygpLCB7IGRpYWdvbmFsOiB0cnVlIH0pLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0QXJlYUJ5UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJlYXMuZmluZChhcmVhID0+IGFyZWEuaW5jbHVkZXNQb3NpdGlvbihwb3NpdGlvbikpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBQbGF5ZXIgfSBmcm9tICcuL0dhbWVPYmplY3RzJztcbi8vIGltcG9ydCBBdWRpbyBmcm9tICcuL0F1ZGlvJztcbmltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuaW1wb3J0IENhbWVyYSBmcm9tICcuL0NhbWVyYSc7XG5pbXBvcnQgQ29ubmVjdGlvbiBmcm9tICcuL0Nvbm5lY3Rpb24nO1xuaW1wb3J0IEdhbWVPYmplY3RzU2VydmljZSBmcm9tICcuL0dhbWVPYmplY3RzJztcbmltcG9ydCBJbnB1dCBmcm9tICcuL0lucHV0JztcbmltcG9ydCBJbnRlcnZhbHMgZnJvbSAnLi9JbnRlcnZhbHMnO1xuaW1wb3J0IExvY2F0aW9uIGZyb20gJy4vTG9jYXRpb25zL0RyZWFtVG93bic7XG5pbXBvcnQgQ29sbGlkZXJzIGZyb20gJy4vQ29sbGlkZXJzJztcbmltcG9ydCBNb2RlbHMgZnJvbSAnLi9Nb2RlbHMnO1xuaW1wb3J0IFBhcnRpY2xlcyBmcm9tICcuL1BhcnRpY2xlcyc7XG5pbXBvcnQgUGF0aEZpbmRlciBmcm9tICcuL1BhdGhGaW5kZXInO1xuaW1wb3J0IFVuaXRzIGZyb20gJy4vVW5pdHMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lIGV4dGVuZHMgQXV0b0JpbmRNZXRob2RzIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICBzZXRSZXN0YXJ0QnV0dG9uVmlzaWJsZTogZnVuY3Rpb24sXG4gICAgICogIHNldFBhdXNlOiBmdW5jdGlvbixcbiAgICAgKiAgcmVzdGFydEdhbWU6IGZ1bmN0aW9uLFxuICAgICAqICBpc1BhdXNlOiBmdW5jdGlvbixcbiAgICAgKiAgaXNUaGlyZFBlcnNvbjogZnVuY3Rpb24sXG4gICAgICogIHVwZGF0ZTogZnVuY3Rpb24sXG4gICAgICogIHVwZGF0ZVBsYXllclBhcmFtczogZnVuY3Rpb24sXG4gICAgICogIGNsZWFySHBCYXJzOiBmdW5jdGlvbixcbiAgICAgKiAgc3dpdGNoQ2FtZXJhOiBmdW5jdGlvbixcbiAgICAgKiAgc2V0RnBzOiBmdW5jdGlvbixcbiAgICAgKiAgbm90aWZ5OiBmdW5jdGlvbixcbiAgICAgKiB9fSB1aVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCB1aSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNsb2NrID0gbmV3IFRIUkVFLkNsb2NrKCk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzID0gbmV3IEludGVydmFscyh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnVpID0gdWk7XG4gICAgICAgIHRoaXMubW9kZWxzID0gbmV3IE1vZGVscyh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgICB0aGlzLnBhdGhGaW5kZXIgPSBuZXcgUGF0aEZpbmRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5jb2xsaWRlcnMgPSBuZXcgQ29sbGlkZXJzKHRoaXMpO1xuICAgICAgICB0aGlzLnVuaXRzID0gbmV3IFVuaXRzKHRoaXMpO1xuICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmEodGhpcyk7XG4gICAgICAgIC8vIHRoaXMuYXVkaW8gPSBuZXcgQXVkaW8odGhpcyk7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgSW5wdXQoe1xuICAgICAgICAgICAgb25BY3Rpb246ICgpID0+IHRoaXMubGV2ZWwub25BY3Rpb24oKSxcbiAgICAgICAgICAgIG9uRXhpdDogKCkgPT4gdGhpcy51aS5zZXRQYXVzZSghdGhpcy51aS5pc1BhdXNlKCkpLFxuICAgICAgICAgICAgb25ab29tOiB6b29tID0+IHRoaXMuY2FtZXJhLmFkZFkoem9vbSksXG4gICAgICAgICAgICBvblN3aXRjaENhbWVyYTogKCkgPT4gdGhpcy51aS5zd2l0Y2hDYW1lcmEoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdHNTZXJ2aWNlID0gbmV3IEdhbWVPYmplY3RzU2VydmljZSh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBuZXcgUGFydGljbGVzKHRoaXMpO1xuXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25Ib3N0bmFtZSA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdCcgPyAnbG9jYWxob3N0JyA6ICdnb2h0bWwucnUnO1xuICAgICAgICBjb25zdCBpc1NTTCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gJ2xvY2FsaG9zdCc7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKHRoaXMsIGNvbm5lY3Rpb25Ib3N0bmFtZSwgMTMzNywgaXNTU0wpO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbmV3IExvY2F0aW9uKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzLnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudWkuc2V0RnBzKHRoaXMucmVuZGVyZXIuZnBzLCB0aGlzLnJlbmRlcmVyLnRhcmdldEZwcyk7XG4gICAgICAgICAgICB0aGlzLnVpLnVwZGF0ZVBsYXllclBhcmFtcygpXG4gICAgICAgIH0sIDEwMDApO1xuXG4gICAgICAgIHRoaXMuaW5wdXQuaXNUaGlyZFBlcnNvbiA9IHVpLmlzVGhpcmRQZXJzb24oKTtcbiAgICAgICAgdGhpcy5wYXRoRmluZGVyLnJlYnVpbGRBcmVhcygpO1xuXG4gICAgICAgIHRoaXMuY2xlYXJTY2VuZSgpO1xuICAgICAgICB0aGlzLmFuaW1hdGUoKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnU2NlbmUnLCB0aGlzKTtcbiAgICB9XG5cbiAgICBjbGVhclNjZW5lKCkge1xuICAgICAgICB0aGlzLmdhbWVPYmplY3RzU2VydmljZS5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbi5hZnRlckNsZWFyKCk7XG4gICAgfVxuXG4gICAgYW5pbWF0ZSgpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgZGVsdGFUaW1lID0gdGhpcy5pbnRlcnZhbHMuZ2V0RGVsdGFUaW1lKG5vdyk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzLnVwZGF0ZShub3cpO1xuICAgICAgICBjb25zdCBnYW1lVGltZSA9IHRoaXMuaW50ZXJ2YWxzLmdldFRpbWVQYXNzZWQoKTtcblxuICAgICAgICB0aGlzLmdhbWVPYmplY3RzU2VydmljZS51cGRhdGUoZ2FtZVRpbWUsIGRlbHRhVGltZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnVpLmlzUGF1c2UoKSkge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlKGdhbWVUaW1lLCBkZWx0YVRpbWUpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC51cGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudWkudXBkYXRlKCk7XG4gICAgICAgIHRoaXMubG9jYXRpb24udXBkYXRlKCk7XG4gICAgICAgIHRoaXMucGFydGljbGVzLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24udXBkYXRlKGdhbWVUaW1lLCBkZWx0YVRpbWUpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLmNhbWVyYSwgZGVsdGFUaW1lKTtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGUpO1xuICAgIH1cblxuICAgIHNldExvZ2dlZFVzZXIodXNlck5hbWUsIHBhc3N3b3JkKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHsgdXNlck5hbWUsIHBhc3N3b3JkIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BsYXllcn1cbiAgICAgKi9cbiAgICBnZXRQbGF5ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaXRzLmdldFBsYXllcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VEhSRUUuT2JqZWN0M0R9IG9iamVjdFxuICAgICAqL1xuICAgIGFkZChvYmplY3QpIHtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RIUkVFLk9iamVjdDNEfSBvYmplY3RcbiAgICAgKi9cbiAgICByZW1vdmUob2JqZWN0KSB7XG4gICAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKG9iamVjdCk7XG4gICAgfVxuXG4gICAgbm90aWZ5KHRleHQpIHtcbiAgICAgICAgdGhpcy51aS5ub3RpZnkodGV4dCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5pbXBvcnQgeyBQbGF5ZXIsIEFJLCBBbmltYXRlZEdhbWVPYmplY3QgfSBmcm9tICcuL0dhbWVPYmplY3RzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5pdHMgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuXHRjb25zdHJ1Y3RvcihzY2VuZSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xuXHRcdHRoaXMucGxheWVyID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0Z2V0VW5pdHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlLmdldFVuaXRzKCk7XG5cdH1cblxuXHRnZXRBbGl2ZVVuaXRzKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFVuaXRzKCkuZmlsdGVyKGdhbWVPYmplY3QgPT4gZ2FtZU9iamVjdC5pc0FsaXZlKCkpO1xuXHR9XG5cblx0Z2V0UGxheWVyKCkge1xuXHRcdHJldHVybiB0aGlzLnBsYXllcjtcblx0fVxuXG5cdHNldERlZmF1bHRQbGF5ZXJQYXJhbXMoZGVmYXVsdFBhcmFtcykge1xuXHRcdHRoaXMuZGVmYXVsdFBhcmFtcyA9IGRlZmF1bHRQYXJhbXM7XG5cdH1cblxuXHRjcmVhdGVQbGF5ZXIoe1xuXHRcdG9uQ3JlYXRlID0gKCkgPT4gbnVsbCxcblx0XHRvbktpbGwgPSAoKSA9PiBudWxsLFxuXHRcdG9uRGFtYWdlRGVhbCA9ICgpID0+IG51bGwsXG5cdFx0b25EYW1hZ2VUYWtlbiA9ICgpID0+IG51bGwsXG5cdFx0b25EaWUgPSAoKSA9PiBudWxsLFxuXHRcdG9uTGV2ZWxVcCA9ICgpID0+IG51bGwsXG5cdH0gPSB7fSkge1xuXHRcdGNvbnN0IGdhbWVPYmplY3RzU2VydmljZSA9IHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2NlbmUubW9kZWxzLmxvYWRHTFRGKHtcblx0XHRcdGJhc2VVcmw6ICcuL2Fzc2V0cy9tb2RlbHMvdW5pdHMvcGxheWVyJyxcblx0XHRcdGNhbGxiYWNrOiAobG9hZGVkTW9kZWwpID0+IHtcblx0XHRcdFx0Y29uc3QgZGVmYXVsdFBhcmFtcyA9IHRoaXMuZGVmYXVsdFBhcmFtcztcblx0XHRcdFx0bG9hZGVkTW9kZWwuc2NlbmUucG9zaXRpb24uc2V0KDAsIDAuMSwgMCk7XG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEB0eXBlIHtQbGF5ZXJ9XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRjb25zdCBwbGF5ZXIgPSBnYW1lT2JqZWN0c1NlcnZpY2UuaG9va0dhbWVPYmplY3QobmV3IFBsYXllcih7XG5cdFx0XHRcdFx0YW5pbWF0aW9uczogbG9hZGVkTW9kZWwuYW5pbWF0aW9ucyxcblx0XHRcdFx0XHRvYmplY3Q6IGxvYWRlZE1vZGVsLnNjZW5lLFxuXHRcdFx0XHRcdGlucHV0OiB0aGlzLnNjZW5lLmlucHV0LFxuXHRcdFx0XHRcdGNvbXBsZXhBbmltYXRpb25zOiB0cnVlLFxuXHRcdFx0XHRcdGNoZWNrV2F5OiB0aGlzLnNjZW5lLmNvbGxpZGVycy5jaGVja1dheSxcblx0XHRcdFx0XHRuYW1lOiB0aGlzLnNjZW5lLnVzZXIgPyB0aGlzLnNjZW5lLnVzZXIudXNlck5hbWUgOiAnICcsXG5cdFx0XHRcdFx0b25EYW1hZ2VEZWFsOiBkYW1hZ2VkVW5pdCA9PiBvbkRhbWFnZURlYWwoZGFtYWdlZFVuaXQpLFxuXHRcdFx0XHRcdG9uRGFtYWdlVGFrZW46IChhdHRhY2tlcikgPT4ge1xuXHRcdFx0XHRcdFx0b25EYW1hZ2VUYWtlbihhdHRhY2tlcik7XG5cdFx0XHRcdFx0XHR0aGlzLnNjZW5lLnBhcnRpY2xlcy5sb2FkRWZmZWN0KHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb246IHBsYXllci5wb3NpdGlvbi5jbG9uZSgpLmFkZChuZXcgVEhSRUUuVmVjdG9yMygwLCAwLjc1LCAwKSlcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0b25LaWxsOiAob2JqZWN0KSA9PiBvbktpbGwob2JqZWN0KSxcblx0XHRcdFx0XHRvbkRpZTogKGtpbGxlcikgPT4gb25EaWUoa2lsbGVyKSxcblx0XHRcdFx0XHRvbkxldmVsVXA6ICgpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2NlbmUucGFydGljbGVzLmNyZWF0ZUVmZmVjdCh7XG5cdFx0XHRcdFx0XHRcdGVmZmVjdDogJ2xldmVsLXVwLWFsdC9sZXZlbC11cCcsXG5cdFx0XHRcdFx0XHRcdHNjYWxlOiAxLjUsXG5cdFx0XHRcdFx0XHRcdGF0dGFjaFRvOiB0aGlzLnBsYXllci5vYmplY3QsXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdG9uTGV2ZWxVcCgpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0YXR0YWNrOiAoKSA9PiBnYW1lT2JqZWN0c1NlcnZpY2UuYXR0YWNrKHBsYXllciksXG5cdFx0XHRcdFx0ZmlyZTogKCkgPT4gZ2FtZU9iamVjdHNTZXJ2aWNlLmZpcmUocGxheWVyKSxcblx0XHRcdFx0XHRkZXN0cm95OiAoKSA9PiBnYW1lT2JqZWN0c1NlcnZpY2UuZGVzdHJveUdhbWVPYmplY3QocGxheWVyKSxcblx0XHRcdFx0fSkpO1xuXG5cdFx0XHRcdHRoaXMucGxheWVyID0gcGxheWVyO1xuXHRcdFx0XHRvbkNyZWF0ZShwbGF5ZXIpO1xuXG5cdFx0XHRcdGlmIChkZWZhdWx0UGFyYW1zICYmIGRlZmF1bHRQYXJhbXMucGFyYW1zKSB7XG5cdFx0XHRcdFx0Y29uc3QgeyBwb3NpdGlvbiwgcm90YXRpb24sIHBhcmFtcyB9ID0gZGVmYXVsdFBhcmFtcztcblx0XHRcdFx0XHRjb25zdCBwbGF5ZXJQYXJhbXMgPSBwbGF5ZXIucGFyYW1zO1xuXG5cdFx0XHRcdFx0cGxheWVyLnBvc2l0aW9uLnNldChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcblx0XHRcdFx0XHRwbGF5ZXIucm90YXRpb24uc2V0KHJvdGF0aW9uLngsIHJvdGF0aW9uLnksIHJvdGF0aW9uLnopO1xuXHRcdFx0XHRcdHBsYXllclBhcmFtcy5ocCA9IHBhcmFtcy5ocDtcblx0XHRcdFx0XHRwbGF5ZXJQYXJhbXMuaHBNYXggPSBwYXJhbXMuaHBNYXg7XG5cdFx0XHRcdFx0cGxheWVyUGFyYW1zLmZyYWN0aW9uID0gcGFyYW1zLmZyYWN0aW9uO1xuXHRcdFx0XHRcdHBsYXllclBhcmFtcy5sZXZlbCA9IHBhcmFtcy5sZXZlbDtcblx0XHRcdFx0XHRwbGF5ZXJQYXJhbXMuZGFtYWdlID0gcGFyYW1zLmRhbWFnZTtcblx0XHRcdFx0XHRwbGF5ZXJQYXJhbXMuc3BlZWQgPSBwYXJhbXMuc3BlZWQ7XG5cdFx0XHRcdFx0cGxheWVyUGFyYW1zLmV4cGVyaWVuY2UgPSBwYXJhbXMuZXhwZXJpZW5jZTtcblx0XHRcdFx0XHRwbGF5ZXJQYXJhbXMubW9uZXkgPSBwYXJhbXMubW9uZXk7XG5cdFx0XHRcdFx0cGxheWVyUGFyYW1zLnVuc3BlbnRUYWxlbnRzID0gcGFyYW1zLnVuc3BlbnRUYWxlbnRzO1xuXG5cdFx0XHRcdFx0aWYgKCFwbGF5ZXJQYXJhbXMuaHApIHtcblx0XHRcdFx0XHRcdHBsYXllci5hbmltYXRpb25TdGF0ZS5pc0RpZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRjcmVhdGVBSSh7IGZyYWN0aW9uLCBsZXZlbCwgcG9zaXRpb246IHsgeCwgeSwgeiB9LCByb3RhdGlvbiA9IHt9LCBzY2FsZSwgb25EaWUsIG5hbWUgfSkge1xuXHRcdGNvbnN0IGdhbWVPYmplY3RzU2VydmljZSA9IHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlO1xuXHRcdGNvbnN0IGdldFByaW9yaXR5ID0gKHVuaXQsIHRhcmdldCkgPT4gKFxuXHRcdFx0KHRhcmdldCBpbnN0YW5jZW9mIFBsYXllciA/IDAuNzUgOiAwKVxuXHRcdFx0KyAxIC8gTWF0aC5jZWlsKHRhcmdldC5wb3NpdGlvbi5kaXN0YW5jZVRvKHVuaXQucG9zaXRpb24pKVxuXHRcdCk7XG5cblx0XHR0aGlzLnNjZW5lLm1vZGVscy5sb2FkR0xURih7XG5cdFx0XHRiYXNlVXJsOiBmcmFjdGlvbiA9PT0gJ2dvYXRzJ1xuXHRcdFx0XHQ/ICcuL2Fzc2V0cy9tb2RlbHMvdW5pdHMvZ29hdC13YXJyaW9yJ1xuXHRcdFx0XHQ6ICcuL2Fzc2V0cy9tb2RlbHMvdW5pdHMvZW5lbXknLFxuXHRcdFx0Y2FsbGJhY2s6IChnbHRmKSA9PiB7XG5cdFx0XHRcdGNvbnN0IG5ldHdvcmtDb25uZWN0aW9uID0gdGhpcy5zY2VuZS5jb25uZWN0aW9uO1xuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhbmV0d29ya0Nvbm5lY3Rpb25cblx0XHRcdFx0XHR8fCAhbmV0d29ya0Nvbm5lY3Rpb24ubWV0YVxuXHRcdFx0XHRcdHx8ICFuZXR3b3JrQ29ubmVjdGlvbi5tZXRhLnJvbGVcblx0XHRcdFx0XHR8fCBuZXR3b3JrQ29ubmVjdGlvbi5tZXRhLnJvbGUgPT09ICdob3N0J1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvKiogQHR5cGUge0FJfSAqL1xuXHRcdFx0XHRcdGNvbnN0IGFpID0gZ2FtZU9iamVjdHNTZXJ2aWNlLmhvb2tHYW1lT2JqZWN0KG5ldyBBSSh7XG5cdFx0XHRcdFx0XHRhbmltYXRpb25zOiBnbHRmLmFuaW1hdGlvbnMsXG5cdFx0XHRcdFx0XHRvYmplY3Q6IGdsdGYuc2NlbmUsXG5cdFx0XHRcdFx0XHRzcGVlZDogMC4zNSArIGxldmVsICogMC4wMjUsXG5cdFx0XHRcdFx0XHRkYW1hZ2U6IDUgKyBsZXZlbCAqIDEuNSxcblx0XHRcdFx0XHRcdGhwOiA3MCArIGxldmVsICogMzAsXG5cdFx0XHRcdFx0XHRmcmFjdGlvbixcblx0XHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0XHRsZXZlbCxcblx0XHRcdFx0XHRcdGNoZWNrV2F5OiB0aGlzLnNjZW5lLmNvbGxpZGVycy5jaGVja1dheSxcblx0XHRcdFx0XHRcdGdldE5leHRQb2ludDogdGhpcy5zY2VuZS5wYXRoRmluZGVyLmdldE5leHRQb2ludCxcblx0XHRcdFx0XHRcdGF0dGFjazogKCkgPT4gZ2FtZU9iamVjdHNTZXJ2aWNlLmF0dGFjayhhaSksXG5cdFx0XHRcdFx0XHRvbkRhbWFnZVRha2VuOiAoKSA9PiB0aGlzLnNjZW5lLnBhcnRpY2xlcy5sb2FkRWZmZWN0KHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb246IGFpLnBvc2l0aW9uLmNsb25lKCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAuNzUsIDApKVxuXHRcdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0XHRvbkRpZTogKCkgPT4gdGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmIChhaS5pc0RlYWQoKSkge1xuXHRcdFx0XHRcdFx0XHRcdGdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdChhaSk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAob25EaWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9uRGllKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCAxMDAwMCksXG5cdFx0XHRcdFx0XHRmaW5kVGFyZ2V0OiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5lYXJFbmVteVVuaXRzID0gdGhpcy5nZXRBbGl2ZVVuaXRzKClcblx0XHRcdFx0XHRcdFx0XHQuZmlsdGVyKHVuaXQgPT4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0dW5pdCAhPT0gYWlcblx0XHRcdFx0XHRcdFx0XHRcdCYmIHVuaXQuZ2V0RnJhY3Rpb24oKSAhPT0gZnJhY3Rpb25cblx0XHRcdFx0XHRcdFx0XHRcdCYmIHVuaXQucG9zaXRpb24uZGlzdGFuY2VUbyhhaS5wb3NpdGlvbikgPCAxNVxuXHRcdFx0XHRcdFx0XHRcdCkpXG5cdFx0XHRcdFx0XHRcdFx0LnNvcnQoKHVuaXRBLCB1bml0QikgPT4gZ2V0UHJpb3JpdHkoYWksIHVuaXRCKSAtIGdldFByaW9yaXR5KGFpLCB1bml0QSkpO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZWFyRW5lbXlVbml0cy5sZW5ndGggPyBuZWFyRW5lbXlVbml0c1swXSA6IG51bGw7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0XHRcdGFpLnBvc2l0aW9uLnNldCh4IHx8IDAsIHkgfHwgMCwgeiB8fCAwKTtcblx0XHRcdFx0XHRhaS5yb3RhdGlvbi5zZXQocm90YXRpb24ueCB8fCAwLCByb3RhdGlvbi55IHx8IDAsIHJvdGF0aW9uLnogfHwgMCk7XG5cblx0XHRcdFx0XHRpZiAoc2NhbGUpIHtcblx0XHRcdFx0XHRcdGFpLm9iamVjdC5zY2FsZS5zZXQoc2NhbGUsIHNjYWxlLCBzY2FsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdH0pO1xuXHR9XG5cblx0Y3JlYXRlTmV0d29ya0FJKFxuXHRcdHtcblx0XHRcdHBhcmFtczoge1xuXHRcdFx0XHRmcmFjdGlvbixcblx0XHRcdFx0dW5pdE5ldHdvcmtJZCxcblx0XHRcdFx0bGV2ZWwsXG5cdFx0XHRcdG5hbWUsXG5cdFx0XHRcdGhwLFxuXHRcdFx0XHRocE1heCxcblx0XHRcdFx0ZGFtYWdlLFxuXHRcdFx0XHRmcm9tTmV0d29yayA9IHRydWVcblx0XHRcdH0sXG5cdFx0XHRwb3NpdGlvbixcblx0XHRcdG9uRGllXG5cdFx0fSxcblx0XHRjYWxsYmFjayA9ICgpID0+IHtcblx0XHR9LFxuXHQpIHtcblx0XHRjb25zdCBnYW1lT2JqZWN0c1NlcnZpY2UgPSB0aGlzLnNjZW5lLmdhbWVPYmplY3RzU2VydmljZTtcblx0XHRjb25zdCBnZXRQcmlvcml0eSA9ICh1bml0LCB0YXJnZXQpID0+IChcblx0XHRcdCh0YXJnZXQgaW5zdGFuY2VvZiBQbGF5ZXIgPyAwLjc1IDogMClcblx0XHRcdCsgMSAvIE1hdGguY2VpbCh0YXJnZXQucG9zaXRpb24uZGlzdGFuY2VUbyh1bml0LnBvc2l0aW9uKSlcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2NlbmUubW9kZWxzLmxvYWRHTFRGKHtcblx0XHRcdGJhc2VVcmw6IGZyYWN0aW9uID09PSAnZ29hdHMnXG5cdFx0XHRcdD8gJy4vYXNzZXRzL21vZGVscy91bml0cy9nb2F0LXdhcnJpb3InXG5cdFx0XHRcdDogJy4vYXNzZXRzL21vZGVscy91bml0cy9lbmVteScsXG5cdFx0XHRjYWxsYmFjazogKGxvYWRlZE9iamVjdCkgPT4ge1xuXHRcdFx0XHRjb25zdCBhaSA9IGdhbWVPYmplY3RzU2VydmljZS5ob29rR2FtZU9iamVjdChuZXcgQUkoe1xuXHRcdFx0XHRcdG9iamVjdDogbG9hZGVkT2JqZWN0LnNjZW5lLFxuXHRcdFx0XHRcdGFuaW1hdGlvbnM6IGxvYWRlZE9iamVjdC5hbmltYXRpb25zLFxuXHRcdFx0XHRcdHVuaXROZXR3b3JrSWQsXG5cdFx0XHRcdFx0ZnJhY3Rpb24sXG5cdFx0XHRcdFx0bGV2ZWwsXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRocCxcblx0XHRcdFx0XHRocE1heCxcblx0XHRcdFx0XHRkYW1hZ2UsXG5cdFx0XHRcdFx0ZnJvbU5ldHdvcmssXG5cdFx0XHRcdFx0Y2hlY2tXYXk6IHRoaXMuc2NlbmUuY29sbGlkZXJzLmNoZWNrV2F5LFxuXHRcdFx0XHRcdGdldE5leHRQb2ludDogdGhpcy5zY2VuZS5wYXRoRmluZGVyLmdldE5leHRQb2ludCxcblx0XHRcdFx0XHRhdHRhY2s6ICgpID0+IGdhbWVPYmplY3RzU2VydmljZS5hdHRhY2soYWkpLFxuXHRcdFx0XHRcdG9uRGFtYWdlVGFrZW46ICgpID0+IHRoaXMuc2NlbmUucGFydGljbGVzLmxvYWRFZmZlY3Qoe1xuXHRcdFx0XHRcdFx0cG9zaXRpb246IGFpLnBvc2l0aW9uLmNsb25lKCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAuNzUsIDApKVxuXHRcdFx0XHRcdH0pLFxuXG5cdFx0XHRcdFx0b25EaWU6ICgpID0+IHRoaXMuc2NlbmUuaW50ZXJ2YWxzLnNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGFpLmlzRGVhZCgpKSB7XG5cdFx0XHRcdFx0XHRcdGdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdChhaSk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFhaS5wYXJhbXMuZnJvbU5ldHdvcmspIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmNyZWF0ZU5ldHdvcmtBSSh7XG5cdFx0XHRcdFx0XHRcdFx0XHRmcmFjdGlvbixcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXROZXR3b3JrSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdFx0XHRcdFx0aHAsXG5cdFx0XHRcdFx0XHRcdFx0XHRocE1heCxcblx0XHRcdFx0XHRcdFx0XHRcdGRhbWFnZSxcblx0XHRcdFx0XHRcdFx0XHRcdGZyb21OZXR3b3JrOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRcdGxldmVsOiBsZXZlbCArIDEgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBsZXZlbCksXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCAxMDAwMCksXG5cdFx0XHRcdFx0ZmluZFRhcmdldDogKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKCFhaS5wYXJhbXMuZnJvbU5ldHdvcmspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbmVhckVuZW15VW5pdHMgPSB0aGlzLmdldEFsaXZlVW5pdHMoKVxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIodW5pdCA9PiAoXG5cdFx0XHRcdFx0XHRcdFx0XHR1bml0ICE9PSBhaVxuXHRcdFx0XHRcdFx0XHRcdFx0JiYgdW5pdC5nZXRGcmFjdGlvbigpICE9PSBmcmFjdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0JiYgdW5pdC5wb3NpdGlvbi5kaXN0YW5jZVRvKGFpLnBvc2l0aW9uKSA8IDE1XG5cdFx0XHRcdFx0XHRcdFx0KSlcblx0XHRcdFx0XHRcdFx0XHQuc29ydCgodW5pdEEsIHVuaXRCKSA9PiBnZXRQcmlvcml0eShhaSwgdW5pdEIpIC0gZ2V0UHJpb3JpdHkoYWksIHVuaXRBKSk7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5lYXJFbmVteVVuaXRzLmxlbmd0aCA/IG5lYXJFbmVteVVuaXRzWzBdIDogbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KSk7XG5cblxuXHRcdFx0XHRjYWxsYmFjayhhaSk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXHR9XG5cblx0Y3JlYXRlTmV0d29ya1BsYXllcih7XG5cdFx0cGFyYW1zOiB7IGNvbm5lY3Rpb25JZCwgdW5pdE5ldHdvcmtJZCwgbmFtZSB9LFxuXHRcdG9uRGFtYWdlRGVhbCxcblx0XHRvbktpbGwsXG5cdFx0b25EaWUsXG5cdFx0b25MZXZlbFVwLFxuXHRcdG9uRGFtYWdlVGFrZW4sXG5cdH0sIGNhbGxiYWNrKSB7XG5cdFx0Y29uc3QgZ2FtZU9iamVjdHNTZXJ2aWNlID0gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2U7XG5cblx0XHRyZXR1cm4gdGhpcy5zY2VuZS5tb2RlbHMubG9hZEdMVEYoe1xuXHRcdFx0YmFzZVVybDogJy4vYXNzZXRzL21vZGVscy91bml0cy9uZXR3b3JrLXBsYXllcicsXG5cdFx0XHRjYWxsYmFjazogKGxvYWRlZE9iamVjdCkgPT4ge1xuXHRcdFx0XHQvKiogQHR5cGUge1BsYXllcn0gKi9cblx0XHRcdFx0Y29uc3QgcGxheWVyID0gZ2FtZU9iamVjdHNTZXJ2aWNlLmhvb2tHYW1lT2JqZWN0KG5ldyBQbGF5ZXIoe1xuXHRcdFx0XHRcdG9iamVjdDogbG9hZGVkT2JqZWN0LnNjZW5lLFxuXHRcdFx0XHRcdGFuaW1hdGlvbnM6IGxvYWRlZE9iamVjdC5hbmltYXRpb25zLFxuXHRcdFx0XHRcdHVuaXROZXR3b3JrSWQsXG5cdFx0XHRcdFx0Y29ubmVjdGlvbklkLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZnJvbU5ldHdvcms6IHRydWUsXG5cdFx0XHRcdFx0Y29tcGxleEFuaW1hdGlvbnM6IHRydWUsXG5cdFx0XHRcdFx0Y2hlY2tXYXk6IHRoaXMuc2NlbmUuY29sbGlkZXJzLmNoZWNrV2F5LFxuXHRcdFx0XHRcdGlucHV0OiB7XG5cdFx0XHRcdFx0XHR2ZXJ0aWNhbDogMCxcblx0XHRcdFx0XHRcdGhvcml6b250YWw6IDAsXG5cdFx0XHRcdFx0XHRqdW1wOiBmYWxzZSxcblx0XHRcdFx0XHRcdGN1cnNvcjoge1xuXHRcdFx0XHRcdFx0XHR4OiAwLFxuXHRcdFx0XHRcdFx0XHR5OiAwLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGxvb2s6IHtcblx0XHRcdFx0XHRcdFx0dmVydGljYWw6IDAsXG5cdFx0XHRcdFx0XHRcdGhvcml6b250YWw6IDAsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0b25EaWU6IChraWxsZXIpID0+IHRoaXMuc2NlbmUuaW50ZXJ2YWxzLnNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHBsYXllci5pc0RlYWQoKSkge1xuXHRcdFx0XHRcdFx0XHRnYW1lT2JqZWN0c1NlcnZpY2UuZGVzdHJveUdhbWVPYmplY3QocGxheWVyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9uRGllICYmIG9uRGllKGtpbGxlcilcblx0XHRcdFx0XHR9LCAxMDAwMCksXG5cdFx0XHRcdFx0b25EYW1hZ2VEZWFsOiBkYW1hZ2VkVW5pdCA9PiBvbkRhbWFnZURlYWwgJiYgb25EYW1hZ2VEZWFsKGRhbWFnZWRVbml0KSxcblx0XHRcdFx0XHRvbkRhbWFnZVRha2VuOiAoYXR0YWNrZXIpID0+IHtcblx0XHRcdFx0XHRcdG9uRGFtYWdlVGFrZW4gJiYgb25EYW1hZ2VUYWtlbihhdHRhY2tlcik7XG5cdFx0XHRcdFx0XHR0aGlzLnNjZW5lLnBhcnRpY2xlcy5sb2FkRWZmZWN0KHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb246IHBsYXllci5wb3NpdGlvbi5jbG9uZSgpLmFkZChuZXcgVEhSRUUuVmVjdG9yMygwLCAwLjc1LCAwKSlcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0b25LaWxsOiAob2JqZWN0KSA9PiBvbktpbGwgJiYgb25LaWxsKG9iamVjdCksXG5cdFx0XHRcdFx0b25MZXZlbFVwOiAoKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnNjZW5lLnBhcnRpY2xlcy5jcmVhdGVFZmZlY3Qoe1xuXHRcdFx0XHRcdFx0XHRlZmZlY3Q6ICdsZXZlbC11cC1hbHQvbGV2ZWwtdXAnLFxuXHRcdFx0XHRcdFx0XHRzY2FsZTogMS41LFxuXHRcdFx0XHRcdFx0XHRhdHRhY2hUbzogdGhpcy5wbGF5ZXIub2JqZWN0LFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRvbkxldmVsVXAgJiYgb25MZXZlbFVwKCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRhdHRhY2s6ICgpID0+IGdhbWVPYmplY3RzU2VydmljZS5hdHRhY2socGxheWVyKSxcblx0XHRcdFx0XHRmaXJlOiAoKSA9PiBnYW1lT2JqZWN0c1NlcnZpY2UuZmlyZShwbGF5ZXIpLFxuXHRcdFx0XHRcdGRlc3Ryb3k6ICgpID0+IGdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdChwbGF5ZXIpLFxuXHRcdFx0XHR9KSk7XG5cblx0XHRcdFx0Y2FsbGJhY2socGxheWVyKTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cdH1cbn0iLCIvLyBqYXZhc2NyaXB0LWFzdGFyIDAuNC4xXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9iZ3JpbnMvamF2YXNjcmlwdC1hc3RhclxuLy8gRnJlZWx5IGRpc3RyaWJ1dGFibGUgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuLy8gSW1wbGVtZW50cyB0aGUgYXN0YXIgc2VhcmNoIGFsZ29yaXRobSBpbiBqYXZhc2NyaXB0IHVzaW5nIGEgQmluYXJ5IEhlYXAuXG4vLyBJbmNsdWRlcyBCaW5hcnkgSGVhcCAod2l0aCBtb2RpZmljYXRpb25zKSBmcm9tIE1hcmlqbiBIYXZlcmJla2UuXG4vLyBodHRwOi8vZWxvcXVlbnRqYXZhc2NyaXB0Lm5ldC9hcHBlbmRpeDIuaHRtbFxuKGZ1bmN0aW9uKGRlZmluaXRpb24pIHtcbiAgICAvKiBnbG9iYWwgbW9kdWxlLCBkZWZpbmUgKi9cbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgICAgICB3aW5kb3cuYXN0YXIgPSBleHBvcnRzLmFzdGFyO1xuICAgICAgICB3aW5kb3cuR3JhcGggPSBleHBvcnRzLkdyYXBoO1xuICAgIH1cbn0pKGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gcGF0aFRvKG5vZGUpIHtcbiAgICAgICAgdmFyIGN1cnIgPSBub2RlO1xuICAgICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgICB3aGlsZSAoY3Vyci5wYXJlbnQpIHtcbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChjdXJyKTtcbiAgICAgICAgICAgIGN1cnIgPSBjdXJyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRIZWFwKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUhlYXAoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGFzdGFyID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhbiBBKiBTZWFyY2ggb24gYSBncmFwaCBnaXZlbiBhIHN0YXJ0IGFuZCBlbmQgbm9kZS5cbiAgICAgICAgICogQHBhcmFtIHtHcmFwaH0gZ3JhcGhcbiAgICAgICAgICogQHBhcmFtIHtHcmlkTm9kZX0gc3RhcnRcbiAgICAgICAgICogQHBhcmFtIHtHcmlkTm9kZX0gZW5kXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICogQHBhcmFtIHtib29sfSBbb3B0aW9ucy5jbG9zZXN0XSBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAgICAgICBwYXRoIHRvIHRoZSBjbG9zZXN0IG5vZGUgaWYgdGhlIHRhcmdldCBpcyB1bnJlYWNoYWJsZS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuaGV1cmlzdGljXSBIZXVyaXN0aWMgZnVuY3Rpb24gKHNlZVxuICAgICAgICAgKiAgICAgICAgICBhc3Rhci5oZXVyaXN0aWNzKS5cbiAgICAgICAgICovXG4gICAgICAgIHNlYXJjaDogZnVuY3Rpb24oZ3JhcGgsIHN0YXJ0LCBlbmQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGdyYXBoLmNsZWFuRGlydHkoKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGhldXJpc3RpYyA9IG9wdGlvbnMuaGV1cmlzdGljIHx8IGFzdGFyLmhldXJpc3RpY3MubWFuaGF0dGFuO1xuICAgICAgICAgICAgdmFyIGNsb3Nlc3QgPSBvcHRpb25zLmNsb3Nlc3QgfHwgZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBvcGVuSGVhcCA9IGdldEhlYXAoKTtcbiAgICAgICAgICAgIHZhciBjbG9zZXN0Tm9kZSA9IHN0YXJ0OyAvLyBzZXQgdGhlIHN0YXJ0IG5vZGUgdG8gYmUgdGhlIGNsb3Nlc3QgaWYgcmVxdWlyZWRcblxuICAgICAgICAgICAgc3RhcnQuaCA9IGhldXJpc3RpYyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIGdyYXBoLm1hcmtEaXJ0eShzdGFydCk7XG5cbiAgICAgICAgICAgIG9wZW5IZWFwLnB1c2goc3RhcnQpO1xuXG4gICAgICAgICAgICB3aGlsZSAob3BlbkhlYXAuc2l6ZSgpID4gMCkge1xuXG4gICAgICAgICAgICAgICAgLy8gR3JhYiB0aGUgbG93ZXN0IGYoeCkgdG8gcHJvY2VzcyBuZXh0LiAgSGVhcCBrZWVwcyB0aGlzIHNvcnRlZCBmb3IgdXMuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gb3BlbkhlYXAucG9wKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBFbmQgY2FzZSAtLSByZXN1bHQgaGFzIGJlZW4gZm91bmQsIHJldHVybiB0aGUgdHJhY2VkIHBhdGguXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhUbyhjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsIGNhc2UgLS0gbW92ZSBjdXJyZW50Tm9kZSBmcm9tIG9wZW4gdG8gY2xvc2VkLCBwcm9jZXNzIGVhY2ggb2YgaXRzIG5laWdoYm9ycy5cbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5jbG9zZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluZCBhbGwgbmVpZ2hib3JzIGZvciB0aGUgY3VycmVudCBub2RlLlxuICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaC5uZWlnaGJvcnMoY3VycmVudE5vZGUpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZWlnaGJvci5jbG9zZWQgfHwgbmVpZ2hib3IuaXNXYWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIHZhbGlkIG5vZGUgdG8gcHJvY2Vzcywgc2tpcCB0byBuZXh0IG5laWdoYm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZyBzY29yZSBpcyB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgZnJvbSBzdGFydCB0byBjdXJyZW50IG5vZGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHBhdGggd2UgaGF2ZSBhcnJpdmVkIGF0IHRoaXMgbmVpZ2hib3IgaXMgdGhlIHNob3J0ZXN0IG9uZSB3ZSBoYXZlIHNlZW4geWV0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgZ1Njb3JlID0gY3VycmVudE5vZGUuZyArIG5laWdoYm9yLmdldENvc3QoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmVlblZpc2l0ZWQgPSBuZWlnaGJvci52aXNpdGVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVlblZpc2l0ZWQgfHwgZ1Njb3JlIDwgbmVpZ2hib3IuZykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBhbiBvcHRpbWFsIChzbyBmYXIpIHBhdGggdG8gdGhpcyBub2RlLiAgVGFrZSBzY29yZSBmb3Igbm9kZSB0byBzZWUgaG93IGdvb2QgaXQgaXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvci52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IuaCA9IG5laWdoYm9yLmggfHwgaGV1cmlzdGljKG5laWdoYm9yLCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IuZyA9IGdTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLmYgPSBuZWlnaGJvci5nICsgbmVpZ2hib3IuaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoLm1hcmtEaXJ0eShuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZWlnaGJvdXIgaXMgY2xvc2VyIHRoYW4gdGhlIGN1cnJlbnQgY2xvc2VzdE5vZGUgb3IgaWYgaXQncyBlcXVhbGx5IGNsb3NlIGJ1dCBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGNoZWFwZXIgcGF0aCB0aGFuIHRoZSBjdXJyZW50IGNsb3Nlc3Qgbm9kZSB0aGVuIGl0IGJlY29tZXMgdGhlIGNsb3Nlc3Qgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWlnaGJvci5oIDwgY2xvc2VzdE5vZGUuaCB8fCAobmVpZ2hib3IuaCA9PT0gY2xvc2VzdE5vZGUuaCAmJiBuZWlnaGJvci5nIDwgY2xvc2VzdE5vZGUuZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdE5vZGUgPSBuZWlnaGJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmVlblZpc2l0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoaW5nIHRvIGhlYXAgd2lsbCBwdXQgaXQgaW4gcHJvcGVyIHBsYWNlIGJhc2VkIG9uIHRoZSAnZicgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkhlYXAucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgc2VlbiB0aGUgbm9kZSwgYnV0IHNpbmNlIGl0IGhhcyBiZWVuIHJlc2NvcmVkIHdlIG5lZWQgdG8gcmVvcmRlciBpdCBpbiB0aGUgaGVhcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5IZWFwLnJlc2NvcmVFbGVtZW50KG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNsb3Nlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFRvKGNsb3Nlc3ROb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm8gcmVzdWx0IHdhcyBmb3VuZCAtIGVtcHR5IGFycmF5IHNpZ25pZmllcyBmYWlsdXJlIHRvIGZpbmQgcGF0aC5cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2VlIGxpc3Qgb2YgaGV1cmlzdGljczogaHR0cDovL3RoZW9yeS5zdGFuZm9yZC5lZHUvfmFtaXRwL0dhbWVQcm9ncmFtbWluZy9IZXVyaXN0aWNzLmh0bWxcbiAgICAgICAgaGV1cmlzdGljczoge1xuICAgICAgICAgICAgbWFuaGF0dGFuOiBmdW5jdGlvbihwb3MwLCBwb3MxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQxID0gTWF0aC5hYnMocG9zMS54IC0gcG9zMC54KTtcbiAgICAgICAgICAgICAgICB2YXIgZDIgPSBNYXRoLmFicyhwb3MxLnkgLSBwb3MwLnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkMSArIGQyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpYWdvbmFsOiBmdW5jdGlvbihwb3MwLCBwb3MxKSB7XG4gICAgICAgICAgICAgICAgdmFyIEQgPSAxO1xuICAgICAgICAgICAgICAgIHZhciBEMiA9IE1hdGguc3FydCgyKTtcbiAgICAgICAgICAgICAgICB2YXIgZDEgPSBNYXRoLmFicyhwb3MxLnggLSBwb3MwLngpO1xuICAgICAgICAgICAgICAgIHZhciBkMiA9IE1hdGguYWJzKHBvczEueSAtIHBvczAueSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChEICogKGQxICsgZDIpKSArICgoRDIgLSAoMiAqIEQpKSAqIE1hdGgubWluKGQxLCBkMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGVhbk5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuZiA9IDA7XG4gICAgICAgICAgICBub2RlLmcgPSAwO1xuICAgICAgICAgICAgbm9kZS5oID0gMDtcbiAgICAgICAgICAgIG5vZGUudmlzaXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZS5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGdyYXBoIG1lbW9yeSBzdHJ1Y3R1cmVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBncmlkSW4gMkQgYXJyYXkgb2YgaW5wdXQgd2VpZ2h0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtvcHRpb25zLmRpYWdvbmFsXSBTcGVjaWZpZXMgd2hldGhlciBkaWFnb25hbCBtb3ZlcyBhcmUgYWxsb3dlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdyYXBoKGdyaWRJbiwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmRpYWdvbmFsID0gISFvcHRpb25zLmRpYWdvbmFsO1xuICAgICAgICB0aGlzLmdyaWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBncmlkSW4ubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZFt4XSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMCwgcm93ID0gZ3JpZEluW3hdOyB5IDwgcm93Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgR3JpZE5vZGUoeCwgeSwgcm93W3ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRbeF1beV0gPSBub2RlO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBHcmFwaC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpcnR5Tm9kZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhc3Rhci5jbGVhbk5vZGUodGhpcy5ub2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgR3JhcGgucHJvdG90eXBlLmNsZWFuRGlydHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpcnR5Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFzdGFyLmNsZWFuTm9kZSh0aGlzLmRpcnR5Tm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHlOb2RlcyA9IFtdO1xuICAgIH07XG5cbiAgICBHcmFwaC5wcm90b3R5cGUubWFya0RpcnR5ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB0aGlzLmRpcnR5Tm9kZXMucHVzaChub2RlKTtcbiAgICB9O1xuXG4gICAgR3JhcGgucHJvdG90eXBlLm5laWdoYm9ycyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICB2YXIgeCA9IG5vZGUueDtcbiAgICAgICAgdmFyIHkgPSBub2RlLnk7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5ncmlkO1xuXG4gICAgICAgIC8vIFdlc3RcbiAgICAgICAgaWYgKGdyaWRbeCAtIDFdICYmIGdyaWRbeCAtIDFdW3ldKSB7XG4gICAgICAgICAgICByZXQucHVzaChncmlkW3ggLSAxXVt5XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFYXN0XG4gICAgICAgIGlmIChncmlkW3ggKyAxXSAmJiBncmlkW3ggKyAxXVt5XSkge1xuICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4ICsgMV1beV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU291dGhcbiAgICAgICAgaWYgKGdyaWRbeF0gJiYgZ3JpZFt4XVt5IC0gMV0pIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGdyaWRbeF1beSAtIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vcnRoXG4gICAgICAgIGlmIChncmlkW3hdICYmIGdyaWRbeF1beSArIDFdKSB7XG4gICAgICAgICAgICByZXQucHVzaChncmlkW3hdW3kgKyAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kaWFnb25hbCkge1xuICAgICAgICAgICAgLy8gU291dGh3ZXN0XG4gICAgICAgICAgICBpZiAoZ3JpZFt4IC0gMV0gJiYgZ3JpZFt4IC0gMV1beSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4IC0gMV1beSAtIDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU291dGhlYXN0XG4gICAgICAgICAgICBpZiAoZ3JpZFt4ICsgMV0gJiYgZ3JpZFt4ICsgMV1beSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4ICsgMV1beSAtIDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm9ydGh3ZXN0XG4gICAgICAgICAgICBpZiAoZ3JpZFt4IC0gMV0gJiYgZ3JpZFt4IC0gMV1beSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4IC0gMV1beSArIDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm9ydGhlYXN0XG4gICAgICAgICAgICBpZiAoZ3JpZFt4ICsgMV0gJiYgZ3JpZFt4ICsgMV1beSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4ICsgMV1beSArIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIEdyYXBoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JhcGhTdHJpbmcgPSBbXTtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ncmlkO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG5vZGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICB2YXIgcm93RGVidWcgPSBbXTtcbiAgICAgICAgICAgIHZhciByb3cgPSBub2Rlc1t4XTtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcm93Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgcm93RGVidWcucHVzaChyb3dbeV0ud2VpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYXBoU3RyaW5nLnB1c2gocm93RGVidWcuam9pbihcIiBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFwaFN0cmluZy5qb2luKFwiXFxuXCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBHcmlkTm9kZSh4LCB5LCB3ZWlnaHQpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XG4gICAgfVxuXG4gICAgR3JpZE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIltcIiArIHRoaXMueCArIFwiIFwiICsgdGhpcy55ICsgXCJdXCI7XG4gICAgfTtcblxuICAgIEdyaWROb2RlLnByb3RvdHlwZS5nZXRDb3N0ID0gZnVuY3Rpb24oZnJvbU5laWdoYm9yKSB7XG4gICAgICAgIC8vIFRha2UgZGlhZ29uYWwgd2VpZ2h0IGludG8gY29uc2lkZXJhdGlvbi5cbiAgICAgICAgaWYgKGZyb21OZWlnaGJvciAmJiBmcm9tTmVpZ2hib3IueCAhPSB0aGlzLnggJiYgZnJvbU5laWdoYm9yLnkgIT0gdGhpcy55KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWlnaHQgKiAxLjQxNDIxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndlaWdodDtcbiAgICB9O1xuXG4gICAgR3JpZE5vZGUucHJvdG90eXBlLmlzV2FsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWlnaHQgPT09IDA7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEJpbmFyeUhlYXAoc2NvcmVGdW5jdGlvbikge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5zY29yZUZ1bmN0aW9uID0gc2NvcmVGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBCaW5hcnlIZWFwLnByb3RvdHlwZSA9IHtcbiAgICAgICAgcHVzaDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBBbGxvdyBpdCB0byBzaW5rIGRvd24uXG4gICAgICAgICAgICB0aGlzLnNpbmtEb3duKHRoaXMuY29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBmaXJzdCBlbGVtZW50IHNvIHdlIGNhbiByZXR1cm4gaXQgbGF0ZXIuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb250ZW50WzBdO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuY29udGVudC5wb3AoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgZWxlbWVudHMgbGVmdCwgcHV0IHRoZSBlbmQgZWxlbWVudCBhdCB0aGVcbiAgICAgICAgICAgIC8vIHN0YXJ0LCBhbmQgbGV0IGl0IGJ1YmJsZSB1cC5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFswXSA9IGVuZDtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1YmJsZVVwKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuY29udGVudC5pbmRleE9mKG5vZGUpO1xuXG4gICAgICAgICAgICAvLyBXaGVuIGl0IGlzIGZvdW5kLCB0aGUgcHJvY2VzcyBzZWVuIGluICdwb3AnIGlzIHJlcGVhdGVkXG4gICAgICAgICAgICAvLyB0byBmaWxsIHVwIHRoZSBob2xlLlxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuY29udGVudC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGkgIT09IHRoaXMuY29udGVudC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W2ldID0gZW5kO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NvcmVGdW5jdGlvbihlbmQpIDwgdGhpcy5zY29yZUZ1bmN0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2lua0Rvd24oaSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWJibGVVcChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2NvcmVFbGVtZW50OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLnNpbmtEb3duKHRoaXMuY29udGVudC5pbmRleE9mKG5vZGUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lua0Rvd246IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBlbGVtZW50IHRoYXQgaGFzIHRvIGJlIHN1bmsuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXTtcblxuICAgICAgICAgICAgLy8gV2hlbiBhdCAwLCBhbiBlbGVtZW50IGNhbiBub3Qgc2luayBhbnkgZnVydGhlci5cbiAgICAgICAgICAgIHdoaWxlIChuID4gMCkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBpbmRleCwgYW5kIGZldGNoIGl0LlxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROID0gKChuICsgMSkgPj4gMSkgLSAxO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmNvbnRlbnRbcGFyZW50Tl07XG4gICAgICAgICAgICAgICAgLy8gU3dhcCB0aGUgZWxlbWVudHMgaWYgdGhlIHBhcmVudCBpcyBncmVhdGVyLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCkgPCB0aGlzLnNjb3JlRnVuY3Rpb24ocGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbcGFyZW50Tl0gPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbbl0gPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSAnbicgdG8gY29udGludWUgYXQgdGhlIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgbiA9IHBhcmVudE47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgcGFyZW50IHRoYXQgaXMgbGVzcywgbm8gbmVlZCB0byBzaW5rIGFueSBmdXJ0aGVyLlxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJ1YmJsZVVwOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAvLyBMb29rIHVwIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgaXRzIHNjb3JlLlxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXTtcbiAgICAgICAgICAgIHZhciBlbGVtU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCk7XG5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaW5kaWNlcyBvZiB0aGUgY2hpbGQgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkMk4gPSAobiArIDEpIDw8IDE7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkMU4gPSBjaGlsZDJOIC0gMTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICAgICAgICAgIHZhciBzd2FwID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQxU2NvcmU7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGNoaWxkIGV4aXN0cyAoaXMgaW5zaWRlIHRoZSBhcnJheSkuLi5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQxTiA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGl0IHVwIGFuZCBjb21wdXRlIGl0cyBzY29yZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkMSA9IHRoaXMuY29udGVudFtjaGlsZDFOXTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQxU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQxKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2NvcmUgaXMgbGVzcyB0aGFuIG91ciBlbGVtZW50J3MsIHdlIG5lZWQgdG8gc3dhcC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkMVNjb3JlIDwgZWxlbVNjb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FwID0gY2hpbGQxTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvIHRoZSBzYW1lIGNoZWNrcyBmb3IgdGhlIG90aGVyIGNoaWxkLlxuICAgICAgICAgICAgICAgIGlmIChjaGlsZDJOIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZDIgPSB0aGlzLmNvbnRlbnRbY2hpbGQyTl07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZDJTY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihjaGlsZDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQyU2NvcmUgPCAoc3dhcCA9PT0gbnVsbCA/IGVsZW1TY29yZSA6IGNoaWxkMVNjb3JlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dhcCA9IGNoaWxkMk47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBuZWVkcyB0byBiZSBtb3ZlZCwgc3dhcCBpdCwgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgICAgIGlmIChzd2FwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtuXSA9IHRoaXMuY29udGVudFtzd2FwXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3N3YXBdID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbiA9IHN3YXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgYXJlIGRvbmUuXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhc3RhcjogYXN0YXIsXG4gICAgICAgIEdyYXBoOiBHcmFwaFxuICAgIH07XG59KTsiLCJpbXBvcnQgU2VydmVyIGZyb20gJy4vc3RhbmRhbG9uZS1zZXJ2ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgU2VydmVyKCk7XG4iLCJleHBvcnQgdmFyIFJFVklTSU9OID0gJzExMSc7XG5leHBvcnQgdmFyIE1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyLCBST1RBVEU6IDAsIERPTExZOiAxLCBQQU46IDIgfTtcbmV4cG9ydCB2YXIgVE9VQ0ggPSB7IFJPVEFURTogMCwgUEFOOiAxLCBET0xMWV9QQU46IDIsIERPTExZX1JPVEFURTogMyB9O1xuZXhwb3J0IHZhciBDdWxsRmFjZU5vbmUgPSAwO1xuZXhwb3J0IHZhciBDdWxsRmFjZUJhY2sgPSAxO1xuZXhwb3J0IHZhciBDdWxsRmFjZUZyb250ID0gMjtcbmV4cG9ydCB2YXIgQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xuZXhwb3J0IHZhciBGcm9udEZhY2VEaXJlY3Rpb25DVyA9IDA7XG5leHBvcnQgdmFyIEZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XG5leHBvcnQgdmFyIEJhc2ljU2hhZG93TWFwID0gMDtcbmV4cG9ydCB2YXIgUENGU2hhZG93TWFwID0gMTtcbmV4cG9ydCB2YXIgUENGU29mdFNoYWRvd01hcCA9IDI7XG5leHBvcnQgdmFyIFZTTVNoYWRvd01hcCA9IDM7XG5leHBvcnQgdmFyIEZyb250U2lkZSA9IDA7XG5leHBvcnQgdmFyIEJhY2tTaWRlID0gMTtcbmV4cG9ydCB2YXIgRG91YmxlU2lkZSA9IDI7XG5leHBvcnQgdmFyIEZsYXRTaGFkaW5nID0gMTtcbmV4cG9ydCB2YXIgU21vb3RoU2hhZGluZyA9IDI7XG5leHBvcnQgdmFyIE5vQ29sb3JzID0gMDtcbmV4cG9ydCB2YXIgRmFjZUNvbG9ycyA9IDE7XG5leHBvcnQgdmFyIFZlcnRleENvbG9ycyA9IDI7XG5leHBvcnQgdmFyIE5vQmxlbmRpbmcgPSAwO1xuZXhwb3J0IHZhciBOb3JtYWxCbGVuZGluZyA9IDE7XG5leHBvcnQgdmFyIEFkZGl0aXZlQmxlbmRpbmcgPSAyO1xuZXhwb3J0IHZhciBTdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcbmV4cG9ydCB2YXIgTXVsdGlwbHlCbGVuZGluZyA9IDQ7XG5leHBvcnQgdmFyIEN1c3RvbUJsZW5kaW5nID0gNTtcbmV4cG9ydCB2YXIgQWRkRXF1YXRpb24gPSAxMDA7XG5leHBvcnQgdmFyIFN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XG5leHBvcnQgdmFyIFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xuZXhwb3J0IHZhciBNaW5FcXVhdGlvbiA9IDEwMztcbmV4cG9ydCB2YXIgTWF4RXF1YXRpb24gPSAxMDQ7XG5leHBvcnQgdmFyIFplcm9GYWN0b3IgPSAyMDA7XG5leHBvcnQgdmFyIE9uZUZhY3RvciA9IDIwMTtcbmV4cG9ydCB2YXIgU3JjQ29sb3JGYWN0b3IgPSAyMDI7XG5leHBvcnQgdmFyIE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSAyMDM7XG5leHBvcnQgdmFyIFNyY0FscGhhRmFjdG9yID0gMjA0O1xuZXhwb3J0IHZhciBPbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xuZXhwb3J0IHZhciBEc3RBbHBoYUZhY3RvciA9IDIwNjtcbmV4cG9ydCB2YXIgT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcbmV4cG9ydCB2YXIgRHN0Q29sb3JGYWN0b3IgPSAyMDg7XG5leHBvcnQgdmFyIE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XG5leHBvcnQgdmFyIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XG5leHBvcnQgdmFyIE5ldmVyRGVwdGggPSAwO1xuZXhwb3J0IHZhciBBbHdheXNEZXB0aCA9IDE7XG5leHBvcnQgdmFyIExlc3NEZXB0aCA9IDI7XG5leHBvcnQgdmFyIExlc3NFcXVhbERlcHRoID0gMztcbmV4cG9ydCB2YXIgRXF1YWxEZXB0aCA9IDQ7XG5leHBvcnQgdmFyIEdyZWF0ZXJFcXVhbERlcHRoID0gNTtcbmV4cG9ydCB2YXIgR3JlYXRlckRlcHRoID0gNjtcbmV4cG9ydCB2YXIgTm90RXF1YWxEZXB0aCA9IDc7XG5leHBvcnQgdmFyIE11bHRpcGx5T3BlcmF0aW9uID0gMDtcbmV4cG9ydCB2YXIgTWl4T3BlcmF0aW9uID0gMTtcbmV4cG9ydCB2YXIgQWRkT3BlcmF0aW9uID0gMjtcbmV4cG9ydCB2YXIgTm9Ub25lTWFwcGluZyA9IDA7XG5leHBvcnQgdmFyIExpbmVhclRvbmVNYXBwaW5nID0gMTtcbmV4cG9ydCB2YXIgUmVpbmhhcmRUb25lTWFwcGluZyA9IDI7XG5leHBvcnQgdmFyIFVuY2hhcnRlZDJUb25lTWFwcGluZyA9IDM7XG5leHBvcnQgdmFyIENpbmVvblRvbmVNYXBwaW5nID0gNDtcbmV4cG9ydCB2YXIgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nID0gNTtcblxuZXhwb3J0IHZhciBVVk1hcHBpbmcgPSAzMDA7XG5leHBvcnQgdmFyIEN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IDMwMTtcbmV4cG9ydCB2YXIgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xuZXhwb3J0IHZhciBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcbmV4cG9ydCB2YXIgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDQ7XG5leHBvcnQgdmFyIFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nID0gMzA1O1xuZXhwb3J0IHZhciBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA9IDMwNjtcbmV4cG9ydCB2YXIgQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDc7XG5leHBvcnQgdmFyIFJlcGVhdFdyYXBwaW5nID0gMTAwMDtcbmV4cG9ydCB2YXIgQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IDEwMDE7XG5leHBvcnQgdmFyIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSAxMDAyO1xuZXhwb3J0IHZhciBOZWFyZXN0RmlsdGVyID0gMTAwMztcbmV4cG9ydCB2YXIgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuZXhwb3J0IHZhciBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5leHBvcnQgdmFyIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuZXhwb3J0IHZhciBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcbmV4cG9ydCB2YXIgTGluZWFyRmlsdGVyID0gMTAwNjtcbmV4cG9ydCB2YXIgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5leHBvcnQgdmFyIExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xuZXhwb3J0IHZhciBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuZXhwb3J0IHZhciBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuZXhwb3J0IHZhciBVbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcbmV4cG9ydCB2YXIgQnl0ZVR5cGUgPSAxMDEwO1xuZXhwb3J0IHZhciBTaG9ydFR5cGUgPSAxMDExO1xuZXhwb3J0IHZhciBVbnNpZ25lZFNob3J0VHlwZSA9IDEwMTI7XG5leHBvcnQgdmFyIEludFR5cGUgPSAxMDEzO1xuZXhwb3J0IHZhciBVbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuZXhwb3J0IHZhciBGbG9hdFR5cGUgPSAxMDE1O1xuZXhwb3J0IHZhciBIYWxmRmxvYXRUeXBlID0gMTAxNjtcbmV4cG9ydCB2YXIgVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNztcbmV4cG9ydCB2YXIgVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxODtcbmV4cG9ydCB2YXIgVW5zaWduZWRTaG9ydDU2NVR5cGUgPSAxMDE5O1xuZXhwb3J0IHZhciBVbnNpZ25lZEludDI0OFR5cGUgPSAxMDIwO1xuZXhwb3J0IHZhciBBbHBoYUZvcm1hdCA9IDEwMjE7XG5leHBvcnQgdmFyIFJHQkZvcm1hdCA9IDEwMjI7XG5leHBvcnQgdmFyIFJHQkFGb3JtYXQgPSAxMDIzO1xuZXhwb3J0IHZhciBMdW1pbmFuY2VGb3JtYXQgPSAxMDI0O1xuZXhwb3J0IHZhciBMdW1pbmFuY2VBbHBoYUZvcm1hdCA9IDEwMjU7XG5leHBvcnQgdmFyIFJHQkVGb3JtYXQgPSBSR0JBRm9ybWF0O1xuZXhwb3J0IHZhciBEZXB0aEZvcm1hdCA9IDEwMjY7XG5leHBvcnQgdmFyIERlcHRoU3RlbmNpbEZvcm1hdCA9IDEwMjc7XG5leHBvcnQgdmFyIFJlZEZvcm1hdCA9IDEwMjg7XG5leHBvcnQgdmFyIFJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMzM3NzY7XG5leHBvcnQgdmFyIFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IDMzNzc3O1xuZXhwb3J0IHZhciBSR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAzMzc3ODtcbmV4cG9ydCB2YXIgUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMzM3Nzk7XG5leHBvcnQgdmFyIFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMzU4NDA7XG5leHBvcnQgdmFyIFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDE7XG5leHBvcnQgdmFyIFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQyO1xuZXhwb3J0IHZhciBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAzNTg0MztcbmV4cG9ydCB2YXIgUkdCX0VUQzFfRm9ybWF0ID0gMzYxOTY7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ180eDRfRm9ybWF0ID0gMzc4MDg7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ181eDRfRm9ybWF0ID0gMzc4MDk7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ181eDVfRm9ybWF0ID0gMzc4MTA7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ182eDVfRm9ybWF0ID0gMzc4MTE7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ182eDZfRm9ybWF0ID0gMzc4MTI7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ184eDVfRm9ybWF0ID0gMzc4MTM7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ184eDZfRm9ybWF0ID0gMzc4MTQ7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ184eDhfRm9ybWF0ID0gMzc4MTU7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ18xMHg1X0Zvcm1hdCA9IDM3ODE2O1xuZXhwb3J0IHZhciBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgPSAzNzgxNztcbmV4cG9ydCB2YXIgUkdCQV9BU1RDXzEweDhfRm9ybWF0ID0gMzc4MTg7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQgPSAzNzgxOTtcbmV4cG9ydCB2YXIgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCA9IDM3ODIwO1xuZXhwb3J0IHZhciBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0ID0gMzc4MjE7XG5leHBvcnQgdmFyIExvb3BPbmNlID0gMjIwMDtcbmV4cG9ydCB2YXIgTG9vcFJlcGVhdCA9IDIyMDE7XG5leHBvcnQgdmFyIExvb3BQaW5nUG9uZyA9IDIyMDI7XG5leHBvcnQgdmFyIEludGVycG9sYXRlRGlzY3JldGUgPSAyMzAwO1xuZXhwb3J0IHZhciBJbnRlcnBvbGF0ZUxpbmVhciA9IDIzMDE7XG5leHBvcnQgdmFyIEludGVycG9sYXRlU21vb3RoID0gMjMwMjtcbmV4cG9ydCB2YXIgWmVyb0N1cnZhdHVyZUVuZGluZyA9IDI0MDA7XG5leHBvcnQgdmFyIFplcm9TbG9wZUVuZGluZyA9IDI0MDE7XG5leHBvcnQgdmFyIFdyYXBBcm91bmRFbmRpbmcgPSAyNDAyO1xuZXhwb3J0IHZhciBUcmlhbmdsZXNEcmF3TW9kZSA9IDA7XG5leHBvcnQgdmFyIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IDE7XG5leHBvcnQgdmFyIFRyaWFuZ2xlRmFuRHJhd01vZGUgPSAyO1xuZXhwb3J0IHZhciBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XG5leHBvcnQgdmFyIHNSR0JFbmNvZGluZyA9IDMwMDE7XG5leHBvcnQgdmFyIEdhbW1hRW5jb2RpbmcgPSAzMDA3O1xuZXhwb3J0IHZhciBSR0JFRW5jb2RpbmcgPSAzMDAyO1xuZXhwb3J0IHZhciBMb2dMdXZFbmNvZGluZyA9IDMwMDM7XG5leHBvcnQgdmFyIFJHQk03RW5jb2RpbmcgPSAzMDA0O1xuZXhwb3J0IHZhciBSR0JNMTZFbmNvZGluZyA9IDMwMDU7XG5leHBvcnQgdmFyIFJHQkRFbmNvZGluZyA9IDMwMDY7XG5leHBvcnQgdmFyIEJhc2ljRGVwdGhQYWNraW5nID0gMzIwMDtcbmV4cG9ydCB2YXIgUkdCQURlcHRoUGFja2luZyA9IDMyMDE7XG5leHBvcnQgdmFyIFRhbmdlbnRTcGFjZU5vcm1hbE1hcCA9IDA7XG5leHBvcnQgdmFyIE9iamVjdFNwYWNlTm9ybWFsTWFwID0gMTtcblxuZXhwb3J0IHZhciBaZXJvU3RlbmNpbE9wID0gMDtcbmV4cG9ydCB2YXIgS2VlcFN0ZW5jaWxPcCA9IDc2ODA7XG5leHBvcnQgdmFyIFJlcGxhY2VTdGVuY2lsT3AgPSA3NjgxO1xuZXhwb3J0IHZhciBJbmNyZW1lbnRTdGVuY2lsT3AgPSA3NjgyO1xuZXhwb3J0IHZhciBEZWNyZW1lbnRTdGVuY2lsT3AgPSA3NjgzO1xuZXhwb3J0IHZhciBJbmNyZW1lbnRXcmFwU3RlbmNpbE9wID0gMzQwNTU7XG5leHBvcnQgdmFyIERlY3JlbWVudFdyYXBTdGVuY2lsT3AgPSAzNDA1NjtcbmV4cG9ydCB2YXIgSW52ZXJ0U3RlbmNpbE9wID0gNTM4NjtcblxuZXhwb3J0IHZhciBOZXZlclN0ZW5jaWxGdW5jID0gNTEyO1xuZXhwb3J0IHZhciBMZXNzU3RlbmNpbEZ1bmMgPSA1MTM7XG5leHBvcnQgdmFyIEVxdWFsU3RlbmNpbEZ1bmMgPSA1MTQ7XG5leHBvcnQgdmFyIExlc3NFcXVhbFN0ZW5jaWxGdW5jID0gNTE1O1xuZXhwb3J0IHZhciBHcmVhdGVyU3RlbmNpbEZ1bmMgPSA1MTY7XG5leHBvcnQgdmFyIE5vdEVxdWFsU3RlbmNpbEZ1bmMgPSA1MTc7XG5leHBvcnQgdmFyIEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jID0gNTE4O1xuZXhwb3J0IHZhciBBbHdheXNTdGVuY2lsRnVuYyA9IDUxOTtcblxuZXhwb3J0IHZhciBTdGF0aWNEcmF3VXNhZ2UgPSAzNTA0NDtcbmV4cG9ydCB2YXIgRHluYW1pY0RyYXdVc2FnZSA9IDM1MDQ4O1xuZXhwb3J0IHZhciBTdHJlYW1EcmF3VXNhZ2UgPSAzNTA0MDtcbmV4cG9ydCB2YXIgU3RhdGljUmVhZFVzYWdlID0gMzUwNDU7XG5leHBvcnQgdmFyIER5bmFtaWNSZWFkVXNhZ2UgPSAzNTA0OTtcbmV4cG9ydCB2YXIgU3RyZWFtUmVhZFVzYWdlID0gMzUwNDE7XG5leHBvcnQgdmFyIFN0YXRpY0NvcHlVc2FnZSA9IDM1MDQ2O1xuZXhwb3J0IHZhciBEeW5hbWljQ29weVVzYWdlID0gMzUwNTA7XG5leHBvcnQgdmFyIFN0cmVhbUNvcHlVc2FnZSA9IDM1MDQyO1xuIiwiLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50ZGlzcGF0Y2hlci5qcy9cbiAqL1xuXG5mdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7fVxuXG5PYmplY3QuYXNzaWduKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLCB7XG5cblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cblx0XHR9XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGhhc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuXHRcdHJldHVybiBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMTtcblxuXHR9LFxuXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZiggbGlzdGVuZXIgKTtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRcdGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHRkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0dmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcblxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xuXG5cdFx0XHR2YXIgYXJyYXkgPSBsaXN0ZW5lckFycmF5LnNsaWNlKCAwICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59ICk7XG5cblxuZXhwb3J0IHsgRXZlbnREaXNwYXRjaGVyIH07XG4iLCIvKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gTGF5ZXJzKCkge1xuXG5cdHRoaXMubWFzayA9IDEgfCAwO1xuXG59XG5cbk9iamVjdC5hc3NpZ24oIExheWVycy5wcm90b3R5cGUsIHtcblxuXHRzZXQ6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayA9IDEgPDwgY2hhbm5lbCB8IDA7XG5cblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayB8PSAxIDw8IGNoYW5uZWwgfCAwO1xuXG5cdH0sXG5cblx0ZW5hYmxlQWxsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLm1hc2sgPSAweGZmZmZmZmZmIHwgMDtcblxuXHR9LFxuXG5cdHRvZ2dsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xuXG5cdFx0dGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbCB8IDA7XG5cblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XG5cblx0XHR0aGlzLm1hc2sgJj0gfiAoIDEgPDwgY2hhbm5lbCB8IDAgKTtcblxuXHR9LFxuXG5cdGRpc2FibGVBbGw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMubWFzayA9IDA7XG5cblx0fSxcblxuXHR0ZXN0OiBmdW5jdGlvbiAoIGxheWVycyApIHtcblxuXHRcdHJldHVybiAoIHRoaXMubWFzayAmIGxheWVycy5tYXNrICkgIT09IDA7XG5cblx0fVxuXG59ICk7XG5cblxuZXhwb3J0IHsgTGF5ZXJzIH07XG4iLCJpbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vbWF0aC9RdWF0ZXJuaW9uLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlci5qcyc7XG5pbXBvcnQgeyBFdWxlciB9IGZyb20gJy4uL21hdGgvRXVsZXIuanMnO1xuaW1wb3J0IHsgTGF5ZXJzIH0gZnJvbSAnLi9MYXllcnMuanMnO1xuaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4uL21hdGgvTWF0cml4My5qcyc7XG5pbXBvcnQgeyBfTWF0aCB9IGZyb20gJy4uL21hdGgvTWF0aC5qcyc7XG5pbXBvcnQgeyBUcmlhbmdsZXNEcmF3TW9kZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5cbnZhciBfb2JqZWN0M0RJZCA9IDA7XG5cbnZhciBfdjEgPSBuZXcgVmVjdG9yMygpO1xudmFyIF9xMSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG52YXIgX20xID0gbmV3IE1hdHJpeDQoKTtcbnZhciBfdGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcblxudmFyIF9wb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG52YXIgX3NjYWxlID0gbmV3IFZlY3RvcjMoKTtcbnZhciBfcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbnZhciBfeEF4aXMgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xudmFyIF95QXhpcyA9IG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XG52YXIgX3pBeGlzID0gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcblxudmFyIF9hZGRlZEV2ZW50ID0geyB0eXBlOiAnYWRkZWQnIH07XG52YXIgX3JlbW92ZWRFdmVudCA9IHsgdHlwZTogJ3JlbW92ZWQnIH07XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGVsZXBoYW50YXR3b3JrIC8gd3d3LmVsZXBoYW50YXR3b3JrLmNoXG4gKi9cblxuZnVuY3Rpb24gT2JqZWN0M0QoKSB7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfb2JqZWN0M0RJZCArKyB9ICk7XG5cblx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cdHRoaXMudHlwZSA9ICdPYmplY3QzRCc7XG5cblx0dGhpcy5wYXJlbnQgPSBudWxsO1xuXHR0aGlzLmNoaWxkcmVuID0gW107XG5cblx0dGhpcy51cCA9IE9iamVjdDNELkRlZmF1bHRVcC5jbG9uZSgpO1xuXG5cdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciByb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XG5cblx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcblxuXHRcdHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCByb3RhdGlvbiwgZmFsc2UgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xuXG5cdFx0cm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcblxuXHR9XG5cblx0cm90YXRpb24uX29uQ2hhbmdlKCBvblJvdGF0aW9uQ2hhbmdlICk7XG5cdHF1YXRlcm5pb24uX29uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0dmFsdWU6IHBvc2l0aW9uXG5cdFx0fSxcblx0XHRyb3RhdGlvbjoge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiByb3RhdGlvblxuXHRcdH0sXG5cdFx0cXVhdGVybmlvbjoge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBxdWF0ZXJuaW9uXG5cdFx0fSxcblx0XHRzY2FsZToge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBzY2FsZVxuXHRcdH0sXG5cdFx0bW9kZWxWaWV3TWF0cml4OiB7XG5cdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDQoKVxuXHRcdH0sXG5cdFx0bm9ybWFsTWF0cml4OiB7XG5cdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxuXHRcdH1cblx0fSApO1xuXG5cdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0dGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGU7XG5cdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG5cdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblxuXHR0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xuXHR0aGlzLnJlbmRlck9yZGVyID0gMDtcblxuXHR0aGlzLnVzZXJEYXRhID0ge307XG5cbn1cblxuT2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcbk9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcblxuT2JqZWN0M0QucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IE9iamVjdDNELFxuXG5cdGlzT2JqZWN0M0Q6IHRydWUsXG5cblx0b25CZWZvcmVSZW5kZXI6IGZ1bmN0aW9uICgpIHt9LFxuXHRvbkFmdGVyUmVuZGVyOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLm1hdHJpeC5wcmVtdWx0aXBseSggbWF0cml4ICk7XG5cblx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdH0sXG5cblx0YXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XG5cblx0fSxcblxuXHRyb3RhdGVPbkF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdF9xMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBfcTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cm90YXRlT25Xb3JsZEF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdC8vIG1ldGhvZCBhc3N1bWVzIG5vIHJvdGF0ZWQgcGFyZW50XG5cblx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggX3ExICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF94QXhpcywgYW5nbGUgKTtcblxuXHR9LFxuXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF95QXhpcywgYW5nbGUgKTtcblxuXHR9LFxuXG5cdHJvdGF0ZVo6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF96QXhpcywgYW5nbGUgKTtcblxuXHR9LFxuXG5cdHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBkaXN0YW5jZSApIHtcblxuXHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0X3YxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5hZGQoIF92MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0cmFuc2xhdGVYOiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfeEF4aXMsIGRpc3RhbmNlICk7XG5cblx0fSxcblxuXHR0cmFuc2xhdGVZOiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfeUF4aXMsIGRpc3RhbmNlICk7XG5cblx0fSxcblxuXHR0cmFuc2xhdGVaOiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfekF4aXMsIGRpc3RhbmNlICk7XG5cblx0fSxcblxuXHRsb2NhbFRvV29ybGQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHR9LFxuXG5cdHdvcmxkVG9Mb2NhbDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggX20xLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKSApO1xuXG5cdH0sXG5cblx0bG9va0F0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHQvLyBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgaGF2aW5nIG5vbi11bmlmb3JtbHktc2NhbGVkIHBhcmVudChzKVxuXG5cdFx0aWYgKCB4LmlzVmVjdG9yMyApIHtcblxuXHRcdFx0X3RhcmdldC5jb3B5KCB4ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfdGFyZ2V0LnNldCggeCwgeSwgeiApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdF9wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdGlmICggdGhpcy5pc0NhbWVyYSB8fCB0aGlzLmlzTGlnaHQgKSB7XG5cblx0XHRcdF9tMS5sb29rQXQoIF9wb3NpdGlvbiwgX3RhcmdldCwgdGhpcy51cCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X20xLmxvb2tBdCggX3RhcmdldCwgX3Bvc2l0aW9uLCB0aGlzLnVwICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcblxuXHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRfbTEuZXh0cmFjdFJvdGF0aW9uKCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRcdF9xMS5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSApO1xuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBfcTEuaW52ZXJzZSgpICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0ID09PSB0aGlzICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLlwiLCBvYmplY3QgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAoIG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCApICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0b2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIF9hZGRlZEV2ZW50ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC5cIiwgb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBvYmplY3QgKTtcblxuXHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcblxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IG51bGw7XG5cdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIF9yZW1vdmVkRXZlbnQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXR0YWNoOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdC8vIGFkZHMgb2JqZWN0IGFzIGEgY2hpbGQgb2YgdGhpcywgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIG9iamVjdCdzIHdvcmxkIHRyYW5zZm9ybVxuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdF9tMS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdG9iamVjdC5wYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRcdF9tMS5tdWx0aXBseSggb2JqZWN0LnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0fVxuXG5cdFx0b2JqZWN0LmFwcGx5TWF0cml4KCBfbTEgKTtcblxuXHRcdG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIGZhbHNlICk7XG5cblx0XHR0aGlzLmFkZCggb2JqZWN0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldE9iamVjdEJ5SWQ6IGZ1bmN0aW9uICggaWQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xuXG5cdH0sXG5cblx0Z2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcblxuXHR9LFxuXG5cdGdldE9iamVjdEJ5UHJvcGVydHk6IGZ1bmN0aW9uICggbmFtZSwgdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xuXHRcdFx0dmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cblx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG9iamVjdDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHR9LFxuXG5cdGdldFdvcmxkUG9zaXRpb246IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRXb3JsZFBvc2l0aW9uKCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH0sXG5cblx0Z2V0V29ybGRRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHRhcmdldCApIHtcblxuXHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZ2V0V29ybGRRdWF0ZXJuaW9uKCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcblx0XHRcdHRhcmdldCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggX3Bvc2l0aW9uLCB0YXJnZXQsIF9zY2FsZSApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9LFxuXG5cdGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRXb3JsZFNjYWxlKCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggX3Bvc2l0aW9uLCBfcXVhdGVybmlvbiwgdGFyZ2V0ICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH0sXG5cblx0Z2V0V29ybGREaXJlY3Rpb246IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRXb3JsZERpcmVjdGlvbigpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XG5cdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0dmFyIGUgPSB0aGlzLm1hdHJpeFdvcmxkLmVsZW1lbnRzO1xuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoIGVbIDggXSwgZVsgOSBdLCBlWyAxMCBdICkubm9ybWFsaXplKCk7XG5cblx0fSxcblxuXHRyYXljYXN0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHR0cmF2ZXJzZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZSggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHRyYXZlcnNlVmlzaWJsZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHR0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRjYWxsYmFjayggcGFyZW50ICk7XG5cblx0XHRcdHBhcmVudC50cmF2ZXJzZUFuY2VzdG9ycyggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHVwZGF0ZU1hdHJpeDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH0sXG5cblx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSB8fCBmb3JjZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0Zm9yY2UgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIGNoaWxkcmVuXG5cblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHVwZGF0ZVdvcmxkTWF0cml4OiBmdW5jdGlvbiAoIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuICkge1xuXG5cdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0aWYgKCB1cGRhdGVQYXJlbnRzID09PSB0cnVlICYmIHBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0cGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxuXG5cdFx0aWYgKCB1cGRhdGVDaGlsZHJlbiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjaGlsZHJlblsgaSBdLnVwZGF0ZVdvcmxkTWF0cml4KCBmYWxzZSwgdHJ1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdC8vIG1ldGEgaXMgYSBzdHJpbmcgd2hlbiBjYWxsZWQgZnJvbSBKU09OLnN0cmluZ2lmeVxuXHRcdHZhciBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcblxuXHRcdHZhciBvdXRwdXQgPSB7fTtcblxuXHRcdC8vIG1ldGEgaXMgYSBoYXNoIHVzZWQgdG8gY29sbGVjdCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMuXG5cdFx0Ly8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3Rcblx0XHQvLyBiZWluZyBzZXJpYWxpemVkLlxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHQvLyBpbml0aWFsaXplIG1ldGEgb2JqXG5cdFx0XHRtZXRhID0ge1xuXHRcdFx0XHRnZW9tZXRyaWVzOiB7fSxcblx0XHRcdFx0bWF0ZXJpYWxzOiB7fSxcblx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRpbWFnZXM6IHt9LFxuXHRcdFx0XHRzaGFwZXM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRvdXRwdXQubWV0YWRhdGEgPSB7XG5cdFx0XHRcdHZlcnNpb246IDQuNSxcblx0XHRcdFx0dHlwZTogJ09iamVjdCcsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHQvLyBzdGFuZGFyZCBPYmplY3QzRCBzZXJpYWxpemF0aW9uXG5cblx0XHR2YXIgb2JqZWN0ID0ge307XG5cblx0XHRvYmplY3QudXVpZCA9IHRoaXMudXVpZDtcblx0XHRvYmplY3QudHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIG9iamVjdC5uYW1lID0gdGhpcy5uYW1lO1xuXHRcdGlmICggdGhpcy5jYXN0U2hhZG93ID09PSB0cnVlICkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5yZWNlaXZlU2hhZG93ID09PSB0cnVlICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIG9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cdFx0aWYgKCB0aGlzLmZydXN0dW1DdWxsZWQgPT09IGZhbHNlICkgb2JqZWN0LmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcblx0XHRpZiAoIHRoaXMucmVuZGVyT3JkZXIgIT09IDAgKSBvYmplY3QucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXHRcdGlmICggSlNPTi5zdHJpbmdpZnkoIHRoaXMudXNlckRhdGEgKSAhPT0gJ3t9JyApIG9iamVjdC51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG5cblx0XHRvYmplY3QubGF5ZXJzID0gdGhpcy5sYXllcnMubWFzaztcblx0XHRvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IGZhbHNlICkgb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdC8vIG9iamVjdCBzcGVjaWZpYyBwcm9wZXJ0aWVzXG5cblx0XHRpZiAoIHRoaXMuaXNNZXNoICYmIHRoaXMuZHJhd01vZGUgIT09IFRyaWFuZ2xlc0RyYXdNb2RlICkgb2JqZWN0LmRyYXdNb2RlID0gdGhpcy5kcmF3TW9kZTtcblxuXHRcdGlmICggdGhpcy5pc0luc3RhbmNlZE1lc2ggKSB7XG5cblx0XHRcdG9iamVjdC50eXBlID0gJ0luc3RhbmNlZE1lc2gnO1xuXHRcdFx0b2JqZWN0LmNvdW50ID0gdGhpcy5jb3VudDtcblx0XHRcdG9iamVjdC5pbnN0YW5jZU1hdHJpeCA9IHRoaXMuaW5zdGFuY2VNYXRyaXgudG9KU09OKCk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplKCBsaWJyYXJ5LCBlbGVtZW50ICkge1xuXG5cdFx0XHRpZiAoIGxpYnJhcnlbIGVsZW1lbnQudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bGlicmFyeVsgZWxlbWVudC51dWlkIF0gPSBlbGVtZW50LnRvSlNPTiggbWV0YSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtZW50LnV1aWQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuaXNNZXNoIHx8IHRoaXMuaXNMaW5lIHx8IHRoaXMuaXNQb2ludHMgKSB7XG5cblx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHNlcmlhbGl6ZSggbWV0YS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5ICk7XG5cblx0XHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5nZW9tZXRyeS5wYXJhbWV0ZXJzO1xuXG5cdFx0XHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCAmJiBwYXJhbWV0ZXJzLnNoYXBlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBzaGFwZXMgPSBwYXJhbWV0ZXJzLnNoYXBlcztcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBzaGFwZSA9IHNoYXBlc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHRoaXMubWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHR2YXIgdXVpZHMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLm1hdGVyaWFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR1dWlkcy5wdXNoKCBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsWyBpIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSB1dWlkcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdC5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xuXHRcdFx0dmFyIG1hdGVyaWFscyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubWF0ZXJpYWxzICk7XG5cdFx0XHR2YXIgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XG5cdFx0XHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblx0XHRcdHZhciBzaGFwZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnNoYXBlcyApO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJpZXMubGVuZ3RoID4gMCApIG91dHB1dC5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcblx0XHRcdGlmICggbWF0ZXJpYWxzLmxlbmd0aCA+IDAgKSBvdXRwdXQubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xuXHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgb3V0cHV0LnRleHR1cmVzID0gdGV4dHVyZXM7XG5cdFx0XHRpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgb3V0cHV0LmltYWdlcyA9IGltYWdlcztcblx0XHRcdGlmICggc2hhcGVzLmxlbmd0aCA+IDAgKSBvdXRwdXQuc2hhcGVzID0gc2hhcGVzO1xuXG5cdFx0fVxuXG5cdFx0b3V0cHV0Lm9iamVjdCA9IG9iamVjdDtcblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0XHQvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxuXHRcdC8vIHJlbW92ZSBtZXRhZGF0YSBvbiBlYWNoIGl0ZW1cblx0XHQvLyBhbmQgcmV0dXJuIGFzIGFycmF5XG5cdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XG5cblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gY2FjaGUgKSB7XG5cblx0XHRcdFx0dmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XG5cdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuXHRcdFx0XHR2YWx1ZXMucHVzaCggZGF0YSApO1xuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICggcmVjdXJzaXZlICkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHVuZGVmaW5lZCApIHJlY3Vyc2l2ZSA9IHRydWU7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdHRoaXMudXAuY29weSggc291cmNlLnVwICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBzb3VyY2UucXVhdGVybmlvbiApO1xuXHRcdHRoaXMuc2NhbGUuY29weSggc291cmNlLnNjYWxlICk7XG5cblx0XHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBzb3VyY2UubWF0cml4V29ybGQgKTtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xuXG5cdFx0dGhpcy5sYXllcnMubWFzayA9IHNvdXJjZS5sYXllcnMubWFzaztcblx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcblxuXHRcdHRoaXMuY2FzdFNoYWRvdyA9IHNvdXJjZS5jYXN0U2hhZG93O1xuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xuXG5cdFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gc291cmNlLmZydXN0dW1DdWxsZWQ7XG5cdFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcblxuXHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcblxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlblsgaSBdO1xuXHRcdFx0XHR0aGlzLmFkZCggY2hpbGQuY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn0gKTtcblxuXG5leHBvcnQgeyBPYmplY3QzRCB9O1xuIiwiaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vUXVhdGVybmlvbi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuL01hdHJpeDQuanMnO1xuaW1wb3J0IHsgX01hdGggfSBmcm9tICcuL01hdGguanMnO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG52YXIgX21hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG52YXIgX3F1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG5mdW5jdGlvbiBFdWxlciggeCwgeSwgeiwgb3JkZXIgKSB7XG5cblx0dGhpcy5feCA9IHggfHwgMDtcblx0dGhpcy5feSA9IHkgfHwgMDtcblx0dGhpcy5feiA9IHogfHwgMDtcblx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCBFdWxlci5EZWZhdWx0T3JkZXI7XG5cbn1cblxuRXVsZXIuUm90YXRpb25PcmRlcnMgPSBbICdYWVonLCAnWVpYJywgJ1pYWScsICdYWlknLCAnWVhaJywgJ1pZWCcgXTtcblxuRXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBFdWxlci5wcm90b3R5cGUsIHtcblxuXHR4OiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX3g7XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHR9XG5cblx0fSxcblxuXHR5OiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX3k7XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHR9XG5cblx0fSxcblxuXHR6OiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX3o7XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRvcmRlcjoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl9vcmRlcjtcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuX29yZGVyID0gdmFsdWU7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHR9XG5cblx0fVxuXG59ICk7XG5cbk9iamVjdC5hc3NpZ24oIEV1bGVyLnByb3RvdHlwZSwge1xuXG5cdGlzRXVsZXI6IHRydWUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cblx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XG5cdFx0dGhpcy5feSA9IGV1bGVyLl95O1xuXHRcdHRoaXMuX3ogPSBldWxlci5fejtcblx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgY2xhbXAgPSBfTWF0aC5jbGFtcDtcblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdHZhciBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xuXHRcdHZhciBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xuXHRcdHZhciBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cblx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMTEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0dGhpcy5feiA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggLSBjbGFtcCggbTIzLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMjMgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTIyICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblx0XHRcdFx0dGhpcy5feiA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTMyICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIxICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMTIgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feSA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6ICcgKyBvcmRlciApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuXHRcdF9tYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX21hdHJpeCwgb3JkZXIsIHVwZGF0ZSApO1xuXG5cdH0sXG5cblx0c2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uICggdiwgb3JkZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyIHx8IHRoaXMuX29yZGVyICk7XG5cblx0fSxcblxuXHRyZW9yZGVyOiBmdW5jdGlvbiAoIG5ld09yZGVyICkge1xuXG5cdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuXG5cdFx0X3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggX3F1YXRlcm5pb24sIG5ld09yZGVyICk7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cblx0XHRyZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cblx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIDIgXTtcblx0XHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX29yZGVyO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0dG9WZWN0b3IzOiBmdW5jdGlvbiAoIG9wdGlvbmFsUmVzdWx0ICkge1xuXG5cdFx0aWYgKCBvcHRpb25hbFJlc3VsdCApIHtcblxuXHRcdFx0cmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IzKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRfb25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdF9vbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxuXG59ICk7XG5cblxuZXhwb3J0IHsgRXVsZXIgfTtcbiIsIi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxudmFyIF9sdXQgPSBbXTtcblxuZm9yICggdmFyIGkgPSAwOyBpIDwgMjU2OyBpICsrICkge1xuXG5cdF9sdXRbIGkgXSA9ICggaSA8IDE2ID8gJzAnIDogJycgKSArICggaSApLnRvU3RyaW5nKCAxNiApO1xuXG59XG5cbnZhciBfTWF0aCA9IHtcblxuXHRERUcyUkFEOiBNYXRoLlBJIC8gMTgwLFxuXHRSQUQyREVHOiAxODAgLyBNYXRoLlBJLFxuXG5cdGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XG5cblx0XHR2YXIgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdFx0dmFyIGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRcdHZhciBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0XHR2YXIgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdFx0dmFyIHV1aWQgPSBfbHV0WyBkMCAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDggJiAweGZmIF0gKyBfbHV0WyBkMCA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDI0ICYgMHhmZiBdICsgJy0nICtcblx0XHRcdF9sdXRbIGQxICYgMHhmZiBdICsgX2x1dFsgZDEgPj4gOCAmIDB4ZmYgXSArICctJyArIF9sdXRbIGQxID4+IDE2ICYgMHgwZiB8IDB4NDAgXSArIF9sdXRbIGQxID4+IDI0ICYgMHhmZiBdICsgJy0nICtcblx0XHRcdF9sdXRbIGQyICYgMHgzZiB8IDB4ODAgXSArIF9sdXRbIGQyID4+IDggJiAweGZmIF0gKyAnLScgKyBfbHV0WyBkMiA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQyID4+IDI0ICYgMHhmZiBdICtcblx0XHRcdF9sdXRbIGQzICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gOCAmIDB4ZmYgXSArIF9sdXRbIGQzID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gMjQgJiAweGZmIF07XG5cblx0XHQvLyAudG9VcHBlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG5cdFx0cmV0dXJuIHV1aWQudG9VcHBlckNhc2UoKTtcblxuXHR9LFxuXG5cdGNsYW1wOiBmdW5jdGlvbiAoIHZhbHVlLCBtaW4sIG1heCApIHtcblxuXHRcdHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCB2YWx1ZSApICk7XG5cblx0fSxcblxuXHQvLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cblx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuXG5cdGV1Y2xpZGVhbk1vZHVsbzogZnVuY3Rpb24gKCBuLCBtICkge1xuXG5cdFx0cmV0dXJuICggKCBuICUgbSApICsgbSApICUgbTtcblxuXHR9LFxuXG5cdC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cblxuXHRtYXBMaW5lYXI6IGZ1bmN0aW9uICggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XG5cblx0XHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxuXHR9LFxuXG5cdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9pbnRlcnBvbGF0aW9uXG5cblx0bGVycDogZnVuY3Rpb24gKCB4LCB5LCB0ICkge1xuXG5cdFx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcblxuXHR9LFxuXG5cdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxuXG5cdHNtb290aHN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRcdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XG5cblx0fSxcblxuXHRzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRcdHJldHVybiB4ICogeCAqIHggKiAoIHggKiAoIHggKiA2IC0gMTUgKSArIDEwICk7XG5cblx0fSxcblxuXHQvLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cblx0cmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cblx0XHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xuXG5cdH0sXG5cblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuXHRyYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG5cdFx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxuXHR9LFxuXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcblxuXHRyYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uICggcmFuZ2UgKSB7XG5cblx0XHRyZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcblxuXHR9LFxuXG5cdGRlZ1RvUmFkOiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XG5cblx0XHRyZXR1cm4gZGVncmVlcyAqIF9NYXRoLkRFRzJSQUQ7XG5cblx0fSxcblxuXHRyYWRUb0RlZzogZnVuY3Rpb24gKCByYWRpYW5zICkge1xuXG5cdFx0cmV0dXJuIHJhZGlhbnMgKiBfTWF0aC5SQUQyREVHO1xuXG5cdH0sXG5cblx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cblx0fSxcblxuXHRjZWlsUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5jZWlsKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcblxuXHR9LFxuXG5cdGZsb29yUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5mbG9vciggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cblx0fVxuXG59O1xuXG5cbmV4cG9ydCB7IF9NYXRoIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxudmFyIF92ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG5mdW5jdGlvbiBNYXRyaXgzKCkge1xuXG5cdHRoaXMuZWxlbWVudHMgPSBbXG5cblx0XHQxLCAwLCAwLFxuXHRcdDAsIDEsIDAsXG5cdFx0MCwgMCwgMVxuXG5cdF07XG5cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcblxuXHR9XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggTWF0cml4My5wcm90b3R5cGUsIHtcblxuXHRpc01hdHJpeDM6IHRydWUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDEgXSA9IG4yMTsgdGVbIDIgXSA9IG4zMTtcblx0XHR0ZVsgMyBdID0gbjEyOyB0ZVsgNCBdID0gbjIyOyB0ZVsgNSBdID0gbjMyO1xuXHRcdHRlWyA2IF0gPSBuMTM7IHRlWyA3IF0gPSBuMjM7IHRlWyA4IF0gPSBuMzM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCxcblx0XHRcdDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdO1xuXHRcdHRlWyAzIF0gPSBtZVsgMyBdOyB0ZVsgNCBdID0gbWVbIDQgXTsgdGVbIDUgXSA9IG1lWyA1IF07XG5cdFx0dGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdOyB0ZVsgOCBdID0gbWVbIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0bWVbIDAgXSwgbWVbIDQgXSwgbWVbIDggXSxcblx0XHRcdG1lWyAxIF0sIG1lWyA1IF0sIG1lWyA5IF0sXG5cdFx0XHRtZVsgMiBdLCBtZVsgNiBdLCBtZVsgMTAgXVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXBwbHlUb0J1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yLnggPSBhdHRyaWJ1dGUuZ2V0WCggaSApO1xuXHRcdFx0X3ZlY3Rvci55ID0gYXR0cmlidXRlLmdldFkoIGkgKTtcblx0XHRcdF92ZWN0b3IueiA9IGF0dHJpYnV0ZS5nZXRaKCBpICk7XG5cblx0XHRcdF92ZWN0b3IuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cblx0XHRcdGF0dHJpYnV0ZS5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJ1dGU7XG5cblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH0sXG5cblx0cHJlbXVsdGlwbHk6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuXHR9LFxuXG5cdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHZhciBhZSA9IGEuZWxlbWVudHM7XG5cdFx0dmFyIGJlID0gYi5lbGVtZW50cztcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyAzIF0sIGExMyA9IGFlWyA2IF07XG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA0IF0sIGEyMyA9IGFlWyA3IF07XG5cdFx0dmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA1IF0sIGEzMyA9IGFlWyA4IF07XG5cblx0XHR2YXIgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDMgXSwgYjEzID0gYmVbIDYgXTtcblx0XHR2YXIgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDQgXSwgYjIzID0gYmVbIDcgXTtcblx0XHR2YXIgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDUgXSwgYjMzID0gYmVbIDggXTtcblxuXHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzE7XG5cdFx0dGVbIDMgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcblx0XHR0ZVsgNiBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzO1xuXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTtcblx0XHR0ZVsgNCBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xuXHRcdHRlWyA3IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzM7XG5cblx0XHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxO1xuXHRcdHRlWyA1IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XG5cdFx0dGVbIDggXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdICo9IHM7IHRlWyAzIF0gKj0gczsgdGVbIDYgXSAqPSBzO1xuXHRcdHRlWyAxIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgNyBdICo9IHM7XG5cdFx0dGVbIDIgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA4IF0gKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgYSA9IHRlWyAwIF0sIGIgPSB0ZVsgMSBdLCBjID0gdGVbIDIgXSxcblx0XHRcdGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXG5cdFx0XHRnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xuXG5cdFx0cmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcblxuXHR9LFxuXG5cdGdldEludmVyc2U6IGZ1bmN0aW9uICggbWF0cml4LCB0aHJvd09uRGVnZW5lcmF0ZSApIHtcblxuXHRcdGlmICggbWF0cml4ICYmIG1hdHJpeC5pc01hdHJpeDQgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuTWF0cml4MzogLmdldEludmVyc2UoKSBubyBsb25nZXIgdGFrZXMgYSBNYXRyaXg0IGFyZ3VtZW50LlwiICk7XG5cblx0XHR9XG5cblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHMsXG5cdFx0XHR0ZSA9IHRoaXMuZWxlbWVudHMsXG5cblx0XHRcdG4xMSA9IG1lWyAwIF0sIG4yMSA9IG1lWyAxIF0sIG4zMSA9IG1lWyAyIF0sXG5cdFx0XHRuMTIgPSBtZVsgMyBdLCBuMjIgPSBtZVsgNCBdLCBuMzIgPSBtZVsgNSBdLFxuXHRcdFx0bjEzID0gbWVbIDYgXSwgbjIzID0gbWVbIDcgXSwgbjMzID0gbWVbIDggXSxcblxuXHRcdFx0dDExID0gbjMzICogbjIyIC0gbjMyICogbjIzLFxuXHRcdFx0dDEyID0gbjMyICogbjEzIC0gbjMzICogbjEyLFxuXHRcdFx0dDEzID0gbjIzICogbjEyIC0gbjIyICogbjEzLFxuXG5cdFx0XHRkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTM7XG5cblx0XHRpZiAoIGRldCA9PT0gMCApIHtcblxuXHRcdFx0dmFyIG1zZyA9IFwiVEhSRUUuTWF0cml4MzogLmdldEludmVyc2UoKSBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cblx0XHRcdGlmICggdGhyb3dPbkRlZ2VuZXJhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIG1zZyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmlkZW50aXR5KCk7XG5cblx0XHR9XG5cblx0XHR2YXIgZGV0SW52ID0gMSAvIGRldDtcblxuXHRcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XG5cdFx0dGVbIDEgXSA9ICggbjMxICogbjIzIC0gbjMzICogbjIxICkgKiBkZXRJbnY7XG5cdFx0dGVbIDIgXSA9ICggbjMyICogbjIxIC0gbjMxICogbjIyICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgMyBdID0gdDEyICogZGV0SW52O1xuXHRcdHRlWyA0IF0gPSAoIG4zMyAqIG4xMSAtIG4zMSAqIG4xMyApICogZGV0SW52O1xuXHRcdHRlWyA1IF0gPSAoIG4zMSAqIG4xMiAtIG4zMiAqIG4xMSApICogZGV0SW52O1xuXG5cdFx0dGVbIDYgXSA9IHQxMyAqIGRldEludjtcblx0XHR0ZVsgNyBdID0gKCBuMjEgKiBuMTMgLSBuMjMgKiBuMTEgKSAqIGRldEludjtcblx0XHR0ZVsgOCBdID0gKCBuMjIgKiBuMTEgLSBuMjEgKiBuMTIgKSAqIGRldEludjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdG1wLCBtID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG5cdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcblx0XHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4NCApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuZ2V0SW52ZXJzZSggdGhpcyApLnRyYW5zcG9zZSgpO1xuXG5cdH0sXG5cblx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XG5cblx0XHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRyWyAwIF0gPSBtWyAwIF07XG5cdFx0clsgMSBdID0gbVsgMyBdO1xuXHRcdHJbIDIgXSA9IG1bIDYgXTtcblx0XHRyWyAzIF0gPSBtWyAxIF07XG5cdFx0clsgNCBdID0gbVsgNCBdO1xuXHRcdHJbIDUgXSA9IG1bIDcgXTtcblx0XHRyWyA2IF0gPSBtWyAyIF07XG5cdFx0clsgNyBdID0gbVsgNSBdO1xuXHRcdHJbIDggXSA9IG1bIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0VXZUcmFuc2Zvcm06IGZ1bmN0aW9uICggdHgsIHR5LCBzeCwgc3ksIHJvdGF0aW9uLCBjeCwgY3kgKSB7XG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCByb3RhdGlvbiApO1xuXHRcdHZhciBzID0gTWF0aC5zaW4oIHJvdGF0aW9uICk7XG5cblx0XHR0aGlzLnNldChcblx0XHRcdHN4ICogYywgc3ggKiBzLCAtIHN4ICogKCBjICogY3ggKyBzICogY3kgKSArIGN4ICsgdHgsXG5cdFx0XHQtIHN5ICogcywgc3kgKiBjLCAtIHN5ICogKCAtIHMgKiBjeCArIGMgKiBjeSApICsgY3kgKyB0eSxcblx0XHRcdDAsIDAsIDFcblx0XHQpO1xuXG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uICggc3gsIHN5ICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gc3g7IHRlWyAzIF0gKj0gc3g7IHRlWyA2IF0gKj0gc3g7XG5cdFx0dGVbIDEgXSAqPSBzeTsgdGVbIDQgXSAqPSBzeTsgdGVbIDcgXSAqPSBzeTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKTtcblx0XHR2YXIgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciBhMTEgPSB0ZVsgMCBdLCBhMTIgPSB0ZVsgMyBdLCBhMTMgPSB0ZVsgNiBdO1xuXHRcdHZhciBhMjEgPSB0ZVsgMSBdLCBhMjIgPSB0ZVsgNCBdLCBhMjMgPSB0ZVsgNyBdO1xuXG5cdFx0dGVbIDAgXSA9IGMgKiBhMTEgKyBzICogYTIxO1xuXHRcdHRlWyAzIF0gPSBjICogYTEyICsgcyAqIGEyMjtcblx0XHR0ZVsgNiBdID0gYyAqIGExMyArIHMgKiBhMjM7XG5cblx0XHR0ZVsgMSBdID0gLSBzICogYTExICsgYyAqIGEyMTtcblx0XHR0ZVsgNCBdID0gLSBzICogYTEyICsgYyAqIGEyMjtcblx0XHR0ZVsgNyBdID0gLSBzICogYTEzICsgYyAqIGEyMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIHR4LCB0eSApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdICs9IHR4ICogdGVbIDIgXTsgdGVbIDMgXSArPSB0eCAqIHRlWyA1IF07IHRlWyA2IF0gKz0gdHggKiB0ZVsgOCBdO1xuXHRcdHRlWyAxIF0gKz0gdHkgKiB0ZVsgMiBdOyB0ZVsgNCBdICs9IHR5ICogdGVbIDUgXTsgdGVbIDcgXSArPSB0eSAqIHRlWyA4IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSA9IHRlWyA4IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG59ICk7XG5cblxuZXhwb3J0IHsgTWF0cml4MyB9O1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XG5cbnZhciBfdjEgPSBuZXcgVmVjdG9yMygpO1xudmFyIF9tMSA9IG5ldyBNYXRyaXg0KCk7XG52YXIgX3plcm8gPSBuZXcgVmVjdG9yMyggMCwgMCwgMCApO1xudmFyIF9vbmUgPSBuZXcgVmVjdG9yMyggMSwgMSwgMSApO1xudmFyIF94ID0gbmV3IFZlY3RvcjMoKTtcbnZhciBfeSA9IG5ldyBWZWN0b3IzKCk7XG52YXIgX3ogPSBuZXcgVmVjdG9yMygpO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cbiAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuZnVuY3Rpb24gTWF0cml4NCgpIHtcblxuXHR0aGlzLmVsZW1lbnRzID0gW1xuXG5cdFx0MSwgMCwgMCwgMCxcblx0XHQwLCAxLCAwLCAwLFxuXHRcdDAsIDAsIDEsIDAsXG5cdFx0MCwgMCwgMCwgMVxuXG5cdF07XG5cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcblxuXHR9XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggTWF0cml4NC5wcm90b3R5cGUsIHtcblxuXHRpc01hdHJpeDQ6IHRydWUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgNCBdID0gbjEyOyB0ZVsgOCBdID0gbjEzOyB0ZVsgMTIgXSA9IG4xNDtcblx0XHR0ZVsgMSBdID0gbjIxOyB0ZVsgNSBdID0gbjIyOyB0ZVsgOSBdID0gbjIzOyB0ZVsgMTMgXSA9IG4yNDtcblx0XHR0ZVsgMiBdID0gbjMxOyB0ZVsgNiBdID0gbjMyOyB0ZVsgMTAgXSA9IG4zMzsgdGVbIDE0IF0gPSBuMzQ7XG5cdFx0dGVbIDMgXSA9IG40MTsgdGVbIDcgXSA9IG40MjsgdGVbIDExIF0gPSBuNDM7IHRlWyAxNSBdID0gbjQ0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07IHRlWyAzIF0gPSBtZVsgMyBdO1xuXHRcdHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTsgdGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdO1xuXHRcdHRlWyA4IF0gPSBtZVsgOCBdOyB0ZVsgOSBdID0gbWVbIDkgXTsgdGVbIDEwIF0gPSBtZVsgMTAgXTsgdGVbIDExIF0gPSBtZVsgMTEgXTtcblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdOyB0ZVsgMTMgXSA9IG1lWyAxMyBdOyB0ZVsgMTQgXSA9IG1lWyAxNCBdOyB0ZVsgMTUgXSA9IG1lWyAxNSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHMsIG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07XG5cdFx0dGVbIDEzIF0gPSBtZVsgMTMgXTtcblx0XHR0ZVsgMTQgXSA9IG1lWyAxNCBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRleHRyYWN0QmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHhBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDAgKTtcblx0XHR5QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAxICk7XG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlQmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcblx0XHRcdHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXG5cdFx0XHR4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGV4dHJhY3RSb3RhdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gdGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCByZWZsZWN0aW9uIG1hdHJpY2VzXG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR2YXIgc2NhbGVYID0gMSAvIF92MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XG5cdFx0dmFyIHNjYWxlWSA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdHZhciBzY2FsZVogPSAxIC8gX3YxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcblxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xuXHRcdHRlWyAxIF0gPSBtZVsgMSBdICogc2NhbGVYO1xuXHRcdHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xuXHRcdHRlWyAzIF0gPSAwO1xuXG5cdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XG5cdFx0dGVbIDUgXSA9IG1lWyA1IF0gKiBzY2FsZVk7XG5cdFx0dGVbIDYgXSA9IG1lWyA2IF0gKiBzY2FsZVk7XG5cdFx0dGVbIDcgXSA9IDA7XG5cblx0XHR0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcblx0XHR0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcblx0XHR0ZVsgMTAgXSA9IG1lWyAxMCBdICogc2NhbGVaO1xuXHRcdHRlWyAxMSBdID0gMDtcblxuXHRcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDE0IF0gPSAwO1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0aWYgKCAhICggZXVsZXIgJiYgZXVsZXIuaXNFdWxlciApICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLm1ha2VSb3RhdGlvbkZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cblx0XHR9XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XG5cdFx0dmFyIGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKTtcblx0XHR2YXIgYyA9IE1hdGguY29zKCB5ICksIGQgPSBNYXRoLnNpbiggeSApO1xuXHRcdHZhciBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XG5cblx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGMgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcblx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBjO1xuXG5cdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYmUgKyBhZiAqIGQ7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGNlICsgZGYgKiBiO1xuXHRcdFx0dGVbIDQgXSA9IGRlICogYiAtIGNmO1xuXHRcdFx0dGVbIDggXSA9IGEgKiBkO1xuXG5cdFx0XHR0ZVsgMSBdID0gYSAqIGY7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gLSBiO1xuXG5cdFx0XHR0ZVsgMiBdID0gY2YgKiBiIC0gZGU7XG5cdFx0XHR0ZVsgNiBdID0gZGYgKyBjZSAqIGI7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xuXHRcdFx0dGVbIDQgXSA9IC0gYSAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XG5cblx0XHRcdHRlWyAxIF0gPSBjZiArIGRlICogYjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcblxuXHRcdFx0dGVbIDIgXSA9IC0gYSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XG5cblx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XG5cdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XG5cblx0XHRcdHRlWyAxIF0gPSBjICogZjtcblx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcblx0XHRcdHRlWyA5IF0gPSBhZiAqIGQgLSBiZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZDtcblx0XHRcdHRlWyA2IF0gPSBiICogYztcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gYmQgLSBhYyAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gYmMgKiBmICsgYWQ7XG5cblx0XHRcdHRlWyAxIF0gPSBmO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGU7XG5cblx0XHRcdHRlWyAyIF0gPSAtIGQgKiBlO1xuXHRcdFx0dGVbIDYgXSA9IGFkICogZiArIGJjO1xuXHRcdFx0dGVbIDEwIF0gPSBhYyAtIGJkICogZjtcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcblxuXHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGY7XG5cdFx0XHR0ZVsgOCBdID0gZCAqIGU7XG5cblx0XHRcdHRlWyAxIF0gPSBhYyAqIGYgKyBiZDtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcblxuXHRcdFx0dGVbIDIgXSA9IGJjICogZiAtIGFkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBlO1xuXHRcdFx0dGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcblxuXHRcdH1cblxuXHRcdC8vIGJvdHRvbSByb3dcblx0XHR0ZVsgMyBdID0gMDtcblx0XHR0ZVsgNyBdID0gMDtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHQvLyBsYXN0IGNvbHVtblxuXHRcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDE0IF0gPSAwO1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbXBvc2UoIF96ZXJvLCBxLCBfb25lICk7XG5cblx0fSxcblxuXHRsb29rQXQ6IGZ1bmN0aW9uICggZXllLCB0YXJnZXQsIHVwICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdF96LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICk7XG5cblx0XHRpZiAoIF96Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxuXG5cdFx0XHRfei56ID0gMTtcblxuXHRcdH1cblxuXHRcdF96Lm5vcm1hbGl6ZSgpO1xuXHRcdF94LmNyb3NzVmVjdG9ycyggdXAsIF96ICk7XG5cblx0XHRpZiAoIF94Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIHVwIGFuZCB6IGFyZSBwYXJhbGxlbFxuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB1cC56ICkgPT09IDEgKSB7XG5cblx0XHRcdFx0X3oueCArPSAwLjAwMDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3oueiArPSAwLjAwMDE7XG5cblx0XHRcdH1cblxuXHRcdFx0X3oubm9ybWFsaXplKCk7XG5cdFx0XHRfeC5jcm9zc1ZlY3RvcnMoIHVwLCBfeiApO1xuXG5cdFx0fVxuXG5cdFx0X3gubm9ybWFsaXplKCk7XG5cdFx0X3kuY3Jvc3NWZWN0b3JzKCBfeiwgX3ggKTtcblxuXHRcdHRlWyAwIF0gPSBfeC54OyB0ZVsgNCBdID0gX3kueDsgdGVbIDggXSA9IF96Lng7XG5cdFx0dGVbIDEgXSA9IF94Lnk7IHRlWyA1IF0gPSBfeS55OyB0ZVsgOSBdID0gX3oueTtcblx0XHR0ZVsgMiBdID0gX3guejsgdGVbIDYgXSA9IF95Lno7IHRlWyAxMCBdID0gX3ouejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcblxuXHRcdGlmICggbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCBuICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XG5cblx0fSxcblxuXHRwcmVtdWx0aXBseTogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgdGhpcyApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlNYXRyaWNlczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dmFyIGFlID0gYS5lbGVtZW50cztcblx0XHR2YXIgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xuXHRcdHZhciBhMzEgPSBhZVsgMiBdLCBhMzIgPSBhZVsgNiBdLCBhMzMgPSBhZVsgMTAgXSwgYTM0ID0gYWVbIDE0IF07XG5cdFx0dmFyIGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcblxuXHRcdHZhciBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcblx0XHR2YXIgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDUgXSwgYjIzID0gYmVbIDkgXSwgYjI0ID0gYmVbIDEzIF07XG5cdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcblx0XHR2YXIgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xuXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcblx0XHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuXHRcdHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XG5cblx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG5cdFx0dGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0Mztcblx0XHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XG5cdFx0dGVbIDYgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0Mjtcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0Mztcblx0XHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XG5cdFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0Mjtcblx0XHR0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0Mztcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xuXHRcdHRlWyAxIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOSBdICo9IHM7IHRlWyAxMyBdICo9IHM7XG5cdFx0dGVbIDIgXSAqPSBzOyB0ZVsgNiBdICo9IHM7IHRlWyAxMCBdICo9IHM7IHRlWyAxNCBdICo9IHM7XG5cdFx0dGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3YxLnggPSBhdHRyaWJ1dGUuZ2V0WCggaSApO1xuXHRcdFx0X3YxLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaSApO1xuXHRcdFx0X3YxLnogPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xuXG5cdFx0XHRfdjEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cblx0XHRcdGF0dHJpYnV0ZS5zZXRYWVooIGksIF92MS54LCBfdjEueSwgX3YxLnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJ1dGU7XG5cblx0fSxcblxuXHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciBuMTEgPSB0ZVsgMCBdLCBuMTIgPSB0ZVsgNCBdLCBuMTMgPSB0ZVsgOCBdLCBuMTQgPSB0ZVsgMTIgXTtcblx0XHR2YXIgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XG5cdFx0dmFyIG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcblx0XHR2YXIgbjQxID0gdGVbIDMgXSwgbjQyID0gdGVbIDcgXSwgbjQzID0gdGVbIDExIF0sIG40NCA9IHRlWyAxNSBdO1xuXG5cdFx0Ly9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcblx0XHQvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcblxuXHRcdHJldHVybiAoXG5cdFx0XHRuNDEgKiAoXG5cdFx0XHRcdCsgbjE0ICogbjIzICogbjMyXG5cdFx0XHRcdCAtIG4xMyAqIG4yNCAqIG4zMlxuXHRcdFx0XHQgLSBuMTQgKiBuMjIgKiBuMzNcblx0XHRcdFx0ICsgbjEyICogbjI0ICogbjMzXG5cdFx0XHRcdCArIG4xMyAqIG4yMiAqIG4zNFxuXHRcdFx0XHQgLSBuMTIgKiBuMjMgKiBuMzRcblx0XHRcdCkgK1xuXHRcdFx0bjQyICogKFxuXHRcdFx0XHQrIG4xMSAqIG4yMyAqIG4zNFxuXHRcdFx0XHQgLSBuMTEgKiBuMjQgKiBuMzNcblx0XHRcdFx0ICsgbjE0ICogbjIxICogbjMzXG5cdFx0XHRcdCAtIG4xMyAqIG4yMSAqIG4zNFxuXHRcdFx0XHQgKyBuMTMgKiBuMjQgKiBuMzFcblx0XHRcdFx0IC0gbjE0ICogbjIzICogbjMxXG5cdFx0XHQpICtcblx0XHRcdG40MyAqIChcblx0XHRcdFx0KyBuMTEgKiBuMjQgKiBuMzJcblx0XHRcdFx0IC0gbjExICogbjIyICogbjM0XG5cdFx0XHRcdCAtIG4xNCAqIG4yMSAqIG4zMlxuXHRcdFx0XHQgKyBuMTIgKiBuMjEgKiBuMzRcblx0XHRcdFx0ICsgbjE0ICogbjIyICogbjMxXG5cdFx0XHRcdCAtIG4xMiAqIG4yNCAqIG4zMVxuXHRcdFx0KSArXG5cdFx0XHRuNDQgKiAoXG5cdFx0XHRcdC0gbjEzICogbjIyICogbjMxXG5cdFx0XHRcdCAtIG4xMSAqIG4yMyAqIG4zMlxuXHRcdFx0XHQgKyBuMTEgKiBuMjIgKiBuMzNcblx0XHRcdFx0ICsgbjEzICogbjIxICogbjMyXG5cdFx0XHRcdCAtIG4xMiAqIG4yMSAqIG4zM1xuXHRcdFx0XHQgKyBuMTIgKiBuMjMgKiBuMzFcblx0XHRcdClcblxuXHRcdCk7XG5cblx0fSxcblxuXHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIHRtcDtcblxuXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xuXG5cdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHgueDtcblx0XHRcdHRlWyAxMyBdID0geC55O1xuXHRcdFx0dGVbIDE0IF0gPSB4Lno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHg7XG5cdFx0XHR0ZVsgMTMgXSA9IHk7XG5cdFx0XHR0ZVsgMTQgXSA9IHo7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkRlZ2VuZXJhdGUgKSB7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLFxuXHRcdFx0bWUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRuMTEgPSBtZVsgMCBdLCBuMjEgPSBtZVsgMSBdLCBuMzEgPSBtZVsgMiBdLCBuNDEgPSBtZVsgMyBdLFxuXHRcdFx0bjEyID0gbWVbIDQgXSwgbjIyID0gbWVbIDUgXSwgbjMyID0gbWVbIDYgXSwgbjQyID0gbWVbIDcgXSxcblx0XHRcdG4xMyA9IG1lWyA4IF0sIG4yMyA9IG1lWyA5IF0sIG4zMyA9IG1lWyAxMCBdLCBuNDMgPSBtZVsgMTEgXSxcblx0XHRcdG4xNCA9IG1lWyAxMiBdLCBuMjQgPSBtZVsgMTMgXSwgbjM0ID0gbWVbIDE0IF0sIG40NCA9IG1lWyAxNSBdLFxuXG5cdFx0XHR0MTEgPSBuMjMgKiBuMzQgKiBuNDIgLSBuMjQgKiBuMzMgKiBuNDIgKyBuMjQgKiBuMzIgKiBuNDMgLSBuMjIgKiBuMzQgKiBuNDMgLSBuMjMgKiBuMzIgKiBuNDQgKyBuMjIgKiBuMzMgKiBuNDQsXG5cdFx0XHR0MTIgPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQsXG5cdFx0XHR0MTMgPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQsXG5cdFx0XHR0MTQgPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XG5cblx0XHR2YXIgZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzICsgbjQxICogdDE0O1xuXG5cdFx0aWYgKCBkZXQgPT09IDAgKSB7XG5cblx0XHRcdHZhciBtc2cgPSBcIlRIUkVFLk1hdHJpeDQ6IC5nZXRJbnZlcnNlKCkgY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xuXG5cdFx0XHRpZiAoIHRocm93T25EZWdlbmVyYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCBtc2cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGRldEludiA9IDEgLyBkZXQ7XG5cblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuXHRcdHRlWyAxIF0gPSAoIG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAyIF0gPSAoIG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAzIF0gPSAoIG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDQgXSA9IHQxMiAqIGRldEludjtcblx0XHR0ZVsgNSBdID0gKCBuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgNiBdID0gKCBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgNyBdID0gKCBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyA4IF0gPSB0MTMgKiBkZXRJbnY7XG5cdFx0dGVbIDkgXSA9ICggbjE0ICogbjIzICogbjQxIC0gbjEzICogbjI0ICogbjQxIC0gbjE0ICogbjIxICogbjQzICsgbjExICogbjI0ICogbjQzICsgbjEzICogbjIxICogbjQ0IC0gbjExICogbjIzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDEwIF0gPSAoIG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAxMSBdID0gKCBuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyAxMiBdID0gdDE0ICogZGV0SW52O1xuXHRcdHRlWyAxMyBdID0gKCBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQgKSAqIGRldEludjtcblx0XHR0ZVsgMTQgXSA9ICggbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDE1IF0gPSAoIG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMyApICogZGV0SW52O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR2YXIgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcblxuXHRcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XG5cdFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcblx0XHR0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcblx0XHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Z2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgc2NhbGVYU3EgPSB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICsgdGVbIDIgXSAqIHRlWyAyIF07XG5cdFx0dmFyIHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xuXHRcdHZhciBzY2FsZVpTcSA9IHRlWyA4IF0gKiB0ZVsgOCBdICsgdGVbIDkgXSAqIHRlWyA5IF0gKyB0ZVsgMTAgXSAqIHRlWyAxMCBdO1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggTWF0aC5tYXgoIHNjYWxlWFNxLCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApO1xuXG5cdH0sXG5cblx0bWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgeCxcblx0XHRcdDAsIDEsIDAsIHksXG5cdFx0XHQwLCAwLCAxLCB6LFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uWDogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgYywgLSBzLCAwLFxuXHRcdFx0MCwgcywgYywgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VSb3RhdGlvblk6IGZ1bmN0aW9uICggdGhldGEgKSB7XG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0IGMsIDAsIHMsIDAsXG5cdFx0XHQgMCwgMSwgMCwgMCxcblx0XHRcdC0gcywgMCwgYywgMCxcblx0XHRcdCAwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUm90YXRpb25aOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdGMsIC0gcywgMCwgMCxcblx0XHRcdHMsIGMsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcblx0XHR2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXHRcdHZhciB0ID0gMSAtIGM7XG5cdFx0dmFyIHggPSBheGlzLngsIHkgPSBheGlzLnksIHogPSBheGlzLno7XG5cdFx0dmFyIHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxuXHRcdFx0dHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxuXHRcdFx0dHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdCByZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VTY2FsZTogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdHgsIDAsIDAsIDAsXG5cdFx0XHQwLCB5LCAwLCAwLFxuXHRcdFx0MCwgMCwgeiwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VTaGVhcjogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIHksIHosIDAsXG5cdFx0XHR4LCAxLCB6LCAwLFxuXHRcdFx0eCwgeSwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvbXBvc2U6IGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciB4ID0gcXVhdGVybmlvbi5feCwgeSA9IHF1YXRlcm5pb24uX3ksIHogPSBxdWF0ZXJuaW9uLl96LCB3ID0gcXVhdGVybmlvbi5fdztcblx0XHR2YXIgeDIgPSB4ICsgeCxcdHkyID0geSArIHksIHoyID0geiArIHo7XG5cdFx0dmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XG5cdFx0dmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XG5cdFx0dmFyIHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XG5cblx0XHR2YXIgc3ggPSBzY2FsZS54LCBzeSA9IHNjYWxlLnksIHN6ID0gc2NhbGUuejtcblxuXHRcdHRlWyAwIF0gPSAoIDEgLSAoIHl5ICsgenogKSApICogc3g7XG5cdFx0dGVbIDEgXSA9ICggeHkgKyB3eiApICogc3g7XG5cdFx0dGVbIDIgXSA9ICggeHogLSB3eSApICogc3g7XG5cdFx0dGVbIDMgXSA9IDA7XG5cblx0XHR0ZVsgNCBdID0gKCB4eSAtIHd6ICkgKiBzeTtcblx0XHR0ZVsgNSBdID0gKCAxIC0gKCB4eCArIHp6ICkgKSAqIHN5O1xuXHRcdHRlWyA2IF0gPSAoIHl6ICsgd3ggKSAqIHN5O1xuXHRcdHRlWyA3IF0gPSAwO1xuXG5cdFx0dGVbIDggXSA9ICggeHogKyB3eSApICogc3o7XG5cdFx0dGVbIDkgXSA9ICggeXogLSB3eCApICogc3o7XG5cdFx0dGVbIDEwIF0gPSAoIDEgLSAoIHh4ICsgeXkgKSApICogc3o7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0dGVbIDEyIF0gPSBwb3NpdGlvbi54O1xuXHRcdHRlWyAxMyBdID0gcG9zaXRpb24ueTtcblx0XHR0ZVsgMTQgXSA9IHBvc2l0aW9uLno7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkZWNvbXBvc2U6IGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciBzeCA9IF92MS5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKS5sZW5ndGgoKTtcblx0XHR2YXIgc3kgPSBfdjEuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0dmFyIHN6ID0gX3YxLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKS5sZW5ndGgoKTtcblxuXHRcdC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG5cdFx0dmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcblx0XHRpZiAoIGRldCA8IDAgKSBzeCA9IC0gc3g7XG5cblx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XG5cdFx0cG9zaXRpb24ueSA9IHRlWyAxMyBdO1xuXHRcdHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcblxuXHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cdFx0X20xLmNvcHkoIHRoaXMgKTtcblxuXHRcdHZhciBpbnZTWCA9IDEgLyBzeDtcblx0XHR2YXIgaW52U1kgPSAxIC8gc3k7XG5cdFx0dmFyIGludlNaID0gMSAvIHN6O1xuXG5cdFx0X20xLmVsZW1lbnRzWyAwIF0gKj0gaW52U1g7XG5cdFx0X20xLmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG5cdFx0X20xLmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XG5cblx0XHRfbTEuZWxlbWVudHNbIDQgXSAqPSBpbnZTWTtcblx0XHRfbTEuZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcblx0XHRfbTEuZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcblxuXHRcdF9tMS5lbGVtZW50c1sgOCBdICo9IGludlNaO1xuXHRcdF9tMS5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuXHRcdF9tMS5lbGVtZW50c1sgMTAgXSAqPSBpbnZTWjtcblxuXHRcdHF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcblxuXHRcdHNjYWxlLnggPSBzeDtcblx0XHRzY2FsZS55ID0gc3k7XG5cdFx0c2NhbGUueiA9IHN6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUGVyc3BlY3RpdmU6IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRpZiAoIGZhciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubWFrZVBlcnNwZWN0aXZlKCkgaGFzIGJlZW4gcmVkZWZpbmVkIGFuZCBoYXMgYSBuZXcgc2lnbmF0dXJlLiBQbGVhc2UgY2hlY2sgdGhlIGRvY3MuJyApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR2YXIgeCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHR2YXIgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcblxuXHRcdHZhciBhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0dmFyIGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcblx0XHR2YXIgYyA9IC0gKCBmYXIgKyBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcblx0XHR2YXIgZCA9IC0gMiAqIGZhciAqIG5lYXIgLyAoIGZhciAtIG5lYXIgKTtcblxuXHRcdHRlWyAwIF0gPSB4O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gYTtcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gYztcdHRlWyAxNCBdID0gZDtcblx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAtIDE7XHR0ZVsgMTUgXSA9IDA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VPcnRob2dyYXBoaWM6IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHR2YXIgaCA9IDEuMCAvICggdG9wIC0gYm90dG9tICk7XG5cdFx0dmFyIHAgPSAxLjAgLyAoIGZhciAtIG5lYXIgKTtcblxuXHRcdHZhciB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XG5cdFx0dmFyIHkgPSAoIHRvcCArIGJvdHRvbSApICogaDtcblx0XHR2YXIgeiA9ICggZmFyICsgbmVhciApICogcDtcblxuXHRcdHRlWyAwIF0gPSAyICogdztcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IDA7XHR0ZVsgMTIgXSA9IC0geDtcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSAyICogaDtcdHRlWyA5IF0gPSAwO1x0dGVbIDEzIF0gPSAtIHk7XG5cdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gLSAyICogcDtcdHRlWyAxNCBdID0gLSB6O1xuXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IDA7XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgOSBdID0gdGVbIDkgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxufSApO1xuXG5cbmV4cG9ydCB7IE1hdHJpeDQgfTtcbiIsIi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG5pbXBvcnQgeyBfTWF0aCB9IGZyb20gJy4vTWF0aC5qcyc7XG5cbmZ1bmN0aW9uIFF1YXRlcm5pb24oIHgsIHksIHosIHcgKSB7XG5cblx0dGhpcy5feCA9IHggfHwgMDtcblx0dGhpcy5feSA9IHkgfHwgMDtcblx0dGhpcy5feiA9IHogfHwgMDtcblx0dGhpcy5fdyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcblxufVxuXG5PYmplY3QuYXNzaWduKCBRdWF0ZXJuaW9uLCB7XG5cblx0c2xlcnA6IGZ1bmN0aW9uICggcWEsIHFiLCBxbSwgdCApIHtcblxuXHRcdHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xuXG5cdH0sXG5cblx0c2xlcnBGbGF0OiBmdW5jdGlvbiAoIGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxLCB0ICkge1xuXG5cdFx0Ly8gZnV6ei1mcmVlLCBhcnJheS1iYXNlZCBRdWF0ZXJuaW9uIFNMRVJQIG9wZXJhdGlvblxuXG5cdFx0dmFyIHgwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDAgXSxcblx0XHRcdHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXSxcblx0XHRcdHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXSxcblx0XHRcdHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXSxcblxuXHRcdFx0eDEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMCBdLFxuXHRcdFx0eTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdLFxuXHRcdFx0ejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdLFxuXHRcdFx0dzEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMyBdO1xuXG5cdFx0aWYgKCB3MCAhPT0gdzEgfHwgeDAgIT09IHgxIHx8IHkwICE9PSB5MSB8fCB6MCAhPT0gejEgKSB7XG5cblx0XHRcdHZhciBzID0gMSAtIHQsXG5cblx0XHRcdFx0Y29zID0geDAgKiB4MSArIHkwICogeTEgKyB6MCAqIHoxICsgdzAgKiB3MSxcblxuXHRcdFx0XHRkaXIgPSAoIGNvcyA+PSAwID8gMSA6IC0gMSApLFxuXHRcdFx0XHRzcXJTaW4gPSAxIC0gY29zICogY29zO1xuXG5cdFx0XHQvLyBTa2lwIHRoZSBTbGVycCBmb3IgdGlueSBzdGVwcyB0byBhdm9pZCBudW1lcmljIHByb2JsZW1zOlxuXHRcdFx0aWYgKCBzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHR2YXIgc2luID0gTWF0aC5zcXJ0KCBzcXJTaW4gKSxcblx0XHRcdFx0XHRsZW4gPSBNYXRoLmF0YW4yKCBzaW4sIGNvcyAqIGRpciApO1xuXG5cdFx0XHRcdHMgPSBNYXRoLnNpbiggcyAqIGxlbiApIC8gc2luO1xuXHRcdFx0XHR0ID0gTWF0aC5zaW4oIHQgKiBsZW4gKSAvIHNpbjtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdERpciA9IHQgKiBkaXI7XG5cblx0XHRcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xuXHRcdFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XG5cdFx0XHR6MCA9IHowICogcyArIHoxICogdERpcjtcblx0XHRcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyO1xuXG5cdFx0XHQvLyBOb3JtYWxpemUgaW4gY2FzZSB3ZSBqdXN0IGRpZCBhIGxlcnA6XG5cdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xuXG5cdFx0XHRcdHZhciBmID0gMSAvIE1hdGguc3FydCggeDAgKiB4MCArIHkwICogeTAgKyB6MCAqIHowICsgdzAgKiB3MCApO1xuXG5cdFx0XHRcdHgwICo9IGY7XG5cdFx0XHRcdHkwICo9IGY7XG5cdFx0XHRcdHowICo9IGY7XG5cdFx0XHRcdHcwICo9IGY7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcblxuXHR9XG5cbn0gKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFF1YXRlcm5pb24ucHJvdG90eXBlLCB7XG5cblx0eDoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl94O1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5feCA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0eToge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl95O1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5feSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0ejoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl96O1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5feiA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0dzoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl93O1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5fdyA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0fVxuXG5cdH1cblxufSApO1xuXG5PYmplY3QuYXNzaWduKCBRdWF0ZXJuaW9uLnByb3RvdHlwZSwge1xuXG5cdGlzUXVhdGVybmlvbjogdHJ1ZSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX3cgPSB3O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93ICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XG5cblx0XHR0aGlzLl94ID0gcXVhdGVybmlvbi54O1xuXHRcdHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XG5cdFx0dGhpcy5feiA9IHF1YXRlcm5pb24uejtcblx0XHR0aGlzLl93ID0gcXVhdGVybmlvbi53O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIsIHVwZGF0ZSApIHtcblxuXHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHggPSBldWxlci5feCwgeSA9IGV1bGVyLl95LCB6ID0gZXVsZXIuX3osIG9yZGVyID0gZXVsZXIub3JkZXI7XG5cblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG5cdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cblx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cblx0XHR2YXIgY29zID0gTWF0aC5jb3M7XG5cdFx0dmFyIHNpbiA9IE1hdGguc2luO1xuXG5cdFx0dmFyIGMxID0gY29zKCB4IC8gMiApO1xuXHRcdHZhciBjMiA9IGNvcyggeSAvIDIgKTtcblx0XHR2YXIgYzMgPSBjb3MoIHogLyAyICk7XG5cblx0XHR2YXIgczEgPSBzaW4oIHggLyAyICk7XG5cdFx0dmFyIHMyID0gc2luKCB5IC8gMiApO1xuXHRcdHZhciBzMyA9IHNpbiggeiAvIDIgKTtcblxuXHRcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLl94ID0gYXhpcy54ICogcztcblx0XHR0aGlzLl95ID0gYXhpcy55ICogcztcblx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcblx0XHR0aGlzLl93ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dmFyIHRlID0gbS5lbGVtZW50cyxcblxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcblx0XHRcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXG5cdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXSxcblxuXHRcdFx0dHJhY2UgPSBtMTEgKyBtMjIgKyBtMzMsXG5cdFx0XHRzO1xuXG5cdFx0aWYgKCB0cmFjZSA+IDAgKSB7XG5cblx0XHRcdHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XG5cblx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcblx0XHRcdHRoaXMuX3kgPSAoIG0xMyAtIG0zMSApICogcztcblx0XHRcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcblxuXHRcdH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XG5cblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XG5cblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl95ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTIzICsgbTMyICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uICggdkZyb20sIHZUbyApIHtcblxuXHRcdC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG5cdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xuXG5cdFx0dmFyIHIgPSB2RnJvbS5kb3QoIHZUbyApICsgMTtcblxuXHRcdGlmICggciA8IEVQUyApIHtcblxuXHRcdFx0ciA9IDA7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIHZGcm9tLnggKSA+IE1hdGguYWJzKCB2RnJvbS56ICkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IC0gdkZyb20ueTtcblx0XHRcdFx0dGhpcy5feSA9IHZGcm9tLng7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0dGhpcy5feSA9IC0gdkZyb20uejtcblx0XHRcdFx0dGhpcy5feiA9IHZGcm9tLnk7XG5cdFx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBjcm9zc1ZlY3RvcnMoIHZGcm9tLCB2VG8gKTsgLy8gaW5saW5lZCB0byBhdm9pZCBjeWNsaWMgZGVwZW5kZW5jeSBvbiBWZWN0b3IzXG5cblx0XHRcdHRoaXMuX3ggPSB2RnJvbS55ICogdlRvLnogLSB2RnJvbS56ICogdlRvLnk7XG5cdFx0XHR0aGlzLl95ID0gdkZyb20ueiAqIHZUby54IC0gdkZyb20ueCAqIHZUby56O1xuXHRcdFx0dGhpcy5feiA9IHZGcm9tLnggKiB2VG8ueSAtIHZGcm9tLnkgKiB2VG8ueDtcblx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cblx0fSxcblxuXHRhbmdsZVRvOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHRyZXR1cm4gMiAqIE1hdGguYWNvcyggTWF0aC5hYnMoIF9NYXRoLmNsYW1wKCB0aGlzLmRvdCggcSApLCAtIDEsIDEgKSApICk7XG5cblx0fSxcblxuXHRyb3RhdGVUb3dhcmRzOiBmdW5jdGlvbiAoIHEsIHN0ZXAgKSB7XG5cblx0XHR2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlVG8oIHEgKTtcblxuXHRcdGlmICggYW5nbGUgPT09IDAgKSByZXR1cm4gdGhpcztcblxuXHRcdHZhciB0ID0gTWF0aC5taW4oIDEsIHN0ZXAgLyBhbmdsZSApO1xuXG5cdFx0dGhpcy5zbGVycCggcSwgdCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBxdWF0ZXJuaW9uIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0cmV0dXJuIHRoaXMuY29uanVnYXRlKCk7XG5cblx0fSxcblxuXHRjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuX3ggKj0gLSAxO1xuXHRcdHRoaXMuX3kgKj0gLSAxO1xuXHRcdHRoaXMuX3ogKj0gLSAxO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcblxuXHR9LFxuXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XG5cblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdGlmICggbCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0dGhpcy5fdyA9IDE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRsID0gMSAvIGw7XG5cblx0XHRcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcblx0XHRcdHRoaXMuX3kgPSB0aGlzLl95ICogbDtcblx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcblx0XHRcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcblxuXHRcdH1cblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggcSwgcCApIHtcblxuXHRcdGlmICggcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCBxLCBwICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG5cblx0fSxcblxuXHRwcmVtdWx0aXBseTogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgdGhpcyApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cblx0XHR2YXIgcWF4ID0gYS5feCwgcWF5ID0gYS5feSwgcWF6ID0gYS5feiwgcWF3ID0gYS5fdztcblx0XHR2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcblxuXHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG5cdFx0dGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcblx0XHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuXHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xuXG5cdFx0aWYgKCB0ID09PSAwICkgcmV0dXJuIHRoaXM7XG5cdFx0aWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcblxuXHRcdHZhciB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cblx0XHR2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG5cdFx0XHR0aGlzLl93ID0gLSBxYi5fdztcblx0XHRcdHRoaXMuX3ggPSAtIHFiLl94O1xuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XG5cdFx0XHR0aGlzLl96ID0gLSBxYi5fejtcblxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSB3O1xuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdHZhciBzcXJTaW5IYWxmVGhldGEgPSAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGE7XG5cblx0XHRpZiAoIHNxclNpbkhhbGZUaGV0YSA8PSBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0dmFyIHMgPSAxIC0gdDtcblx0XHRcdHRoaXMuX3cgPSBzICogdyArIHQgKiB0aGlzLl93O1xuXHRcdFx0dGhpcy5feCA9IHMgKiB4ICsgdCAqIHRoaXMuX3g7XG5cdFx0XHR0aGlzLl95ID0gcyAqIHkgKyB0ICogdGhpcy5feTtcblx0XHRcdHRoaXMuX3ogPSBzICogeiArIHQgKiB0aGlzLl96O1xuXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdHZhciBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIHNxclNpbkhhbGZUaGV0YSApO1xuXHRcdHZhciBoYWxmVGhldGEgPSBNYXRoLmF0YW4yKCBzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSApO1xuXHRcdHZhciByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXG5cdFx0XHRyYXRpb0IgPSBNYXRoLnNpbiggdCAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xuXG5cdFx0dGhpcy5fdyA9ICggdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0IgKTtcblx0XHR0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feiA9ICggeiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0IgKTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XG5cblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX3c7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRfb25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdF9vbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxuXG59ICk7XG5cblxuZXhwb3J0IHsgUXVhdGVybmlvbiB9O1xuIiwiaW1wb3J0IHsgX01hdGggfSBmcm9tICcuL01hdGguanMnO1xuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vUXVhdGVybmlvbi5qcyc7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3Iga2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cbnZhciBfdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbnZhciBfcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmZ1bmN0aW9uIFZlY3RvcjMoIHgsIHksIHogKSB7XG5cblx0dGhpcy54ID0geCB8fCAwO1xuXHR0aGlzLnkgPSB5IHx8IDA7XG5cdHRoaXMueiA9IHogfHwgMDtcblxufVxuXG5PYmplY3QuYXNzaWduKCBWZWN0b3IzLnByb3RvdHlwZSwge1xuXG5cdGlzVmVjdG9yMzogdHJ1ZSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdHRoaXMueSA9IHNjYWxhcjtcblx0XHR0aGlzLnogPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcblxuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblx0XHR0aGlzLnogKz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXHRcdHRoaXMueiArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXHRcdHRoaXMueiA9IGEueiArIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHR0aGlzLnkgKz0gdi55ICogcztcblx0XHR0aGlzLnogKz0gdi56ICogcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCAtPSBzO1xuXHRcdHRoaXMueSAtPSBzO1xuXHRcdHRoaXMueiAtPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICo9IHYueDtcblx0XHR0aGlzLnkgKj0gdi55O1xuXHRcdHRoaXMueiAqPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICogYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0aWYgKCAhICggZXVsZXIgJiYgZXVsZXIuaXNFdWxlciApICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cblx0fSxcblxuXHRhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xuXG5cdH0sXG5cblx0YXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF0gKiB6O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXBwbHlOb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4MyggbSApLm5vcm1hbGl6ZSgpO1xuXG5cdH0sXG5cblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR2YXIgdyA9IDEgLyAoIGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICk7XG5cblx0XHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKSAqIHc7XG5cdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICkgKiB3O1xuXHRcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0dmFyIHF4ID0gcS54LCBxeSA9IHEueSwgcXogPSBxLnosIHF3ID0gcS53O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuXHRcdHZhciBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcblx0XHR2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG5cdFx0dmFyIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuXHRcdHZhciBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG5cdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcblx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xuXHRcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHByb2plY3Q6IGZ1bmN0aW9uICggY2FtZXJhICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdH0sXG5cblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHR9LFxuXG5cdHRyYW5zZm9ybURpcmVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXHRcdC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCAvPSB2Lng7XG5cdFx0dGhpcy55IC89IHYueTtcblx0XHR0aGlzLnogLz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuXHR9LFxuXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCBtaW5WYWwsIG1heFZhbCApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy55ICkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnogKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCBsZW5ndGggfHwgMSApLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApICk7XG5cblx0fSxcblxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXG5cdH0sXG5cblx0Ly8gVE9ETyBsZW5ndGhTcXVhcmVkP1xuXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xuXG5cdH0sXG5cblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcblxuXHR9LFxuXG5cdG1hbmhhdHRhbkxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcblxuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcblxuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XG5cblx0fSxcblxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cblx0fSxcblxuXHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5jcm9zcygpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmNyb3NzVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHRoaXMsIHYgKTtcblxuXHR9LFxuXG5cdGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dmFyIGF4ID0gYS54LCBheSA9IGEueSwgYXogPSBhLno7XG5cdFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XG5cblx0XHR0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcblx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcblx0XHR0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cHJvamVjdE9uVmVjdG9yOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHQvLyB2IGNhbm5vdCBiZSB0aGUgemVybyB2XG5cblx0XHR2YXIgc2NhbGFyID0gdi5kb3QoIHRoaXMgKSAvIHYubGVuZ3RoU3EoKTtcblxuXHRcdHJldHVybiB0aGlzLmNvcHkoIHYgKS5tdWx0aXBseVNjYWxhciggc2NhbGFyICk7XG5cblx0fSxcblxuXHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCBwbGFuZU5vcm1hbCApIHtcblxuXHRcdF92ZWN0b3IuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcblxuXHRcdHJldHVybiB0aGlzLnN1YiggX3ZlY3RvciApO1xuXG5cdH0sXG5cblx0cmVmbGVjdDogZnVuY3Rpb24gKCBub3JtYWwgKSB7XG5cblx0XHQvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcblx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG5cblx0XHRyZXR1cm4gdGhpcy5zdWIoIF92ZWN0b3IuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xuXG5cdH0sXG5cblx0YW5nbGVUbzogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIGRlbm9taW5hdG9yID0gTWF0aC5zcXJ0KCB0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkgKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSBjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogYW5nbGVUbygpIGNhblxcJ3QgaGFuZGxlIHplcm8gbGVuZ3RoIHZlY3RvcnMuJyApO1xuXG5cdFx0dmFyIHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdHJldHVybiBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2LnksIGR6ID0gdGhpcy56IC0gdi56O1xuXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblxuXHR9LFxuXG5cdG1hbmhhdHRhbkRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICkgKyBNYXRoLmFicyggdGhpcy56IC0gdi56ICk7XG5cblx0fSxcblxuXHRzZXRGcm9tU3BoZXJpY2FsOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tU3BoZXJpY2FsQ29vcmRzKCBzLnJhZGl1cywgcy5waGksIHMudGhldGEgKTtcblxuXHR9LFxuXG5cdHNldEZyb21TcGhlcmljYWxDb29yZHM6IGZ1bmN0aW9uICggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG5cdFx0dmFyIHNpblBoaVJhZGl1cyA9IE1hdGguc2luKCBwaGkgKSAqIHJhZGl1cztcblxuXHRcdHRoaXMueCA9IHNpblBoaVJhZGl1cyAqIE1hdGguc2luKCB0aGV0YSApO1xuXHRcdHRoaXMueSA9IE1hdGguY29zKCBwaGkgKSAqIHJhZGl1cztcblx0XHR0aGlzLnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUN5bGluZHJpY2FsOiBmdW5jdGlvbiAoIGMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoIGMucmFkaXVzLCBjLnRoZXRhLCBjLnkgKTtcblxuXHR9LFxuXG5cdHNldEZyb21DeWxpbmRyaWNhbENvb3JkczogZnVuY3Rpb24gKCByYWRpdXMsIHRoZXRhLCB5ICkge1xuXG5cdFx0dGhpcy54ID0gcmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbU1hdHJpeFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAxMiBdO1xuXHRcdHRoaXMueSA9IGVbIDEzIF07XG5cdFx0dGhpcy56ID0gZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbU1hdHJpeFNjYWxlOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgc3ggPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcblx0XHR2YXIgc3kgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcblx0XHR2YXIgc3ogPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcblxuXHRcdHRoaXMueCA9IHN4O1xuXHRcdHRoaXMueSA9IHN5O1xuXHRcdHRoaXMueiA9IHN6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiAoIG0sIGluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZnJvbUFycmF5KCBtLmVsZW1lbnRzLCBpbmRleCAqIDQgKTtcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgKTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9LFxuXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59ICk7XG5cblxuZXhwb3J0IHsgVmVjdG9yMyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQnKTtcblxuV2ViU29ja2V0LmNyZWF0ZVdlYlNvY2tldFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3N0cmVhbScpO1xuV2ViU29ja2V0LlNlcnZlciA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXInKTtcbldlYlNvY2tldC5SZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3JlY2VpdmVyJyk7XG5XZWJTb2NrZXQuU2VuZGVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgYnVmZmVycyBpbnRvIGEgbmV3IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBhcnJheSBvZiBidWZmZXJzIHRvIGNvbmNhdFxuICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoIFRoZSB0b3RhbCBsZW5ndGggb2YgYnVmZmVycyBpbiB0aGUgbGlzdFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgcmVzdWx0aW5nIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjb25jYXQobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHJldHVybiBsaXN0WzBdO1xuXG4gIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJ1ZiA9IGxpc3RbaV07XG4gICAgdGFyZ2V0LnNldChidWYsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGJ1Zi5sZW5ndGg7XG4gIH1cblxuICBpZiAob2Zmc2V0IDwgdG90YWxMZW5ndGgpIHJldHVybiB0YXJnZXQuc2xpY2UoMCwgb2Zmc2V0KTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIE1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBzb3VyY2UgVGhlIGJ1ZmZlciB0byBtYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBvdXRwdXQgVGhlIGJ1ZmZlciB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgd3JpdGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIG1hc2suXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0W29mZnNldCArIGldID0gc291cmNlW2ldIF4gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBVbm1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byB1bm1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfdW5tYXNrKGJ1ZmZlciwgbWFzaykge1xuICAvLyBSZXF1aXJlZCB1bnRpbCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzkwMDYgaXMgcmVzb2x2ZWQuXG4gIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBidWZmZXJbaV0gXj0gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhbiBgQXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gQ29udmVydGVkIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ1Zikge1xuICBpZiAoYnVmLmJ5dGVMZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBkYXRhYCB0byBhIGBCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBidWZmZXJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9CdWZmZXIoZGF0YSkge1xuICB0b0J1ZmZlci5yZWFkT25seSA9IHRydWU7XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgcmV0dXJuIGRhdGE7XG5cbiAgbGV0IGJ1ZjtcblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICB0b0J1ZmZlci5yZWFkT25seSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn1cblxudHJ5IHtcbiAgY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJ2J1ZmZlcnV0aWwnKTtcbiAgY29uc3QgYnUgPSBidWZmZXJVdGlsLkJ1ZmZlclV0aWwgfHwgYnVmZmVyVXRpbDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25jYXQsXG4gICAgbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPCA0OCkgX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGVsc2UgYnUubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH0sXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgICBlbHNlIGJ1LnVubWFzayhidWZmZXIsIG1hc2spO1xuICAgIH1cbiAgfTtcbn0gY2F0Y2ggKGUpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29uY2F0LFxuICAgIG1hc2s6IF9tYXNrLFxuICAgIHRvQXJyYXlCdWZmZXIsXG4gICAgdG9CdWZmZXIsXG4gICAgdW5tYXNrOiBfdW5tYXNrXG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCSU5BUllfVFlQRVM6IFsnbm9kZWJ1ZmZlcicsICdhcnJheWJ1ZmZlcicsICdmcmFnbWVudHMnXSxcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXG4gIGtTdGF0dXNDb2RlOiBTeW1ib2woJ3N0YXR1cy1jb2RlJyksXG4gIGtXZWJTb2NrZXQ6IFN5bWJvbCgnd2Vic29ja2V0JyksXG4gIEVNUFRZX0JVRkZFUjogQnVmZmVyLmFsbG9jKDApLFxuICBOT09QOiAoKSA9PiB7fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgcmVjZWl2ZWQgZGF0YVxuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhLCB0YXJnZXQpIHtcbiAgICBzdXBlcignbWVzc2FnZScsIHRhcmdldCk7XG5cbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2xvc2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENsb3NlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgYmVpbmcgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb24gQSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2RlLCByZWFzb24sIHRhcmdldCkge1xuICAgIHN1cGVyKCdjbG9zZScsIHRhcmdldCk7XG5cbiAgICB0aGlzLndhc0NsZWFuID0gdGFyZ2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGFyZ2V0Ll9jbG9zZUZyYW1lU2VudDtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIG9wZW4gZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIE9wZW5FdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgT3BlbkV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXMgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgc3VwZXIoJ29wZW4nLCB0YXJnZXQpO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFcnJvckV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yIFRoZSBlcnJvciB0aGF0IGdlbmVyYXRlZCB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7V2ViU29ja2V0fSB0YXJnZXQgQSByZWZlcmVuY2UgdG8gdGhlIHRhcmdldCB0byB3aGljaCB0aGUgZXZlbnQgd2FzIGRpc3BhdGNoZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVycm9yLCB0YXJnZXQpIHtcbiAgICBzdXBlcignZXJyb3InLCB0YXJnZXQpO1xuXG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcbiAgICogICAgIHRoZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMub25jZSBBIGBCb29sZWFuYGAgaW5kaWNhdGluZyB0aGF0IHRoZSBsaXN0ZW5lclxuICAgKiAgICAgc2hvdWxkIGJlIGludm9rZWQgYXQgbW9zdCBvbmNlIGFmdGVyIGJlaW5nIGFkZGVkLiBJZiBgdHJ1ZWAsIHRoZVxuICAgKiAgICAgbGlzdGVuZXIgd291bGQgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIHdoZW4gaW52b2tlZC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIG5ldyBNZXNzYWdlRXZlbnQoZGF0YSwgdGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgQ2xvc2VFdmVudChjb2RlLCBtZXNzYWdlLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgRXJyb3JFdmVudChlcnJvciwgdGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgbmV3IE9wZW5FdmVudCh0aGlzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0aG9kID0gb3B0aW9ucyAmJiBvcHRpb25zLm9uY2UgPyAnb25jZScgOiAnb24nO1xuXG4gICAgaWYgKHR5cGUgPT09ICdtZXNzYWdlJykge1xuICAgICAgb25NZXNzYWdlLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpc1ttZXRob2RdKHR5cGUsIG9uTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2xvc2UnKSB7XG4gICAgICBvbkNsb3NlLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpc1ttZXRob2RdKHR5cGUsIG9uQ2xvc2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgb25FcnJvci5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXNbbWV0aG9kXSh0eXBlLCBvbkVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgb25PcGVuLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpc1ttZXRob2RdKHR5cGUsIG9uT3Blbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbWV0aG9kXSh0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnModHlwZSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdGVuZXJzW2ldLl9saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy9cbi8vIEFsbG93ZWQgdG9rZW4gY2hhcmFjdGVyczpcbi8vXG4vLyAnIScsICcjJywgJyQnLCAnJScsICcmJywgJycnLCAnKicsICcrJywgJy0nLFxuLy8gJy4nLCAwLTksIEEtWiwgJ14nLCAnXycsICdgJywgYS16LCAnfCcsICd+J1xuLy9cbi8vIHRva2VuQ2hhcnNbMzJdID09PSAwIC8vICcgJ1xuLy8gdG9rZW5DaGFyc1szM10gPT09IDEgLy8gJyEnXG4vLyB0b2tlbkNoYXJzWzM0XSA9PT0gMCAvLyAnXCInXG4vLyAuLi5cbi8vXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHRva2VuQ2hhcnMgPSBbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAgLSAxNVxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXG4gIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDAsIC8vIDMyIC0gNDdcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gNDggLSA2M1xuICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIC8vIDgwIC0gOTVcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gOTYgLSAxMTFcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcbl07XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBpZiAoaGVhZGVyID09PSB1bmRlZmluZWQgfHwgaGVhZGVyID09PSAnJykgcmV0dXJuIG9mZmVycztcblxuICBsZXQgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG11c3RVbmVzY2FwZSA9IGZhbHNlO1xuICBsZXQgaXNFc2NhcGluZyA9IGZhbHNlO1xuICBsZXQgaW5RdW90ZXMgPSBmYWxzZTtcbiAgbGV0IGV4dGVuc2lvbk5hbWU7XG4gIGxldCBwYXJhbU5hbWU7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKDsgaSA8IGhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5IC8qICdcXHQnICovKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiAvKiAnOycgKi8gfHwgY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBwdXNoKHBhcmFtcywgaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNkIC8qICc9JyAqLyAmJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xuICAgICAgICBwYXJhbU5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgdmFsdWUgb2YgYSBxdW90ZWQtc3RyaW5nIGFmdGVyIHVuZXNjYXBpbmcgbXVzdCBjb25mb3JtIHRvIHRoZVxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICAgIC8vXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZSBpZiAoIW11c3RVbmVzY2FwZSkgbXVzdFVuZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyIC8qICdcIicgKi8gJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NWMgLyogJ1xcJyAqLykge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSAweDNkKSB7XG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgIT09IC0xICYmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgaW5RdW90ZXMpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xuY29uc3Qga1J1biA9IFN5bWJvbCgna1J1bicpO1xuXG4vKipcbiAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU1RSTUwvYXN5bmMtbGltaXRlclxuICovXG5jbGFzcyBMaW1pdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uY3VycmVuY3kgVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZCB0byBydW5cbiAgICogICAgIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZChqb2IpIHtcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xuICAgIHRoaXNba1J1bl0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW2tSdW5dKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcgPT09IHRoaXMuY29uY3VycmVuY3kpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBqb2IgPSB0aGlzLmpvYnMuc2hpZnQoKTtcblxuICAgICAgdGhpcy5wZW5kaW5nKys7XG4gICAgICBqb2IodGhpc1trRG9uZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnLi9saW1pdGVyJyk7XG5jb25zdCB7IGtTdGF0dXNDb2RlLCBOT09QIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKTtcbmNvbnN0IGtQZXJNZXNzYWdlRGVmbGF0ZSA9IFN5bWJvbCgncGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xuY29uc3Qga0J1ZmZlcnMgPSBTeW1ib2woJ2J1ZmZlcnMnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcblxuLy9cbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxuLy8gYXMgZG9jdW1lbnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg4NzEjaXNzdWVjb21tZW50LTI1MDkxNTkxM1xuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xMjAyXG4vL1xuLy8gSW50ZW50aW9uYWxseSBnbG9iYWw7IGl0J3MgdGhlIGdsb2JhbCB0aHJlYWQgcG9vbCB0aGF0J3MgYW4gaXNzdWUuXG4vL1xubGV0IHpsaWJMaW1pdGVyO1xuXG4vKipcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyIFJlcXVlc3QvYWNjZXB0IGRpc2FibGluZ1xuICAgKiAgICAgb2Ygc2VydmVyIGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyIEFkdmVydGlzZS9hY2tub3dsZWRnZVxuICAgKiAgICAgZGlzYWJsaW5nIG9mIGNsaWVudCBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzIFJlcXVlc3QvY29uZmlybSB0aGVcbiAgICogICAgIHVzZSBvZiBhIGN1c3RvbSBzZXJ2ZXIgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgQWR2ZXJ0aXNlIHN1cHBvcnRcbiAgICogICAgIGZvciwgb3IgcmVxdWVzdCwgYSBjdXN0b20gY2xpZW50IHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvbiBkZWZsYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvbiBpbmZsYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnRocmVzaG9sZCBTaXplIChpbiBieXRlcykgYmVsb3cgd2hpY2ggbWVzc2FnZXNcbiAgICogICAgIHNob3VsZCBub3QgYmUgY29tcHJlc3NlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0IFRoZSBudW1iZXIgb2YgY29uY3VycmVudCBjYWxscyB0b1xuICAgKiAgICAgemxpYlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzU2VydmVyIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvciBjbGllbnRcbiAgICogICAgIG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFBheWxvYWQgVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaXNTZXJ2ZXIsIG1heFBheWxvYWQpIHtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fdGhyZXNob2xkID1cbiAgICAgIHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xuICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuXG4gICAgaWYgKCF6bGliTGltaXRlcikge1xuICAgICAgY29uc3QgY29uY3VycmVuY3kgPVxuICAgICAgICB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0XG4gICAgICAgICAgOiAxMDtcbiAgICAgIHpsaWJMaW1pdGVyID0gbmV3IExpbWl0ZXIoY29uY3VycmVuY3kpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBleHRlbnNpb25OYW1lKCkge1xuICAgIHJldHVybiAncGVybWVzc2FnZS1kZWZsYXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG9mZmVyKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT0gbnVsbCkge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci9yZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWNjZXB0KGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucyk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMuX2lzU2VydmVyXG4gICAgICA/IHRoaXMuYWNjZXB0QXNTZXJ2ZXIoY29uZmlndXJhdGlvbnMpXG4gICAgICA6IHRoaXMuYWNjZXB0QXNDbGllbnQoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXMucGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFsbCByZXNvdXJjZXMgdXNlZCBieSB0aGUgZXh0ZW5zaW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLl9pbmZsYXRlKSB7XG4gICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZCdcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvZmZlcnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc1NlcnZlcihvZmZlcnMpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCBhY2NlcHRlZCA9IG9mZmVycy5maW5kKChwYXJhbXMpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyKSB8fFxuICAgICAgICAocGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgJiZcbiAgICAgICAgICAob3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA+IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzKSkpIHx8XG4gICAgICAgICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFhY2NlcHRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIHRoZSBleHRlbnNpb24gb2ZmZXJzIGNhbiBiZSBhY2NlcHRlZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IG9wdHMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID09PSB0cnVlIHx8XG4gICAgICBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlXG4gICAgKSB7XG4gICAgICBkZWxldGUgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cztcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjZXB0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IHRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3BvbnNlIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc0NsaWVudChyZXNwb25zZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJlc3BvbnNlWzBdO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhcmFtZXRlciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA+IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgb3IgaW52YWxpZCBwYXJhbWV0ZXIgXCJjbGllbnRfbWF4X3dpbmRvd19iaXRzXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvZmZlcnMvcmVzcG9uc2Ugd2l0aCBub3JtYWxpemVkIHBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zLmZvckVhY2goKHBhcmFtcykgPT4ge1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGllbnRfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1NlcnZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcicgfHxcbiAgICAgICAgICBrZXkgPT09ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29uZmlndXJhdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9jb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG5cbiAgICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2luZmxhdGVba1Blck1lc3NhZ2VEZWZsYXRlXSA9IHRoaXM7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2Vycm9yJywgaW5mbGF0ZU9uRXJyb3IpO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2luZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcbiAgICBpZiAoZmluKSB0aGlzLl9pbmZsYXRlLndyaXRlKFRSQUlMRVIpO1xuXG4gICAgdGhpcy5faW5mbGF0ZS5mbHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl9pbmZsYXRlW2tFcnJvcl07XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ3NlcnZlcicgOiAnY2xpZW50JztcblxuICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgLy9cbiAgICAgIC8vIEFuIGAnZXJyb3InYCBldmVudCBpcyBlbWl0dGVkLCBvbmx5IG9uIE5vZGUuanMgPCAxMC4wLjAsIGlmIHRoZVxuICAgICAgLy8gYHpsaWIuRGVmbGF0ZVJhd2AgaW5zdGFuY2UgaXMgY2xvc2VkIHdoaWxlIGRhdGEgaXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgIGlzIGNhbGxlZCBhdCB0aGUgd3JvbmdcbiAgICAgIC8vIHRpbWUgZHVlIHRvIGFuIGFibm9ybWFsIFdlYlNvY2tldCBjbG9zdXJlLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2Vycm9yJywgTk9PUCk7XG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdkYXRhJywgZGVmbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xuICAgIHRoaXMuX2RlZmxhdGUuZmx1c2goemxpYi5aX1NZTkNfRkxVU0gsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbikgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSA0KTtcblxuICAgICAgLy9cbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW4gaW5cbiAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IG51bGw7XG5cbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZXJNZXNzYWdlRGVmbGF0ZTtcblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkRlZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcblxuICBpZiAoXG4gICAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkIDwgMSB8fFxuICAgIHRoaXNba1RvdGFsTGVuZ3RoXSA8PSB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWRcbiAgKSB7XG4gICAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpc1trRXJyb3JdID0gbmV3IFJhbmdlRXJyb3IoJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKTtcbiAgdGhpc1trRXJyb3JdW2tTdGF0dXNDb2RlXSA9IDEwMDk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgdGhpcy5yZXNldCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkVycm9yKGVycikge1xuICAvL1xuICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYFpsaWIjY2xvc2UoKWAgYXMgdGhlIGhhbmRsZSBpcyBhdXRvbWF0aWNhbGx5XG4gIC8vIGNsb3NlZCB3aGVuIGFuIGVycm9yIGlzIGVtaXR0ZWQuXG4gIC8vXG4gIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5faW5mbGF0ZSA9IG51bGw7XG4gIGVycltrU3RhdHVzQ29kZV0gPSAxMDA3O1xuICB0aGlzW2tDYWxsYmFja10oZXJyKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgY29uY2F0LCB0b0FycmF5QnVmZmVyLCB1bm1hc2sgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUsIGlzVmFsaWRVVEY4IH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3QgR0VUX0lORk8gPSAwO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzE2ID0gMTtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XG5jb25zdCBHRVRfTUFTSyA9IDM7XG5jb25zdCBHRVRfREFUQSA9IDQ7XG5jb25zdCBJTkZMQVRJTkcgPSA1O1xuXG4vKipcbiAqIEh5QmkgUmVjZWl2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgc3RyZWFtLldyaXRhYmxlXG4gKi9cbmNsYXNzIFJlY2VpdmVyIGV4dGVuZHMgV3JpdGFibGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlY2VpdmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYmluYXJ5VHlwZSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzU2VydmVyIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW4gY2xpZW50IG9yIHNlcnZlclxuICAgKiAgICAgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4UGF5bG9hZCBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihiaW5hcnlUeXBlLCBleHRlbnNpb25zLCBpc1NlcnZlciwgbWF4UGF5bG9hZCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhaXNTZXJ2ZXI7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fYnVmZmVycyA9IFtdO1xuXG4gICAgdGhpcy5fY29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21hc2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgdGhpcy5fbWFza2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZmluID0gZmFsc2U7XG4gICAgdGhpcy5fb3Bjb2RlID0gMDtcblxuICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGBXcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlKClgLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgVGhlIGNodW5rIG9mIGRhdGEgdG8gd3JpdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIFRoZSBjaGFyYWN0ZXIgZW5jb2Rpbmcgb2YgYGNodW5rYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKi9cbiAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3N0YXRlID09IEdFVF9JTkZPKSByZXR1cm4gY2IoKTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWVzIGBuYCBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGNvbnN1bWVcbiAgICogQHJldHVybiB7QnVmZmVyfSBUaGUgY29uc3VtZWQgYnl0ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN1bWUobikge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gbjtcblxuICAgIGlmIChuID09PSB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2J1ZmZlcnMuc2hpZnQoKTtcblxuICAgIGlmIChuIDwgdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICB0aGlzLl9idWZmZXJzWzBdID0gYnVmLnNsaWNlKG4pO1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwLCBuKTtcbiAgICB9XG5cbiAgICBjb25zdCBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG5cbiAgICBkbyB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XG5cbiAgICAgIGlmIChuID49IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgZHN0LnNldCh0aGlzLl9idWZmZXJzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkc3Quc2V0KG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IGJ1Zi5zbGljZShuKTtcbiAgICAgIH1cblxuICAgICAgbiAtPSBidWYubGVuZ3RoO1xuICAgIH0gd2hpbGUgKG4gPiAwKTtcblxuICAgIHJldHVybiBkc3Q7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBwYXJzaW5nIGxvb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydExvb3AoY2IpIHtcbiAgICBsZXQgZXJyO1xuICAgIHRoaXMuX2xvb3AgPSB0cnVlO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICBjYXNlIEdFVF9JTkZPOlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0SW5mbygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF8xNjpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldFBheWxvYWRMZW5ndGgxNigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldFBheWxvYWRMZW5ndGg2NCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9NQVNLOlxuICAgICAgICAgIHRoaXMuZ2V0TWFzaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9EQVRBOlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0RGF0YShjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gYElORkxBVElOR2BcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRoaXMuX2xvb3ApO1xuXG4gICAgY2IoZXJyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEluZm8oKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdSU1YyIGFuZCBSU1YzIG11c3QgYmUgY2xlYXInLCB0cnVlLCAxMDAyKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xuXG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnUlNWMSBtdXN0IGJlIGNsZWFyJywgdHJ1ZSwgMTAwMik7XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnUlNWMSBtdXN0IGJlIGNsZWFyJywgdHJ1ZSwgMTAwMik7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnaW52YWxpZCBvcGNvZGUgMCcsIHRydWUsIDEwMDIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcGNvZGUgPSB0aGlzLl9mcmFnbWVudGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsIHRydWUsIDEwMDIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcgJiYgdGhpcy5fb3Bjb2RlIDwgMHgwYikge1xuICAgICAgaWYgKCF0aGlzLl9maW4pIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ0ZJTiBtdXN0IGJlIHNldCcsIHRydWUsIDEwMDIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnUlNWMSBtdXN0IGJlIGNsZWFyJywgdHJ1ZSwgMTAwMik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID4gMHg3ZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsIHRydWUsIDEwMDIpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAweDgwKSA9PT0gMHg4MDtcblxuICAgIGlmICh0aGlzLl9pc1NlcnZlcikge1xuICAgICAgaWYgKCF0aGlzLl9tYXNrZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ01BU0sgbXVzdCBiZSBzZXQnLCB0cnVlLCAxMDAyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdNQVNLIG11c3QgYmUgY2xlYXInLCB0cnVlLCAxMDAyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2UgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrMTYpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoMTYoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMuY29uc3VtZSgyKS5yZWFkVUludDE2QkUoMCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrNjQpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDgpO1xuICAgIGNvbnN0IG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMCk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBtYXhpbXVtIHNhZmUgaW50ZWdlciBpbiBKYXZhU2NyaXB0IGlzIDJeNTMgLSAxLiBBbiBlcnJvciBpcyByZXR1cm5lZFxuICAgIC8vIGlmIHBheWxvYWQgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIG51bWJlci5cbiAgICAvL1xuICAgIGlmIChudW0gPiBNYXRoLnBvdygyLCA1MyAtIDMyKSAtIDEpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIFdlYlNvY2tldCBmcmFtZTogcGF5bG9hZCBsZW5ndGggPiAyXjUzIC0gMScsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAxMDA5XG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBudW0gKiBNYXRoLnBvdygyLCAzMikgKyBidWYucmVhZFVJbnQzMkJFKDQpO1xuICAgIHJldHVybiB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXlsb2FkIGxlbmd0aCBoYXMgYmVlbiByZWFkLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKCkge1xuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoICYmIHRoaXMuX29wY29kZSA8IDB4MDgpIHtcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArPSB0aGlzLl9wYXlsb2FkTGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLCBmYWxzZSwgMTAwOSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2tlZCkgdGhpcy5fc3RhdGUgPSBHRVRfTUFTSztcbiAgICBlbHNlIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgbWFzayBieXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1hc2soKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA0KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbWFzayA9IHRoaXMuY29uc3VtZSg0KTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGRhdGEgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERhdGEoY2IpIHtcbiAgICBsZXQgZGF0YSA9IEVNUFRZX0JVRkZFUjtcblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN1bWUodGhpcy5fcGF5bG9hZExlbmd0aCk7XG4gICAgICBpZiAodGhpcy5fbWFza2VkKSB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHJldHVybiB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEpO1xuXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmdodCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKFxuICAgICAgICAgICAgZXJyb3IoUmFuZ2VFcnJvciwgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLCBmYWxzZSwgMTAwOSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goYnVmKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXIgPSB0aGlzLmRhdGFNZXNzYWdlKCk7XG4gICAgICBpZiAoZXIpIHJldHVybiBjYihlcik7XG5cbiAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0YU1lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2Zpbikge1xuICAgICAgY29uc3QgbWVzc2FnZUxlbmd0aCA9IHRoaXMuX21lc3NhZ2VMZW5ndGg7XG4gICAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLl9mcmFnbWVudHM7XG5cbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDIpIHtcbiAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdub2RlYnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgZGF0YSA9IHRvQXJyYXlCdWZmZXIoY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoRXJyb3IsICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJywgdHJ1ZSwgMTAwNyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgY29udHJvbCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGhhbmRsZVxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb250cm9sTWVzc2FnZShkYXRhKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIDEwMDUsICcnKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdpbnZhbGlkIHBheWxvYWQgbGVuZ3RoIDEnLCB0cnVlLCAxMDAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBkYXRhLnJlYWRVSW50MTZCRSgwKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsIGBpbnZhbGlkIHN0YXR1cyBjb2RlICR7Y29kZX1gLCB0cnVlLCAxMDAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGEuc2xpY2UoMik7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKEVycm9yLCAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsIHRydWUsIDEwMDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIGNvZGUsIGJ1Zi50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOSkge1xuICAgICAgdGhpcy5lbWl0KCdwaW5nJywgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCgncG9uZycsIGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWNlaXZlcjtcblxuLyoqXG4gKiBCdWlsZHMgYW4gZXJyb3Igb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7KEVycm9yfFJhbmdlRXJyb3IpfSBFcnJvckN0b3IgVGhlIGVycm9yIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtCb29sZWFufSBwcmVmaXggU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGFkZCBhIGRlZmF1bHQgcHJlZml4IHRvXG4gKiAgICAgYG1lc3NhZ2VgXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzQ29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yKX0gVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSkge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxuICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICk7XG5cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBlcnJvcik7XG4gIGVycltrU3RhdHVzQ29kZV0gPSBzdGF0dXNDb2RlO1xuICByZXR1cm4gZXJyO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHJhbmRvbUZpbGxTeW5jIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgeyBFTVBUWV9CVUZGRVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGlzVmFsaWRTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcbmNvbnN0IHsgbWFzazogYXBwbHlNYXNrLCB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBtYXNrID0gQnVmZmVyLmFsbG9jKDQpO1xuXG4vKipcbiAqIEh5QmkgU2VuZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBTZW5kZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFNlbmRlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvY2tldCwgZXh0ZW5zaW9ucykge1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbXByZXNzID0gZmFsc2U7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9kZWZsYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhIHBpZWNlIG9mIGRhdGEgYWNjb3JkaW5nIHRvIHRoZSBIeUJpIFdlYlNvY2tldCBwcm90b2NvbC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgdG8gZnJhbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnJlYWRPbmx5IFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmUgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZSBGSU4gYml0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5tYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucnN2MSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZSBSU1YxIGJpdFxuICAgKiBAcmV0dXJuIHtCdWZmZXJbXX0gVGhlIGZyYW1lZCBkYXRhIGFzIGEgbGlzdCBvZiBgQnVmZmVyYCBpbnN0YW5jZXNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc3RhdGljIGZyYW1lKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZXJnZSA9IG9wdGlvbnMubWFzayAmJiBvcHRpb25zLnJlYWRPbmx5O1xuICAgIGxldCBvZmZzZXQgPSBvcHRpb25zLm1hc2sgPyA2IDogMjtcbiAgICBsZXQgcGF5bG9hZExlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDY1NTM2KSB7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XG4gICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCA+IDEyNSkge1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2O1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXJnZSA/IGRhdGEubGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0KTtcblxuICAgIHRhcmdldFswXSA9IG9wdGlvbnMuZmluID8gb3B0aW9ucy5vcGNvZGUgfCAweDgwIDogb3B0aW9ucy5vcGNvZGU7XG4gICAgaWYgKG9wdGlvbnMucnN2MSkgdGFyZ2V0WzBdIHw9IDB4NDA7XG5cbiAgICB0YXJnZXRbMV0gPSBwYXlsb2FkTGVuZ3RoO1xuXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDE2QkUoZGF0YS5sZW5ndGgsIDIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MzJCRSgwLCAyKTtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQzMkJFKGRhdGEubGVuZ3RoLCA2KTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMubWFzaykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuXG4gICAgcmFuZG9tRmlsbFN5bmMobWFzaywgMCwgNCk7XG5cbiAgICB0YXJnZXRbMV0gfD0gMHg4MDtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gNF0gPSBtYXNrWzBdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMV0gPSBtYXNrWzNdO1xuXG4gICAgaWYgKG1lcmdlKSB7XG4gICAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgdGFyZ2V0LCBvZmZzZXQsIGRhdGEubGVuZ3RoKTtcbiAgICAgIHJldHVybiBbdGFyZ2V0XTtcbiAgICB9XG5cbiAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgZGF0YSwgMCwgZGF0YS5sZW5ndGgpO1xuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7KE51bWJlcnx1bmRlZmluZWQpfSBjb2RlIFRoZSBzdGF0dXMgY29kZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgVGhlIG1lc3NhZ2UgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBidWY7XG5cbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWYgPSBFTVBUWV9CVUZGRVI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdmFsaWQgZXJyb3IgY29kZSBudW1iZXInKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCB8fCBkYXRhID09PSAnJykge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgbWVzc2FnZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTIzIGJ5dGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgbGVuZ3RoKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgICAgYnVmLndyaXRlKGRhdGEsIDIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kb0Nsb3NlLCBidWYsIG1hc2ssIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9DbG9zZShidWYsIG1hc2ssIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIGNsb3NlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZG9DbG9zZShkYXRhLCBtYXNrLCBjYikge1xuICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgICAgZmluOiB0cnVlLFxuICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgb3Bjb2RlOiAweDA4LFxuICAgICAgICBtYXNrLFxuICAgICAgICByZWFkT25seTogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgY2JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGluZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBjb25zdCBidWYgPSB0b0J1ZmZlcihkYXRhKTtcblxuICAgIGlmIChidWYubGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRvUGluZywgYnVmLCBtYXNrLCB0b0J1ZmZlci5yZWFkT25seSwgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb1BpbmcoYnVmLCBtYXNrLCB0b0J1ZmZlci5yZWFkT25seSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYW5kIHNlbmRzIGEgcGluZyBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVhZE9ubHkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZSBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZG9QaW5nKGRhdGEsIG1hc2ssIHJlYWRPbmx5LCBjYikge1xuICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgICAgZmluOiB0cnVlLFxuICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgb3Bjb2RlOiAweDA5LFxuICAgICAgICBtYXNrLFxuICAgICAgICByZWFkT25seVxuICAgICAgfSksXG4gICAgICBjYlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwb25nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGRhdGEpO1xuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9Qb25nLCBidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvUG9uZyhidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhbmQgc2VuZHMgYSBwb25nIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSByZWFkT25seSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkb1BvbmcoZGF0YSwgbWFzaywgcmVhZE9ubHksIGNiKSB7XG4gICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICBTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICBmaW46IHRydWUsXG4gICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICBvcGNvZGU6IDB4MGEsXG4gICAgICAgIG1hc2ssXG4gICAgICAgIHJlYWRPbmx5XG4gICAgICB9KSxcbiAgICAgIGNiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGRhdGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNvbXByZXNzIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmJpbmFyeSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZpbiBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5tYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgY29uc3QgYnVmID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcblxuICAgIGlmICh0aGlzLl9maXJzdEZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XG4gICAgICBpZiAocnN2MSAmJiBwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICByc3YxID0gYnVmLmxlbmd0aCA+PSBwZXJNZXNzYWdlRGVmbGF0ZS5fdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3YxID0gZmFsc2U7XG4gICAgICBvcGNvZGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZpbikgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG5cbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgIHJzdjEsXG4gICAgICAgIG9wY29kZSxcbiAgICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgICByZWFkT25seTogdG9CdWZmZXIucmVhZE9ubHlcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBidWYsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChidWYsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgICBTZW5kZXIuZnJhbWUoYnVmLCB7XG4gICAgICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgICBvcGNvZGUsXG4gICAgICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgICAgIHJlYWRPbmx5OiB0b0J1ZmZlci5yZWFkT25seVxuICAgICAgICB9KSxcbiAgICAgICAgY2JcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBjb21wcmVzcyBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yZWFkT25seSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5maW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnJzdjEgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHRoaXMuX2RlZmxhdGluZyA9IHRydWU7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoZXJyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9xdWV1ZVtpXVs0XTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHdoaWxlICghdGhpcy5fZGVmbGF0aW5nICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBwYXJhbXNbMV0ubGVuZ3RoO1xuICAgICAgUmVmbGVjdC5hcHBseShwYXJhbXNbMF0sIHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1sxXS5sZW5ndGg7XG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc29ja2V0LmNvcmsoKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgICB0aGlzLl9zb2NrZXQudW5jb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qKlxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmVhbS5EdXBsZXh9IFRoZSBzdHJlYW0uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVuZCgpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVycm9yKGVycikge1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd3MgVGhlIGBXZWJTb2NrZXRgIHRvIHdyYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgYER1cGxleGAgY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge3N0cmVhbS5EdXBsZXh9IFRoZSBkdXBsZXggc3RyZWFtXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldFN0cmVhbSh3cywgb3B0aW9ucykge1xuICBsZXQgcmVzdW1lT25SZWNlaXZlckRyYWluID0gdHJ1ZTtcblxuICBmdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gICAgaWYgKHJlc3VtZU9uUmVjZWl2ZXJEcmFpbikgd3MuX3NvY2tldC5yZXN1bWUoKTtcbiAgfVxuXG4gIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICB3cy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCdkcmFpbicpO1xuICAgICAgd3MuX3JlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd3MuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygnZHJhaW4nKTtcbiAgICB3cy5fcmVjZWl2ZXIub24oJ2RyYWluJywgcmVjZWl2ZXJPbkRyYWluKTtcbiAgfVxuXG4gIGNvbnN0IGR1cGxleCA9IG5ldyBEdXBsZXgoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgYXV0b0Rlc3Ryb3k6IGZhbHNlLFxuICAgIGVtaXRDbG9zZTogZmFsc2UsXG4gICAgb2JqZWN0TW9kZTogZmFsc2UsXG4gICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICB9KTtcblxuICB3cy5vbignbWVzc2FnZScsIGZ1bmN0aW9uIG1lc3NhZ2UobXNnKSB7XG4gICAgaWYgKCFkdXBsZXgucHVzaChtc2cpKSB7XG4gICAgICByZXN1bWVPblJlY2VpdmVyRHJhaW4gPSBmYWxzZTtcbiAgICAgIHdzLl9zb2NrZXQucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIGR1cGxleC5kZXN0cm95KGVycik7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIGR1cGxleC5wdXNoKG51bGwpO1xuICB9KTtcblxuICBkdXBsZXguX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgIH0pO1xuICAgIHdzLnRlcm1pbmF0ZSgpO1xuICB9O1xuXG4gIGR1cGxleC5fZmluYWwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIGBfc29ja2V0YCBwcm9wZXJ0eSBpcyBgbnVsbGAgaXQgbWVhbnMgdGhhdCBgd3NgIGlzIGFcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxuICAgIC8vIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSB3ZWJzb2NrZXQuXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBlbWl0dGVkIG9uIGBkdXBsZXhgIGFmdGVyIHRoaXMgYCdmaW5pc2gnYCBldmVudC4gVGhlIEVPRiBzaWduYWxpbmdcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLk9QRU4gJiYgIXJlc3VtZU9uUmVjZWl2ZXJEcmFpbikge1xuICAgICAgcmVzdW1lT25SZWNlaXZlckRyYWluID0gdHJ1ZTtcbiAgICAgIGlmICghd3MuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpbikgd3MuX3NvY2tldC5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cy5zZW5kKGNodW5rLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgZHVwbGV4Lm9uKCdlbmQnLCBkdXBsZXhPbkVuZCk7XG4gIGR1cGxleC5vbignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgcmV0dXJuIGR1cGxleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXZWJTb2NrZXRTdHJlYW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnRyeSB7XG4gIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICBleHBvcnRzLmlzVmFsaWRVVEY4ID1cbiAgICB0eXBlb2YgaXNWYWxpZFVURjggPT09ICdvYmplY3QnXG4gICAgICA/IGlzVmFsaWRVVEY4LlZhbGlkYXRpb24uaXNWYWxpZFVURjggLy8gdXRmLTgtdmFsaWRhdGVAPDMuMC4wXG4gICAgICA6IGlzVmFsaWRVVEY4O1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICBleHBvcnRzLmlzVmFsaWRVVEY4ID0gKCkgPT4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGF0dXMgY29kZSBpcyBhbGxvd2VkIGluIGEgY2xvc2UgZnJhbWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN0YXR1cyBjb2RlIGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5pc1ZhbGlkU3RhdHVzQ29kZSA9IChjb2RlKSA9PiB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxuICAgICAgY29kZSA8PSAxMDE0ICYmXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXG4gICAgICBjb2RlICE9PSAxMDA2KSB8fFxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxuICApO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCB7IGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBjcmVhdGVTZXJ2ZXIsIFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnaHR0cCcpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyBHVUlELCBrV2ViU29ja2V0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrZXlSZWdleCA9IC9eWysvMC05QS1aYS16XXsyMn09PSQvO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmJhY2tsb2cgVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZiBwZW5kaW5nXG4gICAqICAgICBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuY2xpZW50VHJhY2tpbmcgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHRyYWNrXG4gICAqICAgICBjbGllbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmhvc3QgVGhlIGhvc3RuYW1lIHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5tYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5ub1NlcnZlciBFbmFibGUgbm8gc2VydmVyIG1vZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucGF0aCBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucG9ydCBUaGUgcG9ydCB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtodHRwLlNlcnZlcn0gb3B0aW9ucy5zZXJ2ZXIgQSBwcmUtY3JlYXRlZCBIVFRQL1Mgc2VydmVyIHRvIHVzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnZlcmlmeUNsaWVudCBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgbGlzdGVuZXIgZm9yIHRoZSBgbGlzdGVuaW5nYCBldmVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ09uZSBvZiB0aGUgXCJwb3J0XCIsIFwic2VydmVyXCIsIG9yIFwibm9TZXJ2ZXJcIiBvcHRpb25zIG11c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGNyZWF0ZVNlcnZlcigocmVxLCByZXMpID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9IFNUQVRVU19DT0RFU1s0MjZdO1xuXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsICh3cykgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uJywgd3MsIHJlcSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID09PSB0cnVlKSBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50VHJhY2tpbmcpIHRoaXMuY2xpZW50cyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kIGFkZHJlc3MsIHRoZSBhZGRyZXNzIGZhbWlseSBuYW1lLCBhbmQgcG9ydCBvZiB0aGUgc2VydmVyXG4gICAqIGFzIHJlcG9ydGVkIGJ5IHRoZSBvcGVyYXRpbmcgc3lzdGVtIGlmIGxpc3RlbmluZyBvbiBhbiBJUCBzb2NrZXQuXG4gICAqIElmIHRoZSBzZXJ2ZXIgaXMgbGlzdGVuaW5nIG9uIGEgcGlwZSBvciBVTklYIGRvbWFpbiBzb2NrZXQsIHRoZSBuYW1lIGlzXG4gICAqIHJldHVybmVkIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoT2JqZWN0fFN0cmluZ3xudWxsKX0gVGhlIGFkZHJlc3Mgb2YgdGhlIHNlcnZlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRyZXNzKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBvcGVyYXRpbmcgaW4gXCJub1NlcnZlclwiIG1vZGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3NlcnZlcikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuX3NlcnZlci5hZGRyZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICAvL1xuICAgIC8vIFRlcm1pbmF0ZSBhbGwgYXNzb2NpYXRlZCBjbGllbnRzLlxuICAgIC8vXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpcy5jbGllbnRzKSBjbGllbnQudGVybWluYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgaWYgKHNlcnZlcikge1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gQ2xvc2UgdGhlIGh0dHAgc2VydmVyIGlmIGl0IHdhcyBpbnRlcm5hbGx5IGNyZWF0ZWQuXG4gICAgICAvL1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHRoaXMuZW1pdCgnY2xvc2UnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogU2VlIGlmIGEgZ2l2ZW4gcmVxdWVzdCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGlzIHNlcnZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFJlcXVlc3Qgb2JqZWN0IHRvIGluc3BlY3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSByZXF1ZXN0IGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2hvdWxkSGFuZGxlKHJlcSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGF0aCkge1xuICAgICAgY29uc3QgaW5kZXggPSByZXEudXJsLmluZGV4T2YoJz8nKTtcbiAgICAgIGNvbnN0IHBhdGhuYW1lID0gaW5kZXggIT09IC0xID8gcmVxLnVybC5zbGljZSgwLCBpbmRleCkgOiByZXEudXJsO1xuXG4gICAgICBpZiAocGF0aG5hbWUgIT09IHRoaXMub3B0aW9ucy5wYXRoKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgSFRUUCBVcGdyYWRlIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIGNvbnN0IGtleSA9XG4gICAgICByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10udHJpbSgpXG4gICAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgdmVyc2lvbiA9ICtyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgcmVxLm1ldGhvZCAhPT0gJ0dFVCcgfHxcbiAgICAgIHJlcS5oZWFkZXJzLnVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcgfHxcbiAgICAgICFrZXkgfHxcbiAgICAgICFrZXlSZWdleC50ZXN0KGtleSkgfHxcbiAgICAgICh2ZXJzaW9uICE9PSA4ICYmIHZlcnNpb24gIT09IDEzKSB8fFxuICAgICAgIXRoaXMuc2hvdWxkSGFuZGxlKHJlcSlcbiAgICApIHtcbiAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdGhpcy5vcHRpb25zLm1heFBheWxvYWRcbiAgICAgICk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9mZmVycyA9IHBhcnNlKHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXSk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5jb25uZWN0aW9uLmF1dGhvcml6ZWQgfHwgcmVxLmNvbm5lY3Rpb24uZW5jcnlwdGVkKSxcbiAgICAgICAgcmVxXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvLCAodmVyaWZpZWQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpID0+IHtcbiAgICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlIHx8IDQwMSwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoa2V5LCBleHRlbnNpb25zLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoa2V5LCBleHRlbnNpb25zLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZ3JhZGUgdGhlIGNvbm5lY3Rpb24gdG8gV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSB2YWx1ZSBvZiB0aGUgYFNlYy1XZWJTb2NrZXQtS2V5YCBoZWFkZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSBzb2NrZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbXBsZXRlVXBncmFkZShrZXksIGV4dGVuc2lvbnMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lICcgK1xuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBjb25zdCBoZWFkZXJzID0gW1xuICAgICAgJ0hUVFAvMS4xIDEwMSBTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcbiAgICAgICdVcGdyYWRlOiB3ZWJzb2NrZXQnLFxuICAgICAgJ0Nvbm5lY3Rpb246IFVwZ3JhZGUnLFxuICAgICAgYFNlYy1XZWJTb2NrZXQtQWNjZXB0OiAke2RpZ2VzdH1gXG4gICAgXTtcblxuICAgIGNvbnN0IHdzID0gbmV3IFdlYlNvY2tldChudWxsKTtcbiAgICBsZXQgcHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuXG4gICAgaWYgKHByb3RvY29sKSB7XG4gICAgICBwcm90b2NvbCA9IHByb3RvY29sLnRyaW0oKS5zcGxpdCgvICosICovKTtcblxuICAgICAgLy9cbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAgIC8vXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scykge1xuICAgICAgICBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMocHJvdG9jb2wsIHJlcSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm90b2NvbCA9IHByb3RvY29sWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LVByb3RvY29sOiAke3Byb3RvY29sfWApO1xuICAgICAgICB3cy5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0KHtcbiAgICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBbcGFyYW1zXVxuICAgICAgfSk7XG4gICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcbiAgICAgIHdzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IGV4dGVybmFsIG1vZGlmaWNhdGlvbi9pbnNwZWN0aW9uIG9mIGhhbmRzaGFrZSBoZWFkZXJzLlxuICAgIC8vXG4gICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgaGVhZGVycywgcmVxKTtcblxuICAgIHNvY2tldC53cml0ZShoZWFkZXJzLmNvbmNhdCgnXFxyXFxuJykuam9pbignXFxyXFxuJykpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHdzLnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkKTtcblxuICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgIHRoaXMuY2xpZW50cy5hZGQod3MpO1xuICAgICAgd3Mub24oJ2Nsb3NlJywgKCkgPT4gdGhpcy5jbGllbnRzLmRlbGV0ZSh3cykpO1xuICAgIH1cblxuICAgIGNiKHdzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXJzIHdoZW4gY2FsbGVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnMoc2VydmVyLCBtYXApIHtcbiAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyhtYXApKSBzZXJ2ZXIub24oZXZlbnQsIG1hcFtldmVudF0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyhtYXApKSB7XG4gICAgICBzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIG1hcFtldmVudF0pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBFbWl0IGEgYCdjbG9zZSdgIGV2ZW50IG9uIGFuIGBFdmVudEVtaXR0ZXJgLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRDbG9zZShzZXJ2ZXIpIHtcbiAgc2VydmVyLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbi8qKlxuICogSGFuZGxlIHByZW1hdHVyZSBzb2NrZXQgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIHRoaXMuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cbiAqXG4gKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICBpZiAoc29ja2V0LndyaXRhYmxlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgU1RBVFVTX0NPREVTW2NvZGVdO1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBDb25uZWN0aW9uOiAnY2xvc2UnLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnLFxuICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogQnVmZmVyLmJ5dGVMZW5ndGgobWVzc2FnZSksXG4gICAgICAuLi5oZWFkZXJzXG4gICAgfTtcblxuICAgIHNvY2tldC53cml0ZShcbiAgICAgIGBIVFRQLzEuMSAke2NvZGV9ICR7U1RBVFVTX0NPREVTW2NvZGVdfVxcclxcbmAgK1xuICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgICAuam9pbignXFxyXFxuJykgK1xuICAgICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICAgIG1lc3NhZ2VcbiAgICApO1xuICB9XG5cbiAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICBzb2NrZXQuZGVzdHJveSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21CeXRlcywgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xuY29uc3QgU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIEdVSUQsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0LFxuICBOT09QXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9ldmVudC10YXJnZXQnKTtcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IHsgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBXZWJTb2NrZXRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8dXJsLlVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xTdHJpbmdbXSl9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgIHRoaXMucHJvdG9jb2wgPSAnJztcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZU1lc3NhZ2UgPSAnJztcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICAgIHByb3RvY29scyA9IHByb3RvY29scy5qb2luKCcsICcpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHByb3RvY29scztcbiAgICAgICAgcHJvdG9jb2xzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQodGhpcywgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBDT05ORUNUSU5HKCkge1xuICAgIHJldHVybiBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgfVxuICBnZXQgQ0xPU0lORygpIHtcbiAgICByZXR1cm4gV2ViU29ja2V0LkNMT1NJTkc7XG4gIH1cbiAgZ2V0IENMT1NFRCgpIHtcbiAgICByZXR1cm4gV2ViU29ja2V0LkNMT1NFRDtcbiAgfVxuICBnZXQgT1BFTigpIHtcbiAgICByZXR1cm4gV2ViU29ja2V0Lk9QRU47XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBkZXZpYXRlcyBmcm9tIHRoZSBXSEFUV0cgaW50ZXJmYWNlIHNpbmNlIHdzIGRvZXNuJ3Qgc3VwcG9ydCB0aGVcbiAgICogcmVxdWlyZWQgZGVmYXVsdCBcImJsb2JcIiB0eXBlIChpbnN0ZWFkIHdlIGRlZmluZSBhIGN1c3RvbSBcIm5vZGVidWZmZXJcIlxuICAgKiB0eXBlKS5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBiaW5hcnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xuXG4gICAgLy9cbiAgICAvLyBgc29ja2V0LmJ1ZmZlclNpemVgIGlzIGB1bmRlZmluZWRgIGlmIHRoZSBzb2NrZXQgaXMgY2xvc2VkLlxuICAgIC8vXG4gICAgcmV0dXJuICh0aGlzLl9zb2NrZXQuYnVmZmVyU2l6ZSB8fCAwKSArIHRoaXMuX3NlbmRlci5fYnVmZmVyZWRCeXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGV4dGVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2V4dGVuc2lvbnMpLmpvaW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIHNvY2tldCBhbmQgdGhlIGludGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4UGF5bG9hZCBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgbWF4UGF5bG9hZCkge1xuICAgIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKFxuICAgICAgdGhpcy5fYmluYXJ5VHlwZSxcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnMsXG4gICAgICB0aGlzLl9pc1NlcnZlcixcbiAgICAgIG1heFBheWxvYWRcbiAgICApO1xuXG4gICAgdGhpcy5fc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMpO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlci5vbigncGluZycsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuICAgIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIHNvY2tldC5zZXROb0RlbGF5KCk7XG5cbiAgICBpZiAoaGVhZC5sZW5ndGggPiAwKSBzb2NrZXQudW5zaGlmdChoZWFkKTtcblxuICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgICBzb2NrZXQub24oJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgdGhlIGAnY2xvc2UnYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRDbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgKlxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXG4gICAqICAgICAtIC0gLXx3cy5jbG9zZSgpfC0tPnxjbG9zZSBmcmFtZXwtLT58d3MuY2xvc2UoKXwtIC0gLVxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XG4gICAqIENMT1NJTkcgIHx3cy5jbG9zZSgpfDwtLXxjbG9zZSBmcmFtZXw8LS0rLS0tLS0rICAgICAgIENMT1NJTkdcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcbiAgICogICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tPnxmaW58IC0gLSAtIC1cbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xuICAgKiAgICAgLSAtIC0gLSAtfGZpbnw8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgKy0tLStcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgU3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBBIHN0cmluZyBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcpIHtcbiAgICAgIGlmICh0aGlzLl9jbG9zZUZyYW1lU2VudCAmJiB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQpIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLl9zZW5kZXIuY2xvc2UoY29kZSwgZGF0YSwgIXRoaXMuX2lzU2VydmVyLCAoZXJyKSA9PiB7XG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyBoYW5kbGVkIGJ5IHRoZSBgJ2Vycm9yJ2AgbGlzdGVuZXIgb24gdGhlIHNvY2tldC4gV2Ugb25seVxuICAgICAgLy8gd2FudCB0byBrbm93IGlmIHRoZSBjbG9zZSBmcmFtZSBoYXMgYmVlbiBzZW50IGhlcmUuXG4gICAgICAvL1xuICAgICAgaWYgKGVycikgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkKSB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgfSk7XG5cbiAgICAvL1xuICAgIC8vIFNwZWNpZnkgYSB0aW1lb3V0IGZvciB0aGUgY2xvc2luZyBoYW5kc2hha2UgdG8gY29tcGxldGUuXG4gICAgLy9cbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gc2V0VGltZW91dChcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95LmJpbmQodGhpcy5fc29ja2V0KSxcbiAgICAgIGNsb3NlVGltZW91dFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuY29tcHJlc3MgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmJpbmFyeSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZpbiBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5tYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIGRhdGEgaXMgd3JpdHRlbiBvdXRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBiaW5hcnk6IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyxcbiAgICAgIG1hc2s6ICF0aGlzLl9pc1NlcnZlcixcbiAgICAgIGNvbXByZXNzOiB0cnVlLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZW5kZXIuc2VuZChkYXRhIHx8IEVNUFRZX0JVRkZFUiwgb3B0cywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNpYmx5IGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cblxucmVhZHlTdGF0ZXMuZm9yRWFjaCgocmVhZHlTdGF0ZSwgaSkgPT4ge1xuICBXZWJTb2NrZXRbcmVhZHlTdGF0ZV0gPSBpO1xufSk7XG5cbi8vXG4vLyBBZGQgdGhlIGBvbm9wZW5gLCBgb25lcnJvcmAsIGBvbmNsb3NlYCwgYW5kIGBvbm1lc3NhZ2VgIGF0dHJpYnV0ZXMuXG4vLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuLy9cblsnb3BlbicsICdlcnJvcicsICdjbG9zZScsICdtZXNzYWdlJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBsaXN0ZW5lciBvZiB0aGUgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsoRnVuY3Rpb258dW5kZWZpbmVkKX0gVGhlIGV2ZW50IGxpc3RlbmVyIG9yIGB1bmRlZmluZWRgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKG1ldGhvZCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldLl9saXN0ZW5lcikgcmV0dXJuIGxpc3RlbmVyc1tpXS5fbGlzdGVuZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXQobGlzdGVuZXIpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKG1ldGhvZCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvL1xuICAgICAgICAvLyBSZW1vdmUgb25seSB0aGUgbGlzdGVuZXJzIGFkZGVkIHZpYSBgYWRkRXZlbnRMaXN0ZW5lcmAuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyKSB0aGlzLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbldlYlNvY2tldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5XZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgV2ViU29ja2V0IGNsaWVudC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBjbGllbnQgdG8gaW5pdGlhbGl6ZVxuICogQHBhcmFtIHsoU3RyaW5nfHVybC5VUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSBFbmFibGUvZGlzYWJsZVxuICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuaGFuZHNoYWtlVGltZW91dCBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlXG4gKiAgICAgaGFuZHNoYWtlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnByb3RvY29sVmVyc2lvbiBWYWx1ZSBvZiB0aGUgYFNlYy1XZWJTb2NrZXQtVmVyc2lvbmBcbiAqICAgICBoZWFkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLm9yaWdpbiBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3JcbiAqICAgICBgU2VjLVdlYlNvY2tldC1PcmlnaW5gIGhlYWRlclxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWF4UGF5bG9hZCBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZvbGxvd1JlZGlyZWN0cyBXaGV0aGVyIG9yIG5vdCB0byBmb2xsb3cgcmVkaXJlY3RzXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5tYXhSZWRpcmVjdHMgVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlZGlyZWN0cyBhbGxvd2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBwcm90b2NvbFZlcnNpb246IHByb3RvY29sVmVyc2lvbnNbMV0sXG4gICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXG4gICAgZm9sbG93UmVkaXJlY3RzOiBmYWxzZSxcbiAgICBtYXhSZWRpcmVjdHM6IDEwLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgY3JlYXRlQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogdW5kZWZpbmVkLFxuICAgIGhvc3Q6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgcG9ydDogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKCFwcm90b2NvbFZlcnNpb25zLmluY2x1ZGVzKG9wdHMucHJvdG9jb2xWZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgYFVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7b3B0cy5wcm90b2NvbFZlcnNpb259IGAgK1xuICAgICAgICBgKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oJywgJyl9KWBcbiAgICApO1xuICB9XG5cbiAgbGV0IHBhcnNlZFVybDtcblxuICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHBhcnNlZFVybCA9IGFkZHJlc3M7XG4gICAgd2Vic29ja2V0LnVybCA9IGFkZHJlc3MuaHJlZjtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZWRVcmwgPSBuZXcgVVJMKGFkZHJlc3MpO1xuICAgIHdlYnNvY2tldC51cmwgPSBhZGRyZXNzO1xuICB9XG5cbiAgY29uc3QgaXNVbml4U29ja2V0ID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xuXG4gIGlmICghcGFyc2VkVXJsLmhvc3QgJiYgKCFpc1VuaXhTb2NrZXQgfHwgIXBhcnNlZFVybC5wYXRobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVVJMOiAke3dlYnNvY2tldC51cmx9YCk7XG4gIH1cblxuICBjb25zdCBpc1NlY3VyZSA9XG4gICAgcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOicgfHwgcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgY29uc3QgZGVmYXVsdFBvcnQgPSBpc1NlY3VyZSA/IDQ0MyA6IDgwO1xuICBjb25zdCBrZXkgPSByYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICBjb25zdCBnZXQgPSBpc1NlY3VyZSA/IGh0dHBzLmdldCA6IGh0dHAuZ2V0O1xuICBsZXQgcGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID0gaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdDtcbiAgb3B0cy5kZWZhdWx0UG9ydCA9IG9wdHMuZGVmYXVsdFBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMucG9ydCA9IHBhcnNlZFVybC5wb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLmhvc3QgPSBwYXJzZWRVcmwuaG9zdG5hbWUuc3RhcnRzV2l0aCgnWycpXG4gICAgPyBwYXJzZWRVcmwuaG9zdG5hbWUuc2xpY2UoMSwgLTEpXG4gICAgOiBwYXJzZWRVcmwuaG9zdG5hbWU7XG4gIG9wdHMuaGVhZGVycyA9IHtcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXG4gICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxuICAgIENvbm5lY3Rpb246ICdVcGdyYWRlJyxcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0JyxcbiAgICAuLi5vcHRzLmhlYWRlcnNcbiAgfTtcbiAgb3B0cy5wYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lICsgcGFyc2VkVXJsLnNlYXJjaDtcbiAgb3B0cy50aW1lb3V0ID0gb3B0cy5oYW5kc2hha2VUaW1lb3V0O1xuXG4gIGlmIChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlICE9PSB0cnVlID8gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA6IHt9LFxuICAgICAgZmFsc2UsXG4gICAgICBvcHRzLm1heFBheWxvYWRcbiAgICApO1xuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJ10gPSBmb3JtYXQoe1xuICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBwZXJNZXNzYWdlRGVmbGF0ZS5vZmZlcigpXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb3RvY29scykge1xuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1Qcm90b2NvbCddID0gcHJvdG9jb2xzO1xuICB9XG4gIGlmIChvcHRzLm9yaWdpbikge1xuICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSBvcHRzLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgIG9wdHMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgfVxuXG4gIGlmIChpc1VuaXhTb2NrZXQpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG9wdHMucGF0aC5zcGxpdCgnOicpO1xuXG4gICAgb3B0cy5zb2NrZXRQYXRoID0gcGFydHNbMF07XG4gICAgb3B0cy5wYXRoID0gcGFydHNbMV07XG4gIH1cblxuICBsZXQgcmVxID0gKHdlYnNvY2tldC5fcmVxID0gZ2V0KG9wdHMpKTtcblxuICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgcmVxLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdPcGVuaW5nIGhhbmRzaGFrZSBoYXMgdGltZWQgb3V0Jyk7XG4gICAgfSk7XG4gIH1cblxuICByZXEub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgIGlmICh3ZWJzb2NrZXQuX3JlcS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG4gICAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbiAgfSk7XG5cbiAgcmVxLm9uKCdyZXNwb25zZScsIChyZXMpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmxvY2F0aW9uO1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcblxuICAgIGlmIChcbiAgICAgIGxvY2F0aW9uICYmXG4gICAgICBvcHRzLmZvbGxvd1JlZGlyZWN0cyAmJlxuICAgICAgc3RhdHVzQ29kZSA+PSAzMDAgJiZcbiAgICAgIHN0YXR1c0NvZGUgPCA0MDBcbiAgICApIHtcbiAgICAgIGlmICgrK3dlYnNvY2tldC5fcmVkaXJlY3RzID4gb3B0cy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdNYXhpbXVtIHJlZGlyZWN0cyBleGNlZWRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcS5hYm9ydCgpO1xuXG4gICAgICBjb25zdCBhZGRyID0gbmV3IFVSTChsb2NhdGlvbiwgYWRkcmVzcyk7XG5cbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICghd2Vic29ja2V0LmVtaXQoJ3VuZXhwZWN0ZWQtcmVzcG9uc2UnLCByZXEsIHJlcykpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgIHJlcSxcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXEub24oJ3VwZ3JhZGUnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlIGB1cGdyYWRlYFxuICAgIC8vIGV2ZW50LlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgY29uc3QgcHJvdExpc3QgPSAocHJvdG9jb2xzIHx8ICcnKS5zcGxpdCgvLCAqLyk7XG4gICAgbGV0IHByb3RFcnJvcjtcblxuICAgIGlmICghcHJvdG9jb2xzICYmIHNlcnZlclByb3QpIHtcbiAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhIHN1YnByb3RvY29sIGJ1dCBub25lIHdhcyByZXF1ZXN0ZWQnO1xuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xzICYmICFzZXJ2ZXJQcm90KSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xuICAgIH0gZWxzZSBpZiAoc2VydmVyUHJvdCAmJiAhcHJvdExpc3QuaW5jbHVkZXMoc2VydmVyUHJvdCkpIHtcbiAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhbiBpbnZhbGlkIHN1YnByb3RvY29sJztcbiAgICB9XG5cbiAgICBpZiAocHJvdEVycm9yKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0LnByb3RvY29sID0gc2VydmVyUHJvdDtcblxuICAgIGlmIChwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHBhcnNlKHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXSk7XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1xuICAgICAgICAgICAgUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxuICAgICAgICAgIF0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICAgIHdlYnNvY2tldCxcbiAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdlYnNvY2tldC5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCBvcHRzLm1heFBheWxvYWQpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgbmV0LlNvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge25ldC5Tb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZXRDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gb3B0aW9ucy5zb2NrZXRQYXRoO1xuICByZXR1cm4gbmV0LmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYHRscy5UTFNTb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHt0bHMuVExTU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGxzQ29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IHVuZGVmaW5lZDtcblxuICBpZiAoIW9wdGlvbnMuc2VydmVybmFtZSAmJiBvcHRpb25zLnNlcnZlcm5hbWUgIT09ICcnKSB7XG4gICAgb3B0aW9ucy5zZXJ2ZXJuYW1lID0gb3B0aW9ucy5ob3N0O1xuICB9XG5cbiAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEFib3J0IHRoZSBoYW5kc2hha2UgYW5kIGVtaXQgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyhodHRwLkNsaWVudFJlcXVlc3R8bmV0LlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0byBhYm9ydCBvciB0aGVcbiAqICAgICBzb2NrZXQgdG8gZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc3RyZWFtLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldC5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFib3J0SGFuZHNoYWtlKTtcblxuICBpZiAoc3RyZWFtLnNldEhlYWRlcikge1xuICAgIHN0cmVhbS5hYm9ydCgpO1xuICAgIHN0cmVhbS5vbmNlKCdhYm9ydCcsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgd2Vic29ja2V0LmVtaXQuYmluZCh3ZWJzb2NrZXQsICdlcnJvcicpKTtcbiAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgY2FzZXMgd2hlcmUgdGhlIGBwaW5nKClgLCBgcG9uZygpYCwgb3IgYHNlbmQoKWAgbWV0aG9kcyBhcmUgY2FsbGVkXG4gKiB3aGVuIHRoZSBgcmVhZHlTdGF0ZWAgYXR0cmlidXRlIGlzIGBDTE9TSU5HYCBvciBgQ0xPU0VEYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZEFmdGVyQ2xvc2Uod2Vic29ja2V0LCBkYXRhLCBjYikge1xuICBpZiAoZGF0YSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRvQnVmZmVyKGRhdGEpLmxlbmd0aDtcblxuICAgIC8vXG4gICAgLy8gVGhlIGBfYnVmZmVyZWRBbW91bnRgIHByb3BlcnR5IGlzIHVzZWQgb25seSB3aGVuIHRoZSBwZWVyIGlzIGEgY2xpZW50IGFuZFxuICAgIC8vIHRoZSBvcGVuaW5nIGhhbmRzaGFrZSBmYWlscy4gVW5kZXIgdGhlc2UgY2lyY3Vtc3RhbmNlcywgaW4gZmFjdCwgdGhlXG4gICAgLy8gYHNldFNvY2tldCgpYCBtZXRob2QgaXMgbm90IGNhbGxlZCwgc28gdGhlIGBfc29ja2V0YCBhbmQgYF9zZW5kZXJgXG4gICAgLy8gcHJvcGVydGllcyBhcmUgc2V0IHRvIGBudWxsYC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQuX3NvY2tldCkgd2Vic29ja2V0Ll9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXMgKz0gbGVuZ3RoO1xuICAgIGVsc2Ugd2Vic29ja2V0Ll9idWZmZXJlZEFtb3VudCArPSBsZW5ndGg7XG4gIH1cblxuICBpZiAoY2IpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7d2Vic29ja2V0LnJlYWR5U3RhdGV9IGAgK1xuICAgICAgICBgKCR7cmVhZHlTdGF0ZXNbd2Vic29ja2V0LnJlYWR5U3RhdGVdfSlgXG4gICAgKTtcbiAgICBjYihlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnY29uY2x1ZGUnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb24gVGhlIHJlYXNvbiBmb3IgY2xvc2luZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkNvbmNsdWRlKGNvZGUsIHJlYXNvbikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgd2Vic29ja2V0Ll9zb2NrZXQucmVzdW1lKCk7XG5cbiAgd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgPSB0cnVlO1xuICB3ZWJzb2NrZXQuX2Nsb3NlTWVzc2FnZSA9IHJlYXNvbjtcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBjb2RlO1xuXG4gIGlmIChjb2RlID09PSAxMDA1KSB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgZWxzZSB3ZWJzb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdkcmFpbidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25EcmFpbigpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5fc29ja2V0LnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoUmFuZ2VFcnJvcnxFcnJvcil9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcblxuICB3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICB3ZWJzb2NrZXQuX2Nsb3NlQ29kZSA9IGVycltrU3RhdHVzQ29kZV07XG4gIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIHdlYnNvY2tldC5fc29ja2V0LmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdmaW5pc2gnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRmluaXNoKCkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ21lc3NhZ2UnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgbWVzc2FnZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbk1lc3NhZ2UoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwaW5nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBpbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25QaW5nKGRhdGEpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQucG9uZyhkYXRhLCAhd2Vic29ja2V0Ll9pc1NlcnZlciwgTk9PUCk7XG4gIHdlYnNvY2tldC5lbWl0KCdwaW5nJywgZGF0YSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncG9uZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwb25nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUG9uZyhkYXRhKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgncG9uZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnY2xvc2UnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkNsb3NlKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHNvY2tldE9uRW5kKTtcblxuICB3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIC8vXG4gIC8vIFRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgaGF2ZSBiZWVuIHJlY2VpdmVkIG9yIHRoZSBgJ2VuZCdgIGV2ZW50IGVtaXR0ZWQsXG4gIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgc29ja2V0IHdhcyBkZXN0cm95ZWQgZHVlIHRvIGFuIGVycm9yLiBFbnN1cmUgdGhhdCB0aGVcbiAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXG4gIC8vIGl0LiBJZiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgc29ja2V0IGlzIGluIGZsb3dpbmcgbW9kZSB0aGVuIHRoZXJlIGlzIG5vXG4gIC8vIGJ1ZmZlcmVkIGRhdGEgYXMgZXZlcnl0aGluZyBoYXMgYmVlbiBhbHJlYWR5IHdyaXR0ZW4gYW5kIGByZWFkYWJsZS5yZWFkKClgXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYC4gSWYgaW5zdGVhZCwgdGhlIHNvY2tldCBpcyBwYXVzZWQsIGFueSBwb3NzaWJsZSBidWZmZXJlZFxuICAvLyBkYXRhIHdpbGwgYmUgcmVhZCBhcyBhIHNpbmdsZSBjaHVuayBhbmQgZW1pdHRlZCBzeW5jaHJvbm91c2x5IGluIGEgc2luZ2xlXG4gIC8vIGAnZGF0YSdgIGV2ZW50LlxuICAvL1xuICB3ZWJzb2NrZXQuX3NvY2tldC5yZWFkKCk7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcbiAgdGhpcy5lbmQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICB0aGlzLm9uKCdlcnJvcicsIE5PT1ApO1xuXG4gIGlmICh3ZWJzb2NrZXQpIHtcbiAgICB3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAndGhyZWUvc3JjL21hdGgvVmVjdG9yMyc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAndGhyZWUvc3JjL21hdGgvUXVhdGVybmlvbic7XG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJ3RocmVlL3NyYy9jb3JlL09iamVjdDNEJztcblxuZ2xvYmFsLmRlYnVnID0gKC4uLnBhcmFtcykgPT4gY29uc29sZS5sb2coYFskeyhuZXcgRGF0ZSkudG9Mb2NhbGVUaW1lU3RyaW5nKCl9XWAsIC4uLnBhcmFtcyk7XG5cbmNsYXNzIE9iajNEIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRjb25zdHJ1Y3RvciguLi5wcm9wcykge1xuXHRcdHN1cGVyKC4uLnByb3BzKTtcblx0XHR0aGlzLnNjZW5lID0gdGhpcztcblx0fVxufVxuXG5nbG9iYWwuVEhSRUUgPSB7XG5cdFZlY3RvcjMsXG5cdFF1YXRlcm5pb24sXG5cdE9iamVjdDNEOiBPYmozRCxcblx0V2ViR0xSZW5kZXJlcjogKCkgPT4gKHtcblx0XHRyZW5kZXI6ICgpID0+ICh7fSksXG5cdFx0c2V0U2l6ZTogKCkgPT4gKHt9KSxcblx0XHRnZXRDb250ZXh0OiAoKSA9PiAoe1xuXHRcdFx0Y2FudmFzOiB7XG5cdFx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0XHRoZWlnaHQ6IDBcblx0XHRcdH0sXG5cdFx0fSksXG5cdFx0c2hhZG93TWFwOiB7fSxcblx0fSksXG5cdFNjZW5lOiBPYmozRCxcblx0Q2FjaGU6IHt9LFxuXHRDbG9jazogKCkgPT4gKHt9KSxcblx0QW5pbWF0aW9uTWl4ZXI6ICgpID0+ICh7XG5cdFx0dXBkYXRlOiAoKSA9PiAoe30pLFxuXHRcdGNsaXBBY3Rpb246ICgpID0+ICh7XG5cdFx0XHRzdG9wOiAoKSA9PiAoe30pLFxuXHRcdH0pLFxuXHR9KSxcblx0UENGU29mdFNoYWRvd01hcDogKCkgPT4gKHt9KSxcblx0UGVyc3BlY3RpdmVDYW1lcmE6IE9iajNELFxuXHRSYXljYXN0ZXI6ICgpID0+ICh7fSksXG5cdFRleHR1cmVMb2FkZXI6ICgpID0+ICh7XG5cdFx0bG9hZDogKCkgPT4gKHt9KSxcblx0fSksXG5cdEZvZzogKCkgPT4gKHt9KSxcblx0UmVwZWF0V3JhcHBpbmc6ICgpID0+ICh7fSksXG5cdENvbG9yOiAoKSA9PiAoe30pLFxuXHRNZXNoOiBPYmozRCxcblx0Q3ViZUdlb21ldHJ5OiAoKSA9PiAoe30pLFxuXHRNZXNoTGFtYmVydE1hdGVyaWFsOiAoKSA9PiAoe30pLFxuXHROb3JtYWxCbGVuZGluZzogKCkgPT4gKHt9KSxcblx0QWRkaXRpdmVCbGVuZGluZzogKCkgPT4gKHt9KSxcblx0R2VvbWV0cnk6ICgpID0+ICh7fSksXG5cdFBvaW50Q2xvdWRNYXRlcmlhbDogKCkgPT4gKHt9KSxcblx0UG9pbnRDbG91ZDogKCkgPT4gKHt9KSxcblx0QW1iaWVudExpZ2h0OiAoKSA9PiAoe30pLFxuXHREaXJlY3Rpb25hbExpZ2h0OiAoKSA9PiB7XG5cdFx0Y29uc3QgbGlnaHQgPSBuZXcgT2JqM0QoKTtcblx0XHRsaWdodC5zaGFkb3cgPSB7XG5cdFx0XHRjYW1lcmE6IHt9LFxuXHRcdFx0bWFwU2l6ZToge30sXG5cdFx0fTtcblx0XHRyZXR1cm4gbGlnaHQ7XG5cdH0sXG5cdE1lc2hCYXNpY01hdGVyaWFsOiAoKSA9PiAoe30pLFxuXHRCYWNrU2lkZTogKCkgPT4gKHt9KSxcblx0TWVzaEZhY2VNYXRlcmlhbDogKCkgPT4gKHt9KSxcbn07XG5cbmdsb2JhbC5HTFRGTG9hZGVyID0gKCkgPT4gKHtcblx0bG9hZDogKHVybCwgY2FsbGJhY2spID0+IGNhbGxiYWNrKG5ldyBPYmozRCgpKSxcbn0pO1xuXG5nbG9iYWwud2luZG93ID0ge1xuXHRpbm5lcldpZHRoOiAwLFxuXHRpbm5lckhlaWdodDogMCxcblx0Y2xlYXJUaW1lb3V0OiAwLFxuXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZuID0+IHNldFRpbWVvdXQoZm4sIDEwMDAgLyA2MCksXG5cdGxvY2F0aW9uOiB7XG5cdFx0cmVsb2FkOiAoKSA9PiBkZWJ1ZygncmVsb2FkIHBhZ2UnKSxcblx0fSxcblx0YWRkRXZlbnRMaXN0ZW5lcjogKC4uLnBhcmFtcykgPT4gZGVidWcoJ3dpbmRvdy5hZGRFdmVudExpc3RlbmVyJywgLi4ucGFyYW1zKSxcblx0c2V0VGltZW91dDogc2V0VGltZW91dCxcblx0V2ViU29ja2V0OiAoKSA9PiAoe1xuXHRcdG9ub3BlbjogKC4uLnBhcmFtcykgPT4gZGVidWcoJ3dpbmRvdy5XZWJTb2NrZXQub25vcGVuJywgLi4ucGFyYW1zKSxcblx0XHRvbmVycm9yOiAoLi4ucGFyYW1zKSA9PiBkZWJ1Zygnd2luZG93LldlYlNvY2tldC5vbmVycm9yJywgLi4ucGFyYW1zKSxcblx0XHRvbm1lc3NhZ2U6ICguLi5wYXJhbXMpID0+IGRlYnVnKCd3aW5kb3cuV2ViU29ja2V0Lm9ubWVzc2FnZScsIC4uLnBhcmFtcyksXG5cdH0pLFxufTtcblxuZ2xvYmFsLmRvY3VtZW50ID0ge1xuXHRib2R5OiB7XG5cdFx0YWRkRXZlbnRMaXN0ZW5lcjogKC4uLnBhcmFtcykgPT4gZGVidWcoJ2RvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcicsIC4uLnBhcmFtcyksXG5cdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogKC4uLnBhcmFtcykgPT4gZGVidWcoJ2RvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcicsIC4uLnBhcmFtcyksXG5cdH0sXG5cdGRpc3BhdGNoRXZlbnQ6ICguLi5wYXJhbXMpID0+IGRlYnVnKCdkb2N1bWVudC5kaXNwYXRjaEV2ZW50JywgLi4ucGFyYW1zKSxcblx0Z2V0RWxlbWVudEJ5SWQ6ICguLi5wYXJhbXMpID0+IGRlYnVnKCdkb2N1bWVudC5nZXRFbGVtZW50QnlJZCcsIC4uLnBhcmFtcyksXG5cdGFkZEV2ZW50TGlzdGVuZXI6ICguLi5wYXJhbXMpID0+IGRlYnVnKCdkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyJywgLi4ucGFyYW1zKSxcblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogKC4uLnBhcmFtcykgPT4gZGVidWcoJ2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXInLCAuLi5wYXJhbXMpLFxufTtcblxuZXhwb3J0IGNvbnN0IE1vY2tHVUkgPSB7XG5cdFx0aXNTZXJ2ZXI6IHRydWUsXG5cdFx0c2V0UmVzdGFydEJ1dHRvblZpc2libGU6ICgpID0+IG51bGwsXG5cdFx0c2V0UGF1c2U6ICgpID0+IG51bGwsXG5cdFx0cmVzdGFydEdhbWU6ICgpID0+IG51bGwsXG5cdFx0aXNQYXVzZTogKCkgPT4gZmFsc2UsXG5cdFx0aXNUaGlyZFBlcnNvbjogKCkgPT4gZmFsc2UsXG5cdFx0dXBkYXRlOiAoKSA9PiBudWxsLFxuXHRcdHNldENvbm5lY3Rpb25Sb2xlOiBkZWJ1Zyxcblx0XHR1cGRhdGVQbGF5ZXJQYXJhbXM6ICgpID0+IG51bGwsXG5cdFx0Y2xlYXJIcEJhcnM6ICgpID0+IG51bGwsXG5cdFx0c3dpdGNoQ2FtZXJhOiAoKSA9PiBudWxsLFxuXHRcdHNldEZwczogKCkgPT4gbnVsbCxcblx0XHRub3RpZnk6IGRlYnVnLFxuXHRcdHNldExvYWRpbmc6ICgpID0+IG51bGwsXG59O1xuXG5leHBvcnQgY29uc3QgTW9ja1JlbmRlcmVyID0ge1xuXHRmcHM6IDEsXG5cdFx0dGFyZ2V0RnBzOiAxLFxuXHRcdHJlbmRlcmVyOiBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpLFxuXHRcdHJlbmRlcjogKCkgPT4gKHt9KSxcbn07XG4iLCJpbXBvcnQgKiBhcyB3cyBmcm9tICd3cyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5jb25zdCBXZWJTb2NrZXRTZXJ2ZXIgPSB3cy5TZXJ2ZXI7XG5cbmNsYXNzIFNvY2tldFNlcnZlciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuY3JlYXRlV2ViU2VydmVyID0gdGhpcy5jcmVhdGVXZWJTZXJ2ZXIuYmluZCh0aGlzKTtcblx0XHR0aGlzLmNyZWF0ZVNvY2tldFNlcnZlciA9IHRoaXMuY3JlYXRlU29ja2V0U2VydmVyLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5zYXZlVXNlckRhdGEgPSB0aGlzLnNhdmVVc2VyRGF0YS5iaW5kKHRoaXMpO1xuXHRcdHRoaXMubG9hZFVzZXJEYXRhID0gdGhpcy5sb2FkVXNlckRhdGEuYmluZCh0aGlzKTtcblx0XHR0aGlzLnN0YXJ0U29ja2V0U2VydmVyID0gdGhpcy5zdGFydFNvY2tldFNlcnZlci5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuZ2V0Q29ubmVjdGlvbklkID0gdGhpcy5nZXRDb25uZWN0aW9uSWQuYmluZCh0aGlzKTtcblx0XHR0aGlzLnNlbmRHYW1lT2JqZWN0c1RvUGxheWVycyA9IHRoaXMuc2VuZEdhbWVPYmplY3RzVG9QbGF5ZXJzLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5zZW5kID0gdGhpcy5zZW5kLmJpbmQodGhpcyk7XG5cblx0XHRjb25zdCBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuXG5cdFx0dGhpcy5jb25maWcgPSB7XG5cdFx0XHRzc2w6IGlzUHJvZHVjdGlvbixcblx0XHRcdHBvcnQ6IDEzMzcsXG5cdFx0XHRzc2xLZXk6IHBhdGguam9pbihfX2Rpcm5hbWUsICcuL3ByaXZhdGUucGVtJyksXG5cdFx0XHRzc2xDZXJ0aWZpY2F0ZTogcGF0aC5qb2luKF9fZGlybmFtZSwgJy4vZnVsbGNoYWluLnBlbScpLFxuXHRcdFx0c2Vzc2lvbnNQYXRoOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi9zZXNzaW9ucy8nKSxcblx0XHRcdGRlYnVnOiBmYWxzZVxuXHRcdH07XG5cblx0XHRjb25zb2xlLmxvZyhfX2Rpcm5hbWUsIGZzLnJlYWRkaXJTeW5jKF9fZGlybmFtZSkpO1xuXG5cdFx0dGhpcy5kYiA9IHtcblx0XHRcdHNlcXVlbmNlSWQ6IDAsXG5cdFx0XHRob3N0SWQ6IG51bGwsXG5cdFx0XHRjb25uZWN0aW9uczoge30sXG5cdFx0XHRwbGF5ZXJzOiB7fSxcblx0XHRcdGdhbWVPYmplY3RzOiBbXSxcblx0XHR9O1xuXG5cdFx0Y29uc3Qgc29ja2V0U2VydmVyID0gdGhpcy5jcmVhdGVTb2NrZXRTZXJ2ZXIodGhpcy5jb25maWcpO1xuXHRcdHRoaXMuc3RhcnRTb2NrZXRTZXJ2ZXIoc29ja2V0U2VydmVyKTtcblx0fVxuXG5cdGNyZWF0ZVdlYlNlcnZlcihjb25maWcpIHtcblx0XHRjb25zdCBwcm9jZXNzUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcSwgcmVzKSB7XG5cdFx0XHRyZXMud3JpdGVIZWFkKDIwMCk7XG5cdFx0XHRyZXMuZW5kKFwiQWxsIGdsb3J5IHRvIFdlYlNvY2tldHMhXFxuXCIpO1xuXHRcdH07XG5cblx0XHRpZiAoY29uZmlnLnNzbCkge1xuXHRcdFx0Y29uc3Qgc3NsUGFyYW1zID0ge1xuXHRcdFx0XHRrZXk6IGZzLnJlYWRGaWxlU3luYyhjb25maWcuc3NsS2V5KSxcblx0XHRcdFx0Y2VydDogZnMucmVhZEZpbGVTeW5jKGNvbmZpZy5zc2xDZXJ0aWZpY2F0ZSksXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gcmVxdWlyZSgnaHR0cHMnKS5jcmVhdGVTZXJ2ZXIoc3NsUGFyYW1zLCBwcm9jZXNzUmVxdWVzdCkubGlzdGVuKGNvbmZpZy5wb3J0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHJlcXVpcmUoJ2h0dHAnKS5jcmVhdGVTZXJ2ZXIocHJvY2Vzc1JlcXVlc3QpLmxpc3Rlbihjb25maWcucG9ydCk7XG5cdFx0fVxuXHR9XG5cblx0Y3JlYXRlU29ja2V0U2VydmVyKGNvbmZpZykge1xuXHRcdGNvbnN0IHNlcnZlciA9IHRoaXMuY3JlYXRlV2ViU2VydmVyKGNvbmZpZyk7XG5cdFx0Y29uc3Qgd2ViU29ja2V0U2VydmVyID0gbmV3IFdlYlNvY2tldFNlcnZlcih7IHNlcnZlciB9KTtcblxuXHRcdGRlYnVnKGBTZXJ2ZXIgaXMgcnVubmluZyBvbiBwb3J0ICR7Y29uZmlnLnBvcnR9LiBTU0wgaXMgJHtjb25maWcuc3NsID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJ30uYCk7XG5cblx0XHRyZXR1cm4gd2ViU29ja2V0U2VydmVyO1xuXHR9XG5cblx0c2F2ZVVzZXJEYXRhKHRva2VuLCBkYXRhKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghZnMuZXhpc3RzU3luYyh0aGlzLmNvbmZpZy5zZXNzaW9uc1BhdGgpKSB7XG5cdFx0XHRcdGZzLm1rZGlyU3luYyh0aGlzLmNvbmZpZy5zZXNzaW9uc1BhdGgpO1xuXHRcdFx0fVxuXG5cdFx0XHRmcy53cml0ZUZpbGVTeW5jKGAke3RoaXMuY29uZmlnLnNlc3Npb25zUGF0aH0vJHt0b2tlbn1gLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRkZWJ1ZygnU2F2ZSB1c2VyIGRhdGEgZXJyb3InLCBlKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRsb2FkVXNlckRhdGEodG9rZW4pIHtcblx0XHRjb25zdCB0b2tlblBhdGggPSBgJHt0aGlzLmNvbmZpZy5zZXNzaW9uc1BhdGh9LyR7dG9rZW59YDtcblxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoZnMuZXhpc3RzU3luYyh0b2tlblBhdGgpKSB7XG5cdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyh0b2tlblBhdGgsICd1dGY4JykpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGRlYnVnKCdMb2FkIHVzZXIgZGF0YSBlcnJvcicsIGUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGdldENvbm5lY3Rpb25JZChjKSB7XG5cdFx0cmV0dXJuIGMuX2lkO1xuXHR9XG5cblx0c2VuZEdhbWVPYmplY3RzVG9QbGF5ZXJzKCkge1xuXHRcdGNvbnN0IHBsYXllcnMgPSB0aGlzLmRiLnBsYXllcnM7XG5cdFx0Y29uc3QgY29ubmVjdGlvbnMgPSB0aGlzLmRiLmNvbm5lY3Rpb25zO1xuXHRcdGNvbnN0IGdhbWVPYmplY3RzID0gdGhpcy5kYi5nYW1lT2JqZWN0cztcblxuXHRcdE9iamVjdC5rZXlzKGNvbm5lY3Rpb25zKS5mb3JFYWNoKChjb25uZWN0aW9uSWQpID0+IHtcblx0XHRcdGNvbnN0IGNvbm5lY3Rpb24gPSBjb25uZWN0aW9uc1tjb25uZWN0aW9uSWRdO1xuXHRcdFx0Y29uc3QgbmV0d29ya1BsYXllcnMgPSBPYmplY3Qua2V5cyhwbGF5ZXJzKVxuXHRcdFx0XHQuZmlsdGVyKHBsYXllckNvbm5lY3Rpb25JZCA9PiBwbGF5ZXJDb25uZWN0aW9uSWQgIT09IGNvbm5lY3Rpb25JZClcblx0XHRcdFx0Lm1hcChwbGF5ZXJDb25uZWN0aW9uSWQgPT4gcGxheWVyc1twbGF5ZXJDb25uZWN0aW9uSWRdKTtcblxuXHRcdFx0dGhpcy5zZW5kKGNvbm5lY3Rpb24sICd1cGRhdGVHYW1lT2JqZWN0cycsIFsuLi5nYW1lT2JqZWN0cywgLi4ubmV0d29ya1BsYXllcnNdKTtcblx0XHR9KTtcblx0fVxuXG5cdHNlbmQoY29ubmVjdGlvbiwgbWVzc2FnZVR5cGUsIGRhdGEpIHtcblx0XHRjb25uZWN0aW9uLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0bWV0YToge1xuXHRcdFx0XHRzZXJ2ZXI6IHsgdmVyc2lvbjogMSB9LFxuXHRcdFx0XHRyb2xlOiB0aGlzLmdldENvbm5lY3Rpb25JZChjb25uZWN0aW9uKSA9PT0gdGhpcy5kYi5ob3N0SWQgPyAnaG9zdCcgOiAnY2xpZW50Jyxcblx0XHRcdFx0aWQ6IHRoaXMuZ2V0Q29ubmVjdGlvbklkKGNvbm5lY3Rpb24pLFxuXHRcdFx0XHR0b2tlbjogY29ubmVjdGlvbi5fbWV0YS50b2tlbixcblx0XHRcdFx0ZGVidWc6IHRoaXMuY29uZmlnLmRlYnVnLFxuXHRcdFx0fSxcblx0XHRcdGRhdGEsXG5cdFx0XHRtZXNzYWdlVHlwZSxcblx0XHR9KSk7XG5cdH1cblxuXHRzdGFydFNvY2tldFNlcnZlcihzb2NrZXRTZXJ2ZXIpIHtcblx0XHRjb25zdCBkYiA9IHRoaXMuZGI7XG5cdFx0Y29uc3QgbG9hZFVzZXJEYXRhID0gdGhpcy5sb2FkVXNlckRhdGE7XG5cdFx0Y29uc3QgZ2V0Q29ubmVjdGlvbklkID0gdGhpcy5nZXRDb25uZWN0aW9uSWQ7XG5cdFx0Y29uc3Qgc2VuZCA9IHRoaXMuc2VuZDtcblx0XHRjb25zdCBnZXRDb25uZWN0aW9uVG9rZW4gPSBjID0+IGMuX21ldGEudG9rZW47XG5cblx0XHRzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHRPYmplY3QudmFsdWVzKGRiLmNvbm5lY3Rpb25zKS5mb3JFYWNoKChjb25uZWN0aW9uKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNvbm5lY3Rpb25QbGF5ZXIgPSBkYi5wbGF5ZXJzW2dldENvbm5lY3Rpb25JZChjb25uZWN0aW9uKV07XG5cdFx0XHRcdGNvbnN0IHRva2VuID0gZ2V0Q29ubmVjdGlvblRva2VuKGNvbm5lY3Rpb24pO1xuXG5cdFx0XHRcdGlmIChjb25uZWN0aW9uUGxheWVyICYmIHRva2VuKSB7XG5cdFx0XHRcdFx0dGhpcy5zYXZlVXNlckRhdGEodG9rZW4sIGNvbm5lY3Rpb25QbGF5ZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LCAxMDAwMCk7XG5cblx0XHRzb2NrZXRTZXJ2ZXIub24oJ2Nvbm5lY3Rpb24nLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG5cdFx0XHRjb25zdCBpZCA9ICsrZGIuc2VxdWVuY2VJZDtcblxuXHRcdFx0ZGVidWcoJ05ldyBjb25uZWN0aW9uLCBpZDonLCBpZCk7XG5cblx0XHRcdGRiLmNvbm5lY3Rpb25zW2lkXSA9IGNvbm5lY3Rpb247XG5cdFx0XHRjb25uZWN0aW9uLl9tZXRhID0geyBpZCB9O1xuXHRcdFx0Y29ubmVjdGlvbi5faWQgPSBpZDtcblxuXHRcdFx0Y29uc3Qgb25Tb2NrZXRDbG9zZSA9ICgpID0+IHtcblx0XHRcdFx0Y29uc3QgaWQgPSBnZXRDb25uZWN0aW9uSWQoY29ubmVjdGlvbik7XG5cdFx0XHRcdGRlYnVnKCdDb25uZWN0aW9uIGNsb3NlZCwgaWQ6JywgaWQpO1xuXG5cdFx0XHRcdE9iamVjdC52YWx1ZXMoZGIuY29ubmVjdGlvbnMpLmZvckVhY2goKGMpID0+IHtcblx0XHRcdFx0XHRzZW5kKGMsICdkaXNjb25uZWN0ZWQnLCB7IGNvbm5lY3Rpb25JZDogaWQgfSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGRlbGV0ZSBkYi5jb25uZWN0aW9uc1tpZF07XG5cdFx0XHRcdGRlbGV0ZSBkYi5wbGF5ZXJzW2lkXTtcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IG9uU29ja2V0TWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHsgZGF0YSwgbWVzc2FnZVR5cGUsIG1ldGEgfSA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG5cdFx0XHRcdGNvbnN0IGNvbm5lY3Rpb25JZCA9IGdldENvbm5lY3Rpb25JZChjb25uZWN0aW9uKTtcblxuXHRcdFx0XHRpZiAobWV0YSAmJiBtZXRhLnRva2VuICYmIG1ldGEudG9rZW4gIT09IGNvbm5lY3Rpb24uX21ldGEudG9rZW4pIHtcblx0XHRcdFx0XHRkZWJ1ZyhgVXNlciAjJHtjb25uZWN0aW9uSWR9IHRva2VuIGNoYW5nZWQgZnJvbSAke2Nvbm5lY3Rpb24uX21ldGEudG9rZW59IHRvICR7bWV0YS50b2tlbn1gKTtcblx0XHRcdFx0XHRjb25uZWN0aW9uLl9tZXRhLnRva2VuID0gbWV0YS50b2tlbjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHNlbmRVc2VyRGF0YSA9ICgpID0+IHtcblx0XHRcdFx0XHRzZW5kKGNvbm5lY3Rpb24sICdzZXRVc2VyUGxheWVyJywgbG9hZFVzZXJEYXRhKGNvbm5lY3Rpb24uX21ldGEudG9rZW4pKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRjb25zdCB1cGRhdGVQbGF5ZXJEYXRhID0gKHBsYXllcikgPT4ge1xuXHRcdFx0XHRcdGRiLnBsYXllcnNbY29ubmVjdGlvbklkXSA9IHBsYXllcjtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRzd2l0Y2ggKG1lc3NhZ2VUeXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnbG9hZEN1cnJlbnRVc2VyJzoge1xuXHRcdFx0XHRcdFx0c2VuZFVzZXJEYXRhKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYXNlICd1cGRhdGVQbGF5ZXInOiB7XG5cdFx0XHRcdFx0XHR1cGRhdGVQbGF5ZXJEYXRhKGRhdGEpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FzZSAncmVzdGFydFNlcnZlcic6IHtcblx0XHRcdFx0XHRcdC8vIHJlc3RhcnRTZXJ2ZXIoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Y29ubmVjdGlvbi5vbignbWVzc2FnZScsIG9uU29ja2V0TWVzc2FnZSk7XG5cdFx0XHRjb25uZWN0aW9uLm9uKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpO1xuXG5cdFx0XHRzZW5kKGNvbm5lY3Rpb24sICdoYW5kc2hha2UnKTtcblx0XHR9KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBTb2NrZXRTZXJ2ZXI7XG4iLCJpbXBvcnQgeyBNb2NrR1VJLCBNb2NrUmVuZGVyZXIgfSBmcm9tICcuL3NyYy9Nb2NrRGVwZW5kZW5jaWVzJztcbmltcG9ydCBTb2NrZXRTZXJ2ZXIgZnJvbSAnLi9zcmMvU29ja2V0U2VydmVyJztcbmltcG9ydCBTY2VuZSBmcm9tICcuLi9jbGllbnQvc3JjL2pzL1NjZW5lJztcbmltcG9ydCBDb25uZWN0aW9uIGZyb20gJy4uL2NsaWVudC9zcmMvanMvQ29ubmVjdGlvbic7XG5pbXBvcnQgeyBQbGF5ZXIgfSBmcm9tICcuLi9jbGllbnQvc3JjL2pzL0dhbWVPYmplY3RzJztcblxuZnVuY3Rpb24gU2VydmVyKCkge1xuXHRkZWJ1ZygnU3RhcnRpbmcgc2VydmVyIHNjZW5lIGluaXRpYWxpemF0aW9uIC4uLicpO1xuXG5cdGNvbnN0IHNjZW5lID0gbmV3IFNjZW5lKE1vY2tSZW5kZXJlciwgTW9ja0dVSSk7XG5cblx0ZGVidWcoJ1NjZW5lIGlzIGxvYWRlZCcsIHtcblx0XHRUSFJFRTogQm9vbGVhbihUSFJFRSksXG5cdFx0ZG9jdW1lbnQ6IEJvb2xlYW4oZG9jdW1lbnQpLFxuXHRcdHdpbmRvdzogQm9vbGVhbih3aW5kb3cpLFxuXHRcdEdMVEZMb2FkZXI6IEJvb2xlYW4oR0xURkxvYWRlciksXG5cdFx0c2NlbmU6IEJvb2xlYW4oc2NlbmUpLFxuXHRcdHNjZW5lTG9jYXRpb246IEJvb2xlYW4oc2NlbmUubG9jYXRpb24pLFxuXHRcdHNjZW5lQ29sbGlkZXJzOiBzY2VuZS5jb2xsaWRlcnMuY29sbGlkZXJzLmxlbmd0aCxcblx0XHRzY2VuZUFyZWFzOiBzY2VuZS5wYXRoRmluZGVyLmFyZWFzLmxlbmd0aCxcblx0fSk7XG5cblx0Y29uc3QgaW5pdCA9ICgpID0+IHtcblx0XHRjb25zdCBwbGF5ZXIgPSBzY2VuZS5nZXRQbGF5ZXIoKTtcblxuXHRcdGlmIChwbGF5ZXIpIHtcblx0XHRcdHBsYXllci5wYXJhbXMuaHAgPSAwO1xuXHRcdH1cblxuXHRcdGRlYnVnKCdTdGFydGluZyBzb2NrZXQgc2VydmVyIC4uLicpO1xuXHRcdGNvbnN0IHNvY2tldFNlcnZlciA9IG5ldyBTb2NrZXRTZXJ2ZXIoKTtcblxuXHRcdGNvbnN0IHVwZGF0ZUdhbWVPYmplY3RzID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgZGF0YSA9IFtdO1xuXG5cdFx0XHRzY2VuZS51bml0cy5nZXRBbGl2ZVVuaXRzKClcblx0XHRcdFx0LmZpbHRlcih1bml0ID0+ICEodW5pdCBpbnN0YW5jZW9mIFBsYXllcikpXG5cdFx0XHRcdC5mb3JFYWNoKCh1bml0KSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgdW5pdERhdGEgPSBDb25uZWN0aW9uLnVuaXRUb05ldHdvcmsodW5pdCwgbnVsbCwgJ2RyZWFtLXRvd24nKTtcblxuXHRcdFx0XHRcdGlmICh1bml0RGF0YSkge1xuXHRcdFx0XHRcdFx0ZGF0YS5wdXNoKHVuaXREYXRhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRPYmplY3QudmFsdWVzKHNvY2tldFNlcnZlci5kYi5wbGF5ZXJzKVxuXHRcdFx0XHQuZm9yRWFjaChzY2VuZS5jb25uZWN0aW9uLnVwZGF0ZU5ldHdvcmtQbGF5ZXIpO1xuXG5cdFx0XHRzb2NrZXRTZXJ2ZXIuZGIuZ2FtZU9iamVjdHMgPSBkYXRhO1xuXHRcdFx0c29ja2V0U2VydmVyLnNlbmRHYW1lT2JqZWN0c1RvUGxheWVycygpO1xuXHRcdH07XG5cblx0XHRzZXRJbnRlcnZhbCh1cGRhdGVHYW1lT2JqZWN0cywgMTAwKTtcblx0fTtcblxuXHRzZXRUaW1lb3V0KGluaXQsNTAwMCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlcnZlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW1cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidGxzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ6bGliXCIpOyJdLCJzb3VyY2VSb290IjoiIn0=