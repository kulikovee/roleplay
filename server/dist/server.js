/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../client/src/js/AutoBindMethods.js":
/*!*******************************************!*\
  !*** ../client/src/js/AutoBindMethods.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AutoBindMethods; });
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AutoBindMethods = function AutoBindMethods() {
  var _this = this;

  _classCallCheck(this, AutoBindMethods);

  var functionNames = [];
  var obj = Object.getPrototypeOf(this);

  while (obj) {
    if (obj === Object.prototype || obj === AutoBindMethods.prototype) {
      obj = Object.getPrototypeOf(obj);
      continue;
    }

    functionNames = functionNames.concat(Object.getOwnPropertyNames(obj).filter(function (name) {
      return name !== 'constructor' && functionNames.indexOf(name) === -1 && typeof _this[name] === 'function';
    }));
    obj = Object.getPrototypeOf(obj);
  }

  var _iterator = _createForOfIteratorHelper(functionNames),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var functionName = _step.value;
      this[functionName] = this[functionName].bind(this);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};



/***/ }),

/***/ "../client/src/js/Camera.js":
/*!**********************************!*\
  !*** ../client/src/js/Camera.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Camera; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Camera = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Camera, _AutoBindMethods);

  var _super = _createSuper(Camera);

  /**
   * @param {Scene} scene
   */
  function Camera(scene) {
    var _this;

    _classCallCheck(this, Camera);

    _this = _super.call(this);
    _this.scene = scene;

    var ratio = _this.getWidth() / _this.getHeight();

    _this.camera = new THREE.PerspectiveCamera(45, ratio, 1, 100);

    _this.camera.position.set(5, 3, 15);

    _this.deltaY = 10;
    _this.rotateY = 0.25;
    _this.defaultDistance = 10;
    _this.distance = _this.defaultDistance;
    _this.raycaster = new THREE.Raycaster();
    return _this;
  }

  _createClass(Camera, [{
    key: "update",
    value: function update(gameTime, deltaTime) {
      var input = this.scene.input;
      var player = this.scene.getPlayer();
      if (!player) return; // Enabled if "F" is pressed

      if (input.look.cinematic) {
        this.camera.position.set(-40, 15, 10);
        this.camera.lookAt(new THREE.Vector3(-50, 0, 0));
        return;
      }

      var rotateY = this.rotateY + input.look.sensitivity * input.look.vertical / 2000;

      if (rotateY > -0.75 && rotateY < 1.25) {
        this.rotateY = rotateY;
      }

      if (input.isThirdPerson) {
        this.updateThirdPerson(player);
      } else {
        this.camera.position.copy(player.position.clone().add(new THREE.Vector3(7.5, this.deltaY, 0)));
        this.camera.lookAt(player.position);
      }
    }
  }, {
    key: "addY",
    value: function addY(y) {
      if (this.deltaY + y > 1 && this.deltaY + y < 25) {
        this.deltaY += y;
      }
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      var renderer = this.scene.renderer.renderer;
      return renderer.getContext().canvas.width;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      var renderer = this.scene.renderer.renderer;
      return renderer.getContext().canvas.height;
    }
  }, {
    key: "updateThirdPerson",
    value: function updateThirdPerson(player) {
      var _this2 = this;

      var children = this.scene.scene.children,
          deltaY = this.deltaY,
          playerHeadPosition = player.position.clone().add(new THREE.Vector3(0, 1.5, 0)),
          origin = playerHeadPosition,
          destination = this.camera.position,
          direction = new THREE.Vector3();

      var getChildrenFlat = function getChildrenFlat(objects) {
        var _ref;

        return (_ref = []).concat.apply(_ref, _toConsumableArray(objects.map(function (obj) {
          return obj.children ? [obj].concat(_toConsumableArray(getChildrenFlat(obj.children))) : [obj];
        })));
      };

      var environment = [children.find(function (c) {
        return c.name === 'LEVEL_ENVIRONMENT';
      })];
      var flatChildrenMeshes = getChildrenFlat(environment).filter(function (obj) {
        return obj.type === 'Mesh';
      });
      this.raycaster.set(origin, direction.subVectors(destination, origin).normalize());
      this.raycaster.far = deltaY * 1.5;
      var intersects = this.raycaster.intersectObjects(flatChildrenMeshes);
      var distance = Math.min.apply(Math, [deltaY].concat(_toConsumableArray(intersects.map(function (i) {
        return i.distance - _this2.distance * 0.5;
      }))));
      this.distance += (distance - this.distance) / 2;
      var playerForward = player.getForward().multiplyScalar(this.scene.input.look.back ? 1 : -1);
      playerForward.y = this.rotateY;
      this.camera.position.copy(playerHeadPosition.clone().add(playerForward));
      this.camera.lookAt(playerHeadPosition);
      var cameraForward = new THREE.Vector3(0, 0, -1);
      cameraForward.applyQuaternion(this.camera.quaternion);
      this.camera.position.sub(cameraForward.multiplyScalar(this.distance));
    }
  }, {
    key: "toScreenPosition",
    value: function toScreenPosition(position) {
      var widthHalf = 0.5 * this.getWidth();
      var heightHalf = 0.5 * this.getHeight();
      var copiedProjectVector = position.clone().project(this.camera);
      return {
        x: Math.round((copiedProjectVector.x + 1) * widthHalf),
        y: Math.round((-copiedProjectVector.y + 1) * heightHalf),
        z: copiedProjectVector.z
      };
    }
  }]);

  return Camera;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Colliders.js":
/*!*************************************!*\
  !*** ../client/src/js/Colliders.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Colliders; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Colliders = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Colliders, _AutoBindMethods);

  var _super = _createSuper(Colliders);

  function Colliders(scene) {
    var _this;

    _classCallCheck(this, Colliders);

    _this = _super.call(this);
    _this.scene = scene;
    _this.colliders = [];
    _this.nextId = 0;
    return _this;
  }

  _createClass(Colliders, [{
    key: "checkWay",
    value: function checkWay(position, gameObject) {
      var _iterator = _createForOfIteratorHelper(this.colliders),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var collider = _step.value;

          if (collider.fn(position, gameObject)) {
            return false;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return true;
    }
  }, {
    key: "resetColliders",
    value: function resetColliders() {
      this.colliders = [];
    }
  }, {
    key: "removeCollider",
    value: function removeCollider(id) {
      var idx = this.colliders.findIndex(function (c) {
        return c.id === id;
      });

      if (idx > -1) {
        this.colliders.splice(idx, 1);
      }
    }
  }, {
    key: "addColliderFunction",
    value: function addColliderFunction(fn) {
      this.colliders.push({
        id: this.nextId++,
        fn: fn
      });
      this.scene.pathFinder.rebuildAreas();
    }
  }]);

  return Colliders;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Connection.js":
/*!**************************************!*\
  !*** ../client/src/js/Connection.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Connection; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _GameObjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObjects */ "../client/src/js/GameObjects.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Connection = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Connection, _AutoBindMethods);

  var _super = _createSuper(Connection);

  /**
   * @param {Scene} scene
   * @param {string|number} ip
   * @param {string|number} port
   * @param {boolean} isSecure
   */
  function Connection(scene) {
    var _this;

    var ip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'localhost';
    var port = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '1337';
    var isSecure = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    _classCallCheck(this, Connection);

    _this = _super.call(this);
    _this.scene = scene;
    _this.meta = {};
    _this.networkPlayers = {};
    _this.networkAIs = {};
    var WebSocket = window.WebSocket || window.MozWebSocket;
    _this.connection = new WebSocket("".concat(isSecure ? 'wss' : 'ws', "://").concat(ip, ":").concat(port));

    _this.connection.onopen = function () {
      return console.log('open connection');
    };

    _this.connection.onerror = function (error) {
      return console.log('error connection', error);
    };

    _this.connection.onmessage = _this.onMessage;
    return _this;
  }

  _createClass(Connection, [{
    key: "update",
    value: function update(time, deltaTime) {
      this.sendGameObjects();
    }
  }, {
    key: "onMessage",
    value: function onMessage(_ref) {
      var data = _ref.data;

      /**
       * @param {object} meta
       * @param {any} response
       * @param {string} messageType
       */
      var _JSON$parse = JSON.parse(data),
          meta = _JSON$parse.meta,
          response = _JSON$parse.data,
          messageType = _JSON$parse.messageType;

      if (this.meta.role !== meta.role) {
        this.scene.ui.setConnectionRole(meta.role);

        if (this.meta.role && meta.role === 'host') {
          this.hostUnitsFromNetwork();
        } else if (!this.meta.debug) {
          this.clearLocalGameObjects();
        }
      }

      this.meta = meta;

      try {
        switch (messageType) {
          case 'handshake':
            {
              this.processHandshake();
              break;
            }

          case 'restartServer':
            {
              window.location.reload();
              break;
            }

          case 'setUserPlayer':
            {
              var player = this.scene.getPlayer();

              if (player) {
                this.setPlayerParams(player, response);
              } else {
                this.scene.units.setDefaultPlayerParams(response);
              }

              break;
            }

          case 'updateGameObjects':
            {
              this.updateGameObjects(response);
              break;
            }

          case 'disconnected':
            {
              this.removeDisconnectedPlayer(response);
              break;
            }
        }
      } catch (e) {
        console.log('Connection error', e);
      }
    }
  }, {
    key: "takeHost",
    value: function takeHost() {
      this.send('takeHost');
    }
  }, {
    key: "restartServer",
    value: function restartServer() {
      this.send('restartServer');
    } // There is race condition between
    // clearLocalGameObjects and Location.createInteractiveGameObjects

  }, {
    key: "clearLocalGameObjects",
    value: function clearLocalGameObjects() {
      var gameObjectsService = this.scene.gameObjectsService;
      var player = this.scene.getPlayer(); // Clear local gameObjects to replace them by network units (except player)

      gameObjectsService.getUnits().forEach(function (unit) {
        if (!unit.params.fromNetwork && unit !== player) {
          gameObjectsService.destroyGameObject(unit);
        }
      });
    }
  }, {
    key: "send",
    value: function send(messageType, data) {
      var _this$scene$user = this.scene.user,
          userName = _this$scene$user.userName,
          password = _this$scene$user.password;
      var meta = {
        token: this.getHash(userName + password)
      };
      this.connection.send(JSON.stringify({
        messageType: messageType,
        meta: meta,
        data: data
      }));
    }
  }, {
    key: "processHandshake",
    value: function processHandshake() {
      this.send('loadCurrentUser');
    }
  }, {
    key: "updateGameObjects",
    value: function updateGameObjects(gameObjects) {
      var _this2 = this;

      gameObjects.forEach(function (gameObject) {
        switch (gameObject.type) {
          case 'player':
            {
              _this2.updateNetworkPlayer(gameObject);

              break;
            }

          case 'ai':
            {
              _this2.updateNetworkAI(gameObject);

              break;
            }
        }
      });
    }
  }, {
    key: "removeDisconnectedPlayer",
    value: function removeDisconnectedPlayer(_ref2) {
      var connectionId = _ref2.connectionId;
      var gameObjectsService = this.scene.gameObjectsService;
      var disconnectedPlayer = gameObjectsService.getUnits().find(function (unit) {
        return unit instanceof _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"] && unit.params.connectionId === connectionId;
      });
      console.log('Player disconnected', connectionId, disconnectedPlayer);

      if (disconnectedPlayer) {
        disconnectedPlayer.die();
      }
    }
    /**
     * @param {String} str
     * @returns {string}
     */

  }, {
    key: "getHash",
    value: function getHash(str) {
      function hash32(str) {
        var i;
        var l;
        var hval = 0x811c9dc5;

        for (i = 0, l = str.length; i < l; i++) {
          hval ^= str.charCodeAt(i);
          hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
        }

        return ("0000000" + (hval >>> 0).toString(16)).substr(-8);
      }

      var h1 = hash32(str);
      return h1 + hash32(h1 + str);
    }
  }, {
    key: "hostUnitsFromNetwork",
    value: function hostUnitsFromNetwork() {
      this.scene.units.getAliveUnits().forEach(function (unit) {
        if (unit.params.fromNetwork) {
          unit.params.fromNetwork = false;
        }
      });
    }
  }, {
    key: "updateNetworkPlayer",
    value: function updateNetworkPlayer(playerData) {
      var _this3 = this;

      var locationName = playerData.locationName,
          position = playerData.position,
          rotation = playerData.rotation,
          animationState = playerData.animationState,
          params = playerData.params;
      var unitNetworkId = playerData.params.unitNetworkId;

      if (unitNetworkId === this.meta.unitNetworkId && !this.meta.debug) {
        return;
      }

      if (locationName !== this.scene.location.getLocationName()) {
        return;
      }
      /**
       * @type Player | string
       */


      var networkPlayer = this.networkPlayers[unitNetworkId];

      if (!networkPlayer) {
        this.networkPlayers[unitNetworkId] = 'loading';
        this.scene.units.createNetworkPlayer(playerData, function (networkPlayer) {
          _this3.networkPlayers[unitNetworkId] = networkPlayer;
        });
      } else if (networkPlayer !== 'loading') {
        this.setPlayerParams(networkPlayer, {
          position: position,
          rotation: rotation,
          animationState: animationState,
          params: params
        });
      }
    }
  }, {
    key: "setPlayerParams",
    value: function setPlayerParams(player, _ref3) {
      var position = _ref3.position,
          rotation = _ref3.rotation,
          animationState = _ref3.animationState,
          params = _ref3.params;
      player.position.set(position.x, position.y, position.z);
      player.rotation.set(rotation.x, rotation.y, rotation.z);
      player.animationState = animationState;

      if (params) {
        var input = params.input,
            acceleration = params.acceleration;
        var playerParams = player.params;
        playerParams.input.vertical = input.vertical;
        playerParams.input.horizontal = input.horizontal;
        playerParams.input.attack1 = input.attack1;
        playerParams.input.attack2 = input.attack2;
        playerParams.hp = params.hp;
        playerParams.hpMax = params.hpMax;
        playerParams.fraction = params.fraction;
        playerParams.damage = params.damage;
        playerParams.speed = params.speed;
        playerParams.money = params.money;
        playerParams.level = params.level;
        playerParams.unspentTalents = params.unspentTalents;
        playerParams.experience = params.experience;
        playerParams.acceleration.set(acceleration.x, acceleration.y, acceleration.z);
      }
    }
  }, {
    key: "updateNetworkAI",
    value: function updateNetworkAI(unitData) {
      var _this4 = this;

      var locationName = unitData.locationName,
          position = unitData.position,
          rotation = unitData.rotation,
          isRunning = unitData.isRunning,
          isAttack = unitData.isAttack,
          animationState = unitData.animationState,
          scale = unitData.scale,
          params = unitData.params;
      var unitNetworkId = params.unitNetworkId;

      if (locationName !== this.scene.location.getLocationName()) {
        return;
      }
      /**
       * @type AI | string
       */


      var networkAI = this.networkAIs[unitNetworkId];

      if (!networkAI) {
        this.networkAIs[unitNetworkId] = 'loading';
        this.scene.units.createNetworkAI(unitData, function (networkAI) {
          _this4.networkAIs[unitNetworkId] = networkAI;
        });
      } else if (networkAI !== 'loading') {
        networkAI.position.set(position.x, position.y, position.z);
        networkAI.rotation.set(rotation.x, rotation.y, rotation.z);
        networkAI.object.scale.set(scale.x, scale.y, scale.z);
        networkAI.isRunning = isRunning;
        networkAI.isAttack = isAttack;
        networkAI.animationState = animationState;

        if (params) {
          var acceleration = params.acceleration;
          var networkAIParams = networkAI.params;
          networkAIParams.hp = params.hp;
          networkAIParams.hpMax = params.hpMax;
          networkAIParams.fraction = params.fraction;
          networkAIParams.damage = params.damage;
          networkAIParams.level = params.level;
          networkAIParams.acceleration.set(acceleration.x, acceleration.y, acceleration.z);
        }
      }
    }
  }, {
    key: "sendGameObjects",
    value: function sendGameObjects() {
      var _this5 = this;

      var connectionId = this.meta.id;

      if (this.connection.readyState !== 1 || !connectionId) {
        return;
      }

      var player = this.scene.getPlayer();
      var units = this.meta.role === 'host' ? [player].concat(_toConsumableArray(this.scene.units.getAliveUnits().filter(function (unit) {
        return !unit.params.fromNetwork;
      }))) : [player];
      var data = [];
      units.forEach(function (unit) {
        if (unit) {
          var unitRotation = unit.object.rotation.toVector3();

          if (!unit.params.unitNetworkId) {
            var getRandomString = function getRandomString() {
              return Math.random().toString(36).substr(2);
            };

            unit.params.unitNetworkId = getRandomString() + getRandomString();
          }

          var unitNetworkId = unit.params.unitNetworkId;
          var isRunning = unit.isRunning,
              isAttack = unit.isAttack;
          var _unit$params = unit.params,
              hp = _unit$params.hp,
              hpMax = _unit$params.hpMax,
              acceleration = _unit$params.acceleration,
              damage = _unit$params.damage,
              level = _unit$params.level,
              experience = _unit$params.experience,
              fraction = _unit$params.fraction,
              name = _unit$params.name,
              speed = _unit$params.speed,
              unspentTalents = _unit$params.unspentTalents,
              money = _unit$params.money;

          var _ref4 = unit.params.input || {},
              vertical = _ref4.vertical,
              horizontal = _ref4.horizontal,
              attack1 = _ref4.attack1,
              attack2 = _ref4.attack2;

          var vectorToObject = function vectorToObject(vector) {
            var eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
            return {
              x: Math.round(vector.x * eps) / eps,
              y: Math.round(vector.y * eps) / eps,
              z: Math.round(vector.z * eps) / eps
            };
          };

          data.push({
            type: unit instanceof _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"] ? 'player' : 'ai',
            locationName: _this5.scene.location.getLocationName(),
            animationState: unit.animationState,
            isRunning: isRunning,
            isAttack: isAttack,
            position: vectorToObject(unit.position),
            rotation: vectorToObject(unitRotation),
            scale: vectorToObject(unit.object.scale),
            params: {
              connectionId: connectionId,
              unitNetworkId: unitNetworkId,
              name: name,
              hp: hp,
              hpMax: hpMax,
              fraction: fraction,
              damage: damage,
              level: level,
              experience: experience,
              speed: speed,
              money: money,
              unspentTalents: unspentTalents,
              acceleration: vectorToObject(acceleration),
              input: {
                vertical: vertical,
                horizontal: horizontal,
                attack1: attack1,
                attack2: attack2
              }
            }
          });
        }
      });

      if (this.meta.role === 'host') {
        this.send('updateGameObjects', data);
      } else if (data[0]) {
        this.send('updatePlayer', data[0]);
      }
    }
  }]);

  return Connection;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects.js":
/*!***************************************!*\
  !*** ../client/src/js/GameObjects.js ***!
  \***************************************/
/*! exports provided: AI, Player, Fire, Unit, AnimatedGameObject, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GameObjectsService; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _GameObjects_AI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObjects/AI */ "../client/src/js/GameObjects/AI.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AI", function() { return _GameObjects_AI__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _GameObjects_Player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameObjects/Player */ "../client/src/js/GameObjects/Player.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Player", function() { return _GameObjects_Player__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _GameObjects_Fire__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GameObjects/Fire */ "../client/src/js/GameObjects/Fire.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fire", function() { return _GameObjects_Fire__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _GameObjects_Unit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GameObjects/Unit */ "../client/src/js/GameObjects/Unit.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Unit", function() { return _GameObjects_Unit__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GameObjects/AnimatedGameObject */ "../client/src/js/GameObjects/AnimatedGameObject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimatedGameObject", function() { return _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_5__["default"]; });

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }









var GameObjectsService = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(GameObjectsService, _AutoBindMethods);

  var _super = _createSuper(GameObjectsService);

  /**
   * @param {Scene} scene
   */
  function GameObjectsService(scene) {
    var _this;

    _classCallCheck(this, GameObjectsService);

    _this = _super.call(this);
    _this.gameObjects = [];
    _this.nextGameObjectId = 0;
    _this.scene = scene;
    return _this;
  }

  _createClass(GameObjectsService, [{
    key: "update",
    value: function update(time, deltaTime) {
      this.gameObjects.forEach(function (gameObject) {
        return gameObject.update(time, deltaTime);
      });
    }
    /**
     * @param {Unit} attackingUnit
     */

  }, {
    key: "attack",
    value: function attack(attackingUnit) {
      var _this2 = this;

      if (attackingUnit.isDead()) {
        return;
      }

      this.scene.intervals.setTimeout(function () {
        var gameTime = _this2.scene.intervals.getTimePassed();

        if (attackingUnit.isAttackInterrupted(gameTime)) {
          attackingUnit.releaseAttack(gameTime);
          return;
        }

        var attackedUnits = _this2.getUnits().filter(function (gameObject) {
          return gameObject !== attackingUnit && gameObject.isAlive() && gameObject.isEnemy(attackingUnit) && gameObject.position.distanceTo(attackingUnit.position) < 2;
        });

        attackedUnits.forEach(function (collisionGameObject) {
          collisionGameObject.damageTaken({
            damage: attackingUnit.params.damage,
            unit: attackingUnit
          }, gameTime);
        }); // if (attackedUnits.length) {
        //     this.scene.audio.playSound(attackingUnit.position, 'Attack Soft');
        // }
      }, attackingUnit.getAttackTimeout());
    }
    /**
     * @param {Unit} firingGameObject
     */

  }, {
    key: "fire",
    value: function fire(firingGameObject) {
      var _this3 = this;

      if (firingGameObject.isDead()) {
        return;
      }

      var createLightCube = function createLightCube(left) {
        return _this3.scene.models.createCube({
          x: 0.02,
          y: 0.02,
          z: 0.3,
          emissive: '#ff0000',
          position: new THREE.Vector3(0.05 - Number(left) * 0.1, 0, 0),
          noScene: true
        });
      };

      var object = new THREE.Object3D();
      object.position.copy(firingGameObject.getFireInitialPosition());
      object.quaternion.copy(firingGameObject.getFireInitialRotation());
      object.add(createLightCube(true));
      object.add(createLightCube(false));
      this.scene.add(object);
      var fireGameObject = this.hookGameObject(new _GameObjects_Fire__WEBPACK_IMPORTED_MODULE_3__["default"]({
        object: object,
        throttling: new THREE.Vector3(1, 1, 1),
        speed: firingGameObject.params.fireShellSpeed,
        damage: firingGameObject.params.fireDamage,
        parent: firingGameObject,
        checkWay: this.scene.colliders.checkWay,
        getCollisions: function getCollisions() {
          return _this3.gameObjects.filter(function (gameObject) {
            return gameObject instanceof _GameObjects_Unit__WEBPACK_IMPORTED_MODULE_4__["default"] && gameObject.isAlive() && fireGameObject.params.parent !== gameObject && fireGameObject.position.distanceTo(gameObject.position) < 3;
          });
        },
        destroy: function destroy() {
          return _this3.destroyGameObject(fireGameObject);
        }
      }));
      this.scene.intervals.setTimeout(function () {
        return _this3.destroyGameObject(fireGameObject);
      }, 2000); // this.scene.audio.playSound(firingGameObject.position, 'Lasers');
    }
  }, {
    key: "createItem",
    value: function createItem(_ref) {
      var _this4 = this;

      var _ref$scale = _ref.scale,
          scale = _ref$scale === void 0 ? 1.5 : _ref$scale,
          _ref$model = _ref.model,
          model = _ref$model === void 0 ? 'item-heal' : _ref$model,
          _ref$position = _ref.position,
          position = _ref$position === void 0 ? {} : _ref$position,
          canPickup = _ref.canPickup,
          onPickup = _ref.onPickup;
      this.scene.models.loadGLTF({
        baseUrl: './assets/models/items/' + model,
        noScene: true,
        callback: function callback(loadedObject) {
          var positionVector = new THREE.Vector3(position.x || 0, position.y || 0, position.z || 0);
          loadedObject.scene.scale.set(scale, scale, scale);
          loadedObject.scene.traverse(function (child) {
            if (child.isMesh) {
              child.material.transparent = true;
              child.material.alphaTest = 0.5;
            }
          });
          loadedObject.scene.position.set(positionVector.x, positionVector.y, positionVector.z);

          _this4.scene.scene.add(loadedObject.scene);

          var gameItem = new _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_5__["default"]({
            object: loadedObject.scene,
            animations: loadedObject.animations
          });

          _this4.scene.gameObjectsService.hookGameObject(gameItem);

          var checkPickup = function checkPickup() {
            _this4.scene.intervals.setTimeout(function () {
              var getPriority = function getPriority(unit) {
                return 1 / Math.ceil(positionVector.distanceTo(unit.position));
              };

              var nearUnits = _this4.scene.units.getAliveUnits().filter(function (unit) {
                return (!canPickup || canPickup(unit)) && positionVector.distanceTo(unit.position) < 2;
              }).sort(function (unitA, unitB) {
                return getPriority(unitB) - getPriority(unitA);
              });

              if (nearUnits.length) {
                if (onPickup) {
                  onPickup(nearUnits[0]);
                }

                gameItem.animationState.isDie = true;

                _this4.scene.intervals.setTimeout(function () {
                  return _this4.scene.gameObjectsService.destroyGameObject(gameItem);
                }, 500);
              } else {
                checkPickup();
              }
            }, 1000);
          };

          checkPickup();
        }
      });
    }
    /**
     * @param {GameObject} gameObject
     */

  }, {
    key: "hookGameObject",
    value: function hookGameObject(gameObject) {
      this.gameObjects.push(gameObject);
      gameObject.__game_object_id = this.nextGameObjectId++;
      return gameObject;
    }
  }, {
    key: "removeAll",
    value: function removeAll() {
      while (this.gameObjects.length) {
        this.destroyGameObject(this.gameObjects[0]);
      }
    }
  }, {
    key: "removeAllExceptPlayer",
    value: function removeAllExceptPlayer() {
      var _this5 = this;

      var getNextNonPlayerIndex = function getNextNonPlayerIndex() {
        return _this5.gameObjects.findIndex(function (go) {
          return go !== _this5.scene.getPlayer();
        });
      };

      var removeIdx = getNextNonPlayerIndex();

      while (removeIdx > -1) {
        var gameObject = this.gameObjects[removeIdx];
        this.gameObjects.splice(removeIdx, 1);
        this.removeGameObjectFromScene(gameObject);
        removeIdx = getNextNonPlayerIndex();
      }
    }
    /**
     * @param {GameObject} gameObject
     */

  }, {
    key: "destroyGameObject",
    value: function destroyGameObject(gameObject) {
      var index = this.gameObjects.indexOf(gameObject);

      if (index > -1) {
        this.gameObjects.splice(index, 1);
      }

      this.removeGameObjectFromScene(gameObject);
    }
    /**
     * @param {GameObject} gameObject
     */

  }, {
    key: "removeGameObjectFromScene",
    value: function removeGameObjectFromScene(gameObject) {
      var parent = gameObject.object && gameObject.object.parent || this.scene;

      if (parent.remove) {
        parent.remove(gameObject.object);
      } else {
        console.error('Cannot find object parent to remove the object', gameObject);
      }
    }
  }, {
    key: "getUnits",
    value: function getUnits() {
      return this.gameObjects.filter(function (go) {
        return go instanceof _GameObjects_Unit__WEBPACK_IMPORTED_MODULE_4__["default"];
      });
    }
  }]);

  return GameObjectsService;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/AI.js":
/*!******************************************!*\
  !*** ../client/src/js/GameObjects/AI.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AI; });
/* harmony import */ var _FiringUnit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FiringUnit */ "../client/src/js/GameObjects/FiringUnit.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var AI = /*#__PURE__*/function (_FiringUnit) {
  _inherits(AI, _FiringUnit);

  var _super = _createSuper(AI);

  function AI() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AI);

    _this = _super.call(this, _objectSpread({
      speed: 0.5,
      damage: 10,
      mas: 1,
      hp: 100,
      name: 'Unnamed Unit',
      fraction: 'neutral',
      fireTimeout: 1.5,
      attackTimeout: 1.5,
      jumpTimeout: 1.5,
      startRunTimeout: 1,
      nextPointUpdateTimeout: 0.1,
      updateTargetTimeout: 3
    }, params));
    var _this$params = _this.params,
        hp = _this$params.hp,
        damage = _this$params.damage,
        speed = _this$params.speed;
    _this.params.bounty = hp / 4 + damage + speed * 30;
    _this.lastRun = 0;
    _this.lastTargetUpdate = 0;
    _this.lastNextPointUpdate = 0;
    _this.lastJumpTimestamp = 0;
    _this.isRunning = false;
    _this.isAttack = false;
    return _this;
  }

  _createClass(AI, [{
    key: "update",
    value: function update(time, deltaTime) {
      var _this2 = this;

      _get(_getPrototypeOf(AI.prototype), "update", this).call(this, time, deltaTime);

      if (this.isDead()) {
        return;
      }

      if (this.params.findTarget && this.isUpdateTargetReleased(time)) {
        this.params.target = this.params.findTarget();
      }

      var _this$params2 = this.params,
          object = _this$params2.object,
          target = _this$params2.target,
          acceleration = _this$params2.acceleration,
          speed = _this$params2.speed,
          getNextPoint = _this$params2.getNextPoint;

      if (!this.params.fromNetwork) {
        if (target) {
          if (getNextPoint) {
            if (this.isNextPointUpdateReleased(time)) {
              this.lastNextPointUpdate = time;
              this.nextPoint = getNextPoint(this.position, target.position);
            }
          } else {
            this.nextPoint = target.position;
          }
        }

        var isTargetNear = target && object.position.distanceTo(target.position) < 1.75;
        this.isAttack = isTargetNear && this.isEnemy(target) && target.isAlive();

        if (this.isAttack) {
          this.rotateToPosition(target.position);
        } else if (this.nextPoint) {
          this.rotateToPosition(this.nextPoint);
        }

        var isNextPointNear = !this.nextPoint;
        this.isRunning = target && !isTargetNear && !isNextPointNear && (this.isRunning || this.isRunReleased(time)) && this.isAttackReleased(time) && this.isHitReleased(time);
      }

      if (this.isAttack) {
        this.attack();
      }

      this.animationState.isMovingForward = this.isRunning && this.isAcceleration();

      if (this.isRunning) {
        var checkWay = function checkWay(jumpHeight) {
          var _this2$params$acceler = _this2.params.acceleration,
              dx = _this2$params$acceler.x,
              dy = _this2$params$acceler.y,
              dz = _this2$params$acceler.z;
          return _this2.checkWay(dx, dy + jumpHeight, dz);
        };

        this.lastRun = time;
        acceleration.add(this.getForward().multiplyScalar(speed * 0.1 * (deltaTime * 0.06)));
        var isJumpNeeded = this.isGrounded && (acceleration.x || acceleration.z) && time - this.lastJumpTimestamp > this.params.jumpTimeout * 1000 && !checkWay(0.1) && checkWay(1.5);

        if (isJumpNeeded) {
          this.lastJumpTimestamp = time;
          acceleration.y += 0.25;
        }
      }
    }
  }, {
    key: "rotateToPosition",
    value: function rotateToPosition(position) {
      var object = this.params.object;
      var rotationToTargetRadians = Math.atan2(position.x - object.position.x, position.z - object.position.z); // this.animationState.isRotateLeft = rotationToTargetRadians - object.rotation.y > 0.1;
      // this.animationState.isRotateRight = rotationToTargetRadians - object.rotation.y < -0.1;

      var targetQuaternion = new THREE.Quaternion();
      targetQuaternion.setFromEuler(object.rotation.clone().set(0, rotationToTargetRadians, 0));
      object.quaternion.slerp(targetQuaternion, 0.1);
    }
  }, {
    key: "isAcceleration",
    value: function isAcceleration() {
      return Math.abs(this.params.acceleration.x) + Math.abs(this.params.acceleration.y) + Math.abs(this.params.acceleration.z) > 0.01;
    }
  }, {
    key: "isRunReleased",
    value: function isRunReleased(time) {
      return time - this.lastRun > this.params.startRunTimeout * 1000;
    }
  }, {
    key: "isNextPointUpdateReleased",
    value: function isNextPointUpdateReleased(time) {
      return time - this.lastNextPointUpdate > this.params.nextPointUpdateTimeout * 1000;
    }
  }, {
    key: "isUpdateTargetReleased",
    value: function isUpdateTargetReleased(time) {
      return time - this.lastTargetUpdate > this.params.updateTargetTimeout * 1000;
    }
  }, {
    key: "damageTaken",
    value: function damageTaken() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          damage = _ref.damage,
          attacker = _ref.unit;

      var time = arguments.length > 1 ? arguments[1] : undefined;

      _get(_getPrototypeOf(AI.prototype), "damageTaken", this).call(this, {
        damage: damage,
        unit: attacker
      }, time);

      if (!this.params.target) {
        this.params.target = attacker;
        this.lastTargetUpdate = time;
      }
    }
  }]);

  return AI;
}(_FiringUnit__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/AnimatedGameObject.js":
/*!**********************************************************!*\
  !*** ../client/src/js/GameObjects/AnimatedGameObject.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimatedGameObject; });
/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameObject */ "../client/src/js/GameObjects/GameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var animationNames = {
  stand: 'Stand',
  run: 'Run',
  jump: 'Jump',
  attack: 'Attack',
  rotateLeft: 'Rotate Left',
  rotateRight: 'Rotate Right',
  runLeft: 'Run Left',
  runRight: 'Run Right',
  walkBack: 'Walk Back',
  die: 'Die',
  spawn: 'Spawn',
  hit: 'Hit',
  // Complex animimations
  topRun: 'Top Run',
  bottomRun: 'Bottom Run',
  topWalkBack: 'Top Walk Back',
  bottomWalkBack: 'Bottom Walk Back',
  topAttack: 'Top Attack',
  bottomAttack: 'Bottom Attack',
  topStand: 'Top Stand',
  bottomStand: 'Bottom Stand',
  topRunRight: 'Top Run Right',
  topRunLeft: 'Top Run Left',
  topJump: 'Top Jump',
  topHit: 'Top Hit',
  bottomRunRight: 'Bottom Run Right',
  bottomRunLeft: 'Bottom Run Left',
  bottomJump: 'Bottom Jump',
  bottomHit: 'Bottom Hit',
  topDie: 'Top Die',
  bottomDie: 'Bottom Die',
  topSpawn: 'Top Spawn',
  bottomSpawn: 'Bottom Spawn'
};
var topAnimations = ['topRun', 'topWalkBack', 'topAttack', 'topStand', 'topRunRight', 'topRunLeft', 'topJump', 'topHit', 'topDie'];
var bottomAnimations = ['bottomRun', 'bottomWalkBack', 'bottomAttack', 'bottomStand', 'bottomRunRight', 'bottomRunLeft', 'bottomJump', 'bottomHit', 'bottomDie'];
var topBones = ['Right_Forearm', 'Right_Arm', 'Right_Hand', 'Right_Hand_end', 'Right_Shoulder', 'Left_Shoulder', 'Left_Forearm', 'Left_Arm', 'Left_Hand', 'Left_Hand_end', 'Chest', 'Neck', 'Head', 'Head_end'];
var bottomBones = ['Main_Bone', 'Right_Leg', 'Right_Middle_Foot', 'Right_Foot', 'Right_Foot_end', 'Left_Leg', 'Left_Middle_Foot', 'Left_Foot', 'Left_Foot_end', 'Legs_Rotation'];

var AnimatedGameObject = /*#__PURE__*/function (_GameObject) {
  _inherits(AnimatedGameObject, _GameObject);

  var _super = _createSuper(AnimatedGameObject);

  function AnimatedGameObject() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimatedGameObject);

    _this = _super.call(this, _objectSpread({
      animationNames: _objectSpread({}, animationNames),
      topBones: [].concat(topBones),
      bottomBones: [].concat(bottomBones),
      topAnimations: [].concat(topAnimations),
      bottomAnimations: [].concat(bottomAnimations),
      spawnTimeout: 1
    }, params));
    _this.animationState = {
      isMovingForward: false,
      isMovingRight: false,
      isMovingLeft: false,
      isMovingBackward: false,
      isRotateLeft: false,
      isRotateRight: false,
      isAttack: false,
      isJump: false,
      isDie: false,
      isHit: false,
      isSpawn: true
    };
    _this.playingAnimations = {};
    _this.legsRotationY = 0;
    _this.spawnTime = 0;
    _this.mixer = new THREE.AnimationMixer(_this.params.object);

    _this.initAnimations(_this.params.animationNames);

    return _this;
  }

  _createClass(AnimatedGameObject, [{
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(AnimatedGameObject.prototype), "update", this).call(this, time, deltaTime);

      if (!this.spawnTime) {
        this.spawnTime = time;
      } else if (this.animationState.isSpawn && this.isSpawnFinished(time)) {
        this.animationState.isSpawn = false;
      }

      if (this.mixer) {
        this.mixer.update(deltaTime / 1000);
      }

      if (this.params.complexAnimations) {
        this.updateComplexAnimations();
      } else {
        var animation = this.getCurrentAnimation();
        animation && this.playAnimation(animation);
      }
    }
  }, {
    key: "playAnimation",
    value: function playAnimation(animation) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          force = _ref.force;

      if (!animation || !animation._clip) return;
      var animationName = animation._clip.name;
      var shouldUpdate = this.playingAnimationName !== animationName || force;

      if (shouldUpdate) {
        this.playingAnimationName = animationName;
        animation.reset();
        animation.play();

        if (this.playingAnimation) {
          var from = this.playingAnimation;
          from.enabled = true;
          animation.enabled = true;
          from.crossFadeTo(animation, 0.3);
        }

        this.playingAnimation = animation;
      }
    }
  }, {
    key: "initAnimations",
    value: function initAnimations(animationNames) {
      var _this2 = this;

      var _this$params = this.params,
          topAnimations = _this$params.topAnimations,
          bottomAnimations = _this$params.bottomAnimations,
          topBones = _this$params.topBones,
          bottomBones = _this$params.bottomBones,
          complexAnimations = _this$params.complexAnimations;
      this.animations = Object.keys(animationNames).reduce(function (result, key) {
        var excludedBones = [];

        if (complexAnimations) {
          if (topAnimations.includes(key)) {
            excludedBones = bottomBones;
          } else if (bottomAnimations.includes(key)) {
            excludedBones = topBones;
          }
        }

        var modelAnimation = _this2.findModelAnimation(animationNames[key], {
          excludedBones: excludedBones
        });

        var initedAnimation = _this2.createClipAction(modelAnimation);

        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, key, initedAnimation));
      }, {});
      var _this$animations = this.animations;
      _this$animations = _this$animations === void 0 ? {} : _this$animations;
      var jump = _this$animations.jump,
          attack = _this$animations.attack,
          topAttack = _this$animations.topAttack,
          die = _this$animations.die,
          spawn = _this$animations.spawn,
          topDie = _this$animations.topDie,
          bottomDie = _this$animations.bottomDie,
          topJump = _this$animations.topJump,
          bottomJump = _this$animations.bottomJump,
          bottomAttack = _this$animations.bottomAttack;
      [jump, die, spawn, topDie, bottomDie, topJump, bottomJump].forEach(function (clampAnimation) {
        if (clampAnimation) {
          clampAnimation.setLoop(THREE.LoopOnce, 0);
          clampAnimation.clampWhenFinished = true;
        }
      });
      [attack, topAttack, bottomAttack].forEach(function (attackAnimation) {
        if (attackAnimation) {
          attackAnimation.setDuration(_this2.params.attackTimeout);
        }
      });
    }
  }, {
    key: "createClipAction",
    value: function createClipAction(action) {
      return action && this.mixer.clipAction(action).stop();
    }
  }, {
    key: "findModelAnimation",
    value: function findModelAnimation(name) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$excludedBones = _ref2.excludedBones,
          excludedBones = _ref2$excludedBones === void 0 ? [] : _ref2$excludedBones;

      var _this$params$animatio = this.params.animations,
          animations = _this$params$animatio === void 0 ? [] : _this$params$animatio;
      var animation = animations.find(function (animation) {
        return animation.name === name;
      });

      if (animation && excludedBones.length) {
        return this.clearAnimationBones(animation, excludedBones);
      }

      return animation;
    }
  }, {
    key: "isMoving",
    value: function isMoving() {
      return this.animationState.isMovingLeft || this.animationState.isMovingRight || this.animationState.isMovingForward || this.animationState.isMovingBackward;
    }
  }, {
    key: "isSpawnFinished",
    value: function isSpawnFinished(time) {
      return time - this.spawnTime > this.params.spawnTimeout * 1000;
    }
  }, {
    key: "clearAnimationBones",
    value: function clearAnimationBones(animation, bones) {
      if (animation) {
        var getBoneName = function getBoneName(item) {
          return item.name.split('.')[0];
        },
            isNotExcluded = function isNotExcluded(item) {
          return !bones.includes(getBoneName(item));
        };

        animation.tracks = animation.tracks.filter(isNotExcluded);
        return animation;
      }
    }
  }, {
    key: "updateComplexAnimations",
    value: function updateComplexAnimations() {
      var _this$animations2 = this.animations;
      _this$animations2 = _this$animations2 === void 0 ? {} : _this$animations2;
      var topAttack = _this$animations2.topAttack,
          bottomAttack = _this$animations2.bottomAttack,
          topWalkBack = _this$animations2.topWalkBack,
          bottomWalkBack = _this$animations2.bottomWalkBack,
          topRun = _this$animations2.topRun,
          bottomRun = _this$animations2.bottomRun,
          topRunRight = _this$animations2.topRunRight,
          topRunLeft = _this$animations2.topRunLeft,
          topStand = _this$animations2.topStand,
          bottomStand = _this$animations2.bottomStand,
          topJump = _this$animations2.topJump,
          bottomJump = _this$animations2.bottomJump,
          topHit = _this$animations2.topHit,
          bottomHit = _this$animations2.bottomHit,
          topDie = _this$animations2.topDie,
          bottomDie = _this$animations2.bottomDie,
          topSpawn = _this$animations2.topSpawn,
          bottomSpawn = _this$animations2.bottomSpawn;
      var _this$animationState = this.animationState,
          isAttack = _this$animationState.isAttack,
          isMovingRight = _this$animationState.isMovingRight,
          isMovingLeft = _this$animationState.isMovingLeft,
          isMovingBackward = _this$animationState.isMovingBackward,
          isMovingForward = _this$animationState.isMovingForward,
          isJump = _this$animationState.isJump,
          isDie = _this$animationState.isDie,
          isHit = _this$animationState.isHit,
          isSpawn = _this$animationState.isSpawn;
      var playingAnimations = {
        top: isDie && topDie || isHit && topHit || isAttack && topAttack || isJump && topJump || isMovingBackward && isMovingRight && topRunLeft || isMovingBackward && isMovingLeft && topRunRight || isMovingBackward && topWalkBack || isMovingRight && topRunRight || isMovingLeft && topRunLeft || isMovingForward && topRun || isSpawn && topSpawn || topStand,
        bottom: isDie && bottomDie || isJump && bottomJump || isMovingBackward && isMovingRight && bottomWalkBack || isMovingBackward && isMovingLeft && bottomWalkBack || isMovingBackward && bottomWalkBack || isMovingRight && bottomRun || isMovingLeft && bottomRun || isMovingForward && bottomRun || isAttack && bottomAttack || isHit && bottomHit || isSpawn && bottomSpawn || bottomStand
      };
      var legsRotationBone = this.getChildByName('Legs_Rotation');

      if (legsRotationBone) {
        var rotation = legsRotationBone.rotation;
        var y = -0.3;

        if (isMovingLeft) {
          y = isMovingForward ? 0.5 : isMovingBackward ? -0.7 : 1;
        } else if (isMovingRight) {
          y = isMovingForward ? -1.2 : isMovingBackward ? 0.4 : -1.7;
        }

        this.legsRotationY = this.legsRotationY - (this.legsRotationY - y) / 10;
        rotation.set(rotation.x, this.legsRotationY, rotation.z);
      }

      this.blendAnimations(playingAnimations);
    }
  }, {
    key: "blendAnimations",
    value: function blendAnimations(_ref3) {
      var top = _ref3.top,
          bottom = _ref3.bottom;
      if (!(top && bottom && top._clip && bottom._clip)) return;

      var getAnimationName = function getAnimationName(a) {
        return a._clip.name;
      },
          playAnimation = function playAnimation(fromAnimation, animation) {
        var animationName = getAnimationName(animation);
        var fromAnimationName = fromAnimation && getAnimationName(fromAnimation);

        if (fromAnimationName !== animationName) {
          animation.reset();
          animation.play();

          if (fromAnimation) {
            fromAnimation.crossFadeTo(animation, 0.3);
          }
        }
      };

      playAnimation(this.playingAnimations.top, top);
      playAnimation(this.playingAnimations.bottom, bottom);
      this.playingAnimations.top = top;
      this.playingAnimations.bottom = bottom;
    }
  }, {
    key: "getCurrentAnimation",
    value: function getCurrentAnimation() {
      var _this$animations3 = this.animations;
      _this$animations3 = _this$animations3 === void 0 ? {} : _this$animations3;
      var stand = _this$animations3.stand,
          attack = _this$animations3.attack,
          walkBack = _this$animations3.walkBack,
          runLeft = _this$animations3.runLeft,
          runRight = _this$animations3.runRight,
          run = _this$animations3.run,
          jump = _this$animations3.jump,
          hit = _this$animations3.hit,
          rotateLeft = _this$animations3.rotateLeft,
          rotateRight = _this$animations3.rotateRight,
          die = _this$animations3.die,
          spawn = _this$animations3.spawn;
      var _this$animationState2 = this.animationState,
          isAttack = _this$animationState2.isAttack,
          isMovingForward = _this$animationState2.isMovingForward,
          isJump = _this$animationState2.isJump,
          isMovingLeft = _this$animationState2.isMovingLeft,
          isMovingRight = _this$animationState2.isMovingRight,
          isMovingBackward = _this$animationState2.isMovingBackward,
          isRotateLeft = _this$animationState2.isRotateLeft,
          isRotateRight = _this$animationState2.isRotateRight,
          isDie = _this$animationState2.isDie,
          isHit = _this$animationState2.isHit,
          isSpawn = _this$animationState2.isSpawn;
      return isDie && die || isHit && hit || isAttack && attack || isJump && jump || isMovingBackward && walkBack || isMovingLeft && runLeft || isMovingRight && runRight || isMovingForward && run || isRotateLeft && rotateLeft || isRotateRight && rotateRight || isSpawn && spawn || stand;
    }
  }]);

  return AnimatedGameObject;
}(_GameObject__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/Fire.js":
/*!********************************************!*\
  !*** ../client/src/js/GameObjects/Fire.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Fire; });
/* harmony import */ var _Unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Unit */ "../client/src/js/GameObjects/Unit.js");
/* harmony import */ var _MovingGameObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MovingGameObject */ "../client/src/js/GameObjects/MovingGameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Fire = /*#__PURE__*/function (_MovingGameObject) {
  _inherits(Fire, _MovingGameObject);

  var _super = _createSuper(Fire);

  function Fire() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Fire);

    _this = _super.call(this, params);

    _this.params.acceleration.add(_this.getForward().multiplyScalar(_this.params.speed * 0.1));

    return _this;
  }

  _createClass(Fire, [{
    key: "update",
    value: function update(time, deltaTime) {
      var _this2 = this;

      _get(_getPrototypeOf(Fire.prototype), "update", this).call(this, time, deltaTime);

      if (this.params.getCollisions) {
        var collisions = this.params.getCollisions(this);
        collisions.filter(function (collisionGameObject) {
          return collisionGameObject instanceof _Unit__WEBPACK_IMPORTED_MODULE_0__["default"] && collisionGameObject.isEnemy(_this2.params.parent);
        }).forEach(function (collisionGameObject) {
          return collisionGameObject.damageTaken({
            damage: _this2.params.damage,
            unit: _this2.params.parent
          }, time);
        });

        if (collisions.length && this.params.destroy) {
          this.params.destroy(this);
        }
      }
    }
  }]);

  return Fire;
}(_MovingGameObject__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/FiringUnit.js":
/*!**************************************************!*\
  !*** ../client/src/js/GameObjects/FiringUnit.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FiringUnit; });
/* harmony import */ var _Unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Unit */ "../client/src/js/GameObjects/Unit.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var FiringUnit = /*#__PURE__*/function (_Unit) {
  _inherits(FiringUnit, _Unit);

  var _super = _createSuper(FiringUnit);

  function FiringUnit() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, FiringUnit);

    _this = _super.call(this, _objectSpread({
      fireDamage: 10,
      fireTimeout: 1.5,
      fireShellSpeed: 3
    }, params));
    _this.shouldFire = false;
    _this.latestFire = 0;
    return _this;
  }

  _createClass(FiringUnit, [{
    key: "getFireInitialPosition",
    value: function getFireInitialPosition() {
      return this.position.clone().add(this.getUp().multiplyScalar(1.5).add(this.getForward().multiplyScalar(0.3)));
    }
  }, {
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(FiringUnit.prototype), "update", this).call(this, time, deltaTime);

      if (this.isDead()) {
        return;
      }

      this.isFire = false;

      if (this.shouldFire && this.params.fire && this.isFireReleased(time) && this.isAttackReleased(time)) {
        this.isFire = true;
        this.shouldFire = false;
        this.latestFire = time;
        this.params.fire();
      } else {
        this.shouldFire = false;
      }
    }
  }, {
    key: "isFireReleased",
    value: function isFireReleased(time) {
      return time - this.latestFire >= this.params.fireTimeout * 1000;
    }
  }, {
    key: "fire",
    value: function fire() {
      this.shouldFire = true;
    }
  }]);

  return FiringUnit;
}(_Unit__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/GameObject.js":
/*!**************************************************!*\
  !*** ../client/src/js/GameObjects/GameObject.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GameObject; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var GameObject = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(GameObject, _AutoBindMethods);

  var _super = _createSuper(GameObject);

  function GameObject() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GameObject);

    _this = _super.call(this);
    _this.params = _objectSpread({}, params);
    _this.object = params.object;

    if (params.object) {
      _this.position = params.object.position;
      _this.rotation = params.object.rotation;
    }

    _this.events = {};
    return _this;
  }

  _createClass(GameObject, [{
    key: "update",
    value: function update() {}
    /**
     * @param {string} eventName
     * @param {object[]} args
     */

  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(eventName) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this.events[eventName]) {
        this.events[eventName].forEach(function (callback) {
          return callback.apply(void 0, args);
        });
      }
    }
    /**
     * @param {string} eventName
     * @param {function} callback
     */

  }, {
    key: "addEventListener",
    value: function addEventListener(eventName, callback) {
      if (typeof callback === 'function') {
        if (this.events[eventName]) {
          this.events[eventName].push(callback);
        } else {
          this.events[eventName] = [callback];
        }
      }
    }
  }, {
    key: "getChildByName",
    value: function getChildByName(name) {
      return this.object.getObjectByName(name, true);
    }
  }, {
    key: "getChildDirection",
    value: function getChildDirection(arg) {
      var vector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3(0, 0, 1);
      var child = typeof arg === 'string' ? this.getChildByName(arg) : arg;
      return vector.applyQuaternion(this.getChildRotation(child));
    }
  }, {
    key: "getChildPosition",
    value: function getChildPosition(arg) {
      var child = typeof arg === 'string' ? this.getChildByName(arg) : arg;
      return new THREE.Vector3().setFromMatrixPosition(child.matrixWorld);
    }
  }, {
    key: "getChildRotation",
    value: function getChildRotation(arg) {
      var child = typeof arg === 'string' ? this.getChildByName(arg) : arg;
      var target = new THREE.Quaternion();
      child.getWorldQuaternion(target);
      return target;
    }
  }]);

  return GameObject;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/MovingGameObject.js":
/*!********************************************************!*\
  !*** ../client/src/js/GameObjects/MovingGameObject.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MovingGameObject; });
/* harmony import */ var _AnimatedGameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimatedGameObject */ "../client/src/js/GameObjects/AnimatedGameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var MovingGameObject = /*#__PURE__*/function (_AnimatedGameObject) {
  _inherits(MovingGameObject, _AnimatedGameObject);

  var _super = _createSuper(MovingGameObject);

  function MovingGameObject() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MovingGameObject);

    return _super.call(this, _objectSpread({
      speed: 0.1,
      throttling: new THREE.Vector3(0.5, 0.95, 0.5),
      acceleration: new THREE.Vector3(),
      mas: 0,
      checkWay: function checkWay() {
        return true;
      }
    }, params));
  }

  _createClass(MovingGameObject, [{
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(MovingGameObject.prototype), "update", this).call(this, time, deltaTime);

      var _this$params = this.params,
          acceleration = _this$params.acceleration,
          throttling = _this$params.throttling;

      if (this.params.mas) {
        acceleration.y -= 0.01;
        this.isGrounded = !this.checkWay(0, -0.2, 0);
        this.animationState.isJump = !this.isGrounded;
      }

      var isX = Boolean(acceleration.x) && this.checkWay(acceleration.x, 0, 0);
      var isY = Boolean(acceleration.y) && this.checkWay(0, acceleration.y, 0);
      var isZ = Boolean(acceleration.z) && this.checkWay(0, 0, acceleration.z);

      if (!isX || !isY || !isZ) {
        if (!this.params.mas) {
          // Stop object smoothly because of Collider hit
          acceleration.multiplyScalar(0.75);
        }

        if (!isX) {
          var isClimbing = acceleration.x && acceleration.y <= 0 && this.checkWay(acceleration.x, 0.04, 0);

          if (isClimbing) {
            acceleration.y = 0.04 / throttling.y;
          } else {
            acceleration.x = 0;
          }
        }

        if (!isY) {
          acceleration.y = 0;
        }

        if (!isZ) {
          var _isClimbing = acceleration.z && acceleration.y <= 0 && this.checkWay(0, 0.04, acceleration.z);

          if (_isClimbing) {
            acceleration.y = 0.04 / throttling.y;
          } else {
            acceleration.z = 0;
          }
        }
      }

      acceleration.x *= throttling.x;
      acceleration.y *= throttling.y;
      acceleration.z *= throttling.z;
      var isMoving = Math.abs(acceleration.x) > 0.001 || Math.abs(acceleration.y) > 0.001 || Math.abs(acceleration.z) > 0.001;

      if (isMoving) {
        // acceleration.multiplyScalar(deltaTime * 60)
        this.position.add(acceleration);
      }
    }
  }, {
    key: "checkWay",
    value: function checkWay() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var position = this.position,
          checkWay = this.params.checkWay;
      var nextPosition = new THREE.Vector3(position.x + x, position.y + y + 0.1, position.z + z);
      return checkWay(nextPosition, this);
    }
  }, {
    key: "getLeft",
    value: function getLeft() {
      return this.getDirection(new THREE.Vector3(1, 0, 0));
    }
  }, {
    key: "getUp",
    value: function getUp() {
      return this.getDirection(new THREE.Vector3(0, 1, 0));
    }
  }, {
    key: "getForward",
    value: function getForward() {
      return this.getDirection(new THREE.Vector3(0, 0, 1));
    }
    /**
     * @param {THREE.Vector3} direction
     */

  }, {
    key: "getDirection",
    value: function getDirection(direction) {
      direction.applyQuaternion(this.object.quaternion);
      return direction;
    }
  }, {
    key: "getScalarAcceleration",
    value: function getScalarAcceleration() {
      return this.params.acceleration.toArray().map(Math.abs).reduce(function (r, v) {
        return r + v;
      }, 0);
    }
  }]);

  return MovingGameObject;
}(_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/Player.js":
/*!**********************************************!*\
  !*** ../client/src/js/GameObjects/Player.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Player; });
/* harmony import */ var _FiringUnit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FiringUnit */ "../client/src/js/GameObjects/FiringUnit.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Player = /*#__PURE__*/function (_FiringUnit) {
  _inherits(Player, _FiringUnit);

  var _super = _createSuper(Player);

  function Player() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Player);

    _this = _super.call(this, _objectSpread({
      speed: 0.54,
      fireTimeout: 1,
      fireDamage: 25,
      damage: 50,
      hp: 100,
      experience: 0,
      unspentTalents: 0,
      money: 500,
      isFire: false,
      mas: 1,
      level: 1,
      jumpTimeout: 0.9,
      fraction: 'friendly',
      sensitivity: 1
    }, params));
    _this.lastJumpTimestamp = 0;
    _this.rotationAcceleration = 0;
    console.log('Player', _assertThisInitialized(_this));
    params.onLevelUp && _this.addEventListener('onLevelUp', params.onLevelUp);
    return _this;
  }

  _createClass(Player, [{
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(Player.prototype), "update", this).call(this, time, deltaTime);

      if (this.isDead()) {
        return;
      }

      var _this$params = this.params,
          input = _this$params.input,
          object = _this$params.object,
          acceleration = _this$params.acceleration,
          fromNetwork = _this$params.fromNetwork;
      acceleration.add(this.getMovingAcceleration(time, deltaTime));

      if (input.attack1) {
        this.attack();
      }

      if (input.attack2) {
        this.fire();
      }

      this.animationState.isMovingLeft = input.horizontal === -1;
      this.animationState.isMovingRight = input.horizontal === 1;
      this.animationState.isMovingForward = input.vertical === 1;
      this.animationState.isMovingBackward = input.vertical === -1;

      if (!fromNetwork) {
        if (input.isThirdPerson) {
          if (input.look.horizontal) {
            var horizontalLook = input.look.horizontal;
            this.animationState.isRotateLeft = horizontalLook < 0;
            this.animationState.isRotateRight = horizontalLook > 0;
            this.rotationAcceleration += -horizontalLook / 5000 * input.look.sensitivity;
            input.resetHorizontalLook();
          }

          var CALC_ROTATE_THRESHOLD = 0.0000001;

          if (Math.abs(this.rotationAcceleration) > CALC_ROTATE_THRESHOLD) {
            object.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), this.rotationAcceleration);
            this.rotationAcceleration *= 0.7;
          }
        } else {
          var deltaX = window.innerWidth / 2 - input.cursor.x;
          var deltaY = input.cursor.y - window.innerHeight / 2;
          var rotationY = Math.atan2(deltaY, deltaX);
          this.animationState.isRotateLeft = rotationY > object.rotation.y;
          this.animationState.isRotateRight = rotationY < object.rotation.y;
          object.rotation.set(0, rotationY, 0);
        }
      }
    }
  }, {
    key: "getUnspentTalents",
    value: function getUnspentTalents() {
      return this.params.unspentTalents;
    }
  }, {
    key: "decreaseUnspentTalents",
    value: function decreaseUnspentTalents() {
      return this.params.unspentTalents--;
    }
  }, {
    key: "getFireInitialPosition",
    value: function getFireInitialPosition() {
      var head = this.getChildByName('Head');
      var headForward = this.getChildDirection(head, new THREE.Vector3(0, 0, 1));
      var headUp = new THREE.Vector3(0, 1, 0);
      headUp.applyQuaternion(head.quaternion);
      return this.getChildPosition(head).add(headUp.multiplyScalar(0.15)).add(headForward.multiplyScalar(0.25));
    }
  }, {
    key: "getFireInitialRotation",
    value: function getFireInitialRotation() {
      return this.getChildRotation('Head');
    }
  }, {
    key: "addExperience",
    value: function addExperience(experience) {
      this.params.experience += experience;
      var level = this.getLevel();

      if (this.params.level !== level) {
        var levelsUp = level - this.params.level;
        this.params.level = level;
        this.params.unspentTalents += 3 * levelsUp;
        this.params.hp = this.params.hpMax;
        this.dispatchEvent('onLevelUp', level);
      }
    }
  }, {
    key: "getExperience",
    value: function getExperience() {
      return this.params.experience;
    }
  }, {
    key: "getLevelExperience",
    value: function getLevelExperience() {
      return Math.pow(this.getLevel(), 2) * 100;
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return Math.floor(Math.sqrt(this.params.experience / 100)) + 1;
    }
  }, {
    key: "getMovingAcceleration",
    value: function getMovingAcceleration(time, deltaTime) {
      var _this$params$input = this.params.input,
          horizontal = _this$params$input.horizontal,
          vertical = _this$params$input.vertical,
          jump = _this$params$input.jump;
      var speed = vertical && horizontal ? this.params.speed * 0.1 * 0.7 * (deltaTime * 0.06) : this.params.speed * 0.1 * (deltaTime * 0.06);
      var addForward = vertical === 1 ? speed : vertical === -1 ? -speed * 0.6 : 0;
      var addSide = vertical === -1 ? -horizontal * speed * 0.6 : -horizontal * speed;
      var isJump = time - this.lastJumpTimestamp > this.params.jumpTimeout * 1000 && jump && this.isGrounded;

      if (isJump) {
        this.lastJumpTimestamp = time;
      }

      return this.getDirection(new THREE.Vector3(addSide, Number(isJump) * 0.25, addForward));
    }
  }]);

  return Player;
}(_FiringUnit__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/Unit.js":
/*!********************************************!*\
  !*** ../client/src/js/GameObjects/Unit.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Unit; });
/* harmony import */ var _MovingGameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MovingGameObject */ "../client/src/js/GameObjects/MovingGameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Unit = /*#__PURE__*/function (_MovingGameObject) {
  _inherits(Unit, _MovingGameObject);

  var _super = _createSuper(Unit);

  function Unit() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Unit);

    _this = _super.call(this, _objectSpread({
      hp: 100,
      hpMax: params.hp || 100,
      damage: 10,
      attackTimeout: 0.9,
      hitTime: 0.3,
      attackDamageTimeout: 0.3
    }, params));
    _this.shouldAttack = false;
    _this.latestAttackTimestamp = 0;
    _this.latestHitTimestamp = 0;
    ['onDamageTaken', 'onDamageDeal', 'onKill', 'onDie'].forEach(function (eventName) {
      if (typeof params[eventName] === 'function') {
        _this.addEventListener(eventName, params[eventName]);
      }
    });
    return _this;
  }

  _createClass(Unit, [{
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(Unit.prototype), "update", this).call(this, time, deltaTime);

      if (this.isDead()) {
        return;
      }

      var hitReleased = this.isHitReleased(time);
      this.animationState.isHit = !hitReleased;

      if (this.isAttackReleased(time) && hitReleased) {
        this.animationState.isAttack = false;

        if (this.shouldAttack) {
          this.animationState.isAttack = true;
          this.latestAttackTimestamp = time;
          this.params.attack && this.params.attack();
        }
      } else {
        this.shouldAttack = false;
      }
    }
  }, {
    key: "getFraction",
    value: function getFraction() {
      return this.params.fraction;
    }
  }, {
    key: "getCollider",
    value: function getCollider(position) {
      var diffY = position.y - this.position.y;
      return Math.sqrt(Math.pow(position.x - this.position.x, 2) + Math.pow(position.z - this.position.z, 2)) < 1 && diffY >= 0 && diffY < 1.7;
    }
  }, {
    key: "releaseAttack",
    value: function releaseAttack(time) {
      this.latestAttackTimestamp = time - this.params.attackTimeout * 1000;
      this.animationState.isAttack = false;
    }
  }, {
    key: "isAttackReleased",
    value: function isAttackReleased(time) {
      return time - this.latestAttackTimestamp >= this.params.attackTimeout * 1000;
    }
  }, {
    key: "isAttackInterrupted",
    value: function isAttackInterrupted(time) {
      return time - this.latestHitTimestamp <= this.params.attackDamageTimeout * 1000;
    }
  }, {
    key: "isHitReleased",
    value: function isHitReleased(time) {
      return time - this.latestHitTimestamp >= this.params.hitTime * 1000;
    }
  }, {
    key: "attack",
    value: function attack() {
      this.shouldAttack = true;
    }
  }, {
    key: "isDead",
    value: function isDead() {
      return this.params.hp <= 0;
    }
  }, {
    key: "isAlive",
    value: function isAlive() {
      return !this.isDead();
    }
  }, {
    key: "isEnemy",
    value: function isEnemy(unit) {
      return unit.params.fraction !== this.params.fraction && unit.params.fraction !== 'neutral' && this.params.fraction !== 'neutral';
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this.params.level;
    }
  }, {
    key: "getName",
    value: function getName() {
      return this.params.name;
    }
  }, {
    key: "getAttackTimeout",
    value: function getAttackTimeout() {
      return this.params.attackDamageTimeout * 1000;
    }
  }, {
    key: "damageTaken",
    value: function damageTaken() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          damage = _ref.damage,
          attacker = _ref.unit;

      var time = arguments.length > 1 ? arguments[1] : undefined;

      if (damage && attacker) {
        this.params.hp -= damage;
        this.dispatchEvent('onDamageTaken', attacker);

        if (attacker) {
          attacker.dispatchEvent('onDamageDeal', this);
        }

        var interruptByChance = Math.random() < 0.33;
        var interruptByLevel = attacker.getLevel() - this.getLevel() > 2;
        var shouldBeInterrupted = interruptByLevel || interruptByChance;

        if (shouldBeInterrupted) {
          this.latestHitTimestamp = time;
        }

        if (this.isDead()) {
          this.die(attacker);
        }
      }
    }
  }, {
    key: "die",
    value: function die(killingUnit) {
      this.params.hp = 0;
      this.dispatchEvent('onDie', killingUnit);
      this.animationState.isDie = true;

      if (killingUnit) {
        killingUnit.dispatchEvent('onKill', this);
      }
    }
  }, {
    key: "addSpeed",
    value: function addSpeed(speed) {
      this.params.speed += speed;
    }
  }, {
    key: "addDamage",
    value: function addDamage(damage) {
      this.params.damage += damage;
    }
  }, {
    key: "addHP",
    value: function addHP(hp) {
      if (this.isAlive()) {
        this.params.hp = Math.min(this.params.hp + hp, this.params.hpMax);
      }
    }
  }, {
    key: "getMoney",
    value: function getMoney() {
      return this.params.money;
    }
  }, {
    key: "addMoney",
    value: function addMoney(money) {
      this.params.money += money;
    }
  }, {
    key: "addMaxHP",
    value: function addMaxHP(hp) {
      if (this.isAlive()) {
        this.params.hpMax += hp;
        this.params.hp += hp;
      }
    }
  }, {
    key: "getHP",
    value: function getHP() {
      return this.params.hp;
    }
  }, {
    key: "getMaxHP",
    value: function getMaxHP() {
      return this.params.hpMax;
    }
  }, {
    key: "getSpeed",
    value: function getSpeed() {
      return this.params.speed;
    }
  }, {
    key: "getDamage",
    value: function getDamage() {
      return this.params.damage;
    }
  }]);

  return Unit;
}(_MovingGameObject__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Input.js":
/*!*********************************!*\
  !*** ../client/src/js/Input.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Input; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var KEYS = {
  MOUSE_LEFT: 1,
  MOUSE_RIGHT: 3,
  SPACE: 32,
  ENTER: 13,
  ESC: 27,
  C: 67,
  W: 87,
  A: 65,
  S: 83,
  D: 68,
  X: 88,
  Z: 90,
  Q: 81,
  E: 69,
  R: 82,
  F: 70,
  V: 86,
  1: 49,
  2: 50,
  ARROW_LEFT: 37,
  ARROW_RIGHT: 39,
  ARROW_UP: 38,
  ARROW_DOWN: 40
};

var Input = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Input, _AutoBindMethods);

  var _super = _createSuper(Input);

  function Input(params) {
    var _this;

    _classCallCheck(this, Input);

    _this = _super.call(this);
    _this.params = params;
    _this.vertical = 0;
    _this.horizontal = 0;
    _this.attack1 = false;
    _this.attack2 = false;
    _this.look = {
      vertical: 0,
      horizontal: 0,
      back: false,
      sensitivity: 1
    };

    _this.resetHorizontalLook = function () {
      return _this.look.horizontal = 0;
    };

    _this.isThirdPerson = true;
    _this.cursor = {
      x: 0,
      y: 0
    };
    _this.mouse = {
      x: 0,
      y: 0
    };

    _this.addEventListeners();

    return _this;
  }

  _createClass(Input, [{
    key: "update",
    value: function update() {
      this.look.horizontal = 0;
      this.look.vertical = 0;
    }
  }, {
    key: "addEventListeners",
    value: function addEventListeners() {
      var _this2 = this;

      document.addEventListener('mousedown', function (e) {
        if (e.which === KEYS.MOUSE_LEFT) {
          _this2.attack1 = true;
        }

        if (e.which === KEYS.MOUSE_RIGHT) {
          _this2.attack2 = true;
        }
      });
      document.addEventListener('mouseup', function (e) {
        if (e.which === KEYS.MOUSE_LEFT) {
          _this2.attack1 = false;
        }

        if (e.which === KEYS.MOUSE_RIGHT) {
          _this2.attack2 = false;
        }
      });
      var timeout;
      document.addEventListener('mousemove', function (e) {
        _this2.look.horizontal += e.movementX || 0;
        _this2.look.vertical += e.movementY || 0;
        _this2.mouse.x = e.x;
        _this2.mouse.y = e.y;
        var cursorX = _this2.cursor.x + (e.movementX || 0);
        var cursorY = _this2.cursor.y + (e.movementY || 0);

        if (cursorX > 0 && cursorX < window.innerWidth) {
          _this2.cursor.x = cursorX;
        }

        if (cursorY > 0 && cursorY < window.innerHeight) {
          _this2.cursor.y = cursorY;
        }

        if (timeout !== undefined) {
          window.clearTimeout(timeout);
        }

        timeout = window.setTimeout(function () {
          document.dispatchEvent(new Event('onmousemoveend'));
        }, 100);
      });
      document.addEventListener('onmousemoveend', function (e) {
        // Horizontal look is cleaning by Player.update after rotation is applied
        // this.look.horizontal = 0;
        _this2.look.vertical = 0;
      });
      document.addEventListener('keydown', function (e) {
        switch (e.which) {
          case KEYS.ENTER:
            _this2.params.onAction && _this2.params.onAction();
            break;

          case KEYS.ESC:
            _this2.params.onExit && _this2.params.onExit();
            break;

          case KEYS.C:
            _this2.params.onSwitchCamera && _this2.params.onSwitchCamera();
            break;

          case KEYS.W:
          case KEYS.ARROW_UP:
            _this2.vertical = 1;
            break;

          case KEYS.S:
          case KEYS.ARROW_DOWN:
            _this2.vertical = -1;
            break;

          case KEYS.A:
          case KEYS.ARROW_LEFT:
            _this2.horizontal = -1;
            break;

          case KEYS.D:
          case KEYS.ARROW_RIGHT:
            _this2.horizontal = 1;
            break;

          case KEYS.X:
            _this2.look.back = true;
            break;

          case KEYS.F:
            _this2.look.cinematic = true;
            break;

          case KEYS.SPACE:
            _this2.jump = 1;
            break;
        }
      });
      document.addEventListener('keyup', function (e) {
        switch (e.which) {
          case KEYS.W:
          case KEYS.ARROW_UP:
            if (_this2.vertical === 1) {
              _this2.vertical = 0;
            }

            break;

          case KEYS.S:
          case KEYS.ARROW_DOWN:
            if (_this2.vertical === -1) {
              _this2.vertical = 0;
            }

            break;

          case KEYS.A:
          case KEYS.ARROW_LEFT:
            if (_this2.horizontal === -1) {
              _this2.horizontal = 0;
            }

            break;

          case KEYS.D:
          case KEYS.ARROW_RIGHT:
            if (_this2.horizontal === 1) {
              _this2.horizontal = 0;
            }

            break;

          case KEYS.X:
            _this2.look.back = false;
            break;

          case KEYS.F:
            _this2.look.cinematic = false;
            break;

          case KEYS.SPACE:
            _this2.jump = 0;
            break;
        }
      });
      window.addEventListener('wheel', function (e) {
        return _this2.params.onZoom && _this2.params.onZoom(e.deltaY / 100);
      });
      return this;
    }
  }]);

  return Input;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Intervals.js":
/*!*************************************!*\
  !*** ../client/src/js/Intervals.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Intervals; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Intervals = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Intervals, _AutoBindMethods);

  var _super = _createSuper(Intervals);

  function Intervals(scene) {
    var _this;

    _classCallCheck(this, Intervals);

    _this = _super.call(this);
    _this.scene = scene;
    _this.timePassed = 0;
    _this.lastFrame = 0;
    _this.intervals = [];
    _this.intervalIndex = 0;
    return _this;
  }

  _createClass(Intervals, [{
    key: "update",
    value: function update(now) {
      var _this2 = this;

      if (this.scene.ui && !this.scene.ui.isPause()) {
        this.timePassed += now - this.lastFrame;
        this.intervals.filter(function (i) {
          return _this2.timePassed - i.calledAt > i.interval;
        }).forEach(function (interval) {
          interval.calledAt = _this2.timePassed;
          interval.fn();

          if (interval.loops && --interval.loops === 0) {
            _this2.clearInterval(interval.id);
          }
        });
      }

      this.lastFrame = now;
    }
  }, {
    key: "getTimePassed",
    value: function getTimePassed() {
      return this.timePassed;
    }
  }, {
    key: "getDeltaTime",
    value: function getDeltaTime(now) {
      return now - this.lastFrame;
    }
  }, {
    key: "setInterval",
    value: function setInterval(fn, interval, immediately, loops) {
      if (fn && interval) {
        var calledAt = immediately ? this.timePassed - interval : this.timePassed;
        this.intervals.push({
          fn: fn,
          interval: interval,
          calledAt: calledAt,
          loops: loops,
          id: ++this.intervalIndex
        });
      }
    }
  }, {
    key: "setTimeout",
    value: function setTimeout(fn, timeout) {
      if (fn && timeout) {
        this.intervals.push({
          fn: fn,
          interval: timeout,
          loops: 1,
          calledAt: this.timePassed,
          id: ++this.intervalIndex
        });
      }
    }
  }, {
    key: "clearInterval",
    value: function clearInterval(id) {
      var intervalIdx = this.intervals.findIndex(function (i) {
        return i.id === id;
      });

      if (intervalIdx > -1) {
        this.intervals.splice(intervalIdx, 1);
      }
    }
  }]);

  return Intervals;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Locations/AbstractLocation.js":
/*!******************************************************!*\
  !*** ../client/src/js/Locations/AbstractLocation.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AbstractLocation; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var AbstractLocation = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(AbstractLocation, _AutoBindMethods);

  var _super = _createSuper(AbstractLocation);

  /**
   * @param {Scene} scene
   */
  function AbstractLocation(scene) {
    var _this;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unknown-level';

    _classCallCheck(this, AbstractLocation);

    _this = _super.call(this);
    _this.scene = scene;
    _this.id = id;
    return _this;
  }

  _createClass(AbstractLocation, [{
    key: "update",
    value: function update() {}
  }, {
    key: "startLocation",
    value: function startLocation() {}
  }, {
    key: "restartLocation",
    value: function restartLocation() {}
  }, {
    key: "stopLocation",
    value: function stopLocation() {}
  }, {
    key: "onAction",
    value: function onAction() {}
  }, {
    key: "getLocationName",
    value: function getLocationName() {
      return this.id;
    }
  }, {
    key: "createAmbientLight",
    value: function createAmbientLight() {
      var ambientLight = new THREE.AmbientLight(0x888888);
      ambientLight.castShadow = false;
      return ambientLight;
    }
  }, {
    key: "createShadowLight",
    value: function createShadowLight() {
      var light = new THREE.DirectionalLight(0xffffff, 10, 150);
      light.intensity = 1;
      light.shadow.bias = -0.00001;
      var shadowSize = 25;
      light.castShadow = true;
      light.shadow.camera.left = -shadowSize;
      light.shadow.camera.right = shadowSize;
      light.shadow.camera.top = shadowSize;
      light.shadow.camera.bottom = -shadowSize;
      light.shadow.mapSize.width = 512;
      light.shadow.mapSize.height = 512;
      light.shadow.camera.near = 10;
      light.shadow.camera.far = 150;
      light.shadow.camera.visible = true;
      return light;
    }
  }, {
    key: "createSkybox",
    value: function createSkybox() {
      var materialArray = ['xpos', 'xneg', 'ypos', 'yneg', 'zpos', 'zneg'].map(function (direction) {
        var url = "./assets/textures/sky-nebula/nebula-".concat(direction, ".png");
        return new THREE.MeshBasicMaterial({
          map: new THREE.TextureLoader().load(url),
          side: THREE.BackSide,
          fog: false
        });
      });
      var skyGeometry = new THREE.CubeGeometry(75000, 75000, 75000);
      var skyMaterial = new THREE.MeshFaceMaterial(materialArray);
      return new THREE.Mesh(skyGeometry, skyMaterial);
    }
  }]);

  return AbstractLocation;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Locations/DreamTown/Areas.js":
/*!*****************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/Areas.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var buildArea = function buildArea(areaId, map) {
  var _AreaSizes$areaId = AreaSizes[areaId],
      width = _AreaSizes$areaId.width,
      height = _AreaSizes$areaId.height;

  var waypointXToWorldX = function waypointXToWorldX(position) {
    return position - width / 2;
  };

  var waypointYToWorldZ = function waypointYToWorldZ(position) {
    return position - height / 2;
  };

  var worldXToWaypointX = function worldXToWaypointX(position) {
    var graphX = Math.round(position + width / 2);
    return Math.min(Math.max(graphX, 4), width - 5);
  };

  var worldZToWaypointY = function worldZToWaypointY(position) {
    var graphY = Math.round(position + height / 2);
    return Math.min(Math.max(graphY, 4), height - 5);
  };

  var area = {
    id: areaId,
    waypointXToWorldX: waypointXToWorldX,
    waypointYToWorldZ: waypointYToWorldZ,
    worldXToWaypointX: worldXToWaypointX,
    worldZToWaypointY: worldZToWaypointY,
    width: width,
    height: height
  };
  return map(area);
};

var AreaSizes = {
  FLOOR_0: {
    width: 150,
    height: 150
  },
  FLOOR_1: {
    width: 270,
    height: 270
  },
  FLOOR_2: {
    width: 270,
    height: 270
  }
};
var Areas = {
  FLOOR_0: buildArea('FLOOR_0', function (area) {
    return _objectSpread(_objectSpread({}, area), {}, {
      includesPosition: function includesPosition(position) {
        return position.y < 100;
      },
      getWorldWaypointByXY: function getWorldWaypointByXY(x, y) {
        return {
          x: area.waypointXToWorldX(x),
          y: 0.2,
          z: area.waypointYToWorldZ(y)
        };
      },
      getWaypointPortals: function getWaypointPortals() {
        return [{
          from: {
            x: area.worldXToWaypointX(-49),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-49),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_1'
          }
        }, {
          from: {
            x: area.worldXToWaypointX(-49),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-49),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_2'
          }
        }];
      }
    });
  }),
  FLOOR_1: buildArea('FLOOR_1', function (area) {
    return _objectSpread(_objectSpread({}, area), {}, {
      includesPosition: function includesPosition(position) {
        return position.y < 200;
      },
      getWorldWaypointByXY: function getWorldWaypointByXY(x, y) {
        return {
          x: area.waypointXToWorldX(x),
          y: 100.2,
          z: area.waypointYToWorldZ(y)
        };
      },
      getWaypointPortals: function getWaypointPortals() {
        return [{
          from: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_0'
          }
        }, {
          from: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_2'
          }
        }];
      }
    });
  }),
  FLOOR_2: buildArea('FLOOR_2', function (area) {
    return _objectSpread(_objectSpread({}, area), {}, {
      includesPosition: function includesPosition(position) {
        return position.y >= 200;
      },
      getWorldWaypointByXY: function getWorldWaypointByXY(x, y) {
        return {
          x: area.waypointXToWorldX(x),
          y: 200.2,
          z: area.waypointYToWorldZ(y)
        };
      },
      getWaypointPortals: function getWaypointPortals() {
        return [{
          from: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_0'
          }
        }, {
          from: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_1'
          }
        }];
      }
    });
  })
};
/* harmony default export */ __webpack_exports__["default"] = (Areas);

/***/ }),

/***/ "../client/src/js/Locations/DreamTown/Elevator.js":
/*!********************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/Elevator.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Elevator; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Elevator = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Elevator, _AutoBindMethods);

  var _super = _createSuper(Elevator);

  function Elevator(scene, params) {
    var _this;

    _classCallCheck(this, Elevator);

    _this = _super.call(this);
    _this.scene = scene;
    _this.params = params;
    _this.currentFloor = 1;
    _this.target = 0;
    _this.direction = -1;
    _this.speed = 0.3;
    _this.standTime = 10;
    _this.object = _this.scene.models.createCube(params);
    _this.standAt = _this.scene.intervals.getTimePassed();
    return _this;
  }

  _createClass(Elevator, [{
    key: "isReleased",
    value: function isReleased() {
      return this.scene.intervals.getTimePassed() - this.standAt > this.standTime * 1000;
    }
  }, {
    key: "isCarrying",
    value: function isCarrying(_ref) {
      var x = _ref.x,
          y = _ref.y,
          z = _ref.z;
      var _this$object = this.object,
          position = _this$object.position,
          scale = _this$object.scale;
      return Math.abs(x - position.x) < scale.x / 2 && Math.abs(z - position.z) < scale.z / 2 && y - position.y < scale.y / 2 // && (y + 1.7) - position.y > -scale.y / 2
      ;
    }
  }, {
    key: "getFloor",
    value: function getFloor() {
      return this.direction > 0 ? this.object.position.y >= 200 && 2 || this.object.position.y >= 100 && 1 || 0 : this.object.position.y > 100 && 2 || this.object.position.y > 0 && 1 || 0;
    }
  }, {
    key: "update",
    value: function update() {
      var _this2 = this;

      if (this.isReleased()) {
        var floor = this.getFloor();

        if (floor !== this.currentFloor) {
          this.standAt = this.scene.intervals.getTimePassed();
          this.currentFloor = floor;

          if (floor === 2) {
            this.direction = -1;
          } else if (floor === 0) {
            this.direction = 1;
          }

          this.target = floor + this.direction;
        } else {
          var getCarryingPosition = function getCarryingPosition(unit) {
            return _objectSpread(_objectSpread({}, unit.position), {}, {
              y: unit.position.y - (_this2.direction > 0 ? 2 : 0.1)
            });
          };

          var carryingUnits = this.scene.gameObjectsService.getUnits().filter(function (unit) {
            return _this2.isCarrying(getCarryingPosition(unit));
          });
          var thisAcceleration = this.speed * this.direction;
          carryingUnits.forEach(function (unit) {
            unit.position.y += thisAcceleration;
          });
          this.object.position.y += thisAcceleration;
        }
      }
    }
  }]);

  return Elevator;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Locations/DreamTown/Environment.js":
/*!***********************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/Environment.js ***!
  \***********************************************************/
/*! exports provided: createEnvironment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEnvironment", function() { return createEnvironment; });
var createEnvironment = function createEnvironment(_ref) {
  var load = _ref.load,
      trees = _ref.trees,
      houses = _ref.houses,
      addColliderFunction = _ref.addColliderFunction,
      onLoad = _ref.onLoad;
  var pivot = new THREE.Object3D();
  pivot.matrixAutoUpdate = false;
  pivot.name = 'LEVEL_ENVIRONMENT';
  var isEnvironmentLoaded = false;
  var isTreeLoaded = false;
  var isHouseLoaded = false;

  var checkIsAllLoaded = function checkIsAllLoaded() {
    if (isEnvironmentLoaded && isTreeLoaded && isHouseLoaded) {
      onLoad && onLoad();
    }
  };

  load({
    baseUrl: './assets/models/environment/enviroment',
    noScene: true,
    castShadow: false,
    callback: function callback(object) {
      pivot.add(object.scene);
      object.scene.matrixAutoUpdate = false;
      object.scene.updateMatrix();
      isEnvironmentLoaded = true;
      checkIsAllLoaded();
    }
  });
  load({
    baseUrl: './assets/models/environment/tree',
    noScene: true,
    receiveShadow: false,
    callback: function callback(loadedModel) {
      isTreeLoaded = true;
      checkIsAllLoaded();
      trees.forEach(function (position) {
        var model = loadedModel.scene.clone();
        model.name = 'Tree';
        model.position.set(position.x, position.y, position.z);
        model.matrixAutoUpdate = false;
        model.updateMatrix();
        var _model$position = model.position,
            x = _model$position.x,
            z = _model$position.z;
        addColliderFunction(function (position) {
          return Math.abs(position.x - x) < 2 && Math.abs(position.z - z) < 2;
        });
        pivot.add(model);
      });
    }
  });
  load({
    baseUrl: './assets/models/environment/house1',
    receiveShadow: false,
    noScene: true,
    callback: function callback(loadedModel) {
      isHouseLoaded = true;
      checkIsAllLoaded();
      houses.forEach(function (position) {
        var model = loadedModel.scene.clone();
        model.name = 'House1';
        model.position.set(position.x, position.y, position.z);
        model.rotation.set(position.rx || 0, position.ry || 0, position.rz || 0);
        model.matrixAutoUpdate = false;
        model.updateMatrix();
        var _model$position2 = model.position,
            x = _model$position2.x,
            z = _model$position2.z;
        addColliderFunction(function (unitPosition) {
          return Math.abs(unitPosition.x - x) < (position.ry < -3.13 ? 4 : 3) && Math.abs(unitPosition.z - z) < (position.ry < -3.13 ? 3 : 4);
        });
        pivot.add(model);
      });
    }
  });
  return pivot;
};



/***/ }),

/***/ "../client/src/js/Locations/DreamTown/Location.js":
/*!********************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/Location.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Location; });
/* harmony import */ var _AbstractLocation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AbstractLocation */ "../client/src/js/Locations/AbstractLocation.js");
/* harmony import */ var _GameObjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../GameObjects */ "../client/src/js/GameObjects.js");
/* harmony import */ var _Elevator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Elevator */ "../client/src/js/Locations/DreamTown/Elevator.js");
/* harmony import */ var _Environment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Environment */ "../client/src/js/Locations/DreamTown/Environment.js");
/* harmony import */ var _Areas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Areas */ "../client/src/js/Locations/DreamTown/Areas.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }







var Location = /*#__PURE__*/function (_AbstractLocation) {
  _inherits(Location, _AbstractLocation);

  var _super = _createSuper(Location);

  /**
   * @param {Scene} scene
   */
  function Location(scene) {
    var _this;

    _classCallCheck(this, Location);

    _this = _super.call(this, scene);
    _this.id = 'dream-town';
    _this.shadowLightPosition = new THREE.Vector3(25, 50, 25);

    _this.scene.ui.setLoading(true);

    _this.scene.ui.setPause(true);

    _this.environment = Object(_Environment__WEBPACK_IMPORTED_MODULE_3__["createEnvironment"])({
      load: _this.scene.models.loadGLTF,
      addColliderFunction: _this.scene.colliders.addColliderFunction,
      trees: [{
        x: 0,
        y: 0,
        z: 15
      }, {
        x: 0,
        y: 0,
        z: -15
      }, {
        x: 15,
        y: 0,
        z: 0
      }, {
        x: -15,
        y: 0,
        z: 0
      }, {
        x: 15,
        y: 0,
        z: 15
      }, {
        x: 15,
        y: 0,
        z: -15
      }, {
        x: 30,
        y: 0,
        z: 20
      }, {
        x: 30,
        y: 0,
        z: -20
      }, {
        x: 45,
        y: 0,
        z: -35
      }, {
        x: 45,
        y: 0,
        z: 35
      }],
      houses: [{
        x: 0,
        y: 0,
        z: 40,
        ry: -Math.PI
      }, {
        x: -10,
        y: 0,
        z: 30,
        ry: Math.PI / 2
      }, {
        x: 10,
        y: 0,
        z: 30,
        ry: -Math.PI / 2
      } // { x: 75, y: 100, z: 75 },
      // { x: 75, y: 200, z: 75 },
      ],
      onLoad: function onLoad() {
        _this.scene.ui.setLoading(false);

        _this.scene.ui.setPause(false);

        _this.scene.notify('Dream Town');

        _this.startLocation();
      }
    });
    _this.ambientLight = _this.createAmbientLight();
    _this.shadowLight = _this.createShadowLight();

    _this.scene.add(_this.environment);

    _this.scene.add(_this.ambientLight);

    _this.scene.add(_this.shadowLight);

    _this.elevator = new _Elevator__WEBPACK_IMPORTED_MODULE_2__["default"](scene, {
      position: {
        x: -48,
        y: 100,
        z: 0
      },
      x: 4,
      y: 1,
      z: 4
    });
    var color = 0x000000;
    var near = 10;
    var far = 100;
    _this.scene.scene.fog = new THREE.Fog(color, near, far);

    _this.createLocationColliders();

    return _this;
  }

  _createClass(Location, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Location.prototype), "update", this).call(this);

      var player = this.scene.getPlayer();

      if (player) {
        this.elevator.update();
        this.shadowLight.position.copy(player.position).add(this.shadowLightPosition);

        if (this.shadowLight.target !== player.object) {
          this.shadowLight.target = player.object;
        }
      }
    }
  }, {
    key: "reviveHero",
    value: function reviveHero() {
      var player = this.scene.getPlayer();
      player.params.hp = 10;
      player.position.set(0, 0.3, 30);
      player.animationState.isDie = false;
      this.scene.particles.createEffect({
        effect: 'level-up/level-up',
        scale: 1.5,
        attachTo: player.object
      });
    }
  }, {
    key: "afterClear",
    value: function afterClear() {
      var _this2 = this;

      this.scene.units.createPlayer({
        /**
         * @param {Player} player
         */
        onCreate: function onCreate(player) {
          _this2.scene.camera.player = player;

          _this2.scene.ui.updatePlayerParams();

          player.position.set(0, 0.3, 30);
        },
        onDie: function onDie() {
          return window.setTimeout(function () {
            _this2.scene.ui.setPause(true);
          }, 2500);
        },
        onKill: function onKill(object) {
          var player = _this2.scene.getPlayer();

          player.addExperience(object.params.bounty);
          player.addMoney(object.params.bounty);
        },
        onDamageTaken: function onDamageTaken() {
          return _this2.scene.ui.updatePlayerParams();
        },
        onLocationUp: function onLocationUp() {
          return _this2.scene.ui.updatePlayerParams();
        }
      });
      this.createInteractiveGameObjects();
    }
  }, {
    key: "startLocation",
    value: function startLocation() {
      if (this.interval) {
        clearInterval(this.interval);
      }
    }
  }, {
    key: "restartLocation",
    value: function restartLocation() {
      this.scene.clearScene();
    }
  }, {
    key: "stopLocation",
    value: function stopLocation() {
      this.scene.remove(this.environment); // this.scene.remove(this.skybox);

      this.scene.remove(this.ambientLight);
      this.scene.remove(this.shadowLight);
      this.scene.gameObjectsService.removeAllExceptPlayer();

      if (this.interval) {
        clearInterval(this.interval);
      }
    }
  }, {
    key: "createInteractiveGameObjects",
    value: function createInteractiveGameObjects() {
      var _this3 = this;

      var createHealItem = function createHealItem() {
        return _this3.scene.intervals.setTimeout(function () {
          var itemHealPosition = new THREE.Vector3(-6.5, 0.1, 32.8);

          _this3.scene.gameObjectsService.createItem({
            model: 'item-heal',
            position: itemHealPosition,
            canPickup: function canPickup(unit) {
              return unit.getMaxHP() - unit.getHP() > 0;
            },
            onPickup: function onPickup(unit) {
              unit.addHP(25);
              createHealItem();
            }
          });
        }, 10000);
      };

      createHealItem();

      var getAIParams = function getAIParams(_ref) {
        var level = _ref.level,
            params = _objectWithoutProperties(_ref, ["level"]);

        return _objectSpread(_objectSpread({}, params), {}, {
          level: level,
          scale: 0.7 + level / 10,
          onDie: function onDie() {
            return _this3.scene.units.createAI(getAIParams(_objectSpread(_objectSpread({}, params), {}, {
              level: level + 1 + Math.round(Math.random() * level)
            })));
          }
        });
      };

      var getGoatsParams = function getGoatsParams(level, position) {
        return getAIParams({
          level: level,
          position: position,
          fraction: 'goats',
          name: level <= 10 ? 'Goat Warrior' : level <= 20 ? 'Goat Elite' : 'Goat Destroyer'
        });
      };

      var getFriendlyParams = function getFriendlyParams(level, position, rotation) {
        return getAIParams({
          level: level,
          position: position,
          rotation: rotation,
          fraction: 'friendly',
          name: 'Friendly Citizen'
        });
      };

      this.units = [getGoatsParams(3, {
        x: -17,
        y: 0.2,
        z: -5
      }), getGoatsParams(3, {
        x: 17,
        y: 0.2,
        z: -5
      }), getGoatsParams(2, {
        x: -15,
        y: 0.2,
        z: -30
      }), getGoatsParams(2, {
        x: 15,
        y: 0.2,
        z: -30
      }), getGoatsParams(5, {
        x: -30,
        y: 0.2,
        z: -9
      }), getGoatsParams(5, {
        x: 30,
        y: 0.2,
        z: -9
      }), getGoatsParams(4, {
        x: -45,
        y: 0.2,
        z: -30
      }), getGoatsParams(4, {
        x: 45,
        y: 0.2,
        z: -30
      }), getGoatsParams(1, {
        x: 45,
        y: 0.2,
        z: 45
      }), getGoatsParams(1, {
        x: 45,
        y: 0.2,
        z: -45
      }), getGoatsParams(25, {
        x: 0,
        y: 0.2,
        z: 0
      }), getFriendlyParams(5, {
        x: -0.8,
        y: 0.2,
        z: 40 - 4.03
      }, {
        y: Math.PI
      }), getFriendlyParams(5, {
        x: -10 + 3.5,
        y: 0.2,
        z: 29.2
      }, {
        y: Math.PI / 2
      }), getFriendlyParams(5, {
        x: 10 - 3.5,
        y: 0.2,
        z: 30.8
      }, {
        y: -Math.PI / 2
      })].forEach(this.scene.units.createAI);
    }
  }, {
    key: "createLocationColliders",
    value: function createLocationColliders() {
      var _this4 = this;

      var isBetween = function isBetween(v, min, max) {
        return v > min && v < max;
      };

      this.scene.colliders.addColliderFunction(function (position, gameObject) {
        var x = position.x,
            y = position.y,
            z = position.z;
        var absX = Math.abs(x);
        var absZ = Math.abs(z);

        if (y < 0.1 && absX < 50 && absZ < 50 || // floor 0
        y < (absX - 50) / 1.5 && absX > 50 || y < (absZ - 50) / 1.5 && absZ > 50 // out of floor 0
        || y < 90 && absX > 96 && absZ > 96 // out of floor 0
        || isBetween(y, 90, 100) && (absX > 50 || absZ > 50) // floor 1
        || isBetween(y, 90, 190) && (absX > 135 || absZ > 135) // out of floor 1
        || isBetween(y, 190, 200) && (absX > 50 || absZ > 50) // floor 2
        || y > 190 && (absX > 133 || absZ > 133) // out of floor 2
        || _this4.elevator.isCarrying(position)) {
          return true;
        } // TODO: Check if we need units colliders
        // const units = this.scene.units.getAliveUnits();
        //
        // for(let unit of units) {
        //     if (
        //         unit !== gameObject
        //         && (
        //             !(gameObject instanceof Fire)
        //             || gameObject.params.parent !== unit
        //         )
        //         && unit.getCollider(position)
        //     ) {
        //         return true;
        //     }
        // }


        return false;
      });
    }
  }, {
    key: "getAreas",
    value: function getAreas() {
      var _this5 = this;

      var areas = Object.values(_Areas__WEBPACK_IMPORTED_MODULE_4__["default"]);

      var generateWaypoints = function generateWaypoints(width, height, map) {
        return new Array(width).fill(null).map(function (null1, x) {
          return new Array(height).fill(null).map(function (null2, y) {
            return map(x, y);
          });
        });
      };

      return areas.map(function (area) {
        var result = _objectSpread({}, area);

        result.getWaypoints = function () {
          return generateWaypoints(area.width, area.height, function (x, y) {
            if ( // Elevator
            Math.abs(area.waypointXToWorldX(x) - _this5.elevator.params.position.x) <= 5 && Math.abs(area.waypointYToWorldZ(y) - _this5.elevator.params.position.z) <= 1) {
              return 1;
            }

            if (area.id !== 'FLOOR_0' && ( // Center hole
            Math.abs(area.waypointXToWorldX(x)) < 51 && Math.abs(area.waypointYToWorldZ(y)) < 51 || Math.abs(area.waypointXToWorldX(x)) <= 51 && Math.abs(area.waypointYToWorldZ(y)) <= 51 && Math.abs(area.waypointXToWorldX(x)) >= 50 && Math.abs(area.waypointYToWorldZ(y)) >= 50)) {
              return 0;
            }

            if (area.id === 'FLOOR_0' && ( // Floor out
            Math.abs(area.waypointXToWorldX(x)) >= 49 || Math.abs(area.waypointYToWorldZ(y)) >= 49)) {
              return 1;
            }

            return Number(_this5.checkWayForWaypoint(area.getWorldWaypointByXY(x, y)));
          });
        };

        return result;
      });
    }
  }, {
    key: "checkWayForWaypoint",
    value: function checkWayForWaypoint(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          z = _ref2.z;
      var checkWay = this.scene.colliders.checkWay;

      var checkNear = function checkNear(range, diagonal) {
        return checkWay(new THREE.Vector3(x + range, y, z)) && checkWay(new THREE.Vector3(x - range, y, z)) && checkWay(new THREE.Vector3(x, y, z + range)) && checkWay(new THREE.Vector3(x, y, z - range)) && (!diagonal || checkWay(new THREE.Vector3(x + range, y, z + range)) && checkWay(new THREE.Vector3(x - range, y, z - range)) && checkWay(new THREE.Vector3(x - range, y, z + range)) && checkWay(new THREE.Vector3(x + range, y, z - range)));
      };

      return checkWay(new THREE.Vector3(x, y, z)) && checkNear(1, true) && checkNear(2);
    }
  }]);

  return Location;
}(_AbstractLocation__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Locations/DreamTown/index.js":
/*!*****************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/index.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Location__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Location */ "../client/src/js/Locations/DreamTown/Location.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _Location__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/***/ }),

/***/ "../client/src/js/Models.js":
/*!**********************************!*\
  !*** ../client/src/js/Models.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Models; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Models = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Models, _AutoBindMethods);

  var _super = _createSuper(Models);

  function Models(scene) {
    var _this;

    _classCallCheck(this, Models);

    _this = _super.call(this);
    _this.scene = scene;
    return _this;
  }
  /**
   * @param {Object} params
   * @param {number} params.repeatX
   * @param {number} params.repeatY
   * @param {number} params.emissive
   * @param {THREE.Vector3} params.position
   * @returns {THREE.Mesh}
   */


  _createClass(Models, [{
    key: "createCube",
    value: function createCube(params) {
      params = params || {};
      var materialParams = {};

      if (params.image) {
        var texture = new THREE.TextureLoader().load(params.image);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(params.repeatX || 1, params.repeatY || 1);
        materialParams.map = texture;
      }

      if (params.emissive) {
        materialParams.emissive = new THREE.Color(params.emissive);
        materialParams.emissiveIntensity = 1.0;
        materialParams.emissiveMap = null;
      }

      var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1), new THREE.MeshLambertMaterial(materialParams));
      cube.scale.set(params.x || 1, params.y || 1, params.z || 1);

      if (params.position) {
        cube.position.set(params.position.x || 0, params.position.y || 0, params.position.z || 0);
      }

      if (params.rotation) {
        cube.rotation.set(params.rotation.x || 0, params.rotation.y || 0, params.rotation.z || 0);
      }

      if (!params.noScene) {
        this.scene.add(cube);
      }

      return cube;
    }
  }, {
    key: "loadGLTF",
    value: function loadGLTF(_ref) {
      var _this2 = this;

      var baseUrl = _ref.baseUrl,
          _ref$isGLTF = _ref.isGLTF,
          isGLTF = _ref$isGLTF === void 0 ? false : _ref$isGLTF,
          _ref$noScene = _ref.noScene,
          noScene = _ref$noScene === void 0 ? false : _ref$noScene,
          _ref$callback = _ref.callback,
          callback = _ref$callback === void 0 ? function () {
        return null;
      } : _ref$callback,
          _ref$castShadow = _ref.castShadow,
          castShadow = _ref$castShadow === void 0 ? true : _ref$castShadow,
          _ref$receiveShadow = _ref.receiveShadow,
          receiveShadow = _ref$receiveShadow === void 0 ? true : _ref$receiveShadow;
      var loader = new GLTFLoader();
      var url = "".concat(baseUrl, ".glb").concat(isGLTF ? '.gltf' : '');
      loader.load(url, function (loadedModel) {
        loadedModel.scene.traverse(function (child) {
          if (child instanceof THREE.Mesh) {
            child.castShadow = castShadow;
            child.receiveShadow = receiveShadow;
          }
        });
        callback(loadedModel);

        if (!noScene) {
          _this2.scene.add(loadedModel.scene);
        }
      });
    }
  }]);

  return Models;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Particles.js":
/*!*************************************!*\
  !*** ../client/src/js/Particles.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Particles; });
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scene */ "../client/src/js/Scene.js");
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameObjects/AnimatedGameObject */ "../client/src/js/GameObjects/AnimatedGameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var Particles = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Particles, _AutoBindMethods);

  var _super = _createSuper(Particles);

  /**
   * @param {Scene} scene
   */
  function Particles(scene) {
    var _this;

    _classCallCheck(this, Particles);

    _this = _super.call(this);
    _this.scene = scene;
    _this.particles = [];
    return _this;
  }

  _createClass(Particles, [{
    key: "update",
    value: function update() {
      this.particles.forEach(function (p) {
        return p.update();
      });
    }
  }, {
    key: "createSnow",
    value: function createSnow() {
      var _this2 = this;

      var area = new THREE.Vector3(100, 25, 100);
      this.createParticles({
        particleCount: 10000,
        color: 0x888888,
        blending: THREE.NormalBlending,
        position: new THREE.Vector3(-area.x / 2, 0, -area.z / 2),
        getParticlePosition: function getParticlePosition(i) {
          var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this2.getRandomPosition(area);

          if (position.y < 0) {
            var newPosition = _this2.getRandomPosition(area);

            position.x = newPosition.x;
            position.y = area.y;
            position.z = newPosition.z;
          }

          return position;
        }
      });
    }
  }, {
    key: "createEffect",
    value: function createEffect(_ref) {
      var _this3 = this;

      var _ref$scale = _ref.scale,
          scale = _ref$scale === void 0 ? 1.5 : _ref$scale,
          _ref$effect = _ref.effect,
          effect = _ref$effect === void 0 ? 'level-up-alt/level-up' : _ref$effect,
          _ref$position = _ref.position,
          position = _ref$position === void 0 ? {} : _ref$position,
          attachTo = _ref.attachTo,
          _ref$lifeTime = _ref.lifeTime,
          lifeTime = _ref$lifeTime === void 0 ? 2080 : _ref$lifeTime;
      this.scene.models.loadGLTF({
        baseUrl: './assets/models/effects/' + effect,
        noScene: true,
        castShadow: false,
        receiveShadow: false,
        callback: function callback(loadedObject) {
          loadedObject.scene.scale.set(scale, scale, scale);
          loadedObject.scene.traverse(function (child) {
            if (child.isMesh) {
              child.material.transparent = true;
              child.material.alphaTest = 0.5;
            }
          });
          loadedObject.scene.position.set(position.x || 0, position.y || 0, position.z || 0);

          if (attachTo) {
            attachTo.add(loadedObject.scene);
          }

          var effect = new _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_2__["default"]({
            object: loadedObject.scene,
            animations: loadedObject.animations
          });

          _this3.scene.gameObjectsService.hookGameObject(effect);

          _this3.scene.intervals.setTimeout(function () {
            return _this3.scene.gameObjectsService.destroyGameObject(effect);
          }, lifeTime);
        }
      });
    }
  }, {
    key: "loadEffect",
    value: function loadEffect() {
      var _this4 = this;

      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$particleName = _ref2.particleName,
          particleName = _ref2$particleName === void 0 ? 'blood' : _ref2$particleName,
          _ref2$position = _ref2.position,
          position = _ref2$position === void 0 ? new THREE.Vector3() : _ref2$position,
          _ref2$scale = _ref2.scale,
          scale = _ref2$scale === void 0 ? new THREE.Vector3(1, 1, 1) : _ref2$scale;

      var gameObjectsService = this.scene.gameObjectsService;
      return this.scene.models.loadGLTF({
        baseUrl: "./assets/models/effects/".concat(particleName),
        castShadow: false,
        receiveShadow: false,
        callback: function callback(gltf) {
          gltf.scene.position.copy(position);
          gltf.scene.scale.copy(scale);
          gltf.scene.rotation.set(0, Math.random() * Math.PI, 0);
          var particleSystem = gameObjectsService.hookGameObject(new _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_2__["default"]({
            object: gltf.scene,
            animations: gltf.animations
          }));

          _this4.scene.intervals.setTimeout(function () {
            return _this4.scene.gameObjectsService.destroyGameObject(particleSystem);
          }, 625);
        }
      });
    }
  }, {
    key: "getRandomPosition",
    value: function getRandomPosition(area) {
      var random = function random(from, to) {
        return Math.random() * (to - from) + from;
      };

      return new THREE.Vector3(random(0, area.x), random(0, area.y), random(0, area.z));
    }
  }, {
    key: "createParticles",
    value: function createParticles() {
      var _this5 = this;

      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$particleCount = _ref3.particleCount,
          particleCount = _ref3$particleCount === void 0 ? 1000 : _ref3$particleCount,
          _ref3$noScene = _ref3.noScene,
          noScene = _ref3$noScene === void 0 ? false : _ref3$noScene,
          _ref3$position = _ref3.position,
          position = _ref3$position === void 0 ? new THREE.Vector3(0, 5, 0) : _ref3$position,
          _ref3$size = _ref3.size,
          size = _ref3$size === void 0 ? 0.01 : _ref3$size,
          _ref3$color = _ref3.color,
          color = _ref3$color === void 0 ? 0xFFFFFF : _ref3$color,
          _ref3$blending = _ref3.blending,
          blending = _ref3$blending === void 0 ? THREE.AdditiveBlending : _ref3$blending,
          _ref3$depthTest = _ref3.depthTest,
          depthTest = _ref3$depthTest === void 0 ? true : _ref3$depthTest,
          _ref3$transparent = _ref3.transparent,
          transparent = _ref3$transparent === void 0 ? true : _ref3$transparent,
          _ref3$area = _ref3.area,
          area = _ref3$area === void 0 ? new THREE.Vector3(10, 5, 10) : _ref3$area,
          _ref3$getParticleVelo = _ref3.getParticleVelocity,
          getParticleVelocity = _ref3$getParticleVelo === void 0 ? function () {
        return new THREE.Vector3(-0.01, -0.01, 0);
      } : _ref3$getParticleVelo,
          _ref3$getParticlePosi = _ref3.getParticlePosition,
          getParticlePosition = _ref3$getParticlePosi === void 0 ? function (i) {
        var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this5.getRandomPosition(area);
        return position;
      } : _ref3$getParticlePosi;

      var particles = new THREE.Geometry();
      var material = new THREE.PointCloudMaterial({
        color: color,
        size: size,
        blending: blending,
        depthTest: depthTest,
        transparent: transparent
      });

      for (var i = 0; i < particleCount; i++) {
        var particle = getParticlePosition(i);
        particles.velocity = getParticleVelocity(i, particle);
        particles.vertices.push(particle);
      }

      var particleSystem = new THREE.PointCloud(particles, material);
      particleSystem.position.copy(position);
      this.particles.push({
        object: particleSystem,
        update: function update() {
          var index = particleCount;

          while (index--) {
            var _particle = particles.vertices[index];
            _particle.velocity = getParticleVelocity(index, _particle);
            _particle.x += _particle.velocity.x;
            _particle.y += _particle.velocity.y;
            _particle.z += _particle.velocity.z;
            var particlePosition = getParticlePosition(index, _particle);
            _particle.x = particlePosition.x;
            _particle.y = particlePosition.y;
            _particle.z = particlePosition.z;
          }

          particles.verticesNeedUpdate = true;
        }
      });

      if (!noScene) {
        this.scene.add(particleSystem);
      }

      return particleSystem;
    }
  }]);

  return Particles;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "../client/src/js/PathFinder.js":
/*!**************************************!*\
  !*** ../client/src/js/PathFinder.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Colliders; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _Utils_AStar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils/AStar */ "../client/src/js/Utils/AStar.js");
/* harmony import */ var _Utils_AStar__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Utils_AStar__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Colliders = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Colliders, _AutoBindMethods);

  var _super = _createSuper(Colliders);

  function Colliders(scene) {
    var _this;

    _classCallCheck(this, Colliders);

    _this = _super.call(this);
    _this.scene = scene;
    return _this;
  }

  _createClass(Colliders, [{
    key: "getNextPoint",
    value: function getNextPoint(from, to) {
      var area = this.getAreaByPosition(from),
          fromX = area.worldXToWaypointX(from.x),
          fromY = area.worldZToWaypointY(from.z),
          areaTo = this.getAreaByPosition(to);
      var toX;
      var toY;
      var portal;

      if (area.id === areaTo.id) {
        toX = area.worldXToWaypointX(to.x);
        toY = area.worldZToWaypointY(to.z);
      } else {
        portal = area.getWaypointPortals().find(function (portal) {
          return portal.to.areaId === areaTo.id;
        });

        if (portal) {
          toX = portal.from.x;
          toY = portal.from.y;
        } else {
          return to;
        }
      }

      var start = this.getFreeGraphPoint(area.graph, fromX, fromY);
      var end = this.getFreeGraphPoint(area.graph, toX, toY);

      if (start && end) {
        var result = _Utils_AStar__WEBPACK_IMPORTED_MODULE_1___default.a.astar.search(area.graph, start, end, {
          heuristic: _Utils_AStar__WEBPACK_IMPORTED_MODULE_1___default.a.astar.heuristics.diagonal
        });
        var nextGraphPoint = result[2] || result[1];

        if (nextGraphPoint) {
          var nextWorldPoint = new THREE.Vector3(area.waypointXToWorldX(nextGraphPoint.x), to.y, area.waypointYToWorldZ(nextGraphPoint.y));
          return nextWorldPoint;
        } else {
          return null;
        }
      }

      return to;
    }
  }, {
    key: "getFreeGraphPoint",
    value: function getFreeGraphPoint(graph, x, y) {
      var grid = graph.grid;

      var getWeight = function getWeight(x, y) {
        return grid[x] && grid[x][y] && grid[x][y].weight;
      };

      var getNearFreePoint = function getNearFreePoint(range) {
        return getWeight(x + range, y) && grid[x + range][y] || getWeight(x - range, y) && grid[x - range][y] || getWeight(x, y + range) && grid[x][y + range] || getWeight(x, y - range) && grid[x][y - range];
      };

      return getWeight(grid[x][y]) && grid[x][y] || getNearFreePoint(1) || getNearFreePoint(2) || getNearFreePoint(3) || getNearFreePoint(4) || null;
    }
  }, {
    key: "rebuildAreas",
    value: function rebuildAreas() {
      if (this.scene.location) {
        this.areas = this.scene.location.getAreas().map(function (area) {
          return _objectSpread(_objectSpread({}, area), {}, {
            graph: new _Utils_AStar__WEBPACK_IMPORTED_MODULE_1___default.a.Graph(area.getWaypoints(), {
              diagonal: true
            })
          });
        });
      }
    }
  }, {
    key: "getAreaByPosition",
    value: function getAreaByPosition(position) {
      return this.areas.find(function (area) {
        return area.includesPosition(position);
      });
    }
  }]);

  return Colliders;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Scene.js":
/*!*********************************!*\
  !*** ../client/src/js/Scene.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Scene; });
/* harmony import */ var _GameObjects__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameObjects */ "../client/src/js/GameObjects.js");
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Camera */ "../client/src/js/Camera.js");
/* harmony import */ var _Connection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Connection */ "../client/src/js/Connection.js");
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Input */ "../client/src/js/Input.js");
/* harmony import */ var _Intervals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Intervals */ "../client/src/js/Intervals.js");
/* harmony import */ var _Locations_DreamTown__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Locations/DreamTown */ "../client/src/js/Locations/DreamTown/index.js");
/* harmony import */ var _Colliders__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Colliders */ "../client/src/js/Colliders.js");
/* harmony import */ var _Models__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Models */ "../client/src/js/Models.js");
/* harmony import */ var _Particles__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Particles */ "../client/src/js/Particles.js");
/* harmony import */ var _PathFinder__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PathFinder */ "../client/src/js/PathFinder.js");
/* harmony import */ var _Units__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Units */ "../client/src/js/Units.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

 // import Audio from './Audio';














var Scene = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Scene, _AutoBindMethods);

  var _super = _createSuper(Scene);

  /**
   * @param {Renderer} renderer
   * @param {{
   *  setRestartButtonVisible: function,
   *  setPause: function,
   *  restartGame: function,
   *  isPause: function,
   *  isThirdPerson: function,
   *  update: function,
   *  updatePlayerParams: function,
   *  clearHpBars: function,
   *  switchCamera: function,
   *  setFps: function,
   *  notify: function,
   * }} ui
   */
  function Scene(renderer, ui) {
    var _this;

    _classCallCheck(this, Scene);

    _this = _super.call(this);
    _this.clock = new THREE.Clock();
    _this.intervals = new _Intervals__WEBPACK_IMPORTED_MODULE_5__["default"](_assertThisInitialized(_this));
    _this.renderer = renderer;
    _this.ui = ui;
    _this.models = new _Models__WEBPACK_IMPORTED_MODULE_8__["default"](_assertThisInitialized(_this));
    _this.scene = new THREE.Scene();
    _this.pathFinder = new _PathFinder__WEBPACK_IMPORTED_MODULE_10__["default"](_assertThisInitialized(_this));
    _this.colliders = new _Colliders__WEBPACK_IMPORTED_MODULE_7__["default"](_assertThisInitialized(_this));
    _this.units = new _Units__WEBPACK_IMPORTED_MODULE_11__["default"](_assertThisInitialized(_this));
    _this.camera = new _Camera__WEBPACK_IMPORTED_MODULE_2__["default"](_assertThisInitialized(_this)); // this.audio = new Audio(this);

    _this.input = new _Input__WEBPACK_IMPORTED_MODULE_4__["default"]({
      onAction: function onAction() {
        return _this.level.onAction();
      },
      onExit: function onExit() {
        return _this.ui.setPause(!_this.ui.isPause());
      },
      onZoom: function onZoom(zoom) {
        return _this.camera.addY(zoom);
      },
      onSwitchCamera: function onSwitchCamera() {
        return _this.ui.switchCamera();
      }
    });
    _this.gameObjectsService = new _GameObjects__WEBPACK_IMPORTED_MODULE_0__["default"](_assertThisInitialized(_this));
    _this.particles = new _Particles__WEBPACK_IMPORTED_MODULE_9__["default"](_assertThisInitialized(_this));
    _this.connection = new _Connection__WEBPACK_IMPORTED_MODULE_3__["default"](_assertThisInitialized(_this), 'localhost.ru');
    _this.location = new _Locations_DreamTown__WEBPACK_IMPORTED_MODULE_6__["default"](_assertThisInitialized(_this));

    _this.intervals.setInterval(function () {
      _this.ui.setFps(_this.renderer.fps, _this.renderer.targetFps);

      _this.ui.updatePlayerParams();
    }, 1000);

    _this.input.isThirdPerson = ui.isThirdPerson();

    _this.clearScene();

    _this.animate();

    console.log('Scene', _assertThisInitialized(_this));
    return _this;
  }

  _createClass(Scene, [{
    key: "clearScene",
    value: function clearScene() {
      this.gameObjectsService.removeAll();
      this.location.afterClear();
    }
  }, {
    key: "animate",
    value: function animate() {
      var now = Date.now();
      var deltaTime = this.intervals.getDeltaTime(now);
      this.intervals.update(now);
      var gameTime = this.intervals.getTimePassed();
      this.gameObjectsService.update(gameTime, deltaTime);

      if (!this.ui.isPause()) {
        this.camera.update(gameTime, deltaTime);
        this.input.update();
      }

      this.ui.update();
      this.location.update();
      this.particles.update();
      this.connection.update(gameTime, deltaTime);
      this.renderer.render(this.scene, this.camera.camera, deltaTime);
      window.requestAnimationFrame(this.animate);
    }
  }, {
    key: "setLoggedUser",
    value: function setLoggedUser(userName, password) {
      this.user = {
        userName: userName,
        password: password
      };
    }
    /**
     * @returns {Player}
     */

  }, {
    key: "getPlayer",
    value: function getPlayer() {
      return this.units.getPlayer();
    }
    /**
     * @param {THREE.Object3D} object
     */

  }, {
    key: "add",
    value: function add(object) {
      this.scene.add(object);
    }
    /**
     * @param {THREE.Object3D} object
     */

  }, {
    key: "remove",
    value: function remove(object) {
      this.scene.remove(object);
    }
  }, {
    key: "notify",
    value: function notify(text) {
      this.ui.notify(text);
    }
  }]);

  return Scene;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "../client/src/js/Units.js":
/*!*********************************!*\
  !*** ../client/src/js/Units.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Units; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _GameObjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObjects */ "../client/src/js/GameObjects.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Units = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Units, _AutoBindMethods);

  var _super = _createSuper(Units);

  function Units(scene) {
    var _this;

    _classCallCheck(this, Units);

    _this = _super.call(this);
    _this.scene = scene;
    _this.player = undefined;
    return _this;
  }

  _createClass(Units, [{
    key: "getUnits",
    value: function getUnits() {
      return this.scene.gameObjectsService.getUnits();
    }
  }, {
    key: "getAliveUnits",
    value: function getAliveUnits() {
      return this.getUnits().filter(function (gameObject) {
        return gameObject.isAlive();
      });
    }
  }, {
    key: "getPlayer",
    value: function getPlayer() {
      return this.player;
    }
  }, {
    key: "setDefaultPlayerParams",
    value: function setDefaultPlayerParams(defaultParams) {
      this.defaultParams = defaultParams;
    }
  }, {
    key: "createPlayer",
    value: function createPlayer() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$onCreate = _ref.onCreate,
          onCreate = _ref$onCreate === void 0 ? function () {
        return null;
      } : _ref$onCreate,
          _ref$onKill = _ref.onKill,
          _onKill = _ref$onKill === void 0 ? function () {
        return null;
      } : _ref$onKill,
          _ref$onDamageDeal = _ref.onDamageDeal,
          _onDamageDeal = _ref$onDamageDeal === void 0 ? function () {
        return null;
      } : _ref$onDamageDeal,
          _ref$onDamageTaken = _ref.onDamageTaken,
          _onDamageTaken = _ref$onDamageTaken === void 0 ? function () {
        return null;
      } : _ref$onDamageTaken,
          _ref$onDie = _ref.onDie,
          _onDie = _ref$onDie === void 0 ? function () {
        return null;
      } : _ref$onDie,
          _ref$onLevelUp = _ref.onLevelUp,
          _onLevelUp = _ref$onLevelUp === void 0 ? function () {
        return null;
      } : _ref$onLevelUp;

      var gameObjectsService = this.scene.gameObjectsService;
      return this.scene.models.loadGLTF({
        baseUrl: './assets/models/units/player',
        callback: function callback(loadedModel) {
          var defaultParams = _this2.defaultParams;
          loadedModel.scene.position.set(0, 0.1, 0);
          /**
           * @type {Player}
           */

          var player = gameObjectsService.hookGameObject(new _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"]({
            animations: loadedModel.animations,
            object: loadedModel.scene,
            input: _this2.scene.input,
            complexAnimations: true,
            checkWay: _this2.scene.colliders.checkWay,
            name: _this2.scene.user ? _this2.scene.user.userName : ' ',
            onDamageDeal: function onDamageDeal(damagedUnit) {
              return _onDamageDeal(damagedUnit);
            },
            onDamageTaken: function onDamageTaken(attacker) {
              _onDamageTaken(attacker);

              _this2.scene.particles.loadEffect({
                position: player.position.clone().add(new THREE.Vector3(0, 0.75, 0))
              });
            },
            onKill: function onKill(object) {
              return _onKill(object);
            },
            onDie: function onDie(killer) {
              return _onDie(killer);
            },
            onLevelUp: function onLevelUp() {
              _this2.scene.particles.createEffect({
                effect: 'level-up-alt/level-up',
                scale: 1.5,
                attachTo: _this2.player.object
              });

              _onLevelUp();
            },
            attack: function attack() {
              return gameObjectsService.attack(player);
            },
            fire: function fire() {
              return gameObjectsService.fire(player);
            },
            destroy: function destroy() {
              return gameObjectsService.destroyGameObject(player);
            }
          }));
          _this2.player = player;
          onCreate(player);

          if (defaultParams && defaultParams.params) {
            var position = defaultParams.position,
                rotation = defaultParams.rotation,
                params = defaultParams.params;
            var playerParams = player.params;
            player.position.set(position.x, position.y, position.z);
            player.rotation.set(rotation.x, rotation.y, rotation.z);
            playerParams.hp = params.hp;
            playerParams.hpMax = params.hpMax;
            playerParams.fraction = params.fraction;
            playerParams.level = params.level;
            playerParams.damage = params.damage;
            playerParams.speed = params.speed;
            playerParams.experience = params.experience;
            playerParams.money = params.money;
            playerParams.unspentTalents = params.unspentTalents;

            if (!playerParams.hp) {
              player.animationState.isDie = true;
            }
          }
        }
      });
    }
  }, {
    key: "createAI",
    value: function createAI(_ref2) {
      var _this3 = this;

      var fraction = _ref2.fraction,
          level = _ref2.level,
          _ref2$position = _ref2.position,
          x = _ref2$position.x,
          y = _ref2$position.y,
          z = _ref2$position.z,
          _ref2$rotation = _ref2.rotation,
          rotation = _ref2$rotation === void 0 ? {} : _ref2$rotation,
          scale = _ref2.scale,
          _onDie2 = _ref2.onDie,
          name = _ref2.name;
      var gameObjectsService = this.scene.gameObjectsService;

      var getPriority = function getPriority(unit, target) {
        return (target instanceof _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"] ? 0.75 : 0) + 1 / Math.ceil(target.position.distanceTo(unit.position));
      };

      this.scene.models.loadGLTF({
        baseUrl: fraction === 'goats' ? './assets/models/units/goat-warrior' : './assets/models/units/enemy',
        callback: function callback(gltf) {
          var networkConnection = _this3.scene.connection;

          if (!networkConnection || !networkConnection.meta || !networkConnection.meta.role || networkConnection.meta.role === 'host') {
            /** @type {AI} */
            var ai = gameObjectsService.hookGameObject(new _GameObjects__WEBPACK_IMPORTED_MODULE_1__["AI"]({
              animations: gltf.animations,
              object: gltf.scene,
              speed: 0.35 + level * 0.025,
              damage: 5 + level * 1.5,
              hp: 70 + level * 30,
              fraction: fraction,
              name: name,
              level: level,
              checkWay: _this3.scene.colliders.checkWay,
              getNextPoint: _this3.scene.pathFinder.getNextPoint,
              attack: function attack() {
                return gameObjectsService.attack(ai);
              },
              onDamageTaken: function onDamageTaken() {
                return _this3.scene.particles.loadEffect({
                  position: ai.position.clone().add(new THREE.Vector3(0, 0.75, 0))
                });
              },
              onDie: function onDie() {
                return _this3.scene.intervals.setTimeout(function () {
                  if (ai.isDead()) {
                    gameObjectsService.destroyGameObject(ai);

                    if (_onDie2) {
                      _onDie2();
                    }
                  }
                }, 10000);
              },
              findTarget: function findTarget() {
                var nearEnemyUnits = _this3.getAliveUnits().filter(function (unit) {
                  return unit !== ai && unit.getFraction() !== fraction && unit.position.distanceTo(ai.position) < 15;
                }).sort(function (unitA, unitB) {
                  return getPriority(ai, unitB) - getPriority(ai, unitA);
                });

                return nearEnemyUnits.length ? nearEnemyUnits[0] : null;
              }
            }));
            ai.position.set(x || 0, y || 0, z || 0);
            ai.rotation.set(rotation.x || 0, rotation.y || 0, rotation.z || 0);

            if (scale) {
              ai.object.scale.set(scale, scale, scale);
            }
          }
        }
      });
    }
  }, {
    key: "createNetworkAI",
    value: function createNetworkAI(_ref3) {
      var _this4 = this;

      var _ref3$params = _ref3.params,
          fraction = _ref3$params.fraction,
          unitNetworkId = _ref3$params.unitNetworkId,
          level = _ref3$params.level,
          name = _ref3$params.name,
          hp = _ref3$params.hp,
          hpMax = _ref3$params.hpMax,
          damage = _ref3$params.damage,
          _ref3$params$fromNetw = _ref3$params.fromNetwork,
          fromNetwork = _ref3$params$fromNetw === void 0 ? true : _ref3$params$fromNetw,
          position = _ref3.position,
          onDie = _ref3.onDie;

      var _callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

      var gameObjectsService = this.scene.gameObjectsService;

      var getPriority = function getPriority(unit, target) {
        return (target instanceof _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"] ? 0.75 : 0) + 1 / Math.ceil(target.position.distanceTo(unit.position));
      };

      return this.scene.models.loadGLTF({
        baseUrl: fraction === 'goats' ? './assets/models/units/goat-warrior' : './assets/models/units/enemy',
        callback: function callback(loadedObject) {
          var ai = gameObjectsService.hookGameObject(new _GameObjects__WEBPACK_IMPORTED_MODULE_1__["AI"]({
            object: loadedObject.scene,
            animations: loadedObject.animations,
            unitNetworkId: unitNetworkId,
            fraction: fraction,
            level: level,
            name: name,
            hp: hp,
            hpMax: hpMax,
            damage: damage,
            fromNetwork: fromNetwork,
            checkWay: _this4.scene.colliders.checkWay,
            getNextPoint: _this4.scene.pathFinder.getNextPoint,
            attack: function attack() {
              return gameObjectsService.attack(ai);
            },
            onDamageTaken: function onDamageTaken() {
              return _this4.scene.particles.loadEffect({
                position: ai.position.clone().add(new THREE.Vector3(0, 0.75, 0))
              });
            },
            onDie: function onDie() {
              return _this4.scene.intervals.setTimeout(function () {
                if (ai.isDead()) {
                  gameObjectsService.destroyGameObject(ai);

                  if (!ai.params.fromNetwork) {
                    _this4.createNetworkAI({
                      fraction: fraction,
                      unitNetworkId: unitNetworkId,
                      name: name,
                      hp: hp,
                      hpMax: hpMax,
                      damage: damage,
                      fromNetwork: false,
                      level: level + 1 + Math.round(Math.random() * level)
                    });
                  }
                }
              }, 10000);
            },
            findTarget: function findTarget() {
              if (!ai.params.fromNetwork) {
                var nearEnemyUnits = _this4.getAliveUnits().filter(function (unit) {
                  return unit !== ai && unit.getFraction() !== fraction && unit.position.distanceTo(ai.position) < 15;
                }).sort(function (unitA, unitB) {
                  return getPriority(ai, unitB) - getPriority(ai, unitA);
                });

                return nearEnemyUnits.length ? nearEnemyUnits[0] : null;
              }
            }
          }));

          _callback(ai);
        }
      });
    }
  }, {
    key: "createNetworkPlayer",
    value: function createNetworkPlayer(_ref4, _callback2) {
      var _this5 = this;

      var _ref4$params = _ref4.params,
          connectionId = _ref4$params.connectionId,
          unitNetworkId = _ref4$params.unitNetworkId,
          name = _ref4$params.name,
          _onDamageDeal2 = _ref4.onDamageDeal,
          _onKill2 = _ref4.onKill,
          _onDie3 = _ref4.onDie,
          _onLevelUp2 = _ref4.onLevelUp,
          _onDamageTaken2 = _ref4.onDamageTaken;
      var gameObjectsService = this.scene.gameObjectsService;
      return this.scene.models.loadGLTF({
        baseUrl: './assets/models/units/network-player',
        callback: function callback(loadedObject) {
          /** @type {Player} */
          var player = gameObjectsService.hookGameObject(new _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"]({
            object: loadedObject.scene,
            animations: loadedObject.animations,
            unitNetworkId: unitNetworkId,
            connectionId: connectionId,
            name: name,
            fromNetwork: true,
            complexAnimations: true,
            checkWay: _this5.scene.colliders.checkWay,
            input: {
              vertical: 0,
              horizontal: 0,
              jump: false,
              cursor: {
                x: 0,
                y: 0
              },
              look: {
                vertical: 0,
                horizontal: 0
              }
            },
            onDie: function onDie(killer) {
              return _this5.scene.intervals.setTimeout(function () {
                if (player.isDead()) {
                  gameObjectsService.destroyGameObject(player);
                }

                _onDie3 && _onDie3(killer);
              }, 10000);
            },
            onDamageDeal: function onDamageDeal(damagedUnit) {
              return _onDamageDeal2 && _onDamageDeal2(damagedUnit);
            },
            onDamageTaken: function onDamageTaken(attacker) {
              _onDamageTaken2 && _onDamageTaken2(attacker);

              _this5.scene.particles.loadEffect({
                position: player.position.clone().add(new THREE.Vector3(0, 0.75, 0))
              });
            },
            onKill: function onKill(object) {
              return _onKill2 && _onKill2(object);
            },
            onLevelUp: function onLevelUp() {
              _this5.scene.particles.createEffect({
                effect: 'level-up-alt/level-up',
                scale: 1.5,
                attachTo: _this5.player.object
              });

              _onLevelUp2 && _onLevelUp2();
            },
            attack: function attack() {
              return gameObjectsService.attack(player);
            },
            fire: function fire() {
              return gameObjectsService.fire(player);
            },
            destroy: function destroy() {
              return gameObjectsService.destroyGameObject(player);
            }
          }));

          _callback2(player);
        }
      });
    }
  }]);

  return Units;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Utils/AStar.js":
/*!***************************************!*\
  !*** ../client/src/js/Utils/AStar.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// javascript-astar 0.4.1
// http://github.com/bgrins/javascript-astar
// Freely distributable under the MIT License.
// Implements the astar search algorithm in javascript using a Binary Heap.
// Includes Binary Heap (with modifications) from Marijn Haverbeke.
// http://eloquentjavascript.net/appendix2.html
(function (definition) {
  /* global module, define */
  if (( false ? undefined : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {
    module.exports = definition();
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var exports; }
})(function () {
  function pathTo(node) {
    var curr = node;
    var path = [];

    while (curr.parent) {
      path.unshift(curr);
      curr = curr.parent;
    }

    return path;
  }

  function getHeap() {
    return new BinaryHeap(function (node) {
      return node.f;
    });
  }

  var astar = {
    /**
     * Perform an A* Search on a graph given a start and end node.
     * @param {Graph} graph
     * @param {GridNode} start
     * @param {GridNode} end
     * @param {Object} [options]
     * @param {bool} [options.closest] Specifies whether to return the
     path to the closest node if the target is unreachable.
     * @param {Function} [options.heuristic] Heuristic function (see
     *          astar.heuristics).
     */
    search: function search(graph, start, end, options) {
      graph.cleanDirty();
      options = options || {};
      var heuristic = options.heuristic || astar.heuristics.manhattan;
      var closest = options.closest || false;
      var openHeap = getHeap();
      var closestNode = start; // set the start node to be the closest if required

      start.h = heuristic(start, end);
      graph.markDirty(start);
      openHeap.push(start);

      while (openHeap.size() > 0) {
        // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
        var currentNode = openHeap.pop(); // End case -- result has been found, return the traced path.

        if (currentNode === end) {
          return pathTo(currentNode);
        } // Normal case -- move currentNode from open to closed, process each of its neighbors.


        currentNode.closed = true; // Find all neighbors for the current node.

        var neighbors = graph.neighbors(currentNode);

        for (var i = 0, il = neighbors.length; i < il; ++i) {
          var neighbor = neighbors[i];

          if (neighbor.closed || neighbor.isWall()) {
            // Not a valid node to process, skip to next neighbor.
            continue;
          } // The g score is the shortest distance from start to current node.
          // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.


          var gScore = currentNode.g + neighbor.getCost(currentNode);
          var beenVisited = neighbor.visited;

          if (!beenVisited || gScore < neighbor.g) {
            // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
            neighbor.visited = true;
            neighbor.parent = currentNode;
            neighbor.h = neighbor.h || heuristic(neighbor, end);
            neighbor.g = gScore;
            neighbor.f = neighbor.g + neighbor.h;
            graph.markDirty(neighbor);

            if (closest) {
              // If the neighbour is closer than the current closestNode or if it's equally close but has
              // a cheaper path than the current closest node then it becomes the closest node
              if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
                closestNode = neighbor;
              }
            }

            if (!beenVisited) {
              // Pushing to heap will put it in proper place based on the 'f' value.
              openHeap.push(neighbor);
            } else {
              // Already seen the node, but since it has been rescored we need to reorder it in the heap
              openHeap.rescoreElement(neighbor);
            }
          }
        }
      }

      if (closest) {
        return pathTo(closestNode);
      } // No result was found - empty array signifies failure to find path.


      return [];
    },
    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    heuristics: {
      manhattan: function manhattan(pos0, pos1) {
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return d1 + d2;
      },
      diagonal: function diagonal(pos0, pos1) {
        var D = 1;
        var D2 = Math.sqrt(2);
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
      }
    },
    cleanNode: function cleanNode(node) {
      node.f = 0;
      node.g = 0;
      node.h = 0;
      node.visited = false;
      node.closed = false;
      node.parent = null;
    }
  };
  /**
   * A graph memory structure
   * @param {Array} gridIn 2D array of input weights
   * @param {Object} [options]
   * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed
   */

  function Graph(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];

    for (var x = 0; x < gridIn.length; x++) {
      this.grid[x] = [];

      for (var y = 0, row = gridIn[x]; y < row.length; y++) {
        var node = new GridNode(x, y, row[y]);
        this.grid[x][y] = node;
        this.nodes.push(node);
      }
    }

    this.init();
  }

  Graph.prototype.init = function () {
    this.dirtyNodes = [];

    for (var i = 0; i < this.nodes.length; i++) {
      astar.cleanNode(this.nodes[i]);
    }
  };

  Graph.prototype.cleanDirty = function () {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
      astar.cleanNode(this.dirtyNodes[i]);
    }

    this.dirtyNodes = [];
  };

  Graph.prototype.markDirty = function (node) {
    this.dirtyNodes.push(node);
  };

  Graph.prototype.neighbors = function (node) {
    var ret = [];
    var x = node.x;
    var y = node.y;
    var grid = this.grid; // West

    if (grid[x - 1] && grid[x - 1][y]) {
      ret.push(grid[x - 1][y]);
    } // East


    if (grid[x + 1] && grid[x + 1][y]) {
      ret.push(grid[x + 1][y]);
    } // South


    if (grid[x] && grid[x][y - 1]) {
      ret.push(grid[x][y - 1]);
    } // North


    if (grid[x] && grid[x][y + 1]) {
      ret.push(grid[x][y + 1]);
    }

    if (this.diagonal) {
      // Southwest
      if (grid[x - 1] && grid[x - 1][y - 1]) {
        ret.push(grid[x - 1][y - 1]);
      } // Southeast


      if (grid[x + 1] && grid[x + 1][y - 1]) {
        ret.push(grid[x + 1][y - 1]);
      } // Northwest


      if (grid[x - 1] && grid[x - 1][y + 1]) {
        ret.push(grid[x - 1][y + 1]);
      } // Northeast


      if (grid[x + 1] && grid[x + 1][y + 1]) {
        ret.push(grid[x + 1][y + 1]);
      }
    }

    return ret;
  };

  Graph.prototype.toString = function () {
    var graphString = [];
    var nodes = this.grid;

    for (var x = 0; x < nodes.length; x++) {
      var rowDebug = [];
      var row = nodes[x];

      for (var y = 0; y < row.length; y++) {
        rowDebug.push(row[y].weight);
      }

      graphString.push(rowDebug.join(" "));
    }

    return graphString.join("\n");
  };

  function GridNode(x, y, weight) {
    this.x = x;
    this.y = y;
    this.weight = weight;
  }

  GridNode.prototype.toString = function () {
    return "[" + this.x + " " + this.y + "]";
  };

  GridNode.prototype.getCost = function (fromNeighbor) {
    // Take diagonal weight into consideration.
    if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {
      return this.weight * 1.41421;
    }

    return this.weight;
  };

  GridNode.prototype.isWall = function () {
    return this.weight === 0;
  };

  function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
  }

  BinaryHeap.prototype = {
    push: function push(element) {
      // Add the new element to the end of the array.
      this.content.push(element); // Allow it to sink down.

      this.sinkDown(this.content.length - 1);
    },
    pop: function pop() {
      // Store the first element so we can return it later.
      var result = this.content[0]; // Get the element at the end of the array.

      var end = this.content.pop(); // If there are any elements left, put the end element at the
      // start, and let it bubble up.

      if (this.content.length > 0) {
        this.content[0] = end;
        this.bubbleUp(0);
      }

      return result;
    },
    remove: function remove(node) {
      var i = this.content.indexOf(node); // When it is found, the process seen in 'pop' is repeated
      // to fill up the hole.

      var end = this.content.pop();

      if (i !== this.content.length - 1) {
        this.content[i] = end;

        if (this.scoreFunction(end) < this.scoreFunction(node)) {
          this.sinkDown(i);
        } else {
          this.bubbleUp(i);
        }
      }
    },
    size: function size() {
      return this.content.length;
    },
    rescoreElement: function rescoreElement(node) {
      this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function sinkDown(n) {
      // Fetch the element that has to be sunk.
      var element = this.content[n]; // When at 0, an element can not sink any further.

      while (n > 0) {
        // Compute the parent element's index, and fetch it.
        var parentN = (n + 1 >> 1) - 1;
        var parent = this.content[parentN]; // Swap the elements if the parent is greater.

        if (this.scoreFunction(element) < this.scoreFunction(parent)) {
          this.content[parentN] = element;
          this.content[n] = parent; // Update 'n' to continue at the new position.

          n = parentN;
        } // Found a parent that is less, no need to sink any further.
        else {
            break;
          }
      }
    },
    bubbleUp: function bubbleUp(n) {
      // Look up the target element and its score.
      var length = this.content.length;
      var element = this.content[n];
      var elemScore = this.scoreFunction(element);

      while (true) {
        // Compute the indices of the child elements.
        var child2N = n + 1 << 1;
        var child1N = child2N - 1; // This is used to store the new position of the element, if any.

        var swap = null;
        var child1Score; // If the first child exists (is inside the array)...

        if (child1N < length) {
          // Look it up and compute its score.
          var child1 = this.content[child1N];
          child1Score = this.scoreFunction(child1); // If the score is less than our element's, we need to swap.

          if (child1Score < elemScore) {
            swap = child1N;
          }
        } // Do the same checks for the other child.


        if (child2N < length) {
          var child2 = this.content[child2N];
          var child2Score = this.scoreFunction(child2);

          if (child2Score < (swap === null ? elemScore : child1Score)) {
            swap = child2N;
          }
        } // If the element needs to be moved, swap it, and continue.


        if (swap !== null) {
          this.content[n] = this.content[swap];
          this.content[swap] = element;
          n = swap;
        } // Otherwise, we are done.
        else {
            break;
          }
      }
    }
  };
  return {
    astar: astar,
    Graph: Graph
  };
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../server/node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _standalone_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./standalone-server */ "./standalone-server.js");

/* harmony default export */ __webpack_exports__["default"] = (new _standalone_server__WEBPACK_IMPORTED_MODULE_0__["default"]());

/***/ }),

/***/ "./node_modules/three/src/math/Math.js":
/*!*********************************************!*\
  !*** ./node_modules/three/src/math/Math.js ***!
  \*********************************************/
/*! exports provided: _Math */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_Math", function() { return _Math; });
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _lut = [];

for ( var i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

var _Math = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

		var d0 = Math.random() * 0xffffffff | 0;
		var d1 = Math.random() * 0xffffffff | 0;
		var d2 = Math.random() * 0xffffffff | 0;
		var d3 = Math.random() * 0xffffffff | 0;
		var uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toUpperCase() here flattens concatenated strings to save heap memory space.
		return uuid.toUpperCase();

	},

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function ( degrees ) {

		return degrees * _Math.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * _Math.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	ceilPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	},

	floorPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	}

};





/***/ }),

/***/ "./node_modules/three/src/math/Quaternion.js":
/*!***************************************************!*\
  !*** ./node_modules/three/src/math/Quaternion.js ***!
  \***************************************************/
/*! exports provided: Quaternion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math.js */ "./node_modules/three/src/math/Math.js");
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */



function Quaternion( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

}

Object.assign( Quaternion, {

	slerp: function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	},

	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ],

			x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			var s = 1 - t,

				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			var tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

} );

Object.defineProperties( Quaternion.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this._onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this._onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this._onChangeCallback();

		}

	},

	w: {

		get: function () {

			return this._w;

		},

		set: function ( value ) {

			this._w = value;
			this._onChangeCallback();

		}

	}

} );

Object.assign( Quaternion.prototype, {

	isQuaternion: true,

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var cos = Math.cos;
		var sin = Math.sin;

		var c1 = cos( x / 2 );
		var c2 = cos( y / 2 );
		var c3 = cos( z / 2 );

		var s1 = sin( x / 2 );
		var s2 = sin( y / 2 );
		var s3 = sin( z / 2 );

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	},

	setFromUnitVectors: function ( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		var EPS = 0.000001;

		var r = vFrom.dot( vTo ) + 1;

		if ( r < EPS ) {

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	},

	angleTo: function ( q ) {

		return 2 * Math.acos( Math.abs( _Math_js__WEBPACK_IMPORTED_MODULE_0__["_Math"].clamp( this.dot( q ), - 1, 1 ) ) );

	},

	rotateTowards: function ( q, step ) {

		var angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		var t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	},

	inverse: function () {

		// quaternion is assumed to have unit length

		return this.conjugate();

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	premultiply: function ( q ) {

		return this.multiplyQuaternions( q, this );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			var s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	_onChange: function ( callback ) {

		this._onChangeCallback = callback;

		return this;

	},

	_onChangeCallback: function () {}

} );





/***/ }),

/***/ "./node_modules/three/src/math/Vector3.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Vector3.js ***!
  \************************************************/
/*! exports provided: Vector3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math.js */ "./node_modules/three/src/math/Math.js");
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");



/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

var _vector = new Vector3();
var _quaternion = new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__["Quaternion"]();

function Vector3( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

}

Object.assign( Vector3.prototype, {

	isVector3: true,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

	},

	applyAxisAngle: function ( axis, angle ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

	},

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyNormalMatrix: function ( m ) {

		return this.applyMatrix3( m ).normalize();

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x, y = this.y, z = this.z;
		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		var ix = qw * x + qy * z - qz * y;
		var iy = qw * y + qz * x - qx * z;
		var iz = qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function ( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	},

	unproject: function ( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	},

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function ( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	},

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	// TODO lengthSquared?

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	manhattanLength: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function ( v ) {

		// v cannot be the zero v

		var scalar = v.dot( this ) / v.lengthSq();

		return this.copy( v ).multiplyScalar( scalar );

	},

	projectOnPlane: function ( planeNormal ) {

		_vector.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector );

	},

	reflect: function ( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	},

	angleTo: function ( v ) {

		var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) console.error( 'THREE.Vector3: angleTo() can\'t handle zero length vectors.' );

		var theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( _Math_js__WEBPACK_IMPORTED_MODULE_0__["_Math"].clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	manhattanDistanceTo: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	},

	setFromSpherical: function ( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	},

	setFromSphericalCoords: function ( radius, phi, theta ) {

		var sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	},

	setFromCylindrical: function ( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	},

	setFromCylindricalCoords: function ( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	},

	setFromMatrixPosition: function ( m ) {

		var e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

} );





/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const WebSocket = __webpack_require__(/*! ./lib/websocket */ "./node_modules/ws/lib/websocket.js");

WebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ "./node_modules/ws/lib/stream.js");
WebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ "./node_modules/ws/lib/websocket-server.js");
WebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ "./node_modules/ws/lib/receiver.js");
WebSocket.Sender = __webpack_require__(/*! ./lib/sender */ "./node_modules/ws/lib/sender.js");

module.exports = WebSocket;


/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (let i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

try {
  const bufferUtil = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'bufferutil'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = {
    concat,
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    toArrayBuffer,
    toBuffer,
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
}


/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  EMPTY_BUFFER: Buffer.alloc(0),
  NOOP: () => {}
};


/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Class representing an event.
 *
 * @private
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was dispatched
   */
  constructor(type, target) {
    this.target = target;
    this.type = type;
  }
}

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(data, target) {
    super('message', target);

    this.data = data;
  }
}

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {Number} code The status code explaining why the connection is being closed
   * @param {String} reason A human-readable string explaining why the connection is closing
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  }
}

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event {
  /**
   * Create a new `OpenEvent`.
   *
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(target) {
    super('open', target);
  }
}

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {Object} error The error that generated this event
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  }
}

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @param {Object} options An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} options.once A `Boolean`` indicating that the listener
   *     should be invoked at most once after being added. If `true`, the
   *     listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, listener, options) {
    if (typeof listener !== 'function') return;

    function onMessage(data) {
      listener.call(this, new MessageEvent(data, this));
    }

    function onClose(code, message) {
      listener.call(this, new CloseEvent(code, message, this));
    }

    function onError(error) {
      listener.call(this, new ErrorEvent(error, this));
    }

    function onOpen() {
      listener.call(this, new OpenEvent(this));
    }

    const method = options && options.once ? 'once' : 'on';

    if (type === 'message') {
      onMessage._listener = listener;
      this[method](type, onMessage);
    } else if (type === 'close') {
      onClose._listener = listener;
      this[method](type, onClose);
    } else if (type === 'error') {
      onError._listener = listener;
      this[method](type, onError);
    } else if (type === 'open') {
      onOpen._listener = listener;
      this[method](type, onOpen);
    } else {
      this[method](type, listener);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {Function} listener The listener to remove
   * @public
   */
  removeEventListener(type, listener) {
    const listeners = this.listeners(type);

    for (let i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(type, listeners[i]);
      }
    }
  }
};

module.exports = EventTarget;


/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);

  if (header === undefined || header === '') return offers;

  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ "./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} concurrency The maximum number of jobs allowed to run
   *     concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const zlib = __webpack_require__(/*! zlib */ "zlib");

const bufferUtil = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");
const Limiter = __webpack_require__(/*! ./limiter */ "./node_modules/ws/lib/limiter.js");
const { kStatusCode, NOOP } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling
   *     of server context takeover
   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge
   *     disabling of client context takeover
   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the
   *     use of a custom server window size
   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support
   *     for, or request, a custom client window size
   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate
   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate
   * @param {Number} options.threshold Size (in bytes) below which messages
   *     should not be compressed
   * @param {Number} options.concurrencyLimit The number of concurrent calls to
   *     zlib
   * @param {Boolean} isServer Create the instance in either server or client
   *     mode
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      //
      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
      // `zlib.DeflateRaw` instance is closed while data is being processed.
      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
      // time due to an abnormal WebSocket closure.
      //
      this._deflate.on('error', NOOP);
      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.close();
        this._deflate = null;
      } else {
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { Writable } = __webpack_require__(/*! stream */ "stream");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends stream.Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {String} binaryType The type for binary data
   * @param {Object} extensions An object containing the negotiated extensions
   * @param {Boolean} isServer Specifies whether to operate in client or server
   *     mode
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor(binaryType, extensions, isServer, maxPayload) {
    super();

    this._binaryType = binaryType || BINARY_TYPES[0];
    this[kWebSocket] = undefined;
    this._extensions = extensions || {};
    this._isServer = !!isServer;
    this._maxPayload = maxPayload | 0;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(RangeError, 'RSV1 must be clear', true, 1002);
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(RangeError, 'invalid opcode 0', true, 1002);
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(RangeError, 'FIN must be set', true, 1002);
      }

      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002
        );
      }
    } else {
      this._loop = false;
      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error(RangeError, 'MASK must be set', true, 1002);
      }
    } else if (this._masked) {
      this._loop = false;
      return error(RangeError, 'MASK must be clear', true, 1002);
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(RangeError, 'Max payload size exceeded', false, 1009);
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);
      if (this._masked) unmask(data, this._mask);
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its lenght is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(RangeError, 'Max payload size exceeded', false, 1009)
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        let data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data);
      } else {
        const buf = concat(fragments, messageLength);

        if (!isValidUTF8(buf)) {
          this._loop = false;
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('message', buf.toString());
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, '');
        this.end();
      } else if (data.length === 1) {
        return error(RangeError, 'invalid payload length 1', true, 1002);
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          return error(RangeError, `invalid status code ${code}`, true, 1002);
        }

        const buf = data.slice(2);

        if (!isValidUTF8(buf)) {
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('conclude', code, buf.toString());
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {(Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err[kStatusCode] = statusCode;
  return err;
}


/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { randomFillSync } = __webpack_require__(/*! crypto */ "crypto");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { isValidStatusCode } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");
const { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

const mask = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} extensions An object containing the negotiated extensions
   */
  constructor(socket, extensions) {
    this._extensions = extensions || {};
    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame(data, options) {
    const merge = options.mask && options.readOnly;
    let offset = options.mask ? 6 : 2;
    let payloadLength = data.length;

    if (data.length >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2);
      target.writeUInt32BE(data.length, 6);
    }

    if (!options.mask) return [target, data];

    randomFillSync(mask, 0, 4);

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      applyMask(data, mask, target, offset, data.length);
      return [target];
    }

    applyMask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {(Number|undefined)} code The status code component of the body
   * @param {String} data The message component of the body
   * @param {Boolean} mask Specifies whether or not to mask the message
   * @param {Function} cb Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || data === '') {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);
      buf.write(data, 2);
    }

    if (this._deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @private
   */
  doClose(data, mask, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask,
        readOnly: false
      }),
      cb
    );
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  ping(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPing(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a ping message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPing(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  pong(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPong(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a pong message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPong(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  send(data, options, cb) {
    const buf = toBuffer(data);
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate) {
        rsv1 = buf.length >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        fin: options.fin,
        rsv1,
        opcode,
        mask: options.mask,
        readOnly: toBuffer.readOnly
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
      } else {
        this.dispatch(buf, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a data message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} compress Specifies whether or not to compress `data`
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @param {Function} cb Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const callback = this._queue[i][4];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[1].length;
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[1].length;
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} cb Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { Duplex } = __webpack_require__(/*! stream */ "stream");

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {stream.Duplex} The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} options The options for the `Duplex` constructor
 * @return {stream.Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let resumeOnReceiverDrain = true;

  function receiverOnDrain() {
    if (resumeOnReceiverDrain) ws._socket.resume();
  }

  if (ws.readyState === ws.CONNECTING) {
    ws.once('open', function open() {
      ws._receiver.removeAllListeners('drain');
      ws._receiver.on('drain', receiverOnDrain);
    });
  } else {
    ws._receiver.removeAllListeners('drain');
    ws._receiver.on('drain', receiverOnDrain);
  }

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg) {
    if (!duplex.push(msg)) {
      resumeOnReceiverDrain = false;
      ws._socket.pause();
    }
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function(err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });
    ws.terminate();
  };

  duplex._final = function(callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function() {
    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
      resumeOnReceiverDrain = true;
      if (!ws._receiver._writableState.needDrain) ws._socket.resume();
    }
  };

  duplex._write = function(chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


try {
  const isValidUTF8 = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'utf-8-validate'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

  exports.isValidUTF8 =
    typeof isValidUTF8 === 'object'
      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0
      : isValidUTF8;
} catch (e) /* istanbul ignore next */ {
  exports.isValidUTF8 = () => true;
}

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
exports.isValidStatusCode = (code) => {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
};


/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events");
const { createHash } = __webpack_require__(/*! crypto */ "crypto");
const { createServer, STATUS_CODES } = __webpack_require__(/*! http */ "http");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const WebSocket = __webpack_require__(/*! ./websocket */ "./node_modules/ws/lib/websocket.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");
const { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} options.backlog The maximum length of the queue of pending
   *     connections
   * @param {Boolean} options.clientTracking Specifies whether or not to track
   *     clients
   * @param {Function} options.handleProtocols A hook to handle protocols
   * @param {String} options.host The hostname where to bind the server
   * @param {Number} options.maxPayload The maximum allowed message size
   * @param {Boolean} options.noServer Enable no server mode
   * @param {String} options.path Accept only connections matching this path
   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable
   *     permessage-deflate
   * @param {Number} options.port The port where to bind the server
   * @param {http.Server} options.server A pre-created HTTP/S server to use
   * @param {Function} options.verifyClient A hook to reject connections
   * @param {Function} callback A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      ...options
    };

    if (options.port == null && !options.server && !options.noServer) {
      throw new TypeError(
        'One of the "port", "server", or "noServer" options must be specified'
      );
    }

    if (options.port != null) {
      this._server = createServer((req, res) => {
        const body = STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, (ws) => {
            this.emit('connection', ws, req);
          });
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) this.clients = new Set();
    this.options = options;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Close the server.
   *
   * @param {Function} cb Callback
   * @public
   */
  close(cb) {
    if (cb) this.once('close', cb);

    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) {
        server.close(() => this.emit('close'));
        return;
      }
    }

    process.nextTick(emitClose, this);
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key =
      req.headers['sec-websocket-key'] !== undefined
        ? req.headers['sec-websocket-key'].trim()
        : false;
    const version = +req.headers['sec-websocket-version'];
    const extensions = {};

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !key ||
      !keyRegex.test(key) ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    if (this.options.perMessageDeflate) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = parse(req.headers['sec-websocket-extensions']);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.connection.authorized || req.connection.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(key, extensions, req, socket, head, cb);
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(key, extensions, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Object} extensions The accepted extensions
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(key, extensions, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new WebSocket(null);
    let protocol = req.headers['sec-websocket-protocol'];

    if (protocol) {
      protocol = protocol.trim().split(/ *, */);

      //
      // Optionally call external protocol selection handler.
      //
      if (this.options.handleProtocols) {
        protocol = this.options.handleProtocols(protocol, req);
      } else {
        protocol = protocol[0];
      }

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws.protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => this.clients.delete(ws));
    }

    cb(ws);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server.emit('close');
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {net.Socket} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || STATUS_CODES[code];
    headers = {
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message),
      ...headers
    };

    socket.write(
      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\r\n` +
        Object.keys(headers)
          .map((h) => `${h}: ${headers[h]}`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}


/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events");
const https = __webpack_require__(/*! https */ "https");
const http = __webpack_require__(/*! http */ "http");
const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { randomBytes, createHash } = __webpack_require__(/*! crypto */ "crypto");
const { URL } = __webpack_require__(/*! url */ "url");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const Receiver = __webpack_require__(/*! ./receiver */ "./node_modules/ws/lib/receiver.js");
const Sender = __webpack_require__(/*! ./sender */ "./node_modules/ws/lib/sender.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { addEventListener, removeEventListener } = __webpack_require__(/*! ./event-target */ "./node_modules/ws/lib/event-target.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");
const { toBuffer } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|url.URL)} address The URL to which to connect
   * @param {(String|String[])} protocols The subprotocols
   * @param {Object} options Connection options
   */
  constructor(address, protocols, options) {
    super();

    this.readyState = WebSocket.CONNECTING;
    this.protocol = '';

    this._binaryType = BINARY_TYPES[0];
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = '';
    this._closeTimer = null;
    this._closeCode = 1006;
    this._extensions = {};
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (Array.isArray(protocols)) {
        protocols = protocols.join(', ');
      } else if (typeof protocols === 'object' && protocols !== null) {
        options = protocols;
        protocols = undefined;
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  get CONNECTING() {
    return WebSocket.CONNECTING;
  }
  get CLOSING() {
    return WebSocket.CLOSING;
  }
  get CLOSED() {
    return WebSocket.CLOSED;
  }
  get OPEN() {
    return WebSocket.OPEN;
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    //
    // `socket.bufferSize` is `undefined` if the socket is closed.
    //
    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Number} maxPayload The maximum allowed message size
   * @private
   */
  setSocket(socket, head, maxPayload) {
    const receiver = new Receiver(
      this._binaryType,
      this._extensions,
      this._isServer,
      maxPayload
    );

    this._sender = new Sender(socket, this._extensions);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this.readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this.readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this.readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} code Status code explaining why the connection is closing
   * @param {String} data A string explaining why the connection is closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
      return;
    }

    this.readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;
      if (this._closeFrameReceived) this._socket.end();
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Send a ping.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress
   *     `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this.readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

readyStates.forEach((readyState, i) => {
  WebSocket[readyState] = i;
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    /**
     * Return the listener of the event.
     *
     * @return {(Function|undefined)} The event listener or `undefined`
     * @public
     */
    get() {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        if (listeners[i]._listener) return listeners[i]._listener;
      }

      return undefined;
    },
    /**
     * Add a listener for the event.
     *
     * @param {Function} listener The listener to add
     * @public
     */
    set(listener) {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.addEventListener(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|url.URL)} address The URL to which to connect
 * @param {String} protocols The subprotocols
 * @param {Object} options Connection options
 * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable
 *     permessage-deflate
 * @param {Number} options.handshakeTimeout Timeout in milliseconds for the
 *     handshake request
 * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version`
 *     header
 * @param {String} options.origin Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {Number} options.maxPayload The maximum allowed message size
 * @param {Boolean} options.followRedirects Whether or not to follow redirects
 * @param {Number} options.maxRedirects The maximum number of redirects allowed
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket.url = address.href;
  } else {
    parsedUrl = new URL(address);
    websocket.url = address;
  }

  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
    throw new Error(`Invalid URL: ${websocket.url}`);
  }

  const isSecure =
    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const get = isSecure ? https.get : http.get;
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket',
    ...opts.headers
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols) {
    opts.headers['Sec-WebSocket-Protocol'] = protocols;
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req = (websocket._req = get(opts));

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (websocket._req.aborted) return;

    req = websocket._req = null;
    websocket.readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      const addr = new URL(location, address);

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    const protList = (protocols || '').split(/, */);
    let protError;

    if (!protocols && serverProt) {
      protError = 'Server sent a subprotocol but none was requested';
    } else if (protocols && !serverProt) {
      protError = 'Server sent no subprotocol';
    } else if (serverProt && !protList.includes(serverProt)) {
      protError = 'Server sent an invalid subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket.protocol = serverProt;

    if (perMessageDeflate) {
      try {
        const extensions = parse(res.headers['sec-websocket-extensions']);

        if (extensions[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          websocket._extensions[
            PerMessageDeflate.extensionName
          ] = perMessageDeflate;
        }
      } catch (err) {
        abortHandshake(
          websocket,
          socket,
          'Invalid Sec-WebSocket-Extensions header'
        );
        return;
      }
    }

    websocket.setSocket(socket, head, opts.maxPayload);
  });
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the
 *     socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket.readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();
    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} data The data to send
 * @param {Function} cb Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    cb(err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {String} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);
  websocket._socket.resume();

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  this[kWebSocket]._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);

  websocket.readyState = WebSocket.CLOSING;
  websocket._closeCode = err[kStatusCode];
  websocket.emit('error', err);
  websocket._socket.destroy();
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
 * @private
 */
function receiverOnMessage(data) {
  this[kWebSocket].emit('message', data);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('end', socketOnEnd);

  websocket.readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk and emitted synchronously in a single
  // `'data'` event.
  //
  websocket._socket.read();
  websocket._receiver.end();

  this.removeListener('data', socketOnData);
  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket.readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket.readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ "./src/MockDependencies.js":
/*!*********************************!*\
  !*** ./src/MockDependencies.js ***!
  \*********************************/
/*! exports provided: MockGUI, MockRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MockGUI", function() { return MockGUI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MockRenderer", function() { return MockRenderer; });
/* harmony import */ var three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/src/math/Vector3 */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/src/math/Quaternion */ "./node_modules/three/src/math/Quaternion.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




global.debug = function () {
  var _console;

  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return (_console = console).log.apply(_console, ["[".concat(new Date().toLocaleTimeString(), "]")].concat(params));
};

var Object3D = function Object3D() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var objects = [];

  var add = function add(object) {
    return objects.push(object);
  };

  var remove = function remove(object) {
    return objects = object.filter(function (o) {
      return o !== object;
    });
  };

  var object = _objectSpread({
    position: new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
    scale: new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
    rotation: new three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_1__["Quaternion"](),
    add: add,
    remove: remove,
    lookAt: function lookAt() {
      return {};
    },
    traverse: function traverse() {
      return {};
    },
    updateMatrix: function updateMatrix() {
      return {};
    },
    getObjectByName: function getObjectByName() {
      return object;
    }
  }, params);

  object.quaternion = object.rotation;
  object.scene = object;

  object.clone = function () {
    var cloned = Object3D();
    cloned.position.clone(object.position);
    cloned.scale.clone(object.scale);
    cloned.rotation.clone(object.rotation);
    return cloned;
  };

  return object;
};

global.THREE = {
  Vector3: three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_0__["Vector3"],
  Quaternion: three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_1__["Quaternion"],
  Object3D: Object3D,
  WebGLRenderer: function WebGLRenderer() {
    return {
      render: function render() {
        return {};
      },
      setSize: function setSize() {
        return {};
      },
      getContext: function getContext() {
        return {
          canvas: {
            width: 0,
            height: 0
          }
        };
      },
      shadowMap: {}
    };
  },
  Scene: function Scene() {
    return Object3D();
  },
  Cache: {},
  Clock: function Clock() {
    return {};
  },
  AnimationMixer: function AnimationMixer() {
    return {
      update: function update() {
        return {};
      },
      clipAction: function clipAction() {
        return {
          stop: function stop() {
            return {};
          }
        };
      }
    };
  },
  PCFSoftShadowMap: function PCFSoftShadowMap() {
    return {};
  },
  PerspectiveCamera: function PerspectiveCamera() {
    return Object3D();
  },
  Raycaster: function Raycaster() {
    return {};
  },
  TextureLoader: function TextureLoader() {
    return {
      load: function load() {
        return {};
      }
    };
  },
  Fog: function Fog() {
    return {};
  },
  RepeatWrapping: function RepeatWrapping() {
    return {};
  },
  Color: function Color() {
    return {};
  },
  Mesh: function Mesh() {
    return Object3D();
  },
  CubeGeometry: function CubeGeometry() {
    return {};
  },
  MeshLambertMaterial: function MeshLambertMaterial() {
    return {};
  },
  NormalBlending: function NormalBlending() {
    return {};
  },
  AdditiveBlending: function AdditiveBlending() {
    return {};
  },
  Geometry: function Geometry() {
    return {};
  },
  PointCloudMaterial: function PointCloudMaterial() {
    return {};
  },
  PointCloud: function PointCloud() {
    return {};
  },
  AmbientLight: function AmbientLight() {
    return {};
  },
  DirectionalLight: function DirectionalLight() {
    var light = Object3D();
    light.shadow = {
      camera: {},
      mapSize: {}
    };
    return light;
  },
  MeshBasicMaterial: function MeshBasicMaterial() {
    return {};
  },
  BackSide: function BackSide() {
    return {};
  },
  MeshFaceMaterial: function MeshFaceMaterial() {
    return {};
  }
};

global.GLTFLoader = function () {
  return {
    load: function load(url, callback) {
      return callback(Object3D());
    }
  };
};

global.window = {
  innerWidth: 0,
  innerHeight: 0,
  clearTimeout: 0,
  requestAnimationFrame: function requestAnimationFrame(fn) {
    return setTimeout(fn, 1000 / 60);
  },
  location: {
    reload: function reload() {
      return debug('reload page');
    }
  },
  addEventListener: function addEventListener() {
    for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      params[_key2] = arguments[_key2];
    }

    return debug.apply(void 0, ['window.addEventListener'].concat(params));
  },
  setTimeout: setTimeout,
  WebSocket: function WebSocket() {
    return {
      onopen: function onopen() {
        for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          params[_key3] = arguments[_key3];
        }

        return debug.apply(void 0, ['window.WebSocket.onopen'].concat(params));
      },
      onerror: function onerror() {
        for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          params[_key4] = arguments[_key4];
        }

        return debug.apply(void 0, ['window.WebSocket.onerror'].concat(params));
      },
      onmessage: function onmessage() {
        for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          params[_key5] = arguments[_key5];
        }

        return debug.apply(void 0, ['window.WebSocket.onmessage'].concat(params));
      }
    };
  }
};
global.document = {
  body: {
    addEventListener: function addEventListener() {
      for (var _len6 = arguments.length, params = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        params[_key6] = arguments[_key6];
      }

      return debug.apply(void 0, ['document.body.addEventListener'].concat(params));
    },
    removeEventListener: function removeEventListener() {
      for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        params[_key7] = arguments[_key7];
      }

      return debug.apply(void 0, ['document.body.removeEventListener'].concat(params));
    }
  },
  dispatchEvent: function dispatchEvent() {
    for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      params[_key8] = arguments[_key8];
    }

    return debug.apply(void 0, ['document.dispatchEvent'].concat(params));
  },
  getElementById: function getElementById() {
    for (var _len9 = arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      params[_key9] = arguments[_key9];
    }

    return debug.apply(void 0, ['document.getElementById'].concat(params));
  },
  addEventListener: function addEventListener() {
    for (var _len10 = arguments.length, params = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      params[_key10] = arguments[_key10];
    }

    return debug.apply(void 0, ['document.addEventListener'].concat(params));
  },
  removeEventListener: function removeEventListener() {
    for (var _len11 = arguments.length, params = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      params[_key11] = arguments[_key11];
    }

    return debug.apply(void 0, ['document.removeEventListener'].concat(params));
  }
};
var MockGUI = {
  isServer: true,
  setRestartButtonVisible: function setRestartButtonVisible() {
    return null;
  },
  setPause: function setPause() {
    return null;
  },
  restartGame: function restartGame() {
    return null;
  },
  isPause: function isPause() {
    return false;
  },
  isThirdPerson: function isThirdPerson() {
    return false;
  },
  update: function update() {
    return null;
  },
  setConnectionRole: debug,
  updatePlayerParams: function updatePlayerParams() {
    return null;
  },
  clearHpBars: function clearHpBars() {
    return null;
  },
  switchCamera: function switchCamera() {
    return null;
  },
  setFps: function setFps() {
    return null;
  },
  notify: debug,
  setLoading: function setLoading() {
    return null;
  }
};
var MockRenderer = {
  fps: 1,
  targetFps: 1,
  renderer: new THREE.WebGLRenderer(),
  render: function render() {
    return {};
  }
};

/***/ }),

/***/ "./src/SocketServer.js":
/*!*****************************!*\
  !*** ./src/SocketServer.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ "./node_modules/ws/index.js");
/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var WebSocketServer = ws__WEBPACK_IMPORTED_MODULE_0__["Server"];

var SocketServer = /*#__PURE__*/function () {
  function SocketServer() {
    _classCallCheck(this, SocketServer);

    this.createSocketServer = this.createSocketServer.bind(this);
    this.saveUserData = this.saveUserData.bind(this);
    this.loadUserData = this.loadUserData.bind(this);
    this.config = {
      ssl: true,
      port: 1337,
      sslKey: path__WEBPACK_IMPORTED_MODULE_2__["join"](__dirname, './private.key'),
      sslCertificate: path__WEBPACK_IMPORTED_MODULE_2__["join"](__dirname, './fullchain.cert'),
      sessionsPath: path__WEBPACK_IMPORTED_MODULE_2__["join"](__dirname, './sessions/'),
      debug: false
    };
    console.log(__dirname, fs__WEBPACK_IMPORTED_MODULE_1__["readdirSync"](__dirname));
    this.db = {
      sequenceId: 0,
      hostId: null,
      connections: {},
      players: {},
      gameObjects: []
    };
    var socketServer = this.createSocketServer(this.config);
    this.startSocketServer(socketServer);
  }

  _createClass(SocketServer, [{
    key: "createSocketServer",
    value: function createSocketServer(config) {
      var httpServ = config.ssl ? __webpack_require__(/*! https */ "https") : __webpack_require__(/*! http */ "http");
      var server = null;

      var processRequest = function processRequest(req, res) {
        res.writeHead(200);
        res.end("All glory to WebSockets!\n");
      };

      if (config.ssl) {
        server = httpServ.createServer({
          key: fs__WEBPACK_IMPORTED_MODULE_1__["readFileSync"](config.sslKey),
          cert: fs__WEBPACK_IMPORTED_MODULE_1__["readFileSync"](config.sslCertificate)
        }, processRequest).listen(config.port);
      } else {
        server = httpServ.createServer(processRequest).listen(config.port);
      }

      var webSocketServer = new WebSocketServer({
        server: server
      });
      debug("Server is running on port ".concat(config.port));
      return webSocketServer;
    }
  }, {
    key: "saveUserData",
    value: function saveUserData(token, data) {
      try {
        if (!fs__WEBPACK_IMPORTED_MODULE_1__["existsSync"](this.config.sessionsPath)) {
          fs__WEBPACK_IMPORTED_MODULE_1__["mkdirSync"](this.config.sessionsPath);
        }

        fs__WEBPACK_IMPORTED_MODULE_1__["writeFileSync"]("".concat(this.config.sessionsPath, "/").concat(token), JSON.stringify(data));
        return true;
      } catch (e) {
        debug('Save user data error', e);
        return false;
      }
    }
  }, {
    key: "loadUserData",
    value: function loadUserData(token) {
      var tokenPath = "".concat(this.config.sessionsPath, "/").concat(token);

      try {
        if (fs__WEBPACK_IMPORTED_MODULE_1__["existsSync"](tokenPath)) {
          return JSON.parse(fs__WEBPACK_IMPORTED_MODULE_1__["readFileSync"](tokenPath, 'utf8'));
        }
      } catch (e) {
        debug('Load user data error', e);
      }

      return false;
    }
  }, {
    key: "startSocketServer",
    value: function startSocketServer(socketServer) {
      var _this = this;

      var getConnectionId = function getConnectionId(c) {
        return c._id;
      };

      var getConnectionToken = function getConnectionToken(c) {
        return c._meta.token;
      };

      var send = function send(connection, messageType, data) {
        return connection.send(JSON.stringify({
          meta: {
            server: {
              version: 1
            },
            role: getConnectionId(connection) === _this.db.hostId ? 'host' : 'client',
            id: getConnectionId(connection),
            token: connection._meta.token,
            debug: _this.config.debug
          },
          data: data,
          messageType: messageType
        }));
      };

      setInterval(function () {
        var isHost = function isHost(connection) {
          return getConnectionId(connection) === _this.db.hostId;
        };

        Object.values(_this.db.connections).forEach(function (connection) {
          var connectionPlayer = _this.db.players[getConnectionId(connection)];

          var networkPlayers = Object.values(_this.db.players).filter(function (player) {
            return player !== connectionPlayer;
          });

          if (isHost(connection)) {
            send(connection, 'updateGameObjects', networkPlayers);
          } else {
            send(connection, 'updateGameObjects', [].concat(_toConsumableArray(_this.db.gameObjects), _toConsumableArray(networkPlayers)));
          }
        });
      }, 100);
      setInterval(function () {
        var isHost = function isHost(connection) {
          return getConnectionId(connection) === _this.db.hostId;
        };

        Object.values(_this.db.connections).forEach(function (connection) {
          var connectionPlayer = _this.db.players[getConnectionId(connection)];

          var token = getConnectionToken(connection);

          if (connectionPlayer && token) {
            _this.saveUserData(token, connectionPlayer);
          }
        });
      }, 10000);
      socketServer.on('connection', function (connection) {
        var _this2 = this;

        var id = ++this.db.sequenceId;
        debug('New connection, id:', id);
        this.db.connections[id] = connection;
        connection._meta = {
          id: id
        };
        connection._id = id;

        if (!this.db.hostId) {
          this.db.hostId = id;
          debug('Host changed to', id);
        }

        var onSocketClose = function onSocketClose() {
          var id = getConnectionId(connection);
          debug('Connection closed, id:', id);

          if (id === _this2.db.hostId) {
            var activeConnections = Object.values(_this2.db.connections).filter(function (c) {
              return c._id !== id;
            });
            _this2.db.hostId = activeConnections.length ? activeConnections[0]._id : null;
            debug('Host changed to', _this2.db.hostId);
          }

          Object.values(_this2.db.connections).forEach(function (c) {
            send(c, 'disconnected', {
              connectionId: id
            });
          });
          delete _this2.db.connections[id];
          delete _this2.db.players[id];
        };

        var onSocketMessage = function onSocketMessage(message) {
          var _JSON$parse = JSON.parse(message),
              data = _JSON$parse.data,
              messageType = _JSON$parse.messageType,
              meta = _JSON$parse.meta;

          var connectionId = getConnectionId(connection);

          if (meta && meta.token && meta.token !== connection._meta.token) {
            debug("User #".concat(connectionId, " token changed from ").concat(connection._meta.token, " to ").concat(meta.token));
            connection._meta.token = meta.token;
          }

          var updateGameObjectsData = function updateGameObjectsData(gameObjects) {
            if (connectionId === _this2.db.hostId) {
              _this2.db.gameObjects = gameObjects.filter(function (gameObject) {
                return gameObject.type !== 'player';
              });
              var player = gameObjects.find(function (gameObject) {
                return gameObject.type === 'player';
              });
              _this2.db.players[connectionId] = player;
            }
          };

          var sendUserData = function sendUserData() {
            send(connection, 'setUserPlayer', _this2.loadUserData(connection._meta.token));
          };

          var updatePlayerData = function updatePlayerData(player) {
            _this2.db.players[connectionId] = player;
          };

          var takeHost = function takeHost() {
            debug("#".concat(connectionId, " takes the host"));
            _this2.db.hostId = connectionId;
          };

          var restartServer = function restartServer() {
            debug("#".concat(connectionId, " reloads server"));
            Object.values(_this2.db.connections).forEach(function (c) {
              return send(c, 'restartServer');
            });
          };

          switch (messageType) {
            case 'loadCurrentUser':
              {
                sendUserData();
                break;
              }

            case 'updateGameObjects':
              {
                updateGameObjectsData(data);
                break;
              }

            case 'updatePlayer':
              {
                updatePlayerData(data);
                break;
              }

            case 'takeHost':
              {
                takeHost();
                break;
              }

            case 'restartServer':
              {
                restartServer();
                break;
              }
          }
        };

        connection.on('message', onSocketMessage);
        connection.on('close', onSocketClose);
        send(connection, 'handshake');
      });
    }
  }]);

  return SocketServer;
}();

/* harmony default export */ __webpack_exports__["default"] = (SocketServer);

/***/ }),

/***/ "./standalone-server.js":
/*!******************************!*\
  !*** ./standalone-server.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_MockDependencies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/MockDependencies */ "./src/MockDependencies.js");
/* harmony import */ var _src_SocketServer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/SocketServer */ "./src/SocketServer.js");
/* harmony import */ var _client_src_js_Scene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../client/src/js/Scene */ "../client/src/js/Scene.js");




function Server() {
  var _this = this;

  debug('Starting server scene initialization ...');
  var scene = new _client_src_js_Scene__WEBPACK_IMPORTED_MODULE_2__["default"](_src_MockDependencies__WEBPACK_IMPORTED_MODULE_0__["MockRenderer"], _src_MockDependencies__WEBPACK_IMPORTED_MODULE_0__["MockGUI"]);
  debug('Scene is loaded', {
    THREE: Boolean(THREE),
    document: Boolean(document),
    window: Boolean(window),
    GLTFLoader: Boolean(GLTFLoader),
    scene: Boolean(scene)
  });

  var logServerStatus = function logServerStatus() {
    return debug('Server status ... Count alive units:', scene.units.getAliveUnits().length, '; is player loaded: ', Boolean(scene.units.getPlayer()), '; units positions: ', scene.units.getAliveUnits().map(function (u) {
      return [u.params.name, ': ', u.position];
    }));
  };

  var startSocketServer = function startSocketServer() {
    debug('Starting socket server ...');
    _this.socketServer = new _src_SocketServer__WEBPACK_IMPORTED_MODULE_1__["default"]();
  };

  setTimeout(function init() {
    var player = scene.getPlayer();

    if (player) {
      player.params.hp = 0;
    }

    startSocketServer();
    setInterval(logServerStatus, 30000);
  }, 5000);
}

/* harmony default export */ __webpack_exports__["default"] = (Server);

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvQXV0b0JpbmRNZXRob2RzLmpzIiwid2VicGFjazovLy8uLi9jbGllbnQvc3JjL2pzL0NhbWVyYS5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9Db2xsaWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvQ29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy9BSS5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy9BbmltYXRlZEdhbWVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvR2FtZU9iamVjdHMvRmlyZS5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy9GaXJpbmdVbml0LmpzIiwid2VicGFjazovLy8uLi9jbGllbnQvc3JjL2pzL0dhbWVPYmplY3RzL0dhbWVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvR2FtZU9iamVjdHMvTW92aW5nR2FtZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy9QbGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvR2FtZU9iamVjdHMvVW5pdC5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9JbnRlcnZhbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvTG9jYXRpb25zL0Fic3RyYWN0TG9jYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvTG9jYXRpb25zL0RyZWFtVG93bi9BcmVhcy5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9Mb2NhdGlvbnMvRHJlYW1Ub3duL0VsZXZhdG9yLmpzIiwid2VicGFjazovLy8uLi9jbGllbnQvc3JjL2pzL0xvY2F0aW9ucy9EcmVhbVRvd24vRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvTG9jYXRpb25zL0RyZWFtVG93bi9Mb2NhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9Mb2NhdGlvbnMvRHJlYW1Ub3duL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9jbGllbnQvc3JjL2pzL01vZGVscy5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9QYXJ0aWNsZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvUGF0aEZpbmRlci5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9TY2VuZS5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9Vbml0cy5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9VdGlscy9BU3Rhci5qcyIsIndlYnBhY2s6Ly8vLi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvTWF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvUXVhdGVybmlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvVmVjdG9yMy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvZXZlbnQtdGFyZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvZXh0ZW5zaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvc2VuZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvc3RyZWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvdmFsaWRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL01vY2tEZXBlbmRlbmNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvY2tldFNlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9zdGFuZGFsb25lLXNlcnZlci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldmVudHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5ldFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInBhdGhcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzdHJlYW1cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ0bHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1cmxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ6bGliXCIiXSwibmFtZXMiOlsiQXV0b0JpbmRNZXRob2RzIiwiZnVuY3Rpb25OYW1lcyIsIm9iaiIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiY29uY2F0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZpbHRlciIsIm5hbWUiLCJpbmRleE9mIiwiZnVuY3Rpb25OYW1lIiwiYmluZCIsIkNhbWVyYSIsInNjZW5lIiwicmF0aW8iLCJnZXRXaWR0aCIsImdldEhlaWdodCIsImNhbWVyYSIsIlRIUkVFIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJwb3NpdGlvbiIsInNldCIsImRlbHRhWSIsInJvdGF0ZVkiLCJkZWZhdWx0RGlzdGFuY2UiLCJkaXN0YW5jZSIsInJheWNhc3RlciIsIlJheWNhc3RlciIsImdhbWVUaW1lIiwiZGVsdGFUaW1lIiwiaW5wdXQiLCJwbGF5ZXIiLCJnZXRQbGF5ZXIiLCJsb29rIiwiY2luZW1hdGljIiwibG9va0F0IiwiVmVjdG9yMyIsInNlbnNpdGl2aXR5IiwidmVydGljYWwiLCJpc1RoaXJkUGVyc29uIiwidXBkYXRlVGhpcmRQZXJzb24iLCJjb3B5IiwiY2xvbmUiLCJhZGQiLCJ5IiwicmVuZGVyZXIiLCJnZXRDb250ZXh0IiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJjaGlsZHJlbiIsInBsYXllckhlYWRQb3NpdGlvbiIsIm9yaWdpbiIsImRlc3RpbmF0aW9uIiwiZGlyZWN0aW9uIiwiZ2V0Q2hpbGRyZW5GbGF0Iiwib2JqZWN0cyIsIm1hcCIsImVudmlyb25tZW50IiwiZmluZCIsImMiLCJmbGF0Q2hpbGRyZW5NZXNoZXMiLCJ0eXBlIiwic3ViVmVjdG9ycyIsIm5vcm1hbGl6ZSIsImZhciIsImludGVyc2VjdHMiLCJpbnRlcnNlY3RPYmplY3RzIiwiTWF0aCIsIm1pbiIsImkiLCJwbGF5ZXJGb3J3YXJkIiwiZ2V0Rm9yd2FyZCIsIm11bHRpcGx5U2NhbGFyIiwiYmFjayIsImNhbWVyYUZvcndhcmQiLCJhcHBseVF1YXRlcm5pb24iLCJxdWF0ZXJuaW9uIiwic3ViIiwid2lkdGhIYWxmIiwiaGVpZ2h0SGFsZiIsImNvcGllZFByb2plY3RWZWN0b3IiLCJwcm9qZWN0IiwieCIsInJvdW5kIiwieiIsIkNvbGxpZGVycyIsImNvbGxpZGVycyIsIm5leHRJZCIsImdhbWVPYmplY3QiLCJjb2xsaWRlciIsImZuIiwiaWQiLCJpZHgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJwdXNoIiwicGF0aEZpbmRlciIsInJlYnVpbGRBcmVhcyIsIkNvbm5lY3Rpb24iLCJpcCIsInBvcnQiLCJpc1NlY3VyZSIsIm1ldGEiLCJuZXR3b3JrUGxheWVycyIsIm5ldHdvcmtBSXMiLCJXZWJTb2NrZXQiLCJ3aW5kb3ciLCJNb3pXZWJTb2NrZXQiLCJjb25uZWN0aW9uIiwib25vcGVuIiwiY29uc29sZSIsImxvZyIsIm9uZXJyb3IiLCJlcnJvciIsIm9ubWVzc2FnZSIsIm9uTWVzc2FnZSIsInRpbWUiLCJzZW5kR2FtZU9iamVjdHMiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwicmVzcG9uc2UiLCJtZXNzYWdlVHlwZSIsInJvbGUiLCJ1aSIsInNldENvbm5lY3Rpb25Sb2xlIiwiaG9zdFVuaXRzRnJvbU5ldHdvcmsiLCJkZWJ1ZyIsImNsZWFyTG9jYWxHYW1lT2JqZWN0cyIsInByb2Nlc3NIYW5kc2hha2UiLCJsb2NhdGlvbiIsInJlbG9hZCIsInNldFBsYXllclBhcmFtcyIsInVuaXRzIiwic2V0RGVmYXVsdFBsYXllclBhcmFtcyIsInVwZGF0ZUdhbWVPYmplY3RzIiwicmVtb3ZlRGlzY29ubmVjdGVkUGxheWVyIiwiZSIsInNlbmQiLCJnYW1lT2JqZWN0c1NlcnZpY2UiLCJnZXRVbml0cyIsImZvckVhY2giLCJ1bml0IiwicGFyYW1zIiwiZnJvbU5ldHdvcmsiLCJkZXN0cm95R2FtZU9iamVjdCIsInVzZXIiLCJ1c2VyTmFtZSIsInBhc3N3b3JkIiwidG9rZW4iLCJnZXRIYXNoIiwic3RyaW5naWZ5IiwiZ2FtZU9iamVjdHMiLCJ1cGRhdGVOZXR3b3JrUGxheWVyIiwidXBkYXRlTmV0d29ya0FJIiwiY29ubmVjdGlvbklkIiwiZGlzY29ubmVjdGVkUGxheWVyIiwiUGxheWVyIiwiZGllIiwic3RyIiwiaGFzaDMyIiwibCIsImh2YWwiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJzdWJzdHIiLCJoMSIsImdldEFsaXZlVW5pdHMiLCJwbGF5ZXJEYXRhIiwibG9jYXRpb25OYW1lIiwicm90YXRpb24iLCJhbmltYXRpb25TdGF0ZSIsInVuaXROZXR3b3JrSWQiLCJnZXRMb2NhdGlvbk5hbWUiLCJuZXR3b3JrUGxheWVyIiwiY3JlYXRlTmV0d29ya1BsYXllciIsImFjY2VsZXJhdGlvbiIsInBsYXllclBhcmFtcyIsImhvcml6b250YWwiLCJhdHRhY2sxIiwiYXR0YWNrMiIsImhwIiwiaHBNYXgiLCJmcmFjdGlvbiIsImRhbWFnZSIsInNwZWVkIiwibW9uZXkiLCJsZXZlbCIsInVuc3BlbnRUYWxlbnRzIiwiZXhwZXJpZW5jZSIsInVuaXREYXRhIiwiaXNSdW5uaW5nIiwiaXNBdHRhY2siLCJzY2FsZSIsIm5ldHdvcmtBSSIsImNyZWF0ZU5ldHdvcmtBSSIsIm9iamVjdCIsIm5ldHdvcmtBSVBhcmFtcyIsInJlYWR5U3RhdGUiLCJ1bml0Um90YXRpb24iLCJ0b1ZlY3RvcjMiLCJnZXRSYW5kb21TdHJpbmciLCJyYW5kb20iLCJ2ZWN0b3JUb09iamVjdCIsInZlY3RvciIsImVwcyIsIkdhbWVPYmplY3RzU2VydmljZSIsIm5leHRHYW1lT2JqZWN0SWQiLCJ1cGRhdGUiLCJhdHRhY2tpbmdVbml0IiwiaXNEZWFkIiwiaW50ZXJ2YWxzIiwic2V0VGltZW91dCIsImdldFRpbWVQYXNzZWQiLCJpc0F0dGFja0ludGVycnVwdGVkIiwicmVsZWFzZUF0dGFjayIsImF0dGFja2VkVW5pdHMiLCJpc0FsaXZlIiwiaXNFbmVteSIsImRpc3RhbmNlVG8iLCJjb2xsaXNpb25HYW1lT2JqZWN0IiwiZGFtYWdlVGFrZW4iLCJnZXRBdHRhY2tUaW1lb3V0IiwiZmlyaW5nR2FtZU9iamVjdCIsImNyZWF0ZUxpZ2h0Q3ViZSIsImxlZnQiLCJtb2RlbHMiLCJjcmVhdGVDdWJlIiwiZW1pc3NpdmUiLCJOdW1iZXIiLCJub1NjZW5lIiwiT2JqZWN0M0QiLCJnZXRGaXJlSW5pdGlhbFBvc2l0aW9uIiwiZ2V0RmlyZUluaXRpYWxSb3RhdGlvbiIsImZpcmVHYW1lT2JqZWN0IiwiaG9va0dhbWVPYmplY3QiLCJGaXJlIiwidGhyb3R0bGluZyIsImZpcmVTaGVsbFNwZWVkIiwiZmlyZURhbWFnZSIsInBhcmVudCIsImNoZWNrV2F5IiwiZ2V0Q29sbGlzaW9ucyIsIlVuaXQiLCJkZXN0cm95IiwibW9kZWwiLCJjYW5QaWNrdXAiLCJvblBpY2t1cCIsImxvYWRHTFRGIiwiYmFzZVVybCIsImNhbGxiYWNrIiwibG9hZGVkT2JqZWN0IiwicG9zaXRpb25WZWN0b3IiLCJ0cmF2ZXJzZSIsImNoaWxkIiwiaXNNZXNoIiwibWF0ZXJpYWwiLCJ0cmFuc3BhcmVudCIsImFscGhhVGVzdCIsImdhbWVJdGVtIiwiQW5pbWF0ZWRHYW1lT2JqZWN0IiwiYW5pbWF0aW9ucyIsImNoZWNrUGlja3VwIiwiZ2V0UHJpb3JpdHkiLCJjZWlsIiwibmVhclVuaXRzIiwic29ydCIsInVuaXRBIiwidW5pdEIiLCJpc0RpZSIsIl9fZ2FtZV9vYmplY3RfaWQiLCJnZXROZXh0Tm9uUGxheWVySW5kZXgiLCJnbyIsInJlbW92ZUlkeCIsInJlbW92ZUdhbWVPYmplY3RGcm9tU2NlbmUiLCJpbmRleCIsInJlbW92ZSIsIkFJIiwibWFzIiwiZmlyZVRpbWVvdXQiLCJhdHRhY2tUaW1lb3V0IiwianVtcFRpbWVvdXQiLCJzdGFydFJ1blRpbWVvdXQiLCJuZXh0UG9pbnRVcGRhdGVUaW1lb3V0IiwidXBkYXRlVGFyZ2V0VGltZW91dCIsImJvdW50eSIsImxhc3RSdW4iLCJsYXN0VGFyZ2V0VXBkYXRlIiwibGFzdE5leHRQb2ludFVwZGF0ZSIsImxhc3RKdW1wVGltZXN0YW1wIiwiZmluZFRhcmdldCIsImlzVXBkYXRlVGFyZ2V0UmVsZWFzZWQiLCJ0YXJnZXQiLCJnZXROZXh0UG9pbnQiLCJpc05leHRQb2ludFVwZGF0ZVJlbGVhc2VkIiwibmV4dFBvaW50IiwiaXNUYXJnZXROZWFyIiwicm90YXRlVG9Qb3NpdGlvbiIsImlzTmV4dFBvaW50TmVhciIsImlzUnVuUmVsZWFzZWQiLCJpc0F0dGFja1JlbGVhc2VkIiwiaXNIaXRSZWxlYXNlZCIsImF0dGFjayIsImlzTW92aW5nRm9yd2FyZCIsImlzQWNjZWxlcmF0aW9uIiwianVtcEhlaWdodCIsImR4IiwiZHkiLCJkeiIsImlzSnVtcE5lZWRlZCIsImlzR3JvdW5kZWQiLCJyb3RhdGlvblRvVGFyZ2V0UmFkaWFucyIsImF0YW4yIiwidGFyZ2V0UXVhdGVybmlvbiIsIlF1YXRlcm5pb24iLCJzZXRGcm9tRXVsZXIiLCJzbGVycCIsImFicyIsImF0dGFja2VyIiwiRmlyaW5nVW5pdCIsImFuaW1hdGlvbk5hbWVzIiwic3RhbmQiLCJydW4iLCJqdW1wIiwicm90YXRlTGVmdCIsInJvdGF0ZVJpZ2h0IiwicnVuTGVmdCIsInJ1blJpZ2h0Iiwid2Fsa0JhY2siLCJzcGF3biIsImhpdCIsInRvcFJ1biIsImJvdHRvbVJ1biIsInRvcFdhbGtCYWNrIiwiYm90dG9tV2Fsa0JhY2siLCJ0b3BBdHRhY2siLCJib3R0b21BdHRhY2siLCJ0b3BTdGFuZCIsImJvdHRvbVN0YW5kIiwidG9wUnVuUmlnaHQiLCJ0b3BSdW5MZWZ0IiwidG9wSnVtcCIsInRvcEhpdCIsImJvdHRvbVJ1blJpZ2h0IiwiYm90dG9tUnVuTGVmdCIsImJvdHRvbUp1bXAiLCJib3R0b21IaXQiLCJ0b3BEaWUiLCJib3R0b21EaWUiLCJ0b3BTcGF3biIsImJvdHRvbVNwYXduIiwidG9wQW5pbWF0aW9ucyIsImJvdHRvbUFuaW1hdGlvbnMiLCJ0b3BCb25lcyIsImJvdHRvbUJvbmVzIiwic3Bhd25UaW1lb3V0IiwiaXNNb3ZpbmdSaWdodCIsImlzTW92aW5nTGVmdCIsImlzTW92aW5nQmFja3dhcmQiLCJpc1JvdGF0ZUxlZnQiLCJpc1JvdGF0ZVJpZ2h0IiwiaXNKdW1wIiwiaXNIaXQiLCJpc1NwYXduIiwicGxheWluZ0FuaW1hdGlvbnMiLCJsZWdzUm90YXRpb25ZIiwic3Bhd25UaW1lIiwibWl4ZXIiLCJBbmltYXRpb25NaXhlciIsImluaXRBbmltYXRpb25zIiwiaXNTcGF3bkZpbmlzaGVkIiwiY29tcGxleEFuaW1hdGlvbnMiLCJ1cGRhdGVDb21wbGV4QW5pbWF0aW9ucyIsImFuaW1hdGlvbiIsImdldEN1cnJlbnRBbmltYXRpb24iLCJwbGF5QW5pbWF0aW9uIiwiZm9yY2UiLCJfY2xpcCIsImFuaW1hdGlvbk5hbWUiLCJzaG91bGRVcGRhdGUiLCJwbGF5aW5nQW5pbWF0aW9uTmFtZSIsInJlc2V0IiwicGxheSIsInBsYXlpbmdBbmltYXRpb24iLCJmcm9tIiwiZW5hYmxlZCIsImNyb3NzRmFkZVRvIiwia2V5cyIsInJlZHVjZSIsInJlc3VsdCIsImtleSIsImV4Y2x1ZGVkQm9uZXMiLCJpbmNsdWRlcyIsIm1vZGVsQW5pbWF0aW9uIiwiZmluZE1vZGVsQW5pbWF0aW9uIiwiaW5pdGVkQW5pbWF0aW9uIiwiY3JlYXRlQ2xpcEFjdGlvbiIsImNsYW1wQW5pbWF0aW9uIiwic2V0TG9vcCIsIkxvb3BPbmNlIiwiY2xhbXBXaGVuRmluaXNoZWQiLCJhdHRhY2tBbmltYXRpb24iLCJzZXREdXJhdGlvbiIsImFjdGlvbiIsImNsaXBBY3Rpb24iLCJzdG9wIiwiY2xlYXJBbmltYXRpb25Cb25lcyIsImJvbmVzIiwiZ2V0Qm9uZU5hbWUiLCJpdGVtIiwic3BsaXQiLCJpc05vdEV4Y2x1ZGVkIiwidHJhY2tzIiwidG9wIiwiYm90dG9tIiwibGVnc1JvdGF0aW9uQm9uZSIsImdldENoaWxkQnlOYW1lIiwiYmxlbmRBbmltYXRpb25zIiwiZ2V0QW5pbWF0aW9uTmFtZSIsImEiLCJmcm9tQW5pbWF0aW9uIiwiZnJvbUFuaW1hdGlvbk5hbWUiLCJHYW1lT2JqZWN0IiwiY29sbGlzaW9ucyIsIk1vdmluZ0dhbWVPYmplY3QiLCJzaG91bGRGaXJlIiwibGF0ZXN0RmlyZSIsImdldFVwIiwiaXNGaXJlIiwiZmlyZSIsImlzRmlyZVJlbGVhc2VkIiwiZXZlbnRzIiwiZXZlbnROYW1lIiwiYXJncyIsImdldE9iamVjdEJ5TmFtZSIsImFyZyIsImdldENoaWxkUm90YXRpb24iLCJzZXRGcm9tTWF0cml4UG9zaXRpb24iLCJtYXRyaXhXb3JsZCIsImdldFdvcmxkUXVhdGVybmlvbiIsImlzWCIsIkJvb2xlYW4iLCJpc1kiLCJpc1oiLCJpc0NsaW1iaW5nIiwiaXNNb3ZpbmciLCJuZXh0UG9zaXRpb24iLCJnZXREaXJlY3Rpb24iLCJ0b0FycmF5IiwiciIsInYiLCJyb3RhdGlvbkFjY2VsZXJhdGlvbiIsIm9uTGV2ZWxVcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRNb3ZpbmdBY2NlbGVyYXRpb24iLCJob3Jpem9udGFsTG9vayIsInJlc2V0SG9yaXpvbnRhbExvb2siLCJDQUxDX1JPVEFURV9USFJFU0hPTEQiLCJyb3RhdGVPbldvcmxkQXhpcyIsImRlbHRhWCIsImlubmVyV2lkdGgiLCJjdXJzb3IiLCJpbm5lckhlaWdodCIsInJvdGF0aW9uWSIsImhlYWQiLCJoZWFkRm9yd2FyZCIsImdldENoaWxkRGlyZWN0aW9uIiwiaGVhZFVwIiwiZ2V0Q2hpbGRQb3NpdGlvbiIsImdldExldmVsIiwibGV2ZWxzVXAiLCJkaXNwYXRjaEV2ZW50IiwicG93IiwiZmxvb3IiLCJzcXJ0IiwiYWRkRm9yd2FyZCIsImFkZFNpZGUiLCJoaXRUaW1lIiwiYXR0YWNrRGFtYWdlVGltZW91dCIsInNob3VsZEF0dGFjayIsImxhdGVzdEF0dGFja1RpbWVzdGFtcCIsImxhdGVzdEhpdFRpbWVzdGFtcCIsImhpdFJlbGVhc2VkIiwiZGlmZlkiLCJpbnRlcnJ1cHRCeUNoYW5jZSIsImludGVycnVwdEJ5TGV2ZWwiLCJzaG91bGRCZUludGVycnVwdGVkIiwia2lsbGluZ1VuaXQiLCJLRVlTIiwiTU9VU0VfTEVGVCIsIk1PVVNFX1JJR0hUIiwiU1BBQ0UiLCJFTlRFUiIsIkVTQyIsIkMiLCJXIiwiQSIsIlMiLCJEIiwiWCIsIloiLCJRIiwiRSIsIlIiLCJGIiwiViIsIkFSUk9XX0xFRlQiLCJBUlJPV19SSUdIVCIsIkFSUk9XX1VQIiwiQVJST1dfRE9XTiIsIklucHV0IiwibW91c2UiLCJhZGRFdmVudExpc3RlbmVycyIsImRvY3VtZW50Iiwid2hpY2giLCJ0aW1lb3V0IiwibW92ZW1lbnRYIiwibW92ZW1lbnRZIiwiY3Vyc29yWCIsImN1cnNvclkiLCJ1bmRlZmluZWQiLCJjbGVhclRpbWVvdXQiLCJFdmVudCIsIm9uQWN0aW9uIiwib25FeGl0Iiwib25Td2l0Y2hDYW1lcmEiLCJvblpvb20iLCJJbnRlcnZhbHMiLCJ0aW1lUGFzc2VkIiwibGFzdEZyYW1lIiwiaW50ZXJ2YWxJbmRleCIsIm5vdyIsImlzUGF1c2UiLCJjYWxsZWRBdCIsImludGVydmFsIiwibG9vcHMiLCJjbGVhckludGVydmFsIiwiaW1tZWRpYXRlbHkiLCJpbnRlcnZhbElkeCIsIkFic3RyYWN0TG9jYXRpb24iLCJhbWJpZW50TGlnaHQiLCJBbWJpZW50TGlnaHQiLCJjYXN0U2hhZG93IiwibGlnaHQiLCJEaXJlY3Rpb25hbExpZ2h0IiwiaW50ZW5zaXR5Iiwic2hhZG93IiwiYmlhcyIsInNoYWRvd1NpemUiLCJyaWdodCIsIm1hcFNpemUiLCJuZWFyIiwidmlzaWJsZSIsIm1hdGVyaWFsQXJyYXkiLCJ1cmwiLCJNZXNoQmFzaWNNYXRlcmlhbCIsIlRleHR1cmVMb2FkZXIiLCJsb2FkIiwic2lkZSIsIkJhY2tTaWRlIiwiZm9nIiwic2t5R2VvbWV0cnkiLCJDdWJlR2VvbWV0cnkiLCJza3lNYXRlcmlhbCIsIk1lc2hGYWNlTWF0ZXJpYWwiLCJNZXNoIiwiYnVpbGRBcmVhIiwiYXJlYUlkIiwiQXJlYVNpemVzIiwid2F5cG9pbnRYVG9Xb3JsZFgiLCJ3YXlwb2ludFlUb1dvcmxkWiIsIndvcmxkWFRvV2F5cG9pbnRYIiwiZ3JhcGhYIiwibWF4Iiwid29ybGRaVG9XYXlwb2ludFkiLCJncmFwaFkiLCJhcmVhIiwiRkxPT1JfMCIsIkZMT09SXzEiLCJGTE9PUl8yIiwiQXJlYXMiLCJpbmNsdWRlc1Bvc2l0aW9uIiwiZ2V0V29ybGRXYXlwb2ludEJ5WFkiLCJnZXRXYXlwb2ludFBvcnRhbHMiLCJ0byIsIkVsZXZhdG9yIiwiY3VycmVudEZsb29yIiwic3RhbmRUaW1lIiwic3RhbmRBdCIsImlzUmVsZWFzZWQiLCJnZXRGbG9vciIsImdldENhcnJ5aW5nUG9zaXRpb24iLCJjYXJyeWluZ1VuaXRzIiwiaXNDYXJyeWluZyIsInRoaXNBY2NlbGVyYXRpb24iLCJjcmVhdGVFbnZpcm9ubWVudCIsInRyZWVzIiwiaG91c2VzIiwiYWRkQ29sbGlkZXJGdW5jdGlvbiIsIm9uTG9hZCIsInBpdm90IiwibWF0cml4QXV0b1VwZGF0ZSIsImlzRW52aXJvbm1lbnRMb2FkZWQiLCJpc1RyZWVMb2FkZWQiLCJpc0hvdXNlTG9hZGVkIiwiY2hlY2tJc0FsbExvYWRlZCIsInVwZGF0ZU1hdHJpeCIsInJlY2VpdmVTaGFkb3ciLCJsb2FkZWRNb2RlbCIsInJ4IiwicnkiLCJyeiIsInVuaXRQb3NpdGlvbiIsIkxvY2F0aW9uIiwic2hhZG93TGlnaHRQb3NpdGlvbiIsInNldExvYWRpbmciLCJzZXRQYXVzZSIsIlBJIiwibm90aWZ5Iiwic3RhcnRMb2NhdGlvbiIsImNyZWF0ZUFtYmllbnRMaWdodCIsInNoYWRvd0xpZ2h0IiwiY3JlYXRlU2hhZG93TGlnaHQiLCJlbGV2YXRvciIsImNvbG9yIiwiRm9nIiwiY3JlYXRlTG9jYXRpb25Db2xsaWRlcnMiLCJwYXJ0aWNsZXMiLCJjcmVhdGVFZmZlY3QiLCJlZmZlY3QiLCJhdHRhY2hUbyIsImNyZWF0ZVBsYXllciIsIm9uQ3JlYXRlIiwidXBkYXRlUGxheWVyUGFyYW1zIiwib25EaWUiLCJvbktpbGwiLCJhZGRFeHBlcmllbmNlIiwiYWRkTW9uZXkiLCJvbkRhbWFnZVRha2VuIiwib25Mb2NhdGlvblVwIiwiY3JlYXRlSW50ZXJhY3RpdmVHYW1lT2JqZWN0cyIsImNsZWFyU2NlbmUiLCJyZW1vdmVBbGxFeGNlcHRQbGF5ZXIiLCJjcmVhdGVIZWFsSXRlbSIsIml0ZW1IZWFsUG9zaXRpb24iLCJjcmVhdGVJdGVtIiwiZ2V0TWF4SFAiLCJnZXRIUCIsImFkZEhQIiwiZ2V0QUlQYXJhbXMiLCJjcmVhdGVBSSIsImdldEdvYXRzUGFyYW1zIiwiZ2V0RnJpZW5kbHlQYXJhbXMiLCJpc0JldHdlZW4iLCJhYnNYIiwiYWJzWiIsImFyZWFzIiwidmFsdWVzIiwiZ2VuZXJhdGVXYXlwb2ludHMiLCJBcnJheSIsImZpbGwiLCJudWxsMSIsIm51bGwyIiwiZ2V0V2F5cG9pbnRzIiwiY2hlY2tXYXlGb3JXYXlwb2ludCIsImNoZWNrTmVhciIsInJhbmdlIiwiZGlhZ29uYWwiLCJNb2RlbHMiLCJtYXRlcmlhbFBhcmFtcyIsImltYWdlIiwidGV4dHVyZSIsIndyYXBTIiwiUmVwZWF0V3JhcHBpbmciLCJ3cmFwVCIsInJlcGVhdCIsInJlcGVhdFgiLCJyZXBlYXRZIiwiQ29sb3IiLCJlbWlzc2l2ZUludGVuc2l0eSIsImVtaXNzaXZlTWFwIiwiY3ViZSIsIk1lc2hMYW1iZXJ0TWF0ZXJpYWwiLCJpc0dMVEYiLCJsb2FkZXIiLCJHTFRGTG9hZGVyIiwiUGFydGljbGVzIiwicCIsImNyZWF0ZVBhcnRpY2xlcyIsInBhcnRpY2xlQ291bnQiLCJibGVuZGluZyIsIk5vcm1hbEJsZW5kaW5nIiwiZ2V0UGFydGljbGVQb3NpdGlvbiIsImdldFJhbmRvbVBvc2l0aW9uIiwibmV3UG9zaXRpb24iLCJsaWZlVGltZSIsInBhcnRpY2xlTmFtZSIsImdsdGYiLCJwYXJ0aWNsZVN5c3RlbSIsInNpemUiLCJBZGRpdGl2ZUJsZW5kaW5nIiwiZGVwdGhUZXN0IiwiZ2V0UGFydGljbGVWZWxvY2l0eSIsIkdlb21ldHJ5IiwiUG9pbnRDbG91ZE1hdGVyaWFsIiwicGFydGljbGUiLCJ2ZWxvY2l0eSIsInZlcnRpY2VzIiwiUG9pbnRDbG91ZCIsInBhcnRpY2xlUG9zaXRpb24iLCJ2ZXJ0aWNlc05lZWRVcGRhdGUiLCJnZXRBcmVhQnlQb3NpdGlvbiIsImZyb21YIiwiZnJvbVkiLCJhcmVhVG8iLCJ0b1giLCJ0b1kiLCJwb3J0YWwiLCJzdGFydCIsImdldEZyZWVHcmFwaFBvaW50IiwiZ3JhcGgiLCJlbmQiLCJBU3RhciIsImFzdGFyIiwic2VhcmNoIiwiaGV1cmlzdGljIiwiaGV1cmlzdGljcyIsIm5leHRHcmFwaFBvaW50IiwibmV4dFdvcmxkUG9pbnQiLCJncmlkIiwiZ2V0V2VpZ2h0Iiwid2VpZ2h0IiwiZ2V0TmVhckZyZWVQb2ludCIsImdldEFyZWFzIiwiR3JhcGgiLCJTY2VuZSIsImNsb2NrIiwiQ2xvY2siLCJQYXRoRmluZGVyIiwiVW5pdHMiLCJ6b29tIiwiYWRkWSIsInN3aXRjaENhbWVyYSIsInNldEludGVydmFsIiwic2V0RnBzIiwiZnBzIiwidGFyZ2V0RnBzIiwiYW5pbWF0ZSIsInJlbW92ZUFsbCIsImFmdGVyQ2xlYXIiLCJEYXRlIiwiZ2V0RGVsdGFUaW1lIiwicmVuZGVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGV4dCIsImRlZmF1bHRQYXJhbXMiLCJvbkRhbWFnZURlYWwiLCJkYW1hZ2VkVW5pdCIsImxvYWRFZmZlY3QiLCJraWxsZXIiLCJuZXR3b3JrQ29ubmVjdGlvbiIsImFpIiwibmVhckVuZW15VW5pdHMiLCJnZXRGcmFjdGlvbiIsImRlZmluaXRpb24iLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmaW5lIiwicGF0aFRvIiwibm9kZSIsImN1cnIiLCJwYXRoIiwidW5zaGlmdCIsImdldEhlYXAiLCJCaW5hcnlIZWFwIiwiZiIsIm9wdGlvbnMiLCJjbGVhbkRpcnR5IiwibWFuaGF0dGFuIiwiY2xvc2VzdCIsIm9wZW5IZWFwIiwiY2xvc2VzdE5vZGUiLCJoIiwibWFya0RpcnR5IiwiY3VycmVudE5vZGUiLCJwb3AiLCJjbG9zZWQiLCJuZWlnaGJvcnMiLCJpbCIsIm5laWdoYm9yIiwiaXNXYWxsIiwiZ1Njb3JlIiwiZyIsImdldENvc3QiLCJiZWVuVmlzaXRlZCIsInZpc2l0ZWQiLCJyZXNjb3JlRWxlbWVudCIsInBvczAiLCJwb3MxIiwiZDEiLCJkMiIsIkQyIiwiY2xlYW5Ob2RlIiwiZ3JpZEluIiwibm9kZXMiLCJyb3ciLCJHcmlkTm9kZSIsImluaXQiLCJkaXJ0eU5vZGVzIiwicmV0IiwiZ3JhcGhTdHJpbmciLCJyb3dEZWJ1ZyIsImpvaW4iLCJmcm9tTmVpZ2hib3IiLCJzY29yZUZ1bmN0aW9uIiwiY29udGVudCIsImVsZW1lbnQiLCJzaW5rRG93biIsImJ1YmJsZVVwIiwibiIsInBhcmVudE4iLCJlbGVtU2NvcmUiLCJjaGlsZDJOIiwiY2hpbGQxTiIsInN3YXAiLCJjaGlsZDFTY29yZSIsImNoaWxkMSIsImNoaWxkMiIsImNoaWxkMlNjb3JlIiwiU2VydmVyIiwiZ2xvYmFsIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwibyIsImNsb25lZCIsIldlYkdMUmVuZGVyZXIiLCJzZXRTaXplIiwic2hhZG93TWFwIiwiQ2FjaGUiLCJQQ0ZTb2Z0U2hhZG93TWFwIiwiYm9keSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJnZXRFbGVtZW50QnlJZCIsIk1vY2tHVUkiLCJpc1NlcnZlciIsInNldFJlc3RhcnRCdXR0b25WaXNpYmxlIiwicmVzdGFydEdhbWUiLCJjbGVhckhwQmFycyIsIk1vY2tSZW5kZXJlciIsIldlYlNvY2tldFNlcnZlciIsIndzIiwiU29ja2V0U2VydmVyIiwiY3JlYXRlU29ja2V0U2VydmVyIiwic2F2ZVVzZXJEYXRhIiwibG9hZFVzZXJEYXRhIiwiY29uZmlnIiwic3NsIiwic3NsS2V5IiwiX19kaXJuYW1lIiwic3NsQ2VydGlmaWNhdGUiLCJzZXNzaW9uc1BhdGgiLCJmcyIsImRiIiwic2VxdWVuY2VJZCIsImhvc3RJZCIsImNvbm5lY3Rpb25zIiwicGxheWVycyIsInNvY2tldFNlcnZlciIsInN0YXJ0U29ja2V0U2VydmVyIiwiaHR0cFNlcnYiLCJyZXF1aXJlIiwic2VydmVyIiwicHJvY2Vzc1JlcXVlc3QiLCJyZXEiLCJyZXMiLCJ3cml0ZUhlYWQiLCJjcmVhdGVTZXJ2ZXIiLCJjZXJ0IiwibGlzdGVuIiwid2ViU29ja2V0U2VydmVyIiwidG9rZW5QYXRoIiwiZ2V0Q29ubmVjdGlvbklkIiwiX2lkIiwiZ2V0Q29ubmVjdGlvblRva2VuIiwiX21ldGEiLCJ2ZXJzaW9uIiwiaXNIb3N0IiwiY29ubmVjdGlvblBsYXllciIsIm9uIiwib25Tb2NrZXRDbG9zZSIsImFjdGl2ZUNvbm5lY3Rpb25zIiwib25Tb2NrZXRNZXNzYWdlIiwibWVzc2FnZSIsInVwZGF0ZUdhbWVPYmplY3RzRGF0YSIsInNlbmRVc2VyRGF0YSIsInVwZGF0ZVBsYXllckRhdGEiLCJ0YWtlSG9zdCIsInJlc3RhcnRTZXJ2ZXIiLCJsb2dTZXJ2ZXJTdGF0dXMiLCJ1Il0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ2xGcUJBLGUsR0FDakIsMkJBQWM7QUFBQTs7QUFBQTs7QUFDVixNQUFJQyxhQUFhLEdBQUcsRUFB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O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOzs7QUFHaUI7Ozs7Ozs7Ozs7Ozs7QUNwSmpCO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSxrQ0FBa0MsOENBQUs7O0FBRXZDLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSxDQUFDOzs7QUFHcUI7Ozs7Ozs7Ozs7Ozs7QUMzbkJ0QjtBQUFBO0FBQUE7QUFBQTtBQUFrQztBQUNXOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHlEQUFVOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiw4Q0FBSzs7QUFFekIsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFB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QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFF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cUJBQXFCO0FBQ2hFLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUNBQXFDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7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QUFDbUIsU0FBTixFQUFmOztBQUVBLFFBQUlELE1BQUosRUFBWTtBQUNYQSxZQUFNLENBQUNpSCxNQUFQLENBQWN1QyxFQUFkLEdBQW1CLENBQW5CO0FBQ0E7O0FBRUQ4cUIscUJBQWlCO0FBQ2pCNUgsZUFBVyxDQUFDMEosZUFBRCxFQUFrQixLQUFsQixDQUFYO0FBQ0EsR0FWUSxFQVdULElBWFMsQ0FBVjtBQWFBOztBQUVjcEUscUVBQWYsRTs7Ozs7Ozs7Ozs7QUM5Q0EsbUM7Ozs7Ozs7Ozs7O0FDQUEsbUM7Ozs7Ozs7Ozs7O0FDQUEsK0I7Ozs7Ozs7Ozs7O0FDQUEsaUM7Ozs7Ozs7Ozs7O0FDQUEsa0M7Ozs7Ozs7Ozs7O0FDQUEsZ0M7Ozs7Ozs7Ozs7O0FDQUEsaUM7Ozs7Ozs7Ozs7O0FDQUEsbUM7Ozs7Ozs7Ozs7O0FDQUEsZ0M7Ozs7Ozs7Ozs7O0FDQUEsZ0M7Ozs7Ozs7Ozs7O0FDQUEsaUMiLCJmaWxlIjoic2VydmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9pbmRleC5qc1wiKTtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxldCBmdW5jdGlvbk5hbWVzID0gW107XG4gICAgICAgIGxldCBvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG5cbiAgICAgICAgd2hpbGUgKG9iaikge1xuICAgICAgICAgICAgaWYgKG9iaiA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBvYmogPT09IEF1dG9CaW5kTWV0aG9kcy5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lcyA9IGZ1bmN0aW9uTmFtZXMuY29uY2F0KFxuICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZmlsdGVyKG5hbWUgPT4gKFxuICAgICAgICAgICAgICAgICAgICBuYW1lICE9PSAnY29uc3RydWN0b3InXG4gICAgICAgICAgICAgICAgICAgICYmIGZ1bmN0aW9uTmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTFcbiAgICAgICAgICAgICAgICAgICAgJiYgdHlwZW9mIHRoaXNbbmFtZV0gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgb2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBmdW5jdGlvbk5hbWUgb2YgZnVuY3Rpb25OYW1lcykge1xuICAgICAgICAgICAgdGhpc1tmdW5jdGlvbk5hbWVdID0gdGhpc1tmdW5jdGlvbk5hbWVdLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW1lcmEgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2NlbmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICBjb25zdCByYXRpbyA9IHRoaXMuZ2V0V2lkdGgoKSAvIHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDQ1LCByYXRpbywgMSwgMTAwKTtcbiAgICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uc2V0KDUsIDMsIDE1KTtcbiAgICAgICAgdGhpcy5kZWx0YVkgPSAxMDtcbiAgICAgICAgdGhpcy5yb3RhdGVZID0gMC4yNTtcbiAgICAgICAgdGhpcy5kZWZhdWx0RGlzdGFuY2UgPSAxMDtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHRoaXMuZGVmYXVsdERpc3RhbmNlO1xuICAgICAgICB0aGlzLnJheWNhc3RlciA9IG5ldyBUSFJFRS5SYXljYXN0ZXIoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZ2FtZVRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICBjb25zdCB7IHNjZW5lOiB7IGlucHV0IH0gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMuc2NlbmUuZ2V0UGxheWVyKCk7XG5cbiAgICAgICAgaWYgKCFwbGF5ZXIpIHJldHVybjtcbiAgICBcbiAgICAgICAgLy8gRW5hYmxlZCBpZiBcIkZcIiBpcyBwcmVzc2VkXG4gICAgICAgIGlmIChpbnB1dC5sb29rLmNpbmVtYXRpYykge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uc2V0KC00MCwgMTUsIDEwKTtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygtNTAsIDAsIDApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBjb25zdCByb3RhdGVZID0gdGhpcy5yb3RhdGVZICsgKGlucHV0Lmxvb2suc2Vuc2l0aXZpdHkgKiBpbnB1dC5sb29rLnZlcnRpY2FsIC8gMjAwMCk7XG5cbiAgICAgICAgaWYgKHJvdGF0ZVkgPiAtMC43NSAmJiByb3RhdGVZIDwgMS4yNSkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGVZID0gcm90YXRlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dC5pc1RoaXJkUGVyc29uKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRoaXJkUGVyc29uKHBsYXllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5jb3B5KFxuICAgICAgICAgICAgICAgIHBsYXllci5wb3NpdGlvbi5jbG9uZSgpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQobmV3IFRIUkVFLlZlY3RvcjMoNy41LCB0aGlzLmRlbHRhWSwgMCkpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5sb29rQXQocGxheWVyLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFkoeSkge1xuICAgICAgICBpZiAodGhpcy5kZWx0YVkgKyB5ID4gMSAmJiB0aGlzLmRlbHRhWSArIHkgPCAyNSkge1xuICAgICAgICAgICAgdGhpcy5kZWx0YVkgKz0geTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFdpZHRoKCkge1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuc2NlbmUucmVuZGVyZXIucmVuZGVyZXI7XG4gICAgICAgIHJldHVybiByZW5kZXJlci5nZXRDb250ZXh0KCkuY2FudmFzLndpZHRoO1xuICAgIH1cblxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnNjZW5lLnJlbmRlcmVyLnJlbmRlcmVyO1xuICAgICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0Q29udGV4dCgpLmNhbnZhcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgdXBkYXRlVGhpcmRQZXJzb24ocGxheWVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NlbmU6IHsgc2NlbmU6IHsgY2hpbGRyZW4gfSB9LCBkZWx0YVkgfSA9IHRoaXMsXG4gICAgICAgICAgICBwbGF5ZXJIZWFkUG9zaXRpb24gPSBwbGF5ZXIucG9zaXRpb24uY2xvbmUoKS5hZGQobmV3IFRIUkVFLlZlY3RvcjMoMCwgMS41LCAwKSksXG4gICAgICAgICAgICBvcmlnaW4gPSBwbGF5ZXJIZWFkUG9zaXRpb24sXG4gICAgICAgICAgICBkZXN0aW5hdGlvbiA9IHRoaXMuY2FtZXJhLnBvc2l0aW9uLFxuICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICBjb25zdCBnZXRDaGlsZHJlbkZsYXQgPSBvYmplY3RzID0+IFtdLmNvbmNhdCguLi5vYmplY3RzLm1hcChcbiAgICAgICAgICAgIG9iaiA9PiBvYmouY2hpbGRyZW5cbiAgICAgICAgICAgICAgICA/IFtvYmosIC4uLmdldENoaWxkcmVuRmxhdChvYmouY2hpbGRyZW4pXVxuICAgICAgICAgICAgICAgIDogW29ial1cbiAgICAgICAgKSk7XG5cbiAgICAgICAgY29uc3QgZW52aXJvbm1lbnQgPSBbY2hpbGRyZW4uZmluZChjID0+IGMubmFtZSA9PT0gJ0xFVkVMX0VOVklST05NRU5UJyldO1xuICAgICAgICBjb25zdCBmbGF0Q2hpbGRyZW5NZXNoZXMgPSBnZXRDaGlsZHJlbkZsYXQoZW52aXJvbm1lbnQpLmZpbHRlcihvYmogPT4gb2JqLnR5cGUgPT09ICdNZXNoJyk7XG5cbiAgICAgICAgdGhpcy5yYXljYXN0ZXIuc2V0KG9yaWdpbiwgZGlyZWN0aW9uLnN1YlZlY3RvcnMoZGVzdGluYXRpb24sIG9yaWdpbikubm9ybWFsaXplKCkpO1xuICAgICAgICB0aGlzLnJheWNhc3Rlci5mYXIgPSBkZWx0YVkgKiAxLjU7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdHMgPSB0aGlzLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzKGZsYXRDaGlsZHJlbk1lc2hlcyk7XG5cbiAgICAgICAgbGV0IGRpc3RhbmNlID0gTWF0aC5taW4oZGVsdGFZLCAuLi5pbnRlcnNlY3RzLm1hcChpID0+IGkuZGlzdGFuY2UgLSB0aGlzLmRpc3RhbmNlICogMC41KSk7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgKz0gKGRpc3RhbmNlIC0gdGhpcy5kaXN0YW5jZSkgLyAyO1xuXG4gICAgICAgIGNvbnN0IHBsYXllckZvcndhcmQgPSBwbGF5ZXIuZ2V0Rm9yd2FyZCgpLm11bHRpcGx5U2NhbGFyKHRoaXMuc2NlbmUuaW5wdXQubG9vay5iYWNrID8gMSA6IC0xKTtcblxuICAgICAgICBwbGF5ZXJGb3J3YXJkLnkgPSB0aGlzLnJvdGF0ZVk7XG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmNvcHkocGxheWVySGVhZFBvc2l0aW9uLmNsb25lKCkuYWRkKHBsYXllckZvcndhcmQpKTtcblxuICAgICAgICB0aGlzLmNhbWVyYS5sb29rQXQocGxheWVySGVhZFBvc2l0aW9uKTtcblxuICAgICAgICBjb25zdCBjYW1lcmFGb3J3YXJkID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgLTEpO1xuICAgICAgICBjYW1lcmFGb3J3YXJkLmFwcGx5UXVhdGVybmlvbih0aGlzLmNhbWVyYS5xdWF0ZXJuaW9uKTtcblxuICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zdWIoY2FtZXJhRm9yd2FyZC5tdWx0aXBseVNjYWxhcih0aGlzLmRpc3RhbmNlKSk7XG4gICAgfVxuXG4gICAgdG9TY3JlZW5Qb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBjb25zdCB3aWR0aEhhbGYgPSAwLjUgKiB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgIGNvbnN0IGhlaWdodEhhbGYgPSAwLjUgKiB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICBjb25zdCBjb3BpZWRQcm9qZWN0VmVjdG9yID0gcG9zaXRpb24uY2xvbmUoKS5wcm9qZWN0KHRoaXMuY2FtZXJhKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogTWF0aC5yb3VuZCgoY29waWVkUHJvamVjdFZlY3Rvci54ICsgMSkgKiB3aWR0aEhhbGYpLFxuICAgICAgICAgICAgeTogTWF0aC5yb3VuZCgoLWNvcGllZFByb2plY3RWZWN0b3IueSArIDEpICogaGVpZ2h0SGFsZiksXG4gICAgICAgICAgICB6OiBjb3BpZWRQcm9qZWN0VmVjdG9yLnpcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgQXV0b0JpbmRNZXRob2RzIGZyb20gJy4vQXV0b0JpbmRNZXRob2RzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sbGlkZXJzIGV4dGVuZHMgQXV0b0JpbmRNZXRob2RzIHtcbiAgICBjb25zdHJ1Y3RvcihzY2VuZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMuY29sbGlkZXJzID0gW107XG4gICAgICAgIHRoaXMubmV4dElkID0gMDtcbiAgICB9XG5cbiAgICBjaGVja1dheShwb3NpdGlvbiwgZ2FtZU9iamVjdCkge1xuICAgICAgICBmb3IobGV0IGNvbGxpZGVyIG9mIHRoaXMuY29sbGlkZXJzKSB7XG4gICAgICAgICAgICBpZiAoY29sbGlkZXIuZm4ocG9zaXRpb24sIGdhbWVPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmVzZXRDb2xsaWRlcnMoKSB7XG4gICAgICAgIHRoaXMuY29sbGlkZXJzID0gW107XG4gICAgfVxuXG4gICAgcmVtb3ZlQ29sbGlkZXIoaWQpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5jb2xsaWRlcnMuZmluZEluZGV4KGMgPT4gYy5pZCA9PT0gaWQpO1xuXG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsaWRlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRDb2xsaWRlckZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIHRoaXMuY29sbGlkZXJzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHRoaXMubmV4dElkKyssXG4gICAgICAgICAgICBmbixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zY2VuZS5wYXRoRmluZGVyLnJlYnVpbGRBcmVhcygpO1xuICAgIH1cbn0iLCJpbXBvcnQgQXV0b0JpbmRNZXRob2RzIGZyb20gJy4vQXV0b0JpbmRNZXRob2RzJztcbmltcG9ydCB7IFBsYXllciwgQUkgfSBmcm9tICcuL0dhbWVPYmplY3RzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29ubmVjdGlvbiBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZVxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlwXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gcG9ydFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2VjdXJlXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzY2VuZSwgaXAgPSAnbG9jYWxob3N0JywgcG9ydCA9ICcxMzM3JywgaXNTZWN1cmUgPSB0cnVlKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdFx0dGhpcy5tZXRhID0ge307XG5cdFx0dGhpcy5uZXR3b3JrUGxheWVycyA9IHt9O1xuXHRcdHRoaXMubmV0d29ya0FJcyA9IHt9O1xuXG5cdFx0Y29uc3QgV2ViU29ja2V0ID0gd2luZG93LldlYlNvY2tldCB8fCB3aW5kb3cuTW96V2ViU29ja2V0O1xuXG5cdFx0dGhpcy5jb25uZWN0aW9uID0gbmV3IFdlYlNvY2tldChgJHtpc1NlY3VyZSA/ICd3c3MnIDogJ3dzJ306Ly8ke2lwfToke3BvcnR9YCk7XG5cdFx0dGhpcy5jb25uZWN0aW9uLm9ub3BlbiA9ICgpID0+IGNvbnNvbGUubG9nKCdvcGVuIGNvbm5lY3Rpb24nKTtcblx0XHR0aGlzLmNvbm5lY3Rpb24ub25lcnJvciA9IChlcnJvcikgPT4gY29uc29sZS5sb2coJ2Vycm9yIGNvbm5lY3Rpb24nLCBlcnJvcik7XG5cdFx0dGhpcy5jb25uZWN0aW9uLm9ubWVzc2FnZSA9IHRoaXMub25NZXNzYWdlO1xuXHR9XG5cblx0dXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuXHRcdHRoaXMuc2VuZEdhbWVPYmplY3RzKCk7XG5cdH1cblxuXHRvbk1lc3NhZ2UoeyBkYXRhIH0pIHtcblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gbWV0YVxuXHRcdCAqIEBwYXJhbSB7YW55fSByZXNwb25zZVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlVHlwZVxuXHRcdCAqL1xuXHRcdGNvbnN0IHsgbWV0YSwgZGF0YTogcmVzcG9uc2UsIG1lc3NhZ2VUeXBlIH0gPSBKU09OLnBhcnNlKGRhdGEpO1xuXG5cdFx0aWYgKHRoaXMubWV0YS5yb2xlICE9PSBtZXRhLnJvbGUpIHtcblx0XHRcdHRoaXMuc2NlbmUudWkuc2V0Q29ubmVjdGlvblJvbGUobWV0YS5yb2xlKTtcblxuXHRcdFx0aWYgKHRoaXMubWV0YS5yb2xlICYmIG1ldGEucm9sZSA9PT0gJ2hvc3QnKSB7XG5cdFx0XHRcdHRoaXMuaG9zdFVuaXRzRnJvbU5ldHdvcmsoKTtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMubWV0YS5kZWJ1Zykge1xuXHRcdFx0XHR0aGlzLmNsZWFyTG9jYWxHYW1lT2JqZWN0cygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMubWV0YSA9IG1ldGE7XG5cblx0XHR0cnkge1xuXHRcdFx0c3dpdGNoIChtZXNzYWdlVHlwZSkge1xuXHRcdFx0XHRjYXNlICdoYW5kc2hha2UnOiB7XG5cdFx0XHRcdFx0dGhpcy5wcm9jZXNzSGFuZHNoYWtlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAncmVzdGFydFNlcnZlcic6IHtcblx0XHRcdFx0XHR3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAnc2V0VXNlclBsYXllcic6IHtcblx0XHRcdFx0XHRjb25zdCBwbGF5ZXIgPSB0aGlzLnNjZW5lLmdldFBsYXllcigpO1xuXG5cdFx0XHRcdFx0aWYgKHBsYXllcikge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRQbGF5ZXJQYXJhbXMocGxheWVyLCByZXNwb25zZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuc2NlbmUudW5pdHMuc2V0RGVmYXVsdFBsYXllclBhcmFtcyhyZXNwb25zZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ3VwZGF0ZUdhbWVPYmplY3RzJzoge1xuXHRcdFx0XHRcdHRoaXMudXBkYXRlR2FtZU9iamVjdHMocmVzcG9uc2UpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6IHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZURpc2Nvbm5lY3RlZFBsYXllcihyZXNwb25zZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBlcnJvcicsIGUpO1xuXHRcdH1cblx0fVxuXG5cdHRha2VIb3N0KCkge1xuXHRcdHRoaXMuc2VuZCgndGFrZUhvc3QnKTtcblx0fVxuXG5cdHJlc3RhcnRTZXJ2ZXIoKSB7XG5cdFx0dGhpcy5zZW5kKCdyZXN0YXJ0U2VydmVyJyk7XG5cdH1cblxuXHQvLyBUaGVyZSBpcyByYWNlIGNvbmRpdGlvbiBiZXR3ZWVuXG5cdC8vIGNsZWFyTG9jYWxHYW1lT2JqZWN0cyBhbmQgTG9jYXRpb24uY3JlYXRlSW50ZXJhY3RpdmVHYW1lT2JqZWN0c1xuXHRjbGVhckxvY2FsR2FtZU9iamVjdHMoKSB7XG5cdFx0Y29uc3QgZ2FtZU9iamVjdHNTZXJ2aWNlID0gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2U7XG5cdFx0Y29uc3QgcGxheWVyID0gdGhpcy5zY2VuZS5nZXRQbGF5ZXIoKTtcblxuXHRcdC8vIENsZWFyIGxvY2FsIGdhbWVPYmplY3RzIHRvIHJlcGxhY2UgdGhlbSBieSBuZXR3b3JrIHVuaXRzIChleGNlcHQgcGxheWVyKVxuXHRcdGdhbWVPYmplY3RzU2VydmljZS5nZXRVbml0cygpLmZvckVhY2goKHVuaXQpID0+IHtcblx0XHRcdGlmICghdW5pdC5wYXJhbXMuZnJvbU5ldHdvcmsgJiYgdW5pdCAhPT0gcGxheWVyKSB7XG5cdFx0XHRcdGdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdCh1bml0KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHNlbmQobWVzc2FnZVR5cGUsIGRhdGEpIHtcblx0XHRjb25zdCB7IHVzZXJOYW1lLCBwYXNzd29yZCB9ID0gdGhpcy5zY2VuZS51c2VyO1xuXG5cdFx0Y29uc3QgbWV0YSA9IHtcblx0XHRcdHRva2VuOiB0aGlzLmdldEhhc2godXNlck5hbWUgKyBwYXNzd29yZCksXG5cdFx0fTtcblxuXHRcdHRoaXMuY29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KHsgbWVzc2FnZVR5cGUsIG1ldGEsIGRhdGEgfSkpXG5cdH1cblxuXHRwcm9jZXNzSGFuZHNoYWtlKCkge1xuXHRcdHRoaXMuc2VuZCgnbG9hZEN1cnJlbnRVc2VyJyk7XG5cdH1cblxuXHR1cGRhdGVHYW1lT2JqZWN0cyhnYW1lT2JqZWN0cykge1xuXHRcdGdhbWVPYmplY3RzLmZvckVhY2goKGdhbWVPYmplY3QpID0+IHtcblx0XHRcdHN3aXRjaCAoZ2FtZU9iamVjdC50eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ3BsYXllcic6IHtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZU5ldHdvcmtQbGF5ZXIoZ2FtZU9iamVjdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAnYWknOiB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGVOZXR3b3JrQUkoZ2FtZU9iamVjdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHJlbW92ZURpc2Nvbm5lY3RlZFBsYXllcih7IGNvbm5lY3Rpb25JZCB9KSB7XG5cdFx0Y29uc3QgZ2FtZU9iamVjdHNTZXJ2aWNlID0gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2U7XG5cdFx0Y29uc3QgZGlzY29ubmVjdGVkUGxheWVyID0gZ2FtZU9iamVjdHNTZXJ2aWNlLmdldFVuaXRzKCkuZmluZCh1bml0ID0+XG5cdFx0XHR1bml0IGluc3RhbmNlb2YgUGxheWVyXG5cdFx0XHQmJiB1bml0LnBhcmFtcy5jb25uZWN0aW9uSWQgPT09IGNvbm5lY3Rpb25JZFxuXHRcdCk7XG5cblx0XHRjb25zb2xlLmxvZygnUGxheWVyIGRpc2Nvbm5lY3RlZCcsIGNvbm5lY3Rpb25JZCwgZGlzY29ubmVjdGVkUGxheWVyKTtcblxuXHRcdGlmIChkaXNjb25uZWN0ZWRQbGF5ZXIpIHtcblx0XHRcdGRpc2Nvbm5lY3RlZFBsYXllci5kaWUoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0SGFzaChzdHIpIHtcblx0XHRmdW5jdGlvbiBoYXNoMzIoc3RyKSB7XG5cdFx0XHRsZXQgaTtcblx0XHRcdGxldCBsO1xuXHRcdFx0bGV0IGh2YWwgPSAweDgxMWM5ZGM1O1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRodmFsIF49IHN0ci5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0XHRodmFsICs9IChodmFsIDw8IDEpICsgKGh2YWwgPDwgNCkgKyAoaHZhbCA8PCA3KSArIChodmFsIDw8IDgpICsgKGh2YWwgPDwgMjQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKFwiMDAwMDAwMFwiICsgKGh2YWwgPj4+IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC04KTtcblx0XHR9XG5cblx0XHRsZXQgaDEgPSBoYXNoMzIoc3RyKTtcblx0XHRyZXR1cm4gaDEgKyBoYXNoMzIoaDEgKyBzdHIpO1xuXHR9XG5cblx0aG9zdFVuaXRzRnJvbU5ldHdvcmsoKSB7XG5cdFx0dGhpcy5zY2VuZS51bml0c1xuXHRcdFx0LmdldEFsaXZlVW5pdHMoKVxuXHRcdFx0LmZvckVhY2goKHVuaXQpID0+IHtcblx0XHRcdFx0aWYgKHVuaXQucGFyYW1zLmZyb21OZXR3b3JrKSB7XG5cdFx0XHRcdFx0dW5pdC5wYXJhbXMuZnJvbU5ldHdvcmsgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH1cblxuXHR1cGRhdGVOZXR3b3JrUGxheWVyKHBsYXllckRhdGEpIHtcblx0XHRjb25zdCB7IGxvY2F0aW9uTmFtZSwgcG9zaXRpb24sIHJvdGF0aW9uLCBhbmltYXRpb25TdGF0ZSwgcGFyYW1zIH0gPSBwbGF5ZXJEYXRhO1xuXHRcdGNvbnN0IHsgcGFyYW1zOiB7IHVuaXROZXR3b3JrSWQgfSB9ID0gcGxheWVyRGF0YTtcblxuXHRcdGlmICh1bml0TmV0d29ya0lkID09PSB0aGlzLm1ldGEudW5pdE5ldHdvcmtJZCAmJiAhdGhpcy5tZXRhLmRlYnVnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGxvY2F0aW9uTmFtZSAhPT0gdGhpcy5zY2VuZS5sb2NhdGlvbi5nZXRMb2NhdGlvbk5hbWUoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIFBsYXllciB8IHN0cmluZ1xuXHRcdCAqL1xuXHRcdGxldCBuZXR3b3JrUGxheWVyID0gdGhpcy5uZXR3b3JrUGxheWVyc1t1bml0TmV0d29ya0lkXTtcblxuXHRcdGlmICghbmV0d29ya1BsYXllcikge1xuXHRcdFx0dGhpcy5uZXR3b3JrUGxheWVyc1t1bml0TmV0d29ya0lkXSA9ICdsb2FkaW5nJztcblxuXHRcdFx0dGhpcy5zY2VuZS51bml0cy5jcmVhdGVOZXR3b3JrUGxheWVyKFxuXHRcdFx0XHRwbGF5ZXJEYXRhLFxuXHRcdFx0XHQobmV0d29ya1BsYXllcikgPT4ge1xuXHRcdFx0XHRcdHRoaXMubmV0d29ya1BsYXllcnNbdW5pdE5ldHdvcmtJZF0gPSBuZXR3b3JrUGxheWVyO1xuXHRcdFx0XHR9LFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKG5ldHdvcmtQbGF5ZXIgIT09ICdsb2FkaW5nJykge1xuXHRcdFx0dGhpcy5zZXRQbGF5ZXJQYXJhbXMobmV0d29ya1BsYXllciwgeyBwb3NpdGlvbiwgcm90YXRpb24sIGFuaW1hdGlvblN0YXRlLCBwYXJhbXMgfSk7XG5cdFx0fVxuXHR9XG5cblx0c2V0UGxheWVyUGFyYW1zKHBsYXllciwgeyBwb3NpdGlvbiwgcm90YXRpb24sIGFuaW1hdGlvblN0YXRlLCBwYXJhbXMgfSkge1xuXHRcdHBsYXllci5wb3NpdGlvbi5zZXQocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XG5cdFx0cGxheWVyLnJvdGF0aW9uLnNldChyb3RhdGlvbi54LCByb3RhdGlvbi55LCByb3RhdGlvbi56KTtcblx0XHRwbGF5ZXIuYW5pbWF0aW9uU3RhdGUgPSBhbmltYXRpb25TdGF0ZTtcblxuXHRcdGlmIChwYXJhbXMpIHtcblx0XHRcdGNvbnN0IHsgaW5wdXQsIGFjY2VsZXJhdGlvbiB9ID0gcGFyYW1zO1xuXHRcdFx0Y29uc3QgcGxheWVyUGFyYW1zID0gcGxheWVyLnBhcmFtcztcblxuXHRcdFx0cGxheWVyUGFyYW1zLmlucHV0LnZlcnRpY2FsID0gaW5wdXQudmVydGljYWw7XG5cdFx0XHRwbGF5ZXJQYXJhbXMuaW5wdXQuaG9yaXpvbnRhbCA9IGlucHV0Lmhvcml6b250YWw7XG5cdFx0XHRwbGF5ZXJQYXJhbXMuaW5wdXQuYXR0YWNrMSA9IGlucHV0LmF0dGFjazE7XG5cdFx0XHRwbGF5ZXJQYXJhbXMuaW5wdXQuYXR0YWNrMiA9IGlucHV0LmF0dGFjazI7XG5cdFx0XHRwbGF5ZXJQYXJhbXMuaHAgPSBwYXJhbXMuaHA7XG5cdFx0XHRwbGF5ZXJQYXJhbXMuaHBNYXggPSBwYXJhbXMuaHBNYXg7XG5cdFx0XHRwbGF5ZXJQYXJhbXMuZnJhY3Rpb24gPSBwYXJhbXMuZnJhY3Rpb247XG5cdFx0XHRwbGF5ZXJQYXJhbXMuZGFtYWdlID0gcGFyYW1zLmRhbWFnZTtcblx0XHRcdHBsYXllclBhcmFtcy5zcGVlZCA9IHBhcmFtcy5zcGVlZDtcblx0XHRcdHBsYXllclBhcmFtcy5tb25leSA9IHBhcmFtcy5tb25leTtcblx0XHRcdHBsYXllclBhcmFtcy5sZXZlbCA9IHBhcmFtcy5sZXZlbDtcblx0XHRcdHBsYXllclBhcmFtcy51bnNwZW50VGFsZW50cyA9IHBhcmFtcy51bnNwZW50VGFsZW50cztcblx0XHRcdHBsYXllclBhcmFtcy5leHBlcmllbmNlID0gcGFyYW1zLmV4cGVyaWVuY2U7XG5cdFx0XHRwbGF5ZXJQYXJhbXMuYWNjZWxlcmF0aW9uLnNldChhY2NlbGVyYXRpb24ueCwgYWNjZWxlcmF0aW9uLnksIGFjY2VsZXJhdGlvbi56KTtcblx0XHR9XG5cdH1cblxuXHR1cGRhdGVOZXR3b3JrQUkodW5pdERhdGEpIHtcblx0XHRjb25zdCB7IGxvY2F0aW9uTmFtZSwgcG9zaXRpb24sIHJvdGF0aW9uLCBpc1J1bm5pbmcsIGlzQXR0YWNrLCBhbmltYXRpb25TdGF0ZSwgc2NhbGUsIHBhcmFtcyB9ID0gdW5pdERhdGE7XG5cdFx0Y29uc3QgeyB1bml0TmV0d29ya0lkIH0gPSBwYXJhbXM7XG5cblx0XHRpZiAobG9jYXRpb25OYW1lICE9PSB0aGlzLnNjZW5lLmxvY2F0aW9uLmdldExvY2F0aW9uTmFtZSgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUgQUkgfCBzdHJpbmdcblx0XHQgKi9cblx0XHRsZXQgbmV0d29ya0FJID0gdGhpcy5uZXR3b3JrQUlzW3VuaXROZXR3b3JrSWRdO1xuXG5cdFx0aWYgKCFuZXR3b3JrQUkpIHtcblx0XHRcdHRoaXMubmV0d29ya0FJc1t1bml0TmV0d29ya0lkXSA9ICdsb2FkaW5nJztcblxuXHRcdFx0dGhpcy5zY2VuZS51bml0cy5jcmVhdGVOZXR3b3JrQUkodW5pdERhdGEsIChuZXR3b3JrQUkpID0+IHtcblx0XHRcdFx0dGhpcy5uZXR3b3JrQUlzW3VuaXROZXR3b3JrSWRdID0gbmV0d29ya0FJO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChuZXR3b3JrQUkgIT09ICdsb2FkaW5nJykge1xuXHRcdFx0bmV0d29ya0FJLnBvc2l0aW9uLnNldChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcblx0XHRcdG5ldHdvcmtBSS5yb3RhdGlvbi5zZXQocm90YXRpb24ueCwgcm90YXRpb24ueSwgcm90YXRpb24ueik7XG5cdFx0XHRuZXR3b3JrQUkub2JqZWN0LnNjYWxlLnNldChzY2FsZS54LCBzY2FsZS55LCBzY2FsZS56KTtcblx0XHRcdG5ldHdvcmtBSS5pc1J1bm5pbmcgPSBpc1J1bm5pbmc7XG5cdFx0XHRuZXR3b3JrQUkuaXNBdHRhY2sgPSBpc0F0dGFjaztcblx0XHRcdG5ldHdvcmtBSS5hbmltYXRpb25TdGF0ZSA9IGFuaW1hdGlvblN0YXRlO1xuXG5cdFx0XHRpZiAocGFyYW1zKSB7XG5cdFx0XHRcdGNvbnN0IHsgYWNjZWxlcmF0aW9uIH0gPSBwYXJhbXM7XG5cdFx0XHRcdGNvbnN0IG5ldHdvcmtBSVBhcmFtcyA9IG5ldHdvcmtBSS5wYXJhbXM7XG5cblx0XHRcdFx0bmV0d29ya0FJUGFyYW1zLmhwID0gcGFyYW1zLmhwO1xuXHRcdFx0XHRuZXR3b3JrQUlQYXJhbXMuaHBNYXggPSBwYXJhbXMuaHBNYXg7XG5cdFx0XHRcdG5ldHdvcmtBSVBhcmFtcy5mcmFjdGlvbiA9IHBhcmFtcy5mcmFjdGlvbjtcblx0XHRcdFx0bmV0d29ya0FJUGFyYW1zLmRhbWFnZSA9IHBhcmFtcy5kYW1hZ2U7XG5cdFx0XHRcdG5ldHdvcmtBSVBhcmFtcy5sZXZlbCA9IHBhcmFtcy5sZXZlbDtcblx0XHRcdFx0bmV0d29ya0FJUGFyYW1zLmFjY2VsZXJhdGlvbi5zZXQoYWNjZWxlcmF0aW9uLngsIGFjY2VsZXJhdGlvbi55LCBhY2NlbGVyYXRpb24ueik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0c2VuZEdhbWVPYmplY3RzKCkge1xuXHRcdGNvbnN0IGNvbm5lY3Rpb25JZCA9IHRoaXMubWV0YS5pZDtcblxuXHRcdGlmICh0aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZSAhPT0gMSB8fCAhY29ubmVjdGlvbklkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgcGxheWVyID0gdGhpcy5zY2VuZS5nZXRQbGF5ZXIoKTtcblx0XHRjb25zdCB1bml0cyA9IChcblx0XHRcdHRoaXMubWV0YS5yb2xlID09PSAnaG9zdCdcblx0XHRcdFx0PyBbXG5cdFx0XHRcdFx0cGxheWVyLFxuXHRcdFx0XHRcdC4uLnRoaXMuc2NlbmUudW5pdHNcblx0XHRcdFx0XHRcdC5nZXRBbGl2ZVVuaXRzKClcblx0XHRcdFx0XHRcdC5maWx0ZXIodW5pdCA9PiAhdW5pdC5wYXJhbXMuZnJvbU5ldHdvcmspXG5cdFx0XHRcdF1cblx0XHRcdFx0OiBbcGxheWVyXVxuXHRcdCk7XG5cblx0XHRjb25zdCBkYXRhID0gW107XG5cblx0XHR1bml0cy5mb3JFYWNoKCh1bml0KSA9PiB7XG5cdFx0XHRpZiAodW5pdCkge1xuXHRcdFx0XHRjb25zdCB1bml0Um90YXRpb24gPSB1bml0Lm9iamVjdC5yb3RhdGlvbi50b1ZlY3RvcjMoKTtcblxuXHRcdFx0XHRpZiAoIXVuaXQucGFyYW1zLnVuaXROZXR3b3JrSWQpIHtcblx0XHRcdFx0XHRjb25zdCBnZXRSYW5kb21TdHJpbmcgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMik7XG5cdFx0XHRcdFx0dW5pdC5wYXJhbXMudW5pdE5ldHdvcmtJZCA9IGdldFJhbmRvbVN0cmluZygpICsgZ2V0UmFuZG9tU3RyaW5nKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB1bml0TmV0d29ya0lkID0gdW5pdC5wYXJhbXMudW5pdE5ldHdvcmtJZDtcblx0XHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRcdGlzUnVubmluZyxcblx0XHRcdFx0XHRpc0F0dGFjayxcblx0XHRcdFx0fSA9IHVuaXQ7XG5cdFx0XHRcdGNvbnN0IHtcblx0XHRcdFx0XHRocCxcblx0XHRcdFx0XHRocE1heCxcblx0XHRcdFx0XHRhY2NlbGVyYXRpb24sXG5cdFx0XHRcdFx0ZGFtYWdlLFxuXHRcdFx0XHRcdGxldmVsLFxuXHRcdFx0XHRcdGV4cGVyaWVuY2UsXG5cdFx0XHRcdFx0ZnJhY3Rpb24sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRzcGVlZCxcblx0XHRcdFx0XHR1bnNwZW50VGFsZW50cyxcblx0XHRcdFx0XHRtb25leSxcblx0XHRcdFx0fSA9IHVuaXQucGFyYW1zO1xuXG5cdFx0XHRcdGNvbnN0IHtcblx0XHRcdFx0XHR2ZXJ0aWNhbCxcblx0XHRcdFx0XHRob3Jpem9udGFsLFxuXHRcdFx0XHRcdGF0dGFjazEsXG5cdFx0XHRcdFx0YXR0YWNrMixcblx0XHRcdFx0fSA9IHVuaXQucGFyYW1zLmlucHV0IHx8IHt9O1xuXG5cdFx0XHRcdGNvbnN0IHZlY3RvclRvT2JqZWN0ID0gKHZlY3RvciwgZXBzID0gMTAwMCkgPT4gKHtcblx0XHRcdFx0XHR4OiBNYXRoLnJvdW5kKHZlY3Rvci54ICogZXBzKSAvIGVwcyxcblx0XHRcdFx0XHR5OiBNYXRoLnJvdW5kKHZlY3Rvci55ICogZXBzKSAvIGVwcyxcblx0XHRcdFx0XHR6OiBNYXRoLnJvdW5kKHZlY3Rvci56ICogZXBzKSAvIGVwcyxcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0ZGF0YS5wdXNoKHtcblx0XHRcdFx0XHR0eXBlOiB1bml0IGluc3RhbmNlb2YgUGxheWVyID8gJ3BsYXllcicgOiAnYWknLFxuXHRcdFx0XHRcdGxvY2F0aW9uTmFtZTogdGhpcy5zY2VuZS5sb2NhdGlvbi5nZXRMb2NhdGlvbk5hbWUoKSxcblx0XHRcdFx0XHRhbmltYXRpb25TdGF0ZTogdW5pdC5hbmltYXRpb25TdGF0ZSxcblx0XHRcdFx0XHRpc1J1bm5pbmcsXG5cdFx0XHRcdFx0aXNBdHRhY2ssXG5cdFx0XHRcdFx0cG9zaXRpb246IHZlY3RvclRvT2JqZWN0KHVuaXQucG9zaXRpb24pLFxuXHRcdFx0XHRcdHJvdGF0aW9uOiB2ZWN0b3JUb09iamVjdCh1bml0Um90YXRpb24pLFxuXHRcdFx0XHRcdHNjYWxlOiB2ZWN0b3JUb09iamVjdCh1bml0Lm9iamVjdC5zY2FsZSksXG5cdFx0XHRcdFx0cGFyYW1zOiB7XG5cdFx0XHRcdFx0XHRjb25uZWN0aW9uSWQsXG5cdFx0XHRcdFx0XHR1bml0TmV0d29ya0lkLFxuXHRcdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRcdGhwLFxuXHRcdFx0XHRcdFx0aHBNYXgsXG5cdFx0XHRcdFx0XHRmcmFjdGlvbixcblx0XHRcdFx0XHRcdGRhbWFnZSxcblx0XHRcdFx0XHRcdGxldmVsLFxuXHRcdFx0XHRcdFx0ZXhwZXJpZW5jZSxcblx0XHRcdFx0XHRcdHNwZWVkLFxuXHRcdFx0XHRcdFx0bW9uZXksXG5cdFx0XHRcdFx0XHR1bnNwZW50VGFsZW50cyxcblx0XHRcdFx0XHRcdGFjY2VsZXJhdGlvbjogdmVjdG9yVG9PYmplY3QoYWNjZWxlcmF0aW9uKSxcblx0XHRcdFx0XHRcdGlucHV0OiB7XG5cdFx0XHRcdFx0XHRcdHZlcnRpY2FsLCBob3Jpem9udGFsLFxuXHRcdFx0XHRcdFx0XHRhdHRhY2sxLCBhdHRhY2syLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmICh0aGlzLm1ldGEucm9sZSA9PT0gJ2hvc3QnKSB7XG5cdFx0XHR0aGlzLnNlbmQoJ3VwZGF0ZUdhbWVPYmplY3RzJywgZGF0YSk7XG5cdFx0fSBlbHNlIGlmIChkYXRhWzBdKSB7XG5cdFx0XHR0aGlzLnNlbmQoJ3VwZGF0ZVBsYXllcicsIGRhdGFbMF0pO1xuXHRcdH1cblx0fVxufSIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuaW1wb3J0IEFJIGZyb20gJy4vR2FtZU9iamVjdHMvQUknO1xuaW1wb3J0IFBsYXllciBmcm9tICcuL0dhbWVPYmplY3RzL1BsYXllcic7XG5pbXBvcnQgRmlyZSBmcm9tICcuL0dhbWVPYmplY3RzL0ZpcmUnO1xuaW1wb3J0IFVuaXQgZnJvbSAnLi9HYW1lT2JqZWN0cy9Vbml0JztcbmltcG9ydCBBbmltYXRlZEdhbWVPYmplY3QgZnJvbSAnLi9HYW1lT2JqZWN0cy9BbmltYXRlZEdhbWVPYmplY3QnO1xuXG5leHBvcnQge1xuICAgIEFJLFxuICAgIFBsYXllcixcbiAgICBGaXJlLFxuICAgIFVuaXQsXG4gICAgQW5pbWF0ZWRHYW1lT2JqZWN0LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZU9iamVjdHNTZXJ2aWNlIGV4dGVuZHMgQXV0b0JpbmRNZXRob2RzIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdHMgPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0R2FtZU9iamVjdElkID0gMDtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIH1cblxuICAgIHVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpIHtcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0cy5mb3JFYWNoKGdhbWVPYmplY3QgPT4gZ2FtZU9iamVjdC51cGRhdGUodGltZSwgZGVsdGFUaW1lKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVbml0fSBhdHRhY2tpbmdVbml0XG4gICAgICovXG4gICAgYXR0YWNrKGF0dGFja2luZ1VuaXQpIHtcbiAgICAgICAgaWYgKGF0dGFja2luZ1VuaXQuaXNEZWFkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2NlbmUuaW50ZXJ2YWxzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ2FtZVRpbWUgPSB0aGlzLnNjZW5lLmludGVydmFscy5nZXRUaW1lUGFzc2VkKCk7XG5cbiAgICAgICAgICAgIGlmIChhdHRhY2tpbmdVbml0LmlzQXR0YWNrSW50ZXJydXB0ZWQoZ2FtZVRpbWUpKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNraW5nVW5pdC5yZWxlYXNlQXR0YWNrKGdhbWVUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGF0dGFja2VkVW5pdHMgPSB0aGlzLmdldFVuaXRzKCkuZmlsdGVyKGdhbWVPYmplY3QgPT4gKFxuICAgICAgICAgICAgICAgIGdhbWVPYmplY3QgIT09IGF0dGFja2luZ1VuaXRcbiAgICAgICAgICAgICAgICAmJiBnYW1lT2JqZWN0LmlzQWxpdmUoKVxuICAgICAgICAgICAgICAgICYmIGdhbWVPYmplY3QuaXNFbmVteShhdHRhY2tpbmdVbml0KVxuICAgICAgICAgICAgICAgICYmIGdhbWVPYmplY3QucG9zaXRpb24uZGlzdGFuY2VUbyhhdHRhY2tpbmdVbml0LnBvc2l0aW9uKSA8IDJcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICBhdHRhY2tlZFVuaXRzLmZvckVhY2goKGNvbGxpc2lvbkdhbWVPYmplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb2xsaXNpb25HYW1lT2JqZWN0LmRhbWFnZVRha2VuKHtcbiAgICAgICAgICAgICAgICAgICAgZGFtYWdlOiBhdHRhY2tpbmdVbml0LnBhcmFtcy5kYW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgIHVuaXQ6IGF0dGFja2luZ1VuaXQsXG4gICAgICAgICAgICAgICAgfSwgZ2FtZVRpbWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gaWYgKGF0dGFja2VkVW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5zY2VuZS5hdWRpby5wbGF5U291bmQoYXR0YWNraW5nVW5pdC5wb3NpdGlvbiwgJ0F0dGFjayBTb2Z0Jyk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH0sIGF0dGFja2luZ1VuaXQuZ2V0QXR0YWNrVGltZW91dCgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VuaXR9IGZpcmluZ0dhbWVPYmplY3RcbiAgICAgKi9cbiAgICBmaXJlKGZpcmluZ0dhbWVPYmplY3QpIHtcbiAgICAgICAgaWYgKGZpcmluZ0dhbWVPYmplY3QuaXNEZWFkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNyZWF0ZUxpZ2h0Q3ViZSA9IGxlZnQgPT4gdGhpcy5zY2VuZS5tb2RlbHMuY3JlYXRlQ3ViZSh7XG4gICAgICAgICAgICB4OiAwLjAyLFxuICAgICAgICAgICAgeTogMC4wMixcbiAgICAgICAgICAgIHo6IDAuMyxcbiAgICAgICAgICAgIGVtaXNzaXZlOiAnI2ZmMDAwMCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoMC4wNSAtIE51bWJlcihsZWZ0KSAqIDAuMSwgMCwgMCksXG4gICAgICAgICAgICBub1NjZW5lOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBvYmplY3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuICAgICAgICBvYmplY3QucG9zaXRpb24uY29weShmaXJpbmdHYW1lT2JqZWN0LmdldEZpcmVJbml0aWFsUG9zaXRpb24oKSk7XG4gICAgICAgIG9iamVjdC5xdWF0ZXJuaW9uLmNvcHkoZmlyaW5nR2FtZU9iamVjdC5nZXRGaXJlSW5pdGlhbFJvdGF0aW9uKCkpO1xuXG4gICAgICAgIG9iamVjdC5hZGQoY3JlYXRlTGlnaHRDdWJlKHRydWUpKTtcbiAgICAgICAgb2JqZWN0LmFkZChjcmVhdGVMaWdodEN1YmUoZmFsc2UpKTtcblxuICAgICAgICB0aGlzLnNjZW5lLmFkZChvYmplY3QpO1xuXG4gICAgICAgIGNvbnN0IGZpcmVHYW1lT2JqZWN0ID0gdGhpcy5ob29rR2FtZU9iamVjdChuZXcgRmlyZSh7XG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICB0aHJvdHRsaW5nOiBuZXcgVEhSRUUuVmVjdG9yMygxLCAxLCAxKSxcbiAgICAgICAgICAgIHNwZWVkOiBmaXJpbmdHYW1lT2JqZWN0LnBhcmFtcy5maXJlU2hlbGxTcGVlZCxcbiAgICAgICAgICAgIGRhbWFnZTogZmlyaW5nR2FtZU9iamVjdC5wYXJhbXMuZmlyZURhbWFnZSxcbiAgICAgICAgICAgIHBhcmVudDogZmlyaW5nR2FtZU9iamVjdCxcbiAgICAgICAgICAgIGNoZWNrV2F5OiB0aGlzLnNjZW5lLmNvbGxpZGVycy5jaGVja1dheSxcbiAgICAgICAgICAgIGdldENvbGxpc2lvbnM6ICgpID0+IHRoaXMuZ2FtZU9iamVjdHMuZmlsdGVyKGdhbWVPYmplY3QgPT4gKFxuICAgICAgICAgICAgICAgIGdhbWVPYmplY3QgaW5zdGFuY2VvZiBVbml0XG4gICAgICAgICAgICAgICAgJiYgZ2FtZU9iamVjdC5pc0FsaXZlKClcbiAgICAgICAgICAgICAgICAmJiBmaXJlR2FtZU9iamVjdC5wYXJhbXMucGFyZW50ICE9PSBnYW1lT2JqZWN0XG4gICAgICAgICAgICAgICAgJiYgZmlyZUdhbWVPYmplY3QucG9zaXRpb24uZGlzdGFuY2VUbyhnYW1lT2JqZWN0LnBvc2l0aW9uKSA8IDNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgZGVzdHJveTogKCkgPT4gdGhpcy5kZXN0cm95R2FtZU9iamVjdChmaXJlR2FtZU9iamVjdCksXG4gICAgICAgIH0pKTtcblxuICAgICAgICB0aGlzLnNjZW5lLmludGVydmFscy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuZGVzdHJveUdhbWVPYmplY3QoZmlyZUdhbWVPYmplY3QpLCAyMDAwKTtcblxuICAgICAgICAvLyB0aGlzLnNjZW5lLmF1ZGlvLnBsYXlTb3VuZChmaXJpbmdHYW1lT2JqZWN0LnBvc2l0aW9uLCAnTGFzZXJzJyk7XG4gICAgfVxuICAgIFxuICAgIGNyZWF0ZUl0ZW0oe1xuICAgICAgICBzY2FsZSA9IDEuNSxcbiAgICAgICAgbW9kZWwgPSAnaXRlbS1oZWFsJyxcbiAgICAgICAgcG9zaXRpb24gPSB7fSxcbiAgICAgICAgY2FuUGlja3VwLFxuICAgICAgICBvblBpY2t1cCxcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuc2NlbmUubW9kZWxzLmxvYWRHTFRGKHtcbiAgICAgICAgICAgIGJhc2VVcmw6ICcuL2Fzc2V0cy9tb2RlbHMvaXRlbXMvJyArIG1vZGVsLFxuICAgICAgICAgICAgbm9TY2VuZTogdHJ1ZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBsb2FkZWRPYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uVmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMocG9zaXRpb24ueCB8fCAwLCBwb3NpdGlvbi55IHx8IDAsIHBvc2l0aW9uLnogfHwgMCk7XG4gICAgICAgICAgICAgICAgbG9hZGVkT2JqZWN0LnNjZW5lLnNjYWxlLnNldChzY2FsZSwgc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxvYWRlZE9iamVjdC5zY2VuZS50cmF2ZXJzZSgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzTWVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwuYWxwaGFUZXN0ID0gMC41O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsb2FkZWRPYmplY3Quc2NlbmUucG9zaXRpb24uc2V0KHBvc2l0aW9uVmVjdG9yLngsIHBvc2l0aW9uVmVjdG9yLnksIHBvc2l0aW9uVmVjdG9yLnopO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuc2NlbmUuYWRkKGxvYWRlZE9iamVjdC5zY2VuZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBnYW1lSXRlbSA9IG5ldyBBbmltYXRlZEdhbWVPYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGxvYWRlZE9iamVjdC5zY2VuZSxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uczogbG9hZGVkT2JqZWN0LmFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmdhbWVPYmplY3RzU2VydmljZS5ob29rR2FtZU9iamVjdChnYW1lSXRlbSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja1BpY2t1cCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZXRQcmlvcml0eSA9IHVuaXQgPT4gMSAvIE1hdGguY2VpbChwb3NpdGlvblZlY3Rvci5kaXN0YW5jZVRvKHVuaXQucG9zaXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWFyVW5pdHMgPSB0aGlzLnNjZW5lLnVuaXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRBbGl2ZVVuaXRzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodW5pdCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFjYW5QaWNrdXAgfHwgY2FuUGlja3VwKHVuaXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zaXRpb25WZWN0b3IuZGlzdGFuY2VUbyh1bml0LnBvc2l0aW9uKSA8IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKHVuaXRBLCB1bml0QikgPT4gZ2V0UHJpb3JpdHkodW5pdEIpIC0gZ2V0UHJpb3JpdHkodW5pdEEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWFyVW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvblBpY2t1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25QaWNrdXAobmVhclVuaXRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYW1lSXRlbS5hbmltYXRpb25TdGF0ZS5pc0RpZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuaW50ZXJ2YWxzLnNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnNjZW5lLmdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdChnYW1lSXRlbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA1MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tQaWNrdXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2hlY2tQaWNrdXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtHYW1lT2JqZWN0fSBnYW1lT2JqZWN0XG4gICAgICovXG4gICAgaG9va0dhbWVPYmplY3QoZ2FtZU9iamVjdCkge1xuICAgICAgICB0aGlzLmdhbWVPYmplY3RzLnB1c2goZ2FtZU9iamVjdCk7XG4gICAgICAgIGdhbWVPYmplY3QuX19nYW1lX29iamVjdF9pZCA9IHRoaXMubmV4dEdhbWVPYmplY3RJZCsrO1xuXG4gICAgICAgIHJldHVybiBnYW1lT2JqZWN0O1xuICAgIH1cblxuICAgIHJlbW92ZUFsbCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuZ2FtZU9iamVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lHYW1lT2JqZWN0KHRoaXMuZ2FtZU9iamVjdHNbMF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlQWxsRXhjZXB0UGxheWVyKCkge1xuICAgICAgICBjb25zdCBnZXROZXh0Tm9uUGxheWVySW5kZXggPSAoKSA9PiB0aGlzLmdhbWVPYmplY3RzLmZpbmRJbmRleChnbyA9PiBnbyAhPT0gdGhpcy5zY2VuZS5nZXRQbGF5ZXIoKSk7XG4gICAgICAgIGxldCByZW1vdmVJZHggPSBnZXROZXh0Tm9uUGxheWVySW5kZXgoKTtcblxuICAgICAgICB3aGlsZSAocmVtb3ZlSWR4ID4gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGdhbWVPYmplY3QgPSB0aGlzLmdhbWVPYmplY3RzW3JlbW92ZUlkeF07XG4gICAgICAgICAgICB0aGlzLmdhbWVPYmplY3RzLnNwbGljZShyZW1vdmVJZHgsIDEpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUdhbWVPYmplY3RGcm9tU2NlbmUoZ2FtZU9iamVjdCk7XG5cbiAgICAgICAgICAgIHJlbW92ZUlkeCA9IGdldE5leHROb25QbGF5ZXJJbmRleCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtHYW1lT2JqZWN0fSBnYW1lT2JqZWN0XG4gICAgICovXG4gICAgZGVzdHJveUdhbWVPYmplY3QoZ2FtZU9iamVjdCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2FtZU9iamVjdHMuaW5kZXhPZihnYW1lT2JqZWN0KTtcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5nYW1lT2JqZWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW1vdmVHYW1lT2JqZWN0RnJvbVNjZW5lKGdhbWVPYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7R2FtZU9iamVjdH0gZ2FtZU9iamVjdFxuICAgICAqL1xuICAgIHJlbW92ZUdhbWVPYmplY3RGcm9tU2NlbmUoZ2FtZU9iamVjdCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSAoZ2FtZU9iamVjdC5vYmplY3QgJiYgZ2FtZU9iamVjdC5vYmplY3QucGFyZW50KSB8fCB0aGlzLnNjZW5lO1xuXG4gICAgICAgIGlmIChwYXJlbnQucmVtb3ZlKSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlKGdhbWVPYmplY3Qub2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBmaW5kIG9iamVjdCBwYXJlbnQgdG8gcmVtb3ZlIHRoZSBvYmplY3QnLCBnYW1lT2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFVuaXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nYW1lT2JqZWN0cy5maWx0ZXIoZ28gPT4gZ28gaW5zdGFuY2VvZiBVbml0KTtcbiAgICB9XG59XG5cbiIsImltcG9ydCBGaXJpbmdVbml0IGZyb20gJy4vRmlyaW5nVW5pdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFJIGV4dGVuZHMgRmlyaW5nVW5pdCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgc3BlZWQ6IDAuNSxcbiAgICAgICAgICAgIGRhbWFnZTogMTAsXG4gICAgICAgICAgICBtYXM6IDEsXG4gICAgICAgICAgICBocDogMTAwLFxuICAgICAgICAgICAgbmFtZTogJ1VubmFtZWQgVW5pdCcsXG4gICAgICAgICAgICBmcmFjdGlvbjogJ25ldXRyYWwnLFxuICAgICAgICAgICAgZmlyZVRpbWVvdXQ6IDEuNSxcbiAgICAgICAgICAgIGF0dGFja1RpbWVvdXQ6IDEuNSxcbiAgICAgICAgICAgIGp1bXBUaW1lb3V0OiAxLjUsXG4gICAgICAgICAgICBzdGFydFJ1blRpbWVvdXQ6IDEsXG4gICAgICAgICAgICBuZXh0UG9pbnRVcGRhdGVUaW1lb3V0OiAwLjEsXG4gICAgICAgICAgICB1cGRhdGVUYXJnZXRUaW1lb3V0OiAzLFxuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IGhwLCBkYW1hZ2UsIHNwZWVkIH0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgICB0aGlzLnBhcmFtcy5ib3VudHkgPSBocCAvIDQgKyBkYW1hZ2UgKyBzcGVlZCAqIDMwO1xuICAgICAgICB0aGlzLmxhc3RSdW4gPSAwO1xuICAgICAgICB0aGlzLmxhc3RUYXJnZXRVcGRhdGUgPSAwO1xuICAgICAgICB0aGlzLmxhc3ROZXh0UG9pbnRVcGRhdGUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RKdW1wVGltZXN0YW1wID0gMDtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0F0dGFjayA9IGZhbHNlO1xuICAgIH1cblxuICAgIHVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKHRpbWUsIGRlbHRhVGltZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNEZWFkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5maW5kVGFyZ2V0ICYmIHRoaXMuaXNVcGRhdGVUYXJnZXRSZWxlYXNlZCh0aW1lKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMudGFyZ2V0ID0gdGhpcy5wYXJhbXMuZmluZFRhcmdldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBvYmplY3QsIHRhcmdldCwgYWNjZWxlcmF0aW9uLCBzcGVlZCwgZ2V0TmV4dFBvaW50IH0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgICBpZiAoIXRoaXMucGFyYW1zLmZyb21OZXR3b3JrKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldE5leHRQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc05leHRQb2ludFVwZGF0ZVJlbGVhc2VkKHRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3ROZXh0UG9pbnRVcGRhdGUgPSB0aW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0UG9pbnQgPSBnZXROZXh0UG9pbnQodGhpcy5wb3NpdGlvbiwgdGFyZ2V0LnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFBvaW50ID0gdGFyZ2V0LnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaXNUYXJnZXROZWFyID0gdGFyZ2V0ICYmIG9iamVjdC5wb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldC5wb3NpdGlvbikgPCAxLjc1O1xuXG4gICAgICAgICAgICB0aGlzLmlzQXR0YWNrID0gKFxuICAgICAgICAgICAgICAgaXNUYXJnZXROZWFyXG4gICAgICAgICAgICAgICAmJiB0aGlzLmlzRW5lbXkodGFyZ2V0KVxuICAgICAgICAgICAgICAgJiYgdGFyZ2V0LmlzQWxpdmUoKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBdHRhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZVRvUG9zaXRpb24odGFyZ2V0LnBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0UG9pbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZVRvUG9zaXRpb24odGhpcy5uZXh0UG9pbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpc05leHRQb2ludE5lYXIgPSAhdGhpcy5uZXh0UG9pbnQ7XG5cbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gKFxuICAgICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgICAgICYmICFpc1RhcmdldE5lYXJcbiAgICAgICAgICAgICAgICAmJiAhaXNOZXh0UG9pbnROZWFyXG4gICAgICAgICAgICAgICAgJiYgKHRoaXMuaXNSdW5uaW5nIHx8IHRoaXMuaXNSdW5SZWxlYXNlZCh0aW1lKSlcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmlzQXR0YWNrUmVsZWFzZWQodGltZSlcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmlzSGl0UmVsZWFzZWQodGltZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0F0dGFjaykge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNNb3ZpbmdGb3J3YXJkID0gdGhpcy5pc1J1bm5pbmcgJiYgdGhpcy5pc0FjY2VsZXJhdGlvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZykge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tXYXkgPSAoanVtcEhlaWdodCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFyYW1zOiB7IGFjY2VsZXJhdGlvbjogeyB4OiBkeCwgeTogZHksIHo6IGR6IH0gfSB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja1dheShkeCwgZHkgKyBqdW1wSGVpZ2h0LCBkeik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmxhc3RSdW4gPSB0aW1lO1xuICAgICAgICAgICAgYWNjZWxlcmF0aW9uLmFkZCh0aGlzLmdldEZvcndhcmQoKS5tdWx0aXBseVNjYWxhcigoc3BlZWQgKiAwLjEpICogKGRlbHRhVGltZSAqIDAuMDYpKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzSnVtcE5lZWRlZCA9IChcbiAgICAgICAgICAgICAgICB0aGlzLmlzR3JvdW5kZWRcbiAgICAgICAgICAgICAgICAmJiAoYWNjZWxlcmF0aW9uLnggfHwgYWNjZWxlcmF0aW9uLnopXG4gICAgICAgICAgICAgICAgJiYgdGltZSAtIHRoaXMubGFzdEp1bXBUaW1lc3RhbXAgPiB0aGlzLnBhcmFtcy5qdW1wVGltZW91dCAqIDEwMDBcbiAgICAgICAgICAgICAgICAmJiAhY2hlY2tXYXkoMC4xKVxuICAgICAgICAgICAgICAgICYmIGNoZWNrV2F5KDEuNSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChpc0p1bXBOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RKdW1wVGltZXN0YW1wID0gdGltZTtcbiAgICAgICAgICAgICAgICBhY2NlbGVyYXRpb24ueSArPSAwLjI1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcm90YXRlVG9Qb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBjb25zdCB7IG9iamVjdCB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgICAgY29uc3Qgcm90YXRpb25Ub1RhcmdldFJhZGlhbnMgPSBNYXRoLmF0YW4yKFxuICAgICAgICAgICAgcG9zaXRpb24ueCAtIG9iamVjdC5wb3NpdGlvbi54LFxuICAgICAgICAgICAgcG9zaXRpb24ueiAtIG9iamVjdC5wb3NpdGlvbi56XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdGhpcy5hbmltYXRpb25TdGF0ZS5pc1JvdGF0ZUxlZnQgPSByb3RhdGlvblRvVGFyZ2V0UmFkaWFucyAtIG9iamVjdC5yb3RhdGlvbi55ID4gMC4xO1xuICAgICAgICAvLyB0aGlzLmFuaW1hdGlvblN0YXRlLmlzUm90YXRlUmlnaHQgPSByb3RhdGlvblRvVGFyZ2V0UmFkaWFucyAtIG9iamVjdC5yb3RhdGlvbi55IDwgLTAuMTtcblxuICAgICAgICBjb25zdCB0YXJnZXRRdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICAgICAgdGFyZ2V0UXVhdGVybmlvbi5zZXRGcm9tRXVsZXIob2JqZWN0LnJvdGF0aW9uLmNsb25lKCkuc2V0KDAsIHJvdGF0aW9uVG9UYXJnZXRSYWRpYW5zLCAwKSk7XG4gICAgICAgIG9iamVjdC5xdWF0ZXJuaW9uLnNsZXJwKHRhcmdldFF1YXRlcm5pb24sIDAuMSk7XG4gICAgfVxuXG4gICAgaXNBY2NlbGVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLnBhcmFtcy5hY2NlbGVyYXRpb24ueClcbiAgICAgICAgICAgICsgTWF0aC5hYnModGhpcy5wYXJhbXMuYWNjZWxlcmF0aW9uLnkpXG4gICAgICAgICAgICArIE1hdGguYWJzKHRoaXMucGFyYW1zLmFjY2VsZXJhdGlvbi56KVxuICAgICAgICApID4gMC4wMTtcbiAgICB9XG5cbiAgICBpc1J1blJlbGVhc2VkKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRpbWUgLSB0aGlzLmxhc3RSdW4gPiB0aGlzLnBhcmFtcy5zdGFydFJ1blRpbWVvdXQgKiAxMDAwO1xuICAgIH1cblxuICAgIGlzTmV4dFBvaW50VXBkYXRlUmVsZWFzZWQodGltZSkge1xuICAgICAgICByZXR1cm4gdGltZSAtIHRoaXMubGFzdE5leHRQb2ludFVwZGF0ZSA+IHRoaXMucGFyYW1zLm5leHRQb2ludFVwZGF0ZVRpbWVvdXQgKiAxMDAwO1xuICAgIH1cblxuICAgIGlzVXBkYXRlVGFyZ2V0UmVsZWFzZWQodGltZSkge1xuICAgICAgICByZXR1cm4gdGltZSAtIHRoaXMubGFzdFRhcmdldFVwZGF0ZSA+IHRoaXMucGFyYW1zLnVwZGF0ZVRhcmdldFRpbWVvdXQgKiAxMDAwO1xuICAgIH1cblxuICAgIGRhbWFnZVRha2VuKHsgZGFtYWdlLCB1bml0OiBhdHRhY2tlciB9ID0ge30sIHRpbWUpIHtcbiAgICAgICAgc3VwZXIuZGFtYWdlVGFrZW4oeyBkYW1hZ2UsIHVuaXQ6IGF0dGFja2VyIH0sIHRpbWUpO1xuXG4gICAgICAgIGlmICghdGhpcy5wYXJhbXMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy50YXJnZXQgPSBhdHRhY2tlcjtcbiAgICAgICAgICAgIHRoaXMubGFzdFRhcmdldFVwZGF0ZSA9IHRpbWU7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IEdhbWVPYmplY3QgZnJvbSAnLi9HYW1lT2JqZWN0JztcblxuY29uc3QgYW5pbWF0aW9uTmFtZXMgPSB7XG4gICAgc3RhbmQ6ICdTdGFuZCcsXG4gICAgcnVuOiAnUnVuJyxcbiAgICBqdW1wOiAnSnVtcCcsXG4gICAgYXR0YWNrOiAnQXR0YWNrJyxcbiAgICByb3RhdGVMZWZ0OiAnUm90YXRlIExlZnQnLFxuICAgIHJvdGF0ZVJpZ2h0OiAnUm90YXRlIFJpZ2h0JyxcbiAgICBydW5MZWZ0OiAnUnVuIExlZnQnLFxuICAgIHJ1blJpZ2h0OiAnUnVuIFJpZ2h0JyxcbiAgICB3YWxrQmFjazogJ1dhbGsgQmFjaycsXG4gICAgZGllOiAnRGllJyxcbiAgICBzcGF3bjogJ1NwYXduJyxcbiAgICBoaXQ6ICdIaXQnLFxuXG4gICAgLy8gQ29tcGxleCBhbmltaW1hdGlvbnNcbiAgICB0b3BSdW46ICdUb3AgUnVuJyxcbiAgICBib3R0b21SdW46ICdCb3R0b20gUnVuJyxcbiAgICB0b3BXYWxrQmFjazogJ1RvcCBXYWxrIEJhY2snLFxuICAgIGJvdHRvbVdhbGtCYWNrOiAnQm90dG9tIFdhbGsgQmFjaycsXG4gICAgdG9wQXR0YWNrOiAnVG9wIEF0dGFjaycsXG4gICAgYm90dG9tQXR0YWNrOiAnQm90dG9tIEF0dGFjaycsXG4gICAgdG9wU3RhbmQ6ICdUb3AgU3RhbmQnLFxuICAgIGJvdHRvbVN0YW5kOiAnQm90dG9tIFN0YW5kJyxcbiAgICB0b3BSdW5SaWdodDogJ1RvcCBSdW4gUmlnaHQnLFxuICAgIHRvcFJ1bkxlZnQ6ICdUb3AgUnVuIExlZnQnLFxuICAgIHRvcEp1bXA6ICdUb3AgSnVtcCcsXG4gICAgdG9wSGl0OiAnVG9wIEhpdCcsXG4gICAgYm90dG9tUnVuUmlnaHQ6ICdCb3R0b20gUnVuIFJpZ2h0JyxcbiAgICBib3R0b21SdW5MZWZ0OiAnQm90dG9tIFJ1biBMZWZ0JyxcbiAgICBib3R0b21KdW1wOiAnQm90dG9tIEp1bXAnLFxuICAgIGJvdHRvbUhpdDogJ0JvdHRvbSBIaXQnLFxuICAgIHRvcERpZTogJ1RvcCBEaWUnLFxuICAgIGJvdHRvbURpZTogJ0JvdHRvbSBEaWUnLFxuICAgIHRvcFNwYXduOiAnVG9wIFNwYXduJyxcbiAgICBib3R0b21TcGF3bjogJ0JvdHRvbSBTcGF3bicsXG59O1xuXG5jb25zdCB0b3BBbmltYXRpb25zID0gW1xuICAgICd0b3BSdW4nLFxuICAgICd0b3BXYWxrQmFjaycsXG4gICAgJ3RvcEF0dGFjaycsXG4gICAgJ3RvcFN0YW5kJyxcbiAgICAndG9wUnVuUmlnaHQnLFxuICAgICd0b3BSdW5MZWZ0JyxcbiAgICAndG9wSnVtcCcsXG4gICAgJ3RvcEhpdCcsXG4gICAgJ3RvcERpZScsXG5dO1xuXG5jb25zdCBib3R0b21BbmltYXRpb25zID0gW1xuICAgICdib3R0b21SdW4nLFxuICAgICdib3R0b21XYWxrQmFjaycsXG4gICAgJ2JvdHRvbUF0dGFjaycsXG4gICAgJ2JvdHRvbVN0YW5kJyxcbiAgICAnYm90dG9tUnVuUmlnaHQnLFxuICAgICdib3R0b21SdW5MZWZ0JyxcbiAgICAnYm90dG9tSnVtcCcsXG4gICAgJ2JvdHRvbUhpdCcsXG4gICAgJ2JvdHRvbURpZScsXG5dO1xuXG5jb25zdCB0b3BCb25lcyA9IFtcbiAgICAnUmlnaHRfRm9yZWFybScsXG4gICAgJ1JpZ2h0X0FybScsXG4gICAgJ1JpZ2h0X0hhbmQnLFxuICAgICdSaWdodF9IYW5kX2VuZCcsXG4gICAgJ1JpZ2h0X1Nob3VsZGVyJyxcbiAgICAnTGVmdF9TaG91bGRlcicsXG4gICAgJ0xlZnRfRm9yZWFybScsXG4gICAgJ0xlZnRfQXJtJyxcbiAgICAnTGVmdF9IYW5kJyxcbiAgICAnTGVmdF9IYW5kX2VuZCcsXG4gICAgJ0NoZXN0JyxcbiAgICAnTmVjaycsXG4gICAgJ0hlYWQnLFxuICAgICdIZWFkX2VuZCdcbl07XG5cbmNvbnN0IGJvdHRvbUJvbmVzID0gW1xuICAgICdNYWluX0JvbmUnLFxuICAgICdSaWdodF9MZWcnLFxuICAgICdSaWdodF9NaWRkbGVfRm9vdCcsXG4gICAgJ1JpZ2h0X0Zvb3QnLFxuICAgICdSaWdodF9Gb290X2VuZCcsXG4gICAgJ0xlZnRfTGVnJyxcbiAgICAnTGVmdF9NaWRkbGVfRm9vdCcsXG4gICAgJ0xlZnRfRm9vdCcsXG4gICAgJ0xlZnRfRm9vdF9lbmQnLFxuICAgICdMZWdzX1JvdGF0aW9uJyxcbl07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGVkR2FtZU9iamVjdCBleHRlbmRzIEdhbWVPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWVzOiB7IC4uLmFuaW1hdGlvbk5hbWVzIH0sXG4gICAgICAgICAgICB0b3BCb25lczogWy4uLnRvcEJvbmVzXSxcbiAgICAgICAgICAgIGJvdHRvbUJvbmVzOiBbLi4uYm90dG9tQm9uZXNdLFxuICAgICAgICAgICAgdG9wQW5pbWF0aW9uczogWy4uLnRvcEFuaW1hdGlvbnNdLFxuICAgICAgICAgICAgYm90dG9tQW5pbWF0aW9uczogWy4uLmJvdHRvbUFuaW1hdGlvbnNdLFxuICAgICAgICAgICAgc3Bhd25UaW1lb3V0OiAxLFxuICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSB7XG4gICAgICAgICAgICBpc01vdmluZ0ZvcndhcmQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNNb3ZpbmdSaWdodDogZmFsc2UsXG4gICAgICAgICAgICBpc01vdmluZ0xlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNNb3ZpbmdCYWNrd2FyZDogZmFsc2UsXG4gICAgICAgICAgICBpc1JvdGF0ZUxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNSb3RhdGVSaWdodDogZmFsc2UsXG4gICAgICAgICAgICBpc0F0dGFjazogZmFsc2UsXG4gICAgICAgICAgICBpc0p1bXA6IGZhbHNlLFxuICAgICAgICAgICAgaXNEaWU6IGZhbHNlLFxuICAgICAgICAgICAgaXNIaXQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNTcGF3bjogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBsYXlpbmdBbmltYXRpb25zID0ge307XG4gICAgICAgIHRoaXMubGVnc1JvdGF0aW9uWSA9IDA7XG4gICAgICAgIHRoaXMuc3Bhd25UaW1lID0gMDtcblxuICAgICAgICB0aGlzLm1peGVyID0gbmV3IFRIUkVFLkFuaW1hdGlvbk1peGVyKHRoaXMucGFyYW1zLm9iamVjdCk7XG5cbiAgICAgICAgdGhpcy5pbml0QW5pbWF0aW9ucyh0aGlzLnBhcmFtcy5hbmltYXRpb25OYW1lcyk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICBzdXBlci51cGRhdGUodGltZSwgZGVsdGFUaW1lKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdGhpcy5zcGF3blRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3Bhd25UaW1lID0gdGltZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFuaW1hdGlvblN0YXRlLmlzU3Bhd24gJiYgdGhpcy5pc1NwYXduRmluaXNoZWQodGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNTcGF3biA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWl4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMubWl4ZXIudXBkYXRlKGRlbHRhVGltZSAvIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmNvbXBsZXhBbmltYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbXBsZXhBbmltYXRpb25zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLmdldEN1cnJlbnRBbmltYXRpb24oKTtcbiAgICAgICAgICAgIGFuaW1hdGlvbiAmJiB0aGlzLnBsYXlBbmltYXRpb24oYW5pbWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBsYXlBbmltYXRpb24oYW5pbWF0aW9uLCB7IGZvcmNlIH0gPSB7fSkge1xuICAgICAgICBpZiAoIWFuaW1hdGlvbiB8fCAhYW5pbWF0aW9uLl9jbGlwKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgYW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbi5fY2xpcC5uYW1lO1xuICAgICAgICBjb25zdCBzaG91bGRVcGRhdGUgPSB0aGlzLnBsYXlpbmdBbmltYXRpb25OYW1lICE9PSBhbmltYXRpb25OYW1lIHx8IGZvcmNlO1xuXG4gICAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMucGxheWluZ0FuaW1hdGlvbk5hbWUgPSBhbmltYXRpb25OYW1lO1xuICAgICAgICAgICAgYW5pbWF0aW9uLnJlc2V0KCk7XG4gICAgICAgICAgICBhbmltYXRpb24ucGxheSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wbGF5aW5nQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLnBsYXlpbmdBbmltYXRpb247XG5cbiAgICAgICAgICAgICAgICBmcm9tLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGZyb20uY3Jvc3NGYWRlVG8oYW5pbWF0aW9uLCAwLjMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBsYXlpbmdBbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0QW5pbWF0aW9ucyhhbmltYXRpb25OYW1lcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0b3BBbmltYXRpb25zLFxuICAgICAgICAgICAgYm90dG9tQW5pbWF0aW9ucyxcbiAgICAgICAgICAgIHRvcEJvbmVzLFxuICAgICAgICAgICAgYm90dG9tQm9uZXMsXG4gICAgICAgICAgICBjb21wbGV4QW5pbWF0aW9ucyxcbiAgICAgICAgfSA9IHRoaXMucGFyYW1zO1xuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IE9iamVjdC5rZXlzKGFuaW1hdGlvbk5hbWVzKS5yZWR1Y2UoXG4gICAgICAgICAgICAocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZXhjbHVkZWRCb25lcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXhBbmltYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BBbmltYXRpb25zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVkQm9uZXMgPSBib3R0b21Cb25lcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChib3R0b21BbmltYXRpb25zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVkQm9uZXMgPSB0b3BCb25lcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsQW5pbWF0aW9uID0gdGhpcy5maW5kTW9kZWxBbmltYXRpb24oYW5pbWF0aW9uTmFtZXNba2V5XSwgeyBleGNsdWRlZEJvbmVzIH0pO1xuICAgICAgICAgICAgICAgIGxldCBpbml0ZWRBbmltYXRpb24gPSB0aGlzLmNyZWF0ZUNsaXBBY3Rpb24obW9kZWxBbmltYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0LCBba2V5XTogaW5pdGVkQW5pbWF0aW9uIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge31cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAganVtcCxcbiAgICAgICAgICAgICAgICBhdHRhY2ssXG4gICAgICAgICAgICAgICAgdG9wQXR0YWNrLFxuICAgICAgICAgICAgICAgIGRpZSxcbiAgICAgICAgICAgICAgICBzcGF3bixcbiAgICAgICAgICAgICAgICB0b3BEaWUsXG4gICAgICAgICAgICAgICAgYm90dG9tRGllLFxuICAgICAgICAgICAgICAgIHRvcEp1bXAsXG4gICAgICAgICAgICAgICAgYm90dG9tSnVtcCxcbiAgICAgICAgICAgICAgICBib3R0b21BdHRhY2tcbiAgICAgICAgICAgIH0gPSB7fVxuICAgICAgICB9ID0gdGhpcztcblxuICAgICAgICBbanVtcCwgZGllLCBzcGF3biwgdG9wRGllLCBib3R0b21EaWUsIHRvcEp1bXAsIGJvdHRvbUp1bXBdLmZvckVhY2goKGNsYW1wQW5pbWF0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2xhbXBBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjbGFtcEFuaW1hdGlvbi5zZXRMb29wKFRIUkVFLkxvb3BPbmNlLCAwKTtcbiAgICAgICAgICAgICAgICBjbGFtcEFuaW1hdGlvbi5jbGFtcFdoZW5GaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFthdHRhY2ssIHRvcEF0dGFjaywgYm90dG9tQXR0YWNrXS5mb3JFYWNoKChhdHRhY2tBbmltYXRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRhY2tBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBhdHRhY2tBbmltYXRpb24uc2V0RHVyYXRpb24odGhpcy5wYXJhbXMuYXR0YWNrVGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNyZWF0ZUNsaXBBY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24gJiYgdGhpcy5taXhlci5jbGlwQWN0aW9uKGFjdGlvbikuc3RvcCgpO1xuICAgIH1cblxuICAgIGZpbmRNb2RlbEFuaW1hdGlvbihuYW1lLCB7IGV4Y2x1ZGVkQm9uZXMgPSBbXSB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb25zID0gW10gfSA9IHRoaXMucGFyYW1zO1xuXG4gICAgICAgIGxldCBhbmltYXRpb24gPSBhbmltYXRpb25zLmZpbmQoYW5pbWF0aW9uID0+IGFuaW1hdGlvbi5uYW1lID09PSBuYW1lKTtcblxuICAgICAgICBpZiAoYW5pbWF0aW9uICYmIGV4Y2x1ZGVkQm9uZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGVhckFuaW1hdGlvbkJvbmVzKGFuaW1hdGlvbiwgZXhjbHVkZWRCb25lcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgIH1cblxuICAgIGlzTW92aW5nKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ0xlZnRcbiAgICAgICAgICAgIHx8IHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNNb3ZpbmdSaWdodFxuICAgICAgICAgICAgfHwgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ0ZvcndhcmRcbiAgICAgICAgICAgIHx8IHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNNb3ZpbmdCYWNrd2FyZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlzU3Bhd25GaW5pc2hlZCh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aW1lIC0gdGhpcy5zcGF3blRpbWUgPiB0aGlzLnBhcmFtcy5zcGF3blRpbWVvdXQgKiAxMDAwO1xuICAgIH1cblxuICAgIGNsZWFyQW5pbWF0aW9uQm9uZXMoYW5pbWF0aW9uLCBib25lcykge1xuICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBnZXRCb25lTmFtZSA9IGl0ZW0gPT4gaXRlbS5uYW1lLnNwbGl0KCcuJylbMF0sXG4gICAgICAgICAgICAgICAgaXNOb3RFeGNsdWRlZCA9IGl0ZW0gPT4gIWJvbmVzLmluY2x1ZGVzKGdldEJvbmVOYW1lKGl0ZW0pKTtcblxuICAgICAgICAgICAgYW5pbWF0aW9uLnRyYWNrcyA9IGFuaW1hdGlvbi50cmFja3MuZmlsdGVyKGlzTm90RXhjbHVkZWQpO1xuXG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlQ29tcGxleEFuaW1hdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0b3BBdHRhY2ssIGJvdHRvbUF0dGFjayxcbiAgICAgICAgICAgICAgICB0b3BXYWxrQmFjaywgYm90dG9tV2Fsa0JhY2ssXG4gICAgICAgICAgICAgICAgdG9wUnVuLCBib3R0b21SdW4sXG4gICAgICAgICAgICAgICAgdG9wUnVuUmlnaHQsXG4gICAgICAgICAgICAgICAgdG9wUnVuTGVmdCxcbiAgICAgICAgICAgICAgICB0b3BTdGFuZCwgYm90dG9tU3RhbmQsXG4gICAgICAgICAgICAgICAgdG9wSnVtcCwgYm90dG9tSnVtcCxcbiAgICAgICAgICAgICAgICB0b3BIaXQsIGJvdHRvbUhpdCxcbiAgICAgICAgICAgICAgICB0b3BEaWUsIGJvdHRvbURpZSxcbiAgICAgICAgICAgICAgICB0b3BTcGF3biwgYm90dG9tU3Bhd24sXG4gICAgICAgICAgICB9ID0ge31cbiAgICAgICAgfSA9IHRoaXM7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaXNBdHRhY2ssXG4gICAgICAgICAgICBpc01vdmluZ1JpZ2h0LFxuICAgICAgICAgICAgaXNNb3ZpbmdMZWZ0LFxuICAgICAgICAgICAgaXNNb3ZpbmdCYWNrd2FyZCxcbiAgICAgICAgICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICAgICAgICAgIGlzSnVtcCxcbiAgICAgICAgICAgIGlzRGllLFxuICAgICAgICAgICAgaXNIaXQsXG4gICAgICAgICAgICBpc1NwYXduLFxuICAgICAgICB9ID0gdGhpcy5hbmltYXRpb25TdGF0ZTtcblxuICAgICAgICBjb25zdCBwbGF5aW5nQW5pbWF0aW9ucyA9IHtcbiAgICAgICAgICAgIHRvcDogKFxuICAgICAgICAgICAgICAgIChpc0RpZSAmJiB0b3BEaWUpXG4gICAgICAgICAgICAgICAgfHwgKGlzSGl0ICYmIHRvcEhpdClcbiAgICAgICAgICAgICAgICB8fCAoaXNBdHRhY2sgJiYgdG9wQXR0YWNrKVxuICAgICAgICAgICAgICAgIHx8IChpc0p1bXAgJiYgdG9wSnVtcClcbiAgICAgICAgICAgICAgICB8fCAoaXNNb3ZpbmdCYWNrd2FyZCAmJiBpc01vdmluZ1JpZ2h0ICYmIHRvcFJ1bkxlZnQpXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nQmFja3dhcmQgJiYgaXNNb3ZpbmdMZWZ0ICYmIHRvcFJ1blJpZ2h0KVxuICAgICAgICAgICAgICAgIHx8IChpc01vdmluZ0JhY2t3YXJkICYmIHRvcFdhbGtCYWNrKVxuICAgICAgICAgICAgICAgIHx8IChpc01vdmluZ1JpZ2h0ICYmIHRvcFJ1blJpZ2h0KVxuICAgICAgICAgICAgICAgIHx8IChpc01vdmluZ0xlZnQgJiYgdG9wUnVuTGVmdClcbiAgICAgICAgICAgICAgICB8fCAoaXNNb3ZpbmdGb3J3YXJkICYmIHRvcFJ1bilcbiAgICAgICAgICAgICAgICB8fCAoaXNTcGF3biAmJiB0b3BTcGF3bilcbiAgICAgICAgICAgICAgICB8fCAodG9wU3RhbmQpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYm90dG9tOiAoXG4gICAgICAgICAgICAgICAgKGlzRGllICYmIGJvdHRvbURpZSlcbiAgICAgICAgICAgICAgICB8fCAoaXNKdW1wICYmIGJvdHRvbUp1bXApXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nQmFja3dhcmQgJiYgaXNNb3ZpbmdSaWdodCAmJiBib3R0b21XYWxrQmFjaylcbiAgICAgICAgICAgICAgICB8fCAoaXNNb3ZpbmdCYWNrd2FyZCAmJiBpc01vdmluZ0xlZnQgJiYgYm90dG9tV2Fsa0JhY2spXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nQmFja3dhcmQgJiYgYm90dG9tV2Fsa0JhY2spXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nUmlnaHQgJiYgYm90dG9tUnVuKVxuICAgICAgICAgICAgICAgIHx8IChpc01vdmluZ0xlZnQgJiYgYm90dG9tUnVuKVxuICAgICAgICAgICAgICAgIHx8IChpc01vdmluZ0ZvcndhcmQgJiYgYm90dG9tUnVuKVxuICAgICAgICAgICAgICAgIHx8IChpc0F0dGFjayAmJiBib3R0b21BdHRhY2spXG4gICAgICAgICAgICAgICAgfHwgKGlzSGl0ICYmIGJvdHRvbUhpdClcbiAgICAgICAgICAgICAgICB8fCAoaXNTcGF3biAmJiBib3R0b21TcGF3bilcbiAgICAgICAgICAgICAgICB8fCAoYm90dG9tU3RhbmQpXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGxlZ3NSb3RhdGlvbkJvbmUgPSB0aGlzLmdldENoaWxkQnlOYW1lKCdMZWdzX1JvdGF0aW9uJyk7XG4gICAgICAgIGlmIChsZWdzUm90YXRpb25Cb25lKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJvdGF0aW9uIH0gPSBsZWdzUm90YXRpb25Cb25lO1xuICAgICAgICAgICAgbGV0IHkgPSAtMC4zO1xuXG4gICAgICAgICAgICBpZiAoaXNNb3ZpbmdMZWZ0KSB7XG4gICAgICAgICAgICAgICAgeSA9IGlzTW92aW5nRm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICA/IDAuNVxuICAgICAgICAgICAgICAgICAgICA6IGlzTW92aW5nQmFja3dhcmQgPyAtMC43IDogMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb3ZpbmdSaWdodCkge1xuICAgICAgICAgICAgICAgIHkgPSBpc01vdmluZ0ZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgPyAtMS4yXG4gICAgICAgICAgICAgICAgICAgIDogaXNNb3ZpbmdCYWNrd2FyZCA/IDAuNCA6IC0xLjc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubGVnc1JvdGF0aW9uWSA9IHRoaXMubGVnc1JvdGF0aW9uWSAtICh0aGlzLmxlZ3NSb3RhdGlvblkgLSB5KSAvIDEwO1xuICAgICAgICAgICAgcm90YXRpb24uc2V0KHJvdGF0aW9uLngsIHRoaXMubGVnc1JvdGF0aW9uWSwgcm90YXRpb24ueik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJsZW5kQW5pbWF0aW9ucyhwbGF5aW5nQW5pbWF0aW9ucyk7XG4gICAgfVxuXG4gICAgYmxlbmRBbmltYXRpb25zKHsgdG9wLCBib3R0b20gfSkge1xuICAgICAgICBpZiAoISh0b3AgJiYgYm90dG9tICYmIHRvcC5fY2xpcCAmJiBib3R0b20uX2NsaXApKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgZ2V0QW5pbWF0aW9uTmFtZSA9IGEgPT4gYS5fY2xpcC5uYW1lLFxuICAgICAgICAgICAgcGxheUFuaW1hdGlvbiA9IChmcm9tQW5pbWF0aW9uLCBhbmltYXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25OYW1lID0gZ2V0QW5pbWF0aW9uTmFtZShhbmltYXRpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb21BbmltYXRpb25OYW1lID0gZnJvbUFuaW1hdGlvbiAmJiBnZXRBbmltYXRpb25OYW1lKGZyb21BbmltYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZyb21BbmltYXRpb25OYW1lICE9PSBhbmltYXRpb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24ucGxheSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tQW5pbWF0aW9uLmNyb3NzRmFkZVRvKGFuaW1hdGlvbiwgMC4zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcGxheUFuaW1hdGlvbih0aGlzLnBsYXlpbmdBbmltYXRpb25zLnRvcCwgdG9wKTtcbiAgICAgICAgcGxheUFuaW1hdGlvbih0aGlzLnBsYXlpbmdBbmltYXRpb25zLmJvdHRvbSwgYm90dG9tKTtcblxuICAgICAgICB0aGlzLnBsYXlpbmdBbmltYXRpb25zLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5wbGF5aW5nQW5pbWF0aW9ucy5ib3R0b20gPSBib3R0b207XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVudEFuaW1hdGlvbigpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgIHN0YW5kLFxuICAgICAgICAgICAgICAgIGF0dGFjayxcbiAgICAgICAgICAgICAgICB3YWxrQmFjayxcbiAgICAgICAgICAgICAgICBydW5MZWZ0LFxuICAgICAgICAgICAgICAgIHJ1blJpZ2h0LFxuICAgICAgICAgICAgICAgIHJ1bixcbiAgICAgICAgICAgICAgICBqdW1wLFxuICAgICAgICAgICAgICAgIGhpdCxcbiAgICAgICAgICAgICAgICByb3RhdGVMZWZ0LFxuICAgICAgICAgICAgICAgIHJvdGF0ZVJpZ2h0LFxuICAgICAgICAgICAgICAgIGRpZSxcbiAgICAgICAgICAgICAgICBzcGF3bixcbiAgICAgICAgICAgIH0gPSB7fVxuICAgICAgICB9ID0gdGhpcztcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpc0F0dGFjayxcbiAgICAgICAgICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICAgICAgICAgIGlzSnVtcCxcbiAgICAgICAgICAgIGlzTW92aW5nTGVmdCxcbiAgICAgICAgICAgIGlzTW92aW5nUmlnaHQsXG4gICAgICAgICAgICBpc01vdmluZ0JhY2t3YXJkLFxuICAgICAgICAgICAgaXNSb3RhdGVMZWZ0LFxuICAgICAgICAgICAgaXNSb3RhdGVSaWdodCxcbiAgICAgICAgICAgIGlzRGllLFxuICAgICAgICAgICAgaXNIaXQsXG4gICAgICAgICAgICBpc1NwYXduLFxuICAgICAgICB9ID0gdGhpcy5hbmltYXRpb25TdGF0ZTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGlzRGllICYmIGRpZSlcbiAgICAgICAgICAgIHx8IChpc0hpdCAmJiBoaXQpXG4gICAgICAgICAgICB8fCAoaXNBdHRhY2sgJiYgYXR0YWNrKVxuICAgICAgICAgICAgfHwgKGlzSnVtcCAmJiBqdW1wKVxuICAgICAgICAgICAgfHwgKGlzTW92aW5nQmFja3dhcmQgJiYgd2Fsa0JhY2spXG4gICAgICAgICAgICB8fCAoaXNNb3ZpbmdMZWZ0ICYmIHJ1bkxlZnQpXG4gICAgICAgICAgICB8fCAoaXNNb3ZpbmdSaWdodCAmJiBydW5SaWdodClcbiAgICAgICAgICAgIHx8IChpc01vdmluZ0ZvcndhcmQgJiYgcnVuKVxuICAgICAgICAgICAgfHwgKGlzUm90YXRlTGVmdCAmJiByb3RhdGVMZWZ0KVxuICAgICAgICAgICAgfHwgKGlzUm90YXRlUmlnaHQgJiYgcm90YXRlUmlnaHQpXG4gICAgICAgICAgICB8fCAoaXNTcGF3biAmJiBzcGF3bilcbiAgICAgICAgICAgIHx8IHN0YW5kXG4gICAgICAgICk7XG4gICAgfVxufSIsImltcG9ydCBVbml0IGZyb20gJy4vVW5pdCc7XG5pbXBvcnQgTW92aW5nR2FtZU9iamVjdCBmcm9tICcuL01vdmluZ0dhbWVPYmplY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXJlIGV4dGVuZHMgTW92aW5nR2FtZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcblxuICAgICAgICB0aGlzLnBhcmFtcy5hY2NlbGVyYXRpb24uYWRkKFxuICAgICAgICAgICAgdGhpcy5nZXRGb3J3YXJkKCkubXVsdGlwbHlTY2FsYXIodGhpcy5wYXJhbXMuc3BlZWQgKiAwLjEpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICBzdXBlci51cGRhdGUodGltZSwgZGVsdGFUaW1lKTtcblxuICAgICAgICBpZiAodGhpcy5wYXJhbXMuZ2V0Q29sbGlzaW9ucykge1xuICAgICAgICAgICAgY29uc3QgY29sbGlzaW9ucyA9IHRoaXMucGFyYW1zLmdldENvbGxpc2lvbnModGhpcyk7XG5cbiAgICAgICAgICAgIGNvbGxpc2lvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChjb2xsaXNpb25HYW1lT2JqZWN0KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbkdhbWVPYmplY3QgaW5zdGFuY2VvZiBVbml0XG4gICAgICAgICAgICAgICAgICAgICYmIGNvbGxpc2lvbkdhbWVPYmplY3QuaXNFbmVteSh0aGlzLnBhcmFtcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChjb2xsaXNpb25HYW1lT2JqZWN0ID0+IChcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uR2FtZU9iamVjdC5kYW1hZ2VUYWtlbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYW1hZ2U6IHRoaXMucGFyYW1zLmRhbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXQ6IHRoaXMucGFyYW1zLnBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZSlcbiAgICAgICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbnMubGVuZ3RoICYmIHRoaXMucGFyYW1zLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcy5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBVbml0IGZyb20gJy4vVW5pdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpcmluZ1VuaXQgZXh0ZW5kcyBVbml0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBmaXJlRGFtYWdlOiAxMCxcbiAgICAgICAgICAgIGZpcmVUaW1lb3V0OiAxLjUsXG4gICAgICAgICAgICBmaXJlU2hlbGxTcGVlZDogMyxcbiAgICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNob3VsZEZpcmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXRlc3RGaXJlID0gMDtcbiAgICB9XG5cbiAgICBnZXRGaXJlSW5pdGlhbFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5jbG9uZSgpLmFkZChcbiAgICAgICAgICAgIHRoaXMuZ2V0VXAoKVxuICAgICAgICAgICAgICAgIC5tdWx0aXBseVNjYWxhcigxLjUpXG4gICAgICAgICAgICAgICAgLmFkZCh0aGlzLmdldEZvcndhcmQoKS5tdWx0aXBseVNjYWxhcigwLjMpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKHRpbWUsIGRlbHRhVGltZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNEZWFkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNGaXJlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkRmlyZSAmJiB0aGlzLnBhcmFtcy5maXJlICYmIHRoaXMuaXNGaXJlUmVsZWFzZWQodGltZSkgJiYgdGhpcy5pc0F0dGFja1JlbGVhc2VkKHRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmlzRmlyZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNob3VsZEZpcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0RmlyZSA9IHRpbWU7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5maXJlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3VsZEZpcmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRmlyZVJlbGVhc2VkKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRpbWUgLSB0aGlzLmxhdGVzdEZpcmUgPj0gdGhpcy5wYXJhbXMuZmlyZVRpbWVvdXQgKiAxMDAwO1xuICAgIH1cblxuICAgIGZpcmUoKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkRmlyZSA9IHRydWU7XG4gICAgfVxufSIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi4vQXV0b0JpbmRNZXRob2RzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZU9iamVjdCBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSB7IC4uLnBhcmFtcyB9O1xuICAgICAgICB0aGlzLm9iamVjdCA9IHBhcmFtcy5vYmplY3Q7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5vYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBwYXJhbXMub2JqZWN0LnBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHBhcmFtcy5vYmplY3Qucm90YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gYXJnc1xuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnROYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soLi4uYXJncykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IFtjYWxsYmFja107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDaGlsZEJ5TmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iamVjdC5nZXRPYmplY3RCeU5hbWUobmFtZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZ2V0Q2hpbGREaXJlY3Rpb24oYXJnLCB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHRoaXMuZ2V0Q2hpbGRCeU5hbWUoYXJnKVxuICAgICAgICAgICAgOiBhcmc7XG5cbiAgICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseVF1YXRlcm5pb24odGhpcy5nZXRDaGlsZFJvdGF0aW9uKGNoaWxkKSk7XG4gICAgfVxuXG4gICAgZ2V0Q2hpbGRQb3NpdGlvbihhcmcpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0eXBlb2YgYXJnID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB0aGlzLmdldENoaWxkQnlOYW1lKGFyZylcbiAgICAgICAgICAgIDogYXJnO1xuXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMygpLnNldEZyb21NYXRyaXhQb3NpdGlvbihjaGlsZC5tYXRyaXhXb3JsZCk7XG4gICAgfVxuXG4gICAgZ2V0Q2hpbGRSb3RhdGlvbihhcmcpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0eXBlb2YgYXJnID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB0aGlzLmdldENoaWxkQnlOYW1lKGFyZylcbiAgICAgICAgICAgIDogYXJnO1xuXG4gICAgICAgIGxldCB0YXJnZXQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAgICAgICBjaGlsZC5nZXRXb3JsZFF1YXRlcm5pb24odGFyZ2V0KTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbn0iLCJpbXBvcnQgQW5pbWF0ZWRHYW1lT2JqZWN0IGZyb20gJy4vQW5pbWF0ZWRHYW1lT2JqZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW92aW5nR2FtZU9iamVjdCBleHRlbmRzIEFuaW1hdGVkR2FtZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgc3BlZWQ6IDAuMSxcbiAgICAgICAgICAgIHRocm90dGxpbmc6IG5ldyBUSFJFRS5WZWN0b3IzKDAuNSwgMC45NSwgMC41KSxcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgICAgIG1hczogMCxcbiAgICAgICAgICAgIGNoZWNrV2F5OiAoKSA9PiB0cnVlLFxuICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKHRpbWUsIGRlbHRhVGltZSk7XG4gICAgICAgIGNvbnN0IHsgcGFyYW1zOiB7IGFjY2VsZXJhdGlvbiwgdGhyb3R0bGluZyB9IH0gPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5tYXMpIHtcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvbi55IC09IDAuMDE7XG5cbiAgICAgICAgICAgIHRoaXMuaXNHcm91bmRlZCA9ICF0aGlzLmNoZWNrV2F5KDAsIC0wLjIsIDApO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc0p1bXAgPSAhdGhpcy5pc0dyb3VuZGVkO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBpc1ggPSBCb29sZWFuKGFjY2VsZXJhdGlvbi54KSAmJiB0aGlzLmNoZWNrV2F5KGFjY2VsZXJhdGlvbi54LCAwLCAwKTtcbiAgICAgICAgY29uc3QgaXNZID0gQm9vbGVhbihhY2NlbGVyYXRpb24ueSkgJiYgdGhpcy5jaGVja1dheSgwLCBhY2NlbGVyYXRpb24ueSwgMCk7XG4gICAgICAgIGNvbnN0IGlzWiA9IEJvb2xlYW4oYWNjZWxlcmF0aW9uLnopICYmIHRoaXMuY2hlY2tXYXkoMCwgMCwgYWNjZWxlcmF0aW9uLnopO1xuXG4gICAgICAgIGlmICghaXNYIHx8ICFpc1kgfHwgIWlzWikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmFtcy5tYXMpIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9wIG9iamVjdCBzbW9vdGhseSBiZWNhdXNlIG9mIENvbGxpZGVyIGhpdFxuICAgICAgICAgICAgICAgIGFjY2VsZXJhdGlvbi5tdWx0aXBseVNjYWxhcigwLjc1KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc1gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0NsaW1iaW5nID0gKGFjY2VsZXJhdGlvbi54ICYmIGFjY2VsZXJhdGlvbi55IDw9IDAgJiYgdGhpcy5jaGVja1dheShhY2NlbGVyYXRpb24ueCwgMC4wNCwgMCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2xpbWJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZWxlcmF0aW9uLnkgPSAwLjA0IC8gdGhyb3R0bGluZy55O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VsZXJhdGlvbi54ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNZKSB7IGFjY2VsZXJhdGlvbi55ID0gMDsgfVxuXG4gICAgICAgICAgICBpZiAoIWlzWikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2xpbWJpbmcgPSAoYWNjZWxlcmF0aW9uLnogJiYgYWNjZWxlcmF0aW9uLnkgPD0gMCAmJiB0aGlzLmNoZWNrV2F5KDAsIDAuMDQsIGFjY2VsZXJhdGlvbi56KSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNDbGltYmluZykge1xuICAgICAgICAgICAgICAgICAgICBhY2NlbGVyYXRpb24ueSA9IDAuMDQgLyB0aHJvdHRsaW5nLnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZWxlcmF0aW9uLnogPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFjY2VsZXJhdGlvbi54ICo9IHRocm90dGxpbmcueDtcbiAgICAgICAgYWNjZWxlcmF0aW9uLnkgKj0gdGhyb3R0bGluZy55O1xuICAgICAgICBhY2NlbGVyYXRpb24ueiAqPSB0aHJvdHRsaW5nLno7XG5cbiAgICAgICAgY29uc3QgaXNNb3ZpbmcgPSAoXG4gICAgICAgICAgICBNYXRoLmFicyhhY2NlbGVyYXRpb24ueCkgPiAwLjAwMVxuICAgICAgICAgICAgfHwgTWF0aC5hYnMoYWNjZWxlcmF0aW9uLnkpID4gMC4wMDFcbiAgICAgICAgICAgIHx8IE1hdGguYWJzKGFjY2VsZXJhdGlvbi56KSA+IDAuMDAxXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzTW92aW5nKSB7XG4gICAgICAgICAgICAvLyBhY2NlbGVyYXRpb24ubXVsdGlwbHlTY2FsYXIoZGVsdGFUaW1lICogNjApXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZChhY2NlbGVyYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2tXYXkoeCA9IDAsIHkgPSAwLCB6ID0gMCkge1xuICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCBwYXJhbXM6IHsgY2hlY2tXYXkgfSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMocG9zaXRpb24ueCArIHgsIHBvc2l0aW9uLnkgKyB5ICsgMC4xLCBwb3NpdGlvbi56ICsgeik7XG5cbiAgICAgICAgcmV0dXJuIGNoZWNrV2F5KG5leHRQb3NpdGlvbiwgdGhpcyk7XG4gICAgfVxuXG4gICAgZ2V0TGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlyZWN0aW9uKG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApKTtcbiAgICB9XG5cbiAgICBnZXRVcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlyZWN0aW9uKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApKTtcbiAgICB9XG5cbiAgICBnZXRGb3J3YXJkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREaXJlY3Rpb24obmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gZGlyZWN0aW9uXG4gICAgICovXG4gICAgZ2V0RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgICBkaXJlY3Rpb24uYXBwbHlRdWF0ZXJuaW9uKHRoaXMub2JqZWN0LnF1YXRlcm5pb24pO1xuICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGdldFNjYWxhckFjY2VsZXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmFjY2VsZXJhdGlvbi50b0FycmF5KClcbiAgICAgICAgICAgIC5tYXAoTWF0aC5hYnMpXG4gICAgICAgICAgICAucmVkdWNlKChyLCB2KSA9PiByICsgdiwgMClcbiAgICB9XG59IiwiaW1wb3J0IEZpcmluZ1VuaXQgZnJvbSAnLi9GaXJpbmdVbml0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheWVyIGV4dGVuZHMgRmlyaW5nVW5pdCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgc3BlZWQ6IDAuNTQsXG4gICAgICAgICAgICBmaXJlVGltZW91dDogMSxcbiAgICAgICAgICAgIGZpcmVEYW1hZ2U6IDI1LFxuICAgICAgICAgICAgZGFtYWdlOiA1MCxcbiAgICAgICAgICAgIGhwOiAxMDAsXG4gICAgICAgICAgICBleHBlcmllbmNlOiAwLFxuICAgICAgICAgICAgdW5zcGVudFRhbGVudHM6IDAsXG4gICAgICAgICAgICBtb25leTogNTAwLFxuICAgICAgICAgICAgaXNGaXJlOiBmYWxzZSxcbiAgICAgICAgICAgIG1hczogMSxcbiAgICAgICAgICAgIGxldmVsOiAxLFxuICAgICAgICAgICAganVtcFRpbWVvdXQ6IDAuOSxcbiAgICAgICAgICAgIGZyYWN0aW9uOiAnZnJpZW5kbHknLFxuICAgICAgICAgICAgc2Vuc2l0aXZpdHk6IDEsXG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubGFzdEp1bXBUaW1lc3RhbXAgPSAwO1xuICAgICAgICB0aGlzLnJvdGF0aW9uQWNjZWxlcmF0aW9uID0gMDtcblxuICAgICAgICBjb25zb2xlLmxvZygnUGxheWVyJywgdGhpcyk7XG5cbiAgICAgICAgcGFyYW1zLm9uTGV2ZWxVcCAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ29uTGV2ZWxVcCcsIHBhcmFtcy5vbkxldmVsVXApO1xuICAgIH1cblxuICAgIHVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKHRpbWUsIGRlbHRhVGltZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNEZWFkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgaW5wdXQsIG9iamVjdCwgYWNjZWxlcmF0aW9uLCBmcm9tTmV0d29yayB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgICAgYWNjZWxlcmF0aW9uLmFkZCh0aGlzLmdldE1vdmluZ0FjY2VsZXJhdGlvbih0aW1lLCBkZWx0YVRpbWUpKTtcblxuICAgICAgICBpZiAoaW5wdXQuYXR0YWNrMSkge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dC5hdHRhY2syKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNNb3ZpbmdMZWZ0ID0gaW5wdXQuaG9yaXpvbnRhbCA9PT0gLTE7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNNb3ZpbmdSaWdodCA9IGlucHV0Lmhvcml6b250YWwgPT09IDE7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNNb3ZpbmdGb3J3YXJkID0gaW5wdXQudmVydGljYWwgPT09IDE7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNNb3ZpbmdCYWNrd2FyZCA9IGlucHV0LnZlcnRpY2FsID09PSAtMTtcblxuICAgICAgICBpZiAoIWZyb21OZXR3b3JrKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuaXNUaGlyZFBlcnNvbikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5sb29rLmhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9yaXpvbnRhbExvb2sgPSBpbnB1dC5sb29rLmhvcml6b250YWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNSb3RhdGVMZWZ0ID0gaG9yaXpvbnRhbExvb2sgPCAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLmlzUm90YXRlUmlnaHQgPSBob3Jpem9udGFsTG9vayA+IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb25BY2NlbGVyYXRpb24gKz0gKC1ob3Jpem9udGFsTG9vayAvIDUwMDApICogaW5wdXQubG9vay5zZW5zaXRpdml0eTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQucmVzZXRIb3Jpem9udGFsTG9vaygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IENBTENfUk9UQVRFX1RIUkVTSE9MRCA9IDAuMDAwMDAwMTtcblxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnJvdGF0aW9uQWNjZWxlcmF0aW9uKSA+IENBTENfUk9UQVRFX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Qucm90YXRlT25Xb3JsZEF4aXMobmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCksIHRoaXMucm90YXRpb25BY2NlbGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdGF0aW9uQWNjZWxlcmF0aW9uICo9IDAuNztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMiAtIGlucHV0LmN1cnNvci54O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhWSA9IGlucHV0LmN1cnNvci55IC0gd2luZG93LmlubmVySGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBjb25zdCByb3RhdGlvblkgPSBNYXRoLmF0YW4yKGRlbHRhWSwgZGVsdGFYKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNSb3RhdGVMZWZ0ID0gcm90YXRpb25ZID4gb2JqZWN0LnJvdGF0aW9uLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc1JvdGF0ZVJpZ2h0ID0gcm90YXRpb25ZIDwgb2JqZWN0LnJvdGF0aW9uLnk7XG5cbiAgICAgICAgICAgICAgICBvYmplY3Qucm90YXRpb24uc2V0KDAsIHJvdGF0aW9uWSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRVbnNwZW50VGFsZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLnVuc3BlbnRUYWxlbnRzO1xuICAgIH1cblxuICAgIGRlY3JlYXNlVW5zcGVudFRhbGVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy51bnNwZW50VGFsZW50cy0tO1xuICAgIH1cblxuICAgIGdldEZpcmVJbml0aWFsUG9zaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLmdldENoaWxkQnlOYW1lKCdIZWFkJyk7XG4gICAgICAgIGNvbnN0IGhlYWRGb3J3YXJkID0gdGhpcy5nZXRDaGlsZERpcmVjdGlvbihoZWFkLCBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKSk7XG4gICAgICAgIGNvbnN0IGhlYWRVcCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApO1xuICAgICAgICBoZWFkVXAuYXBwbHlRdWF0ZXJuaW9uKGhlYWQucXVhdGVybmlvbik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRQb3NpdGlvbihoZWFkKVxuICAgICAgICAgICAgLmFkZChoZWFkVXAubXVsdGlwbHlTY2FsYXIoMC4xNSkpXG4gICAgICAgICAgICAuYWRkKGhlYWRGb3J3YXJkLm11bHRpcGx5U2NhbGFyKDAuMjUpKTtcbiAgICB9XG5cbiAgICBnZXRGaXJlSW5pdGlhbFJvdGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZFJvdGF0aW9uKCdIZWFkJyk7XG4gICAgfVxuXG4gICAgYWRkRXhwZXJpZW5jZShleHBlcmllbmNlKSB7XG4gICAgICAgIHRoaXMucGFyYW1zLmV4cGVyaWVuY2UgKz0gZXhwZXJpZW5jZTtcblxuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMuZ2V0TGV2ZWwoKTtcblxuICAgICAgICBpZiAodGhpcy5wYXJhbXMubGV2ZWwgIT09IGxldmVsKSB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbHNVcCA9IGxldmVsIC0gdGhpcy5wYXJhbXMubGV2ZWw7XG5cbiAgICAgICAgICAgIHRoaXMucGFyYW1zLmxldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy51bnNwZW50VGFsZW50cyArPSAzICogbGV2ZWxzVXA7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5ocCA9IHRoaXMucGFyYW1zLmhwTWF4O1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdvbkxldmVsVXAnLCBsZXZlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRFeHBlcmllbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuZXhwZXJpZW5jZTtcbiAgICB9XG5cbiAgICBnZXRMZXZlbEV4cGVyaWVuY2UoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyh0aGlzLmdldExldmVsKCksIDIpICogMTAwO1xuICAgIH1cblxuICAgIGdldExldmVsKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnNxcnQodGhpcy5wYXJhbXMuZXhwZXJpZW5jZSAvIDEwMCkpICsgMTtcbiAgICB9XG5cbiAgICBnZXRNb3ZpbmdBY2NlbGVyYXRpb24odGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXQ6IHsgaG9yaXpvbnRhbCwgdmVydGljYWwsIGp1bXAgfSB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgICAgY29uc3Qgc3BlZWQgPSB2ZXJ0aWNhbCAmJiBob3Jpem9udGFsXG4gICAgICAgICAgICA/IHRoaXMucGFyYW1zLnNwZWVkICogMC4xICogMC43ICogKGRlbHRhVGltZSAqIDAuMDYpXG4gICAgICAgICAgICA6IHRoaXMucGFyYW1zLnNwZWVkICogMC4xICogKGRlbHRhVGltZSAqIDAuMDYpO1xuXG4gICAgICAgIGNvbnN0IGFkZEZvcndhcmQgPSB2ZXJ0aWNhbCA9PT0gMVxuICAgICAgICAgICAgPyBzcGVlZFxuICAgICAgICAgICAgOiAodmVydGljYWwgPT09IC0xID8gLXNwZWVkICogMC42IDogMCk7XG5cbiAgICAgICAgY29uc3QgYWRkU2lkZSA9IHZlcnRpY2FsID09PSAtMVxuICAgICAgICAgICAgPyAoLWhvcml6b250YWwgKiBzcGVlZCAqIDAuNilcbiAgICAgICAgICAgIDogKC1ob3Jpem9udGFsICogc3BlZWQgKTtcblxuICAgICAgICBjb25zdCBpc0p1bXAgPSAoXG4gICAgICAgICAgICB0aW1lIC0gdGhpcy5sYXN0SnVtcFRpbWVzdGFtcCA+IHRoaXMucGFyYW1zLmp1bXBUaW1lb3V0ICogMTAwMFxuICAgICAgICAgICAgJiYganVtcFxuICAgICAgICAgICAgJiYgdGhpcy5pc0dyb3VuZGVkXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzSnVtcCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0SnVtcFRpbWVzdGFtcCA9IHRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5nZXREaXJlY3Rpb24obmV3IFRIUkVFLlZlY3RvcjMoYWRkU2lkZSwgTnVtYmVyKGlzSnVtcCkgKiAwLjI1LCBhZGRGb3J3YXJkKSk7XG4gICAgfVxufSIsImltcG9ydCBNb3ZpbmdHYW1lT2JqZWN0IGZyb20gJy4vTW92aW5nR2FtZU9iamVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVuaXQgZXh0ZW5kcyBNb3ZpbmdHYW1lT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBocDogMTAwLFxuICAgICAgICAgICAgaHBNYXg6IHBhcmFtcy5ocCB8fCAxMDAsXG4gICAgICAgICAgICBkYW1hZ2U6IDEwLFxuICAgICAgICAgICAgYXR0YWNrVGltZW91dDogMC45LFxuICAgICAgICAgICAgaGl0VGltZTogMC4zLFxuICAgICAgICAgICAgYXR0YWNrRGFtYWdlVGltZW91dDogMC4zLFxuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNob3VsZEF0dGFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhdGVzdEF0dGFja1RpbWVzdGFtcCA9IDA7XG4gICAgICAgIHRoaXMubGF0ZXN0SGl0VGltZXN0YW1wID0gMDtcblxuICAgICAgICBbJ29uRGFtYWdlVGFrZW4nLCAnb25EYW1hZ2VEZWFsJywgJ29uS2lsbCcsICdvbkRpZSddLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHBhcmFtc1tldmVudE5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICBzdXBlci51cGRhdGUodGltZSwgZGVsdGFUaW1lKTtcblxuICAgICAgICBpZiAodGhpcy5pc0RlYWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGl0UmVsZWFzZWQgPSB0aGlzLmlzSGl0UmVsZWFzZWQodGltZSk7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc0hpdCA9ICFoaXRSZWxlYXNlZDtcblxuICAgICAgICBpZiAodGhpcy5pc0F0dGFja1JlbGVhc2VkKHRpbWUpICYmIGhpdFJlbGVhc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLmlzQXR0YWNrID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZEF0dGFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNBdHRhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0QXR0YWNrVGltZXN0YW1wID0gdGltZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcy5hdHRhY2sgJiYgdGhpcy5wYXJhbXMuYXR0YWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3VsZEF0dGFjayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0RnJhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5mcmFjdGlvbjtcbiAgICB9XG5cbiAgICBnZXRDb2xsaWRlcihwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBkaWZmWSA9IHBvc2l0aW9uLnkgLSB0aGlzLnBvc2l0aW9uLnk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICAgICAgICBNYXRoLnBvdyhwb3NpdGlvbi54IC0gdGhpcy5wb3NpdGlvbi54LCAyKVxuICAgICAgICAgICAgICAgICsgTWF0aC5wb3cocG9zaXRpb24ueiAtIHRoaXMucG9zaXRpb24ueiwgMilcbiAgICAgICAgICAgICkgPCAxXG4gICAgICAgICAgICAmJiBkaWZmWSA+PSAwXG4gICAgICAgICAgICAmJiBkaWZmWSA8IDEuN1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlbGVhc2VBdHRhY2sodGltZSkge1xuICAgICAgICB0aGlzLmxhdGVzdEF0dGFja1RpbWVzdGFtcCA9IHRpbWUgLSB0aGlzLnBhcmFtcy5hdHRhY2tUaW1lb3V0ICogMTAwMDtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc0F0dGFjayA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlzQXR0YWNrUmVsZWFzZWQodGltZSkge1xuICAgICAgICByZXR1cm4gKHRpbWUgLSB0aGlzLmxhdGVzdEF0dGFja1RpbWVzdGFtcCA+PSB0aGlzLnBhcmFtcy5hdHRhY2tUaW1lb3V0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgaXNBdHRhY2tJbnRlcnJ1cHRlZCh0aW1lKSB7XG4gICAgICAgIHJldHVybiAodGltZSAtIHRoaXMubGF0ZXN0SGl0VGltZXN0YW1wIDw9IHRoaXMucGFyYW1zLmF0dGFja0RhbWFnZVRpbWVvdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBpc0hpdFJlbGVhc2VkKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aW1lIC0gdGhpcy5sYXRlc3RIaXRUaW1lc3RhbXAgPj0gdGhpcy5wYXJhbXMuaGl0VGltZSAqIDEwMDApO1xuICAgIH1cblxuICAgIGF0dGFjaygpIHtcbiAgICAgICAgdGhpcy5zaG91bGRBdHRhY2sgPSB0cnVlO1xuICAgIH1cblxuICAgIGlzRGVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmhwIDw9IDA7XG4gICAgfVxuXG4gICAgaXNBbGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRGVhZCgpO1xuICAgIH1cbiAgICBcbiAgICBpc0VuZW15KHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHVuaXQucGFyYW1zLmZyYWN0aW9uICE9PSB0aGlzLnBhcmFtcy5mcmFjdGlvblxuICAgICAgICAgICAgJiYgdW5pdC5wYXJhbXMuZnJhY3Rpb24gIT09ICduZXV0cmFsJ1xuICAgICAgICAgICAgJiYgdGhpcy5wYXJhbXMuZnJhY3Rpb24gIT09ICduZXV0cmFsJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldExldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMubGV2ZWw7XG4gICAgfVxuXG4gICAgZ2V0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLm5hbWU7XG4gICAgfVxuXG4gICAgZ2V0QXR0YWNrVGltZW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmF0dGFja0RhbWFnZVRpbWVvdXQgKiAxMDAwO1xuICAgIH1cblxuICAgIGRhbWFnZVRha2VuKHsgZGFtYWdlLCB1bml0OiBhdHRhY2tlciB9ID0ge30sIHRpbWUpIHtcbiAgICAgICAgaWYgKGRhbWFnZSAmJiBhdHRhY2tlcikge1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMuaHAgLT0gZGFtYWdlO1xuXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ29uRGFtYWdlVGFrZW4nLCBhdHRhY2tlcik7XG5cbiAgICAgICAgICAgIGlmIChhdHRhY2tlcikge1xuICAgICAgICAgICAgICAgIGF0dGFja2VyLmRpc3BhdGNoRXZlbnQoJ29uRGFtYWdlRGVhbCcsIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbnRlcnJ1cHRCeUNoYW5jZSA9IE1hdGgucmFuZG9tKCkgPCAwLjMzO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJydXB0QnlMZXZlbCA9IGF0dGFja2VyLmdldExldmVsKCkgLSB0aGlzLmdldExldmVsKCkgPiAyO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkQmVJbnRlcnJ1cHRlZCA9IGludGVycnVwdEJ5TGV2ZWwgfHwgaW50ZXJydXB0QnlDaGFuY2U7XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRCZUludGVycnVwdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RIaXRUaW1lc3RhbXAgPSB0aW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RlYWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGllKGF0dGFja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpZShraWxsaW5nVW5pdCkge1xuICAgICAgICB0aGlzLnBhcmFtcy5ocCA9IDA7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnb25EaWUnLCBraWxsaW5nVW5pdCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNEaWUgPSB0cnVlO1xuXG4gICAgICAgIGlmIChraWxsaW5nVW5pdCkge1xuICAgICAgICAgICAga2lsbGluZ1VuaXQuZGlzcGF0Y2hFdmVudCgnb25LaWxsJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRTcGVlZChzcGVlZCkge1xuICAgICAgICB0aGlzLnBhcmFtcy5zcGVlZCArPSBzcGVlZDtcbiAgICB9XG5cbiAgICBhZGREYW1hZ2UoZGFtYWdlKSB7XG4gICAgICAgIHRoaXMucGFyYW1zLmRhbWFnZSArPSBkYW1hZ2U7XG4gICAgfVxuXG4gICAgYWRkSFAoaHApIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBbGl2ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5ocCA9IE1hdGgubWluKHRoaXMucGFyYW1zLmhwICsgaHAsIHRoaXMucGFyYW1zLmhwTWF4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldE1vbmV5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMubW9uZXk7XG4gICAgfVxuXG4gICAgYWRkTW9uZXkobW9uZXkpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMubW9uZXkgKz0gbW9uZXk7XG4gICAgfVxuXG4gICAgYWRkTWF4SFAoaHApIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBbGl2ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5ocE1heCArPSBocDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLmhwICs9IGhwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0SFAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5ocDtcbiAgICB9XG5cbiAgICBnZXRNYXhIUCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmhwTWF4O1xuICAgIH1cblxuICAgIGdldFNwZWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuc3BlZWQ7XG4gICAgfVxuXG4gICAgZ2V0RGFtYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuZGFtYWdlO1xuICAgIH1cbn0iLCJpbXBvcnQgQXV0b0JpbmRNZXRob2RzIGZyb20gJy4vQXV0b0JpbmRNZXRob2RzJztcblxuY29uc3QgS0VZUyA9IHtcbiAgICBNT1VTRV9MRUZUOiAxLFxuICAgIE1PVVNFX1JJR0hUOiAzLFxuICAgIFNQQUNFOiAzMixcbiAgICBFTlRFUjogMTMsXG4gICAgRVNDOiAyNyxcbiAgICBDOiA2NyxcbiAgICBXOiA4NyxcbiAgICBBOiA2NSxcbiAgICBTOiA4MyxcbiAgICBEOiA2OCxcbiAgICBYOiA4OCxcbiAgICBaOiA5MCxcbiAgICBROiA4MSxcbiAgICBFOiA2OSxcbiAgICBSOiA4MixcbiAgICBGOiA3MCxcbiAgICBWOiA4NixcbiAgICAxOiA0OSxcbiAgICAyOiA1MCxcbiAgICBBUlJPV19MRUZUOiAzNyxcbiAgICBBUlJPV19SSUdIVDogMzksXG4gICAgQVJST1dfVVA6IDM4LFxuICAgIEFSUk9XX0RPV046IDQwLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy52ZXJ0aWNhbCA9IDA7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IDA7XG4gICAgICAgIHRoaXMuYXR0YWNrMSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF0dGFjazIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb29rID0ge1xuICAgICAgICAgICAgdmVydGljYWw6IDAsXG4gICAgICAgICAgICBob3Jpem9udGFsOiAwLFxuICAgICAgICAgICAgYmFjazogZmFsc2UsXG4gICAgICAgICAgICBzZW5zaXRpdml0eTogMSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXNldEhvcml6b250YWxMb29rID0gKCkgPT4gdGhpcy5sb29rLmhvcml6b250YWwgPSAwO1xuICAgICAgICB0aGlzLmlzVGhpcmRQZXJzb24gPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY3Vyc29yID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tb3VzZSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMubG9vay5ob3Jpem9udGFsID0gMDtcbiAgICAgICAgdGhpcy5sb29rLnZlcnRpY2FsID0gMDtcbiAgICB9XG5cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLndoaWNoID09PSBLRVlTLk1PVVNFX0xFRlQpIHsgdGhpcy5hdHRhY2sxID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IEtFWVMuTU9VU0VfUklHSFQpIHsgdGhpcy5hdHRhY2syID0gdHJ1ZTsgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLndoaWNoID09PSBLRVlTLk1PVVNFX0xFRlQpIHsgdGhpcy5hdHRhY2sxID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChlLndoaWNoID09PSBLRVlTLk1PVVNFX1JJR0hUKSB7IHRoaXMuYXR0YWNrMiA9IGZhbHNlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCB0aW1lb3V0O1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb29rLmhvcml6b250YWwgKz0gZS5tb3ZlbWVudFggfHwgMDtcbiAgICAgICAgICAgIHRoaXMubG9vay52ZXJ0aWNhbCArPSBlLm1vdmVtZW50WSB8fCAwO1xuXG4gICAgICAgICAgICB0aGlzLm1vdXNlLnggPSBlLng7XG4gICAgICAgICAgICB0aGlzLm1vdXNlLnkgPSBlLnk7XG5cbiAgICAgICAgICAgIGNvbnN0IGN1cnNvclggPSB0aGlzLmN1cnNvci54ICsgKGUubW92ZW1lbnRYIHx8IDApO1xuICAgICAgICAgICAgY29uc3QgY3Vyc29yWSA9IHRoaXMuY3Vyc29yLnkgKyAoZS5tb3ZlbWVudFkgfHwgMCk7XG5cbiAgICAgICAgICAgIGlmIChjdXJzb3JYID4gMCAmJiBjdXJzb3JYIDwgd2luZG93LmlubmVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci54ID0gY3Vyc29yWDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnNvclkgPiAwICYmIGN1cnNvclkgPCB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci55ID0gY3Vyc29yWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ29ubW91c2Vtb3ZlZW5kJykpO1xuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignb25tb3VzZW1vdmVlbmQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBsb29rIGlzIGNsZWFuaW5nIGJ5IFBsYXllci51cGRhdGUgYWZ0ZXIgcm90YXRpb24gaXMgYXBwbGllZFxuICAgICAgICAgICAgLy8gdGhpcy5sb29rLmhvcml6b250YWwgPSAwO1xuICAgICAgICAgICAgdGhpcy5sb29rLnZlcnRpY2FsID0gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuRU5URVI6IHRoaXMucGFyYW1zLm9uQWN0aW9uICYmIHRoaXMucGFyYW1zLm9uQWN0aW9uKCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5FU0M6IHRoaXMucGFyYW1zLm9uRXhpdCAmJiB0aGlzLnBhcmFtcy5vbkV4aXQoKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkM6IHRoaXMucGFyYW1zLm9uU3dpdGNoQ2FtZXJhICYmIHRoaXMucGFyYW1zLm9uU3dpdGNoQ2FtZXJhKCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5XOiBjYXNlIEtFWVMuQVJST1dfVVA6IHRoaXMudmVydGljYWwgPSAxOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuUzogY2FzZSBLRVlTLkFSUk9XX0RPV046IHRoaXMudmVydGljYWwgPSAtMTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkE6IGNhc2UgS0VZUy5BUlJPV19MRUZUOiB0aGlzLmhvcml6b250YWwgPSAtMTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkQ6IGNhc2UgS0VZUy5BUlJPV19SSUdIVDogdGhpcy5ob3Jpem9udGFsID0gMTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLlg6IHRoaXMubG9vay5iYWNrID0gdHJ1ZTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkY6IHRoaXMubG9vay5jaW5lbWF0aWMgPSB0cnVlOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuU1BBQ0U6IHRoaXMuanVtcCA9IDE7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChlKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuVzpcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuQVJST1dfVVA6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2FsID09PSAxKSB7IHRoaXMudmVydGljYWwgPSAwOyB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5TOlxuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5BUlJPV19ET1dOOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbCA9PT0gLTEpIHsgdGhpcy52ZXJ0aWNhbCA9IDA7IH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkE6XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkFSUk9XX0xFRlQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhvcml6b250YWwgPT09IC0xKSB7IHRoaXMuaG9yaXpvbnRhbCA9IDA7IH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkQ6XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkFSUk9XX1JJR0hUOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ob3Jpem9udGFsID09PSAxKSB7IHRoaXMuaG9yaXpvbnRhbCA9IDA7IH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLlg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9vay5iYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5GOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvb2suY2luZW1hdGljID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5TUEFDRTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5qdW1wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGUgPT4gdGhpcy5wYXJhbXMub25ab29tICYmIHRoaXMucGFyYW1zLm9uWm9vbShlLmRlbHRhWSAvIDEwMCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbiIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRlcnZhbHMgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy50aW1lUGFzc2VkID0gMDtcbiAgICAgICAgdGhpcy5sYXN0RnJhbWUgPSAwO1xuICAgICAgICB0aGlzLmludGVydmFscyA9IFtdO1xuICAgICAgICB0aGlzLmludGVydmFsSW5kZXggPSAwO1xuICAgIH1cblxuICAgIHVwZGF0ZShub3cpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NlbmUudWkgJiYgIXRoaXMuc2NlbmUudWkuaXNQYXVzZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVQYXNzZWQgKz0gbm93IC0gdGhpcy5sYXN0RnJhbWU7XG5cbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihpID0+IHRoaXMudGltZVBhc3NlZCAtIGkuY2FsbGVkQXQgPiBpLmludGVydmFsKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChpbnRlcnZhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbC5jYWxsZWRBdCA9IHRoaXMudGltZVBhc3NlZDtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwuZm4oKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJ2YWwubG9vcHMgJiYgLS1pbnRlcnZhbC5sb29wcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckludGVydmFsKGludGVydmFsLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0RnJhbWUgPSBub3c7XG4gICAgfVxuXG4gICAgZ2V0VGltZVBhc3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZVBhc3NlZDtcbiAgICB9XG5cbiAgICBnZXREZWx0YVRpbWUobm93KSB7XG4gICAgICAgIHJldHVybiBub3cgLSB0aGlzLmxhc3RGcmFtZTtcbiAgICB9XG5cbiAgICBzZXRJbnRlcnZhbChmbiwgaW50ZXJ2YWwsIGltbWVkaWF0ZWx5LCBsb29wcykge1xuICAgICAgICBpZiAoZm4gJiYgaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxlZEF0ID0gaW1tZWRpYXRlbHkgPyB0aGlzLnRpbWVQYXNzZWQgLSBpbnRlcnZhbCA6IHRoaXMudGltZVBhc3NlZDtcblxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgY2FsbGVkQXQsXG4gICAgICAgICAgICAgICAgbG9vcHMsXG4gICAgICAgICAgICAgICAgaWQ6ICsrdGhpcy5pbnRlcnZhbEluZGV4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KGZuLCB0aW1lb3V0KSB7XG4gICAgICAgIGlmIChmbiAmJiB0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLmludGVydmFscy5wdXNoKHtcbiAgICAgICAgICAgICAgICBmbixcbiAgICAgICAgICAgICAgICBpbnRlcnZhbDogdGltZW91dCxcbiAgICAgICAgICAgICAgICBsb29wczogMSxcbiAgICAgICAgICAgICAgICBjYWxsZWRBdDogdGhpcy50aW1lUGFzc2VkLFxuICAgICAgICAgICAgICAgIGlkOiArK3RoaXMuaW50ZXJ2YWxJbmRleCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXJJbnRlcnZhbChpZCkge1xuICAgICAgICBjb25zdCBpbnRlcnZhbElkeCA9IHRoaXMuaW50ZXJ2YWxzLmZpbmRJbmRleChpID0+IGkuaWQgPT09IGlkKTtcblxuICAgICAgICBpZiAoaW50ZXJ2YWxJZHggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHMuc3BsaWNlKGludGVydmFsSWR4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgQXV0b0JpbmRNZXRob2RzIGZyb20gJy4uL0F1dG9CaW5kTWV0aG9kcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFic3RyYWN0TG9jYXRpb24gZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2NlbmUsIGlkID0gJ3Vua25vd24tbGV2ZWwnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHt9XG5cbiAgICBzdGFydExvY2F0aW9uKCkge31cbiAgICByZXN0YXJ0TG9jYXRpb24oKSB7fVxuICAgIHN0b3BMb2NhdGlvbigpIHt9XG4gICAgb25BY3Rpb24oKSB7fVxuXG4gICAgZ2V0TG9jYXRpb25OYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG5cbiAgICBjcmVhdGVBbWJpZW50TGlnaHQoKSB7XG4gICAgICAgIGNvbnN0IGFtYmllbnRMaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoMHg4ODg4ODgpO1xuICAgICAgICBhbWJpZW50TGlnaHQuY2FzdFNoYWRvdyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYW1iaWVudExpZ2h0O1xuICAgIH1cblxuICAgIGNyZWF0ZVNoYWRvd0xpZ2h0KCkge1xuICAgICAgICBjb25zdCBsaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAxMCwgMTUwKTtcbiAgICAgICAgbGlnaHQuaW50ZW5zaXR5ID0gMTtcbiAgICAgICAgbGlnaHQuc2hhZG93LmJpYXMgPSAtMC4wMDAwMTtcbiAgICAgICAgY29uc3Qgc2hhZG93U2l6ZSA9IDI1O1xuICAgICAgICBsaWdodC5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgbGlnaHQuc2hhZG93LmNhbWVyYS5sZWZ0ID0gLXNoYWRvd1NpemU7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5jYW1lcmEucmlnaHQgPSBzaGFkb3dTaXplO1xuICAgICAgICBsaWdodC5zaGFkb3cuY2FtZXJhLnRvcCA9IHNoYWRvd1NpemU7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5jYW1lcmEuYm90dG9tID0gLXNoYWRvd1NpemU7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5tYXBTaXplLndpZHRoID0gNTEyO1xuICAgICAgICBsaWdodC5zaGFkb3cubWFwU2l6ZS5oZWlnaHQgPSA1MTI7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5jYW1lcmEubmVhciA9IDEwO1xuICAgICAgICBsaWdodC5zaGFkb3cuY2FtZXJhLmZhciA9IDE1MDtcbiAgICAgICAgbGlnaHQuc2hhZG93LmNhbWVyYS52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gbGlnaHQ7XG4gICAgfVxuXG5cbiAgICBjcmVhdGVTa3lib3goKSB7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsQXJyYXkgPSBbJ3hwb3MnLCAneG5lZycsICd5cG9zJywgJ3luZWcnLCAnenBvcycsICd6bmVnJ10ubWFwKGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAuL2Fzc2V0cy90ZXh0dXJlcy9za3ktbmVidWxhL25lYnVsYS0ke2RpcmVjdGlvbn0ucG5nYDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgICAgICAgIG1hcDogbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKHVybCksXG4gICAgICAgICAgICAgICAgc2lkZTogVEhSRUUuQmFja1NpZGUsXG4gICAgICAgICAgICAgICAgZm9nOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHNreUdlb21ldHJ5ID0gbmV3IFRIUkVFLkN1YmVHZW9tZXRyeSg3NTAwMCwgNzUwMDAsIDc1MDAwKTtcbiAgICAgICAgY29uc3Qgc2t5TWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbChtYXRlcmlhbEFycmF5KTtcblxuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLk1lc2goc2t5R2VvbWV0cnksIHNreU1hdGVyaWFsKTtcbiAgICB9XG59IiwiY29uc3QgYnVpbGRBcmVhID0gKGFyZWFJZCwgbWFwKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBBcmVhU2l6ZXNbYXJlYUlkXTtcblxuICAgIGNvbnN0IHdheXBvaW50WFRvV29ybGRYID0gcG9zaXRpb24gPT4gcG9zaXRpb24gLSB3aWR0aCAvIDI7XG4gICAgY29uc3Qgd2F5cG9pbnRZVG9Xb3JsZFogPSBwb3NpdGlvbiA9PiBwb3NpdGlvbiAtIGhlaWdodCAvIDI7XG5cbiAgICBjb25zdCB3b3JsZFhUb1dheXBvaW50WCA9IChwb3NpdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBncmFwaFggPSBNYXRoLnJvdW5kKHBvc2l0aW9uICsgd2lkdGggLyAyKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGdyYXBoWCwgNCksIHdpZHRoIC0gNSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHdvcmxkWlRvV2F5cG9pbnRZID0gKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGdyYXBoWSA9IE1hdGgucm91bmQocG9zaXRpb24gKyBoZWlnaHQgLyAyKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGdyYXBoWSwgNCksIGhlaWdodCAtIDUpO1xuICAgIH07XG5cbiAgICBjb25zdCBhcmVhID0ge1xuICAgICAgICBpZDogYXJlYUlkLFxuICAgICAgICB3YXlwb2ludFhUb1dvcmxkWCxcbiAgICAgICAgd2F5cG9pbnRZVG9Xb3JsZFosXG4gICAgICAgIHdvcmxkWFRvV2F5cG9pbnRYLFxuICAgICAgICB3b3JsZFpUb1dheXBvaW50WSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIG1hcChhcmVhKTtcbn07XG5cbmNvbnN0IEFyZWFTaXplcyA9IHtcbiAgICBGTE9PUl8wOiB7XG4gICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgIGhlaWdodDogMTUwLFxuICAgIH0sXG4gICAgRkxPT1JfMToge1xuICAgICAgICB3aWR0aDogMjcwLFxuICAgICAgICBoZWlnaHQ6IDI3MCxcbiAgICB9LFxuICAgIEZMT09SXzI6IHtcbiAgICAgICAgd2lkdGg6IDI3MCxcbiAgICAgICAgaGVpZ2h0OiAyNzAsXG4gICAgfVxufTtcblxuY29uc3QgQXJlYXMgPSB7XG4gICAgRkxPT1JfMDogYnVpbGRBcmVhKCdGTE9PUl8wJywgYXJlYSA9PiAoe1xuICAgICAgICAuLi5hcmVhLFxuICAgICAgICBpbmNsdWRlc1Bvc2l0aW9uOiBwb3NpdGlvbiA9PiBwb3NpdGlvbi55IDwgMTAwLFxuICAgICAgICBnZXRXb3JsZFdheXBvaW50QnlYWTogKHgsIHkpID0+ICh7IHg6IGFyZWEud2F5cG9pbnRYVG9Xb3JsZFgoeCksIHk6IDAuMiwgejogYXJlYS53YXlwb2ludFlUb1dvcmxkWih5KSB9KSxcbiAgICAgICAgZ2V0V2F5cG9pbnRQb3J0YWxzOiAoKSA9PiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogeyB4OiBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKC00OSksIHk6IGFyZWEud29ybGRaVG9XYXlwb2ludFkoMCkgfSxcbiAgICAgICAgICAgICAgICB0bzogeyB4OiBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKC00OSksIHk6IGFyZWEud29ybGRaVG9XYXlwb2ludFkoMCksIGFyZWFJZDogJ0ZMT09SXzEnIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogeyB4OiBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKC00OSksIHk6IGFyZWEud29ybGRaVG9XYXlwb2ludFkoMCkgfSxcbiAgICAgICAgICAgICAgICB0bzogeyB4OiBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKC00OSksIHk6IGFyZWEud29ybGRaVG9XYXlwb2ludFkoMCksIGFyZWFJZDogJ0ZMT09SXzInIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICB9KSksXG5cbiAgICBGTE9PUl8xOiBidWlsZEFyZWEoJ0ZMT09SXzEnLCBhcmVhID0+ICh7XG4gICAgICAgIC4uLmFyZWEsXG4gICAgICAgIGluY2x1ZGVzUG9zaXRpb246IHBvc2l0aW9uID0+IHBvc2l0aW9uLnkgPCAyMDAsXG4gICAgICAgIGdldFdvcmxkV2F5cG9pbnRCeVhZOiAoeCwgeSkgPT4gKHsgeDogYXJlYS53YXlwb2ludFhUb1dvcmxkWCh4KSwgeTogMTAwLjIsIHo6IGFyZWEud2F5cG9pbnRZVG9Xb3JsZFooeSkgfSksXG4gICAgICAgIGdldFdheXBvaW50UG9ydGFsczogKCkgPT4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IHsgeDogYXJlYS53b3JsZFhUb1dheXBvaW50WCgtNDgpLCB5OiBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKDApIH0sXG4gICAgICAgICAgICAgICAgdG86IHsgeDogYXJlYS53b3JsZFhUb1dheXBvaW50WCgtNDgpLCB5OiBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKDApLCBhcmVhSWQ6ICdGTE9PUl8wJyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IHsgeDogYXJlYS53b3JsZFhUb1dheXBvaW50WCgtNDgpLCB5OiBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKDApIH0sXG4gICAgICAgICAgICAgICAgdG86IHsgeDogYXJlYS53b3JsZFhUb1dheXBvaW50WCgtNDgpLCB5OiBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKDApLCBhcmVhSWQ6ICdGTE9PUl8yJyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgfSkpLFxuXG4gICAgRkxPT1JfMjogYnVpbGRBcmVhKCdGTE9PUl8yJywgYXJlYSA9PiAoe1xuICAgICAgICAuLi5hcmVhLFxuICAgICAgICBpbmNsdWRlc1Bvc2l0aW9uOiBwb3NpdGlvbiA9PiBwb3NpdGlvbi55ID49IDIwMCxcbiAgICAgICAgZ2V0V29ybGRXYXlwb2ludEJ5WFk6ICh4LCB5KSA9PiAoeyB4OiBhcmVhLndheXBvaW50WFRvV29ybGRYKHgpLCB5OiAyMDAuMiwgejogYXJlYS53YXlwb2ludFlUb1dvcmxkWih5KSB9KSxcbiAgICAgICAgZ2V0V2F5cG9pbnRQb3J0YWxzOiAoKSA9PiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogeyB4OiBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKC00OCksIHk6IGFyZWEud29ybGRaVG9XYXlwb2ludFkoMCkgfSxcbiAgICAgICAgICAgICAgICB0bzogeyB4OiBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKC00OCksIHk6IGFyZWEud29ybGRaVG9XYXlwb2ludFkoMCksIGFyZWFJZDogJ0ZMT09SXzAnIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogeyB4OiBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKC00OCksIHk6IGFyZWEud29ybGRaVG9XYXlwb2ludFkoMCkgfSxcbiAgICAgICAgICAgICAgICB0bzogeyB4OiBhcmVhLndvcmxkWFRvV2F5cG9pbnRYKC00OCksIHk6IGFyZWEud29ybGRaVG9XYXlwb2ludFkoMCksIGFyZWFJZDogJ0ZMT09SXzEnIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICB9KSksXG59O1xuXG5leHBvcnQgZGVmYXVsdCBBcmVhczsiLCJpbXBvcnQgQXV0b0JpbmRNZXRob2RzIGZyb20gJy4uLy4uL0F1dG9CaW5kTWV0aG9kcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZXZhdG9yIGV4dGVuZHMgQXV0b0JpbmRNZXRob2RzIHtcbiAgICBjb25zdHJ1Y3RvcihzY2VuZSwgcGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcblxuICAgICAgICB0aGlzLmN1cnJlbnRGbG9vciA9IDE7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gMDtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgdGhpcy5zcGVlZCA9IDAuMztcbiAgICAgICAgdGhpcy5zdGFuZFRpbWUgPSAxMDtcblxuICAgICAgICB0aGlzLm9iamVjdCA9IHRoaXMuc2NlbmUubW9kZWxzLmNyZWF0ZUN1YmUocGFyYW1zKTtcbiAgICAgICAgdGhpcy5zdGFuZEF0ID0gdGhpcy5zY2VuZS5pbnRlcnZhbHMuZ2V0VGltZVBhc3NlZCgpO1xuICAgIH1cblxuICAgIGlzUmVsZWFzZWQoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnNjZW5lLmludGVydmFscy5nZXRUaW1lUGFzc2VkKCkgLSB0aGlzLnN0YW5kQXQgPiB0aGlzLnN0YW5kVGltZSAqIDEwMDBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpc0NhcnJ5aW5nKHsgeCwgeSwgeiB9KSB7XG4gICAgICAgIGNvbnN0IHsgb2JqZWN0OiB7IHBvc2l0aW9uLCBzY2FsZSB9IH0gPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBNYXRoLmFicyh4IC0gcG9zaXRpb24ueCkgPCBzY2FsZS54IC8gMlxuICAgICAgICAgICAgJiYgTWF0aC5hYnMoeiAtIHBvc2l0aW9uLnopIDwgc2NhbGUueiAvIDJcbiAgICAgICAgICAgICYmICh5IC0gcG9zaXRpb24ueSA8IHNjYWxlLnkgLyAyKVxuICAgICAgICAgICAgLy8gJiYgKHkgKyAxLjcpIC0gcG9zaXRpb24ueSA+IC1zY2FsZS55IC8gMlxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBnZXRGbG9vcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID4gMFxuICAgICAgICAgICAgICAgID8gKFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5vYmplY3QucG9zaXRpb24ueSA+PSAyMDAgJiYgMilcbiAgICAgICAgICAgICAgICAgICAgfHwgKHRoaXMub2JqZWN0LnBvc2l0aW9uLnkgPj0gMTAwICYmIDEpXG4gICAgICAgICAgICAgICAgICAgIHx8IDBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiAoXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLm9iamVjdC5wb3NpdGlvbi55ID4gMTAwICYmIDIpXG4gICAgICAgICAgICAgICAgICAgIHx8ICh0aGlzLm9iamVjdC5wb3NpdGlvbi55ID4gMCAmJiAxKVxuICAgICAgICAgICAgICAgICAgICB8fCAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWxlYXNlZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBmbG9vciA9IHRoaXMuZ2V0Rmxvb3IoKTtcblxuICAgICAgICAgICAgaWYgKGZsb29yICE9PSB0aGlzLmN1cnJlbnRGbG9vcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhbmRBdCA9IHRoaXMuc2NlbmUuaW50ZXJ2YWxzLmdldFRpbWVQYXNzZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGbG9vciA9IGZsb29yO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZsb29yID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmbG9vciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBmbG9vciArIHRoaXMuZGlyZWN0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZXRDYXJyeWluZ1Bvc2l0aW9uID0gdW5pdCA9PiAoeyAuLi51bml0LnBvc2l0aW9uLCB5OiB1bml0LnBvc2l0aW9uLnkgLSAodGhpcy5kaXJlY3Rpb24gPiAwID8gMiA6IDAuMSkgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FycnlpbmdVbml0cyA9IHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlLmdldFVuaXRzKCkuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICB1bml0ID0+ICh0aGlzLmlzQ2FycnlpbmcoZ2V0Q2FycnlpbmdQb3NpdGlvbih1bml0KSkpLFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0aGlzQWNjZWxlcmF0aW9uID0gdGhpcy5zcGVlZCAqIHRoaXMuZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNhcnJ5aW5nVW5pdHMuZm9yRWFjaCgodW5pdCkgPT4geyB1bml0LnBvc2l0aW9uLnkgKz0gdGhpc0FjY2VsZXJhdGlvbjsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3QucG9zaXRpb24ueSArPSB0aGlzQWNjZWxlcmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0iLCJcbmNvbnN0IGNyZWF0ZUVudmlyb25tZW50ID0gZnVuY3Rpb24gKHtcbiAgICBsb2FkLFxuICAgIHRyZWVzLFxuICAgIGhvdXNlcyxcbiAgICBhZGRDb2xsaWRlckZ1bmN0aW9uLFxuICAgIG9uTG9hZCxcbn0pIHtcbiAgICBjb25zdCBwaXZvdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuICAgIHBpdm90Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICBwaXZvdC5uYW1lID0gJ0xFVkVMX0VOVklST05NRU5UJztcblxuICAgIGxldCBpc0Vudmlyb25tZW50TG9hZGVkID0gZmFsc2U7XG4gICAgbGV0IGlzVHJlZUxvYWRlZCA9IGZhbHNlO1xuICAgIGxldCBpc0hvdXNlTG9hZGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCBjaGVja0lzQWxsTG9hZGVkID0gKCkgPT4ge1xuICAgICAgICBpZiAoaXNFbnZpcm9ubWVudExvYWRlZFxuICAgICAgICAgICAgJiYgaXNUcmVlTG9hZGVkXG4gICAgICAgICAgICAmJiBpc0hvdXNlTG9hZGVkXG4gICAgICAgICkge1xuICAgICAgICAgICAgb25Mb2FkICYmIG9uTG9hZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGxvYWQoe1xuICAgICAgICBiYXNlVXJsOiAnLi9hc3NldHMvbW9kZWxzL2Vudmlyb25tZW50L2Vudmlyb21lbnQnLFxuICAgICAgICBub1NjZW5lOiB0cnVlLFxuICAgICAgICBjYXN0U2hhZG93OiBmYWxzZSxcbiAgICAgICAgY2FsbGJhY2s6IG9iamVjdCA9PiB7XG4gICAgICAgICAgICBwaXZvdC5hZGQob2JqZWN0LnNjZW5lKTtcbiAgICAgICAgICAgIG9iamVjdC5zY2VuZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBvYmplY3Quc2NlbmUudXBkYXRlTWF0cml4KCk7XG4gICAgICAgICAgICBpc0Vudmlyb25tZW50TG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNoZWNrSXNBbGxMb2FkZWQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbG9hZCh7XG4gICAgICAgIGJhc2VVcmw6ICcuL2Fzc2V0cy9tb2RlbHMvZW52aXJvbm1lbnQvdHJlZScsXG4gICAgICAgIG5vU2NlbmU6IHRydWUsXG4gICAgICAgIHJlY2VpdmVTaGFkb3c6IGZhbHNlLFxuICAgICAgICBjYWxsYmFjazogKGxvYWRlZE1vZGVsKSA9PiB7XG4gICAgICAgICAgICBpc1RyZWVMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2hlY2tJc0FsbExvYWRlZCgpO1xuXG4gICAgICAgICAgICB0cmVlcy5mb3JFYWNoKChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gbG9hZGVkTW9kZWwuc2NlbmUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5uYW1lID0gJ1RyZWUnO1xuICAgICAgICAgICAgICAgIG1vZGVsLnBvc2l0aW9uLnNldChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcbiAgICAgICAgICAgICAgICBtb2RlbC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbW9kZWwudXBkYXRlTWF0cml4KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHgsIHogfSA9IG1vZGVsLnBvc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgYWRkQ29sbGlkZXJGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgKHBvc2l0aW9uKSA9PiBNYXRoLmFicyhwb3NpdGlvbi54IC0geCkgPCAyICYmIE1hdGguYWJzKHBvc2l0aW9uLnogLSB6KSA8IDJcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgcGl2b3QuYWRkKG1vZGVsKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGxvYWQoe1xuICAgICAgICBiYXNlVXJsOiAnLi9hc3NldHMvbW9kZWxzL2Vudmlyb25tZW50L2hvdXNlMScsXG4gICAgICAgIHJlY2VpdmVTaGFkb3c6IGZhbHNlLFxuICAgICAgICBub1NjZW5lOiB0cnVlLFxuICAgICAgICBjYWxsYmFjazogKGxvYWRlZE1vZGVsKSA9PiB7XG4gICAgICAgICAgICBpc0hvdXNlTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNoZWNrSXNBbGxMb2FkZWQoKTtcblxuICAgICAgICAgICAgaG91c2VzLmZvckVhY2goKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBsb2FkZWRNb2RlbC5zY2VuZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG1vZGVsLm5hbWUgPSAnSG91c2UxJztcbiAgICAgICAgICAgICAgICBtb2RlbC5wb3NpdGlvbi5zZXQocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XG4gICAgICAgICAgICAgICAgbW9kZWwucm90YXRpb24uc2V0KHBvc2l0aW9uLnJ4IHx8IDAsIHBvc2l0aW9uLnJ5IHx8IDAsIHBvc2l0aW9uLnJ6IHx8IDApO1xuICAgICAgICAgICAgICAgIG1vZGVsLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtb2RlbC51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgeCwgeiB9ID0gbW9kZWwucG9zaXRpb247XG5cbiAgICAgICAgICAgICAgICBhZGRDb2xsaWRlckZ1bmN0aW9uKHVuaXRQb3NpdGlvbiA9PiAoXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHVuaXRQb3NpdGlvbi54IC0geCkgPCAocG9zaXRpb24ucnkgPCAtMy4xMyA/IDQgOiAzKVxuICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLmFicyh1bml0UG9zaXRpb24ueiAtIHopIDwgKHBvc2l0aW9uLnJ5IDwgLTMuMTMgPyAzIDogNClcbiAgICAgICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgICAgIHBpdm90LmFkZChtb2RlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBpdm90O1xufTtcblxuZXhwb3J0IHsgY3JlYXRlRW52aXJvbm1lbnQgfTtcbiIsImltcG9ydCBBYnN0cmFjdExvY2F0aW9uIGZyb20gJy4uL0Fic3RyYWN0TG9jYXRpb24nO1xuaW1wb3J0IHsgUGxheWVyLCBGaXJlIH0gZnJvbSAnLi4vLi4vR2FtZU9iamVjdHMnO1xuaW1wb3J0IEVsZXZhdG9yIGZyb20gJy4vRWxldmF0b3InO1xuaW1wb3J0IHsgY3JlYXRlRW52aXJvbm1lbnQgfSBmcm9tICcuL0Vudmlyb25tZW50JztcbmltcG9ydCBBcmVhcyBmcm9tICcuL0FyZWFzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYXRpb24gZXh0ZW5kcyBBYnN0cmFjdExvY2F0aW9uIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lKSB7XG4gICAgICAgIHN1cGVyKHNjZW5lKTtcbiAgICAgICAgdGhpcy5pZCA9ICdkcmVhbS10b3duJztcblxuICAgICAgICB0aGlzLnNoYWRvd0xpZ2h0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygyNSwgNTAsIDI1KTtcblxuICAgICAgICB0aGlzLnNjZW5lLnVpLnNldExvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2NlbmUudWkuc2V0UGF1c2UodHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5lbnZpcm9ubWVudCA9IGNyZWF0ZUVudmlyb25tZW50KHtcbiAgICAgICAgICAgIGxvYWQ6IHRoaXMuc2NlbmUubW9kZWxzLmxvYWRHTFRGLFxuICAgICAgICAgICAgYWRkQ29sbGlkZXJGdW5jdGlvbjogdGhpcy5zY2VuZS5jb2xsaWRlcnMuYWRkQ29sbGlkZXJGdW5jdGlvbixcbiAgICAgICAgICAgIHRyZWVzOiBbXG4gICAgICAgICAgICAgICAgeyB4OiAwLCB5OiAwLCB6OiAxNSB9LFxuICAgICAgICAgICAgICAgIHsgeDogMCwgeTogMCwgejogLTE1IH0sXG4gICAgICAgICAgICAgICAgeyB4OiAxNSwgeTogMCwgejogMCB9LFxuICAgICAgICAgICAgICAgIHsgeDogLTE1LCB5OiAwLCB6OiAwIH0sXG4gICAgXG4gICAgXG4gICAgICAgICAgICAgICAgeyB4OiAxNSwgeTogMCwgejogMTUgfSxcbiAgICAgICAgICAgICAgICB7IHg6IDE1LCB5OiAwLCB6OiAtMTUgfSxcbiAgICAgICAgICAgICAgICB7IHg6IDMwLCB5OiAwLCB6OiAyMCB9LFxuICAgICAgICAgICAgICAgIHsgeDogMzAsIHk6IDAsIHo6IC0yMCB9LFxuICAgIFxuICAgICAgICAgICAgICAgIHsgeDogNDUsIHk6IDAsIHo6IC0zNSB9LFxuICAgICAgICAgICAgICAgIHsgeDogNDUsIHk6IDAsIHo6IDM1IH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaG91c2VzOiBbXG4gICAgICAgICAgICAgICAgeyB4OiAwLCB5OiAwLCB6OiA0MCwgcnk6IC1NYXRoLlBJIH0sXG4gICAgICAgICAgICAgICAgeyB4OiAtMTAsIHk6IDAsIHo6IDMwLCByeTogTWF0aC5QSSAvIDIgfSxcbiAgICAgICAgICAgICAgICB7IHg6IDEwLCB5OiAwLCB6OiAzMCwgcnk6IC1NYXRoLlBJIC8gMiB9LFxuICAgICAgICAgICAgICAgIC8vIHsgeDogNzUsIHk6IDEwMCwgejogNzUgfSxcbiAgICAgICAgICAgICAgICAvLyB7IHg6IDc1LCB5OiAyMDAsIHo6IDc1IH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgb25Mb2FkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS51aS5zZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnVpLnNldFBhdXNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLm5vdGlmeSgnRHJlYW0gVG93bicpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRMb2NhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFtYmllbnRMaWdodCA9IHRoaXMuY3JlYXRlQW1iaWVudExpZ2h0KCk7XG4gICAgICAgIHRoaXMuc2hhZG93TGlnaHQgPSB0aGlzLmNyZWF0ZVNoYWRvd0xpZ2h0KCk7XG5cbiAgICAgICAgdGhpcy5zY2VuZS5hZGQodGhpcy5lbnZpcm9ubWVudCk7XG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMuYW1iaWVudExpZ2h0KTtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQodGhpcy5zaGFkb3dMaWdodCk7XG5cbiAgICAgICAgdGhpcy5lbGV2YXRvciA9IG5ldyBFbGV2YXRvcihzY2VuZSwge1xuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogLTQ4LCB5OiAxMDAsIHo6IDAgfSxcbiAgICAgICAgICAgIHg6IDQsXG4gICAgICAgICAgICB5OiAxLFxuICAgICAgICAgICAgejogNCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY29sb3IgPSAweDAwMDAwMDtcbiAgICAgICAgY29uc3QgbmVhciA9IDEwO1xuICAgICAgICBjb25zdCBmYXIgPSAxMDA7XG4gICAgICAgIHRoaXMuc2NlbmUuc2NlbmUuZm9nID0gbmV3IFRIUkVFLkZvZyhjb2xvciwgbmVhciwgZmFyKTtcblxuICAgICAgICB0aGlzLmNyZWF0ZUxvY2F0aW9uQ29sbGlkZXJzKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBzdXBlci51cGRhdGUoKTtcblxuICAgICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLnNjZW5lLmdldFBsYXllcigpO1xuXG4gICAgICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZWxldmF0b3IudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2hhZG93TGlnaHQucG9zaXRpb25cbiAgICAgICAgICAgICAgICAuY29weShwbGF5ZXIucG9zaXRpb24pXG4gICAgICAgICAgICAgICAgLmFkZCh0aGlzLnNoYWRvd0xpZ2h0UG9zaXRpb24pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zaGFkb3dMaWdodC50YXJnZXQgIT09IHBsYXllci5vYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd0xpZ2h0LnRhcmdldCA9IHBsYXllci5vYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXZpdmVIZXJvKCkge1xuICAgICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLnNjZW5lLmdldFBsYXllcigpO1xuICAgICAgICBwbGF5ZXIucGFyYW1zLmhwID0gMTA7XG4gICAgICAgIHBsYXllci5wb3NpdGlvbi5zZXQoMCwgMC4zLCAzMCk7XG4gICAgICAgIHBsYXllci5hbmltYXRpb25TdGF0ZS5pc0RpZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjZW5lLnBhcnRpY2xlcy5jcmVhdGVFZmZlY3Qoe1xuICAgICAgICAgICAgZWZmZWN0OiAnbGV2ZWwtdXAvbGV2ZWwtdXAnLFxuICAgICAgICAgICAgc2NhbGU6IDEuNSxcbiAgICAgICAgICAgIGF0dGFjaFRvOiBwbGF5ZXIub2JqZWN0LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZnRlckNsZWFyKCkge1xuICAgICAgICB0aGlzLnNjZW5lLnVuaXRzLmNyZWF0ZVBsYXllcih7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25DcmVhdGU6IChwbGF5ZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmNhbWVyYS5wbGF5ZXIgPSBwbGF5ZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS51aS51cGRhdGVQbGF5ZXJQYXJhbXMoKTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIucG9zaXRpb24uc2V0KDAsIDAuMywgMzApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRGllOiAoKSA9PiB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS51aS5zZXRQYXVzZSh0cnVlKTtcbiAgICAgICAgICAgIH0sIDI1MDApLFxuICAgICAgICAgICAgb25LaWxsOiAob2JqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5zY2VuZS5nZXRQbGF5ZXIoKTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuYWRkRXhwZXJpZW5jZShvYmplY3QucGFyYW1zLmJvdW50eSk7XG4gICAgICAgICAgICAgICAgcGxheWVyLmFkZE1vbmV5KG9iamVjdC5wYXJhbXMuYm91bnR5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRhbWFnZVRha2VuOiAoKSA9PiB0aGlzLnNjZW5lLnVpLnVwZGF0ZVBsYXllclBhcmFtcygpLFxuICAgICAgICAgICAgb25Mb2NhdGlvblVwOiAoKSA9PiB0aGlzLnNjZW5lLnVpLnVwZGF0ZVBsYXllclBhcmFtcygpLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNyZWF0ZUludGVyYWN0aXZlR2FtZU9iamVjdHMoKTtcbiAgICB9XG5cbiAgICBzdGFydExvY2F0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc3RhcnRMb2NhdGlvbigpIHtcbiAgICAgICAgdGhpcy5zY2VuZS5jbGVhclNjZW5lKCk7XG4gICAgfVxuXG4gICAgc3RvcExvY2F0aW9uKCkge1xuICAgICAgICB0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLmVudmlyb25tZW50KTtcbiAgICAgICAgLy8gdGhpcy5zY2VuZS5yZW1vdmUodGhpcy5za3lib3gpO1xuICAgICAgICB0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLmFtYmllbnRMaWdodCk7XG4gICAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMuc2hhZG93TGlnaHQpO1xuICAgICAgICB0aGlzLnNjZW5lLmdhbWVPYmplY3RzU2VydmljZS5yZW1vdmVBbGxFeGNlcHRQbGF5ZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY3JlYXRlSW50ZXJhY3RpdmVHYW1lT2JqZWN0cygpIHtcbiAgICAgICAgY29uc3QgY3JlYXRlSGVhbEl0ZW0gPSAoKSA9PiAoXG4gICAgICAgICAgICB0aGlzLnNjZW5lLmludGVydmFscy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSGVhbFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoLTYuNSwgMC4xLCAzMi44KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlLmNyZWF0ZUl0ZW0oe1xuICAgICAgICAgICAgICAgICAgICBtb2RlbDogJ2l0ZW0taGVhbCcsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpdGVtSGVhbFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjYW5QaWNrdXA6ICh1bml0KSA9PiAodW5pdC5nZXRNYXhIUCgpIC0gdW5pdC5nZXRIUCgpID4gMCksXG4gICAgICAgICAgICAgICAgICAgIG9uUGlja3VwOiAodW5pdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pdC5hZGRIUCgyNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVIZWFsSXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgMTAwMDApXG4gICAgICAgICk7XG4gICAgXG4gICAgICAgIGNyZWF0ZUhlYWxJdGVtKCk7XG5cbiAgICAgICAgY29uc3QgZ2V0QUlQYXJhbXMgPSAoeyBsZXZlbCwgLi4ucGFyYW1zIH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgICAgIHNjYWxlOiAwLjcgKyBsZXZlbCAvIDEwLFxuICAgICAgICAgICAgICAgIG9uRGllOiAoKSA9PiB0aGlzLnNjZW5lLnVuaXRzLmNyZWF0ZUFJKGdldEFJUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwgKyAxICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogbGV2ZWwpLFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZ2V0R29hdHNQYXJhbXMgPSAobGV2ZWwsIHBvc2l0aW9uKSA9PiBnZXRBSVBhcmFtcyh7XG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgZnJhY3Rpb246ICdnb2F0cycsXG4gICAgICAgICAgICBuYW1lOiBsZXZlbCA8PSAxMFxuICAgICAgICAgICAgICAgPyAnR29hdCBXYXJyaW9yJ1xuICAgICAgICAgICAgICAgOiAobGV2ZWwgPD0gMjAgPyAnR29hdCBFbGl0ZScgOiAnR29hdCBEZXN0cm95ZXInKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZ2V0RnJpZW5kbHlQYXJhbXMgPSAobGV2ZWwsIHBvc2l0aW9uLCByb3RhdGlvbikgPT4gZ2V0QUlQYXJhbXMoe1xuICAgICAgICAgICAgbGV2ZWwsIHBvc2l0aW9uLCByb3RhdGlvbiwgZnJhY3Rpb246ICdmcmllbmRseScsIG5hbWU6ICdGcmllbmRseSBDaXRpemVuJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy51bml0cyA9IFtcbiAgICAgICAgICAgIGdldEdvYXRzUGFyYW1zKDMsIHsgeDogLTE3LCB5OiAwLjIsIHo6IC01IH0pLFxuICAgICAgICAgICAgZ2V0R29hdHNQYXJhbXMoMywgeyB4OiAxNyAsIHk6IDAuMiwgejogLTUgfSksXG4gICAgICAgICAgICBnZXRHb2F0c1BhcmFtcygyLCB7IHg6IC0xNSwgeTogMC4yLCB6OiAtMzAgfSksXG4gICAgICAgICAgICBnZXRHb2F0c1BhcmFtcygyLCB7IHg6IDE1LCB5OiAwLjIsIHo6IC0zMCB9KSxcblxuICAgICAgICAgICAgZ2V0R29hdHNQYXJhbXMoNSwgeyB4OiAtMzAsIHk6IDAuMiwgejogLTkgfSksXG4gICAgICAgICAgICBnZXRHb2F0c1BhcmFtcyg1LCB7IHg6IDMwICwgeTogMC4yLCB6OiAtOSB9KSxcbiAgICAgICAgICAgIGdldEdvYXRzUGFyYW1zKDQsIHsgeDogLTQ1LCB5OiAwLjIsIHo6IC0zMCB9KSxcbiAgICAgICAgICAgIGdldEdvYXRzUGFyYW1zKDQsIHsgeDogNDUsIHk6IDAuMiwgejogLTMwIH0pLFxuXG4gICAgICAgICAgICBnZXRHb2F0c1BhcmFtcygxLCB7IHg6IDQ1LCB5OiAwLjIsIHo6IDQ1IH0pLFxuICAgICAgICAgICAgZ2V0R29hdHNQYXJhbXMoMSwgeyB4OiA0NSwgeTogMC4yLCB6OiAtNDUgfSksXG5cbiAgICAgICAgICAgIGdldEdvYXRzUGFyYW1zKDI1LCB7IHg6IDAsIHk6IDAuMiwgejogMCB9KSxcblxuICAgICAgICAgICAgZ2V0RnJpZW5kbHlQYXJhbXMoNSwgeyB4OiAtMC44LCB5OiAwLjIsIHo6IDQwIC0gNC4wMyB9LCB7IHk6IE1hdGguUEkgfSksXG4gICAgICAgICAgICBnZXRGcmllbmRseVBhcmFtcyg1LCB7IHg6IC0xMCArIDMuNSwgeTogMC4yLCB6OiAyOS4yIH0sIHsgeTogTWF0aC5QSSAvIDIgfSksXG4gICAgICAgICAgICBnZXRGcmllbmRseVBhcmFtcyg1LCB7IHg6IDEwIC0gMy41LCB5OiAwLjIsIHo6IDMwLjggfSwgeyB5OiAtTWF0aC5QSSAvIDIgfSksXG4gICAgICAgIF0uZm9yRWFjaCh0aGlzLnNjZW5lLnVuaXRzLmNyZWF0ZUFJKTtcbiAgICB9XG5cbiAgICBjcmVhdGVMb2NhdGlvbkNvbGxpZGVycygpIHtcbiAgICAgICAgY29uc3QgaXNCZXR3ZWVuID0gKHYsIG1pbiwgbWF4KSA9PiB2ID4gbWluICYmIHYgPCBtYXg7XG5cbiAgICAgICAgdGhpcy5zY2VuZS5jb2xsaWRlcnMuYWRkQ29sbGlkZXJGdW5jdGlvbigocG9zaXRpb24sIGdhbWVPYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gcG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCBhYnNYID0gTWF0aC5hYnMoeCk7XG4gICAgICAgICAgICBjb25zdCBhYnNaID0gTWF0aC5hYnMoeik7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA8IDAuMSAmJiBhYnNYIDwgNTAgJiYgYWJzWiA8IDUwKSAvLyBmbG9vciAwXG4gICAgICAgICAgICAgICAgfHwgKCgoeSA8IChhYnNYIC0gNTApIC8gMS41KSAmJiBhYnNYID4gNTApIHx8ICgoeSA8IChhYnNaIC0gNTApIC8gMS41KSAmJiBhYnNaID4gNTApKSAvLyBvdXQgb2YgZmxvb3IgMFxuICAgICAgICAgICAgICAgIHx8ICh5IDwgOTAgJiYgYWJzWCA+IDk2ICYmIGFic1ogPiA5NikgLy8gb3V0IG9mIGZsb29yIDBcbiAgICAgICAgICAgICAgICB8fCAoaXNCZXR3ZWVuKHksIDkwLCAxMDApICYmIChhYnNYID4gNTAgfHwgYWJzWiA+IDUwKSkgLy8gZmxvb3IgMVxuICAgICAgICAgICAgICAgIHx8IChpc0JldHdlZW4oeSwgOTAsIDE5MCkgJiYgKGFic1ggPiAxMzUgfHwgYWJzWiA+IDEzNSkpIC8vIG91dCBvZiBmbG9vciAxXG4gICAgICAgICAgICAgICAgfHwgKGlzQmV0d2Vlbih5LCAxOTAsIDIwMCkgJiYgKGFic1ggPiA1MCB8fCBhYnNaID4gNTApKSAvLyBmbG9vciAyXG4gICAgICAgICAgICAgICAgfHwgKHkgPiAxOTAgJiYgKGFic1ggPiAxMzMgfHwgYWJzWiA+IDEzMykpIC8vIG91dCBvZiBmbG9vciAyXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5lbGV2YXRvci5pc0NhcnJ5aW5nKHBvc2l0aW9uKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHdlIG5lZWQgdW5pdHMgY29sbGlkZXJzXG4gICAgICAgICAgICAvLyBjb25zdCB1bml0cyA9IHRoaXMuc2NlbmUudW5pdHMuZ2V0QWxpdmVVbml0cygpO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGZvcihsZXQgdW5pdCBvZiB1bml0cykge1xuICAgICAgICAgICAgLy8gICAgIGlmIChcbiAgICAgICAgICAgIC8vICAgICAgICAgdW5pdCAhPT0gZ2FtZU9iamVjdFxuICAgICAgICAgICAgLy8gICAgICAgICAmJiAoXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAhKGdhbWVPYmplY3QgaW5zdGFuY2VvZiBGaXJlKVxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgfHwgZ2FtZU9iamVjdC5wYXJhbXMucGFyZW50ICE9PSB1bml0XG4gICAgICAgICAgICAvLyAgICAgICAgIClcbiAgICAgICAgICAgIC8vICAgICAgICAgJiYgdW5pdC5nZXRDb2xsaWRlcihwb3NpdGlvbilcbiAgICAgICAgICAgIC8vICAgICApIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldEFyZWFzKCkge1xuICAgICAgICBjb25zdCBhcmVhcyA9IE9iamVjdC52YWx1ZXMoQXJlYXMpO1xuXG4gICAgICAgIGNvbnN0IGdlbmVyYXRlV2F5cG9pbnRzID0gKHdpZHRoLCBoZWlnaHQsIG1hcCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheSh3aWR0aCkuZmlsbChudWxsKS5tYXAoXG4gICAgICAgICAgICAgICAgKG51bGwxLCB4KSA9PiBuZXcgQXJyYXkoaGVpZ2h0KS5maWxsKG51bGwpLm1hcChcbiAgICAgICAgICAgICAgICAgICAgKG51bGwyLCB5KSA9PiBtYXAoeCwgeSksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGFyZWFzLm1hcCgoYXJlYSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyAuLi5hcmVhIH07XG5cbiAgICAgICAgICAgIHJlc3VsdC5nZXRXYXlwb2ludHMgPSAoKSA9PiBnZW5lcmF0ZVdheXBvaW50cyhcbiAgICAgICAgICAgICAgICBhcmVhLndpZHRoLFxuICAgICAgICAgICAgICAgIGFyZWEuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICh4LCB5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVsZXZhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhhcmVhLndheXBvaW50WFRvV29ybGRYKHgpIC0gdGhpcy5lbGV2YXRvci5wYXJhbXMucG9zaXRpb24ueCkgPD0gNVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5hYnMoYXJlYS53YXlwb2ludFlUb1dvcmxkWih5KSAtIHRoaXMuZWxldmF0b3IucGFyYW1zLnBvc2l0aW9uLnopIDw9IDFcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWEuaWQgIT09ICdGTE9PUl8wJyAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2VudGVyIGhvbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGFyZWEud2F5cG9pbnRYVG9Xb3JsZFgoeCkpIDwgNTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5hYnMoYXJlYS53YXlwb2ludFlUb1dvcmxkWih5KSkgPCA1MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGFyZWEud2F5cG9pbnRYVG9Xb3JsZFgoeCkpIDw9IDUxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGguYWJzKGFyZWEud2F5cG9pbnRZVG9Xb3JsZFooeSkpIDw9IDUxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGguYWJzKGFyZWEud2F5cG9pbnRYVG9Xb3JsZFgoeCkpID49IDUwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGguYWJzKGFyZWEud2F5cG9pbnRZVG9Xb3JsZFooeSkpID49IDUwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJlYS5pZCA9PT0gJ0ZMT09SXzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxvb3Igb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoYXJlYS53YXlwb2ludFhUb1dvcmxkWCh4KSkgPj0gNDlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBNYXRoLmFicyhhcmVhLndheXBvaW50WVRvV29ybGRaKHkpKSA+PSA0OVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLmNoZWNrV2F5Rm9yV2F5cG9pbnQoYXJlYS5nZXRXb3JsZFdheXBvaW50QnlYWSh4LCB5KSkpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNoZWNrV2F5Rm9yV2F5cG9pbnQoeyB4LCB5LCB6IH0pIHtcbiAgICAgICAgY29uc3QgY2hlY2tXYXkgPSB0aGlzLnNjZW5lLmNvbGxpZGVycy5jaGVja1dheTtcbiAgICAgICAgY29uc3QgY2hlY2tOZWFyID0gKHJhbmdlLCBkaWFnb25hbCkgPT4gKFxuICAgICAgICAgICAgY2hlY2tXYXkobmV3IFRIUkVFLlZlY3RvcjMoeCArIHJhbmdlLCB5LCB6KSlcbiAgICAgICAgICAgICYmIChjaGVja1dheShuZXcgVEhSRUUuVmVjdG9yMyh4IC0gcmFuZ2UsIHksIHopKSlcbiAgICAgICAgICAgICYmIChjaGVja1dheShuZXcgVEhSRUUuVmVjdG9yMyh4LCB5LCB6ICsgcmFuZ2UpKSlcbiAgICAgICAgICAgICYmIChjaGVja1dheShuZXcgVEhSRUUuVmVjdG9yMyh4LCB5LCB6IC0gcmFuZ2UpKSlcbiAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAhZGlhZ29uYWwgfHwgKFxuICAgICAgICAgICAgICAgICAgICBjaGVja1dheShuZXcgVEhSRUUuVmVjdG9yMyh4ICsgcmFuZ2UsIHksIHogKyByYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgICYmIGNoZWNrV2F5KG5ldyBUSFJFRS5WZWN0b3IzKHggLSByYW5nZSwgeSwgeiAtIHJhbmdlKSlcbiAgICAgICAgICAgICAgICAgICAgJiYgY2hlY2tXYXkobmV3IFRIUkVFLlZlY3RvcjMoeCAtIHJhbmdlLCB5LCB6ICsgcmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAmJiBjaGVja1dheShuZXcgVEhSRUUuVmVjdG9yMyh4ICsgcmFuZ2UsIHksIHogLSByYW5nZSkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjaGVja1dheShuZXcgVEhSRUUuVmVjdG9yMyh4LCB5LCB6KSlcbiAgICAgICAgICAgICYmIGNoZWNrTmVhcigxLCB0cnVlKVxuICAgICAgICAgICAgJiYgY2hlY2tOZWFyKDIpXG4gICAgICAgICk7XG4gICAgfVxufVxuIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vTG9jYXRpb24nOyIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbHMgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5yZXBlYXRYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5yZXBlYXRZXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbWlzc2l2ZVxuICAgICAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcGFyYW1zLnBvc2l0aW9uXG4gICAgICogQHJldHVybnMge1RIUkVFLk1lc2h9XG4gICAgICovXG4gICAgY3JlYXRlQ3ViZShwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgICAgIGNvbnN0IG1hdGVyaWFsUGFyYW1zID0ge307XG5cbiAgICAgICAgaWYgKHBhcmFtcy5pbWFnZSkge1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZChwYXJhbXMuaW1hZ2UpO1xuICAgICAgICAgICAgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuICAgICAgICAgICAgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuICAgICAgICAgICAgdGV4dHVyZS5yZXBlYXQuc2V0KHBhcmFtcy5yZXBlYXRYIHx8IDEsIHBhcmFtcy5yZXBlYXRZIHx8IDEpO1xuICAgICAgICAgICAgbWF0ZXJpYWxQYXJhbXMubWFwID0gdGV4dHVyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuZW1pc3NpdmUpIHtcbiAgICAgICAgICAgIG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKHBhcmFtcy5lbWlzc2l2ZSk7XG4gICAgICAgICAgICBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcbiAgICAgICAgICAgIG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlTWFwID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1YmUgPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgICAgICAgIG5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoMSwgMSwgMSksXG4gICAgICAgICAgICBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbChtYXRlcmlhbFBhcmFtcylcbiAgICAgICAgKTtcblxuICAgICAgICBjdWJlLnNjYWxlLnNldChwYXJhbXMueCB8fCAxLCBwYXJhbXMueSB8fCAxLCBwYXJhbXMueiB8fCAxKTtcblxuICAgICAgICBpZiAocGFyYW1zLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjdWJlLnBvc2l0aW9uLnNldChcbiAgICAgICAgICAgICAgICBwYXJhbXMucG9zaXRpb24ueCB8fCAwLFxuICAgICAgICAgICAgICAgIHBhcmFtcy5wb3NpdGlvbi55IHx8IDAsXG4gICAgICAgICAgICAgICAgcGFyYW1zLnBvc2l0aW9uLnogfHwgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMucm90YXRpb24pIHtcbiAgICAgICAgICAgIGN1YmUucm90YXRpb24uc2V0KFxuICAgICAgICAgICAgICAgIHBhcmFtcy5yb3RhdGlvbi54IHx8IDAsXG4gICAgICAgICAgICAgICAgcGFyYW1zLnJvdGF0aW9uLnkgfHwgMCxcbiAgICAgICAgICAgICAgICBwYXJhbXMucm90YXRpb24ueiB8fCAwXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXJhbXMubm9TY2VuZSkge1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5hZGQoY3ViZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3ViZTtcbiAgICB9XG5cbiAgICBsb2FkR0xURih7XG4gICAgICAgIGJhc2VVcmwsXG4gICAgICAgIGlzR0xURiA9IGZhbHNlLFxuICAgICAgICBub1NjZW5lID0gZmFsc2UsXG4gICAgICAgIGNhbGxiYWNrID0gKCkgPT4gbnVsbCxcbiAgICAgICAgY2FzdFNoYWRvdyA9IHRydWUsXG4gICAgICAgIHJlY2VpdmVTaGFkb3cgPSB0cnVlLFxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IEdMVEZMb2FkZXIoKTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7YmFzZVVybH0uZ2xiJHtpc0dMVEYgPyAnLmdsdGYnIDogJyd9YDtcbiAgICAgICAgXG4gICAgICAgIGxvYWRlci5sb2FkKHVybCwgKGxvYWRlZE1vZGVsKSA9PiB7XG4gICAgICAgICAgICBsb2FkZWRNb2RlbC5zY2VuZS50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSBjYXN0U2hhZG93O1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FsbGJhY2sobG9hZGVkTW9kZWwpO1xuXG4gICAgICAgICAgICBpZiAoIW5vU2NlbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmFkZChsb2FkZWRNb2RlbC5zY2VuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSAnLi9TY2VuZSc7XG5pbXBvcnQgQXV0b0JpbmRNZXRob2RzIGZyb20gJy4vQXV0b0JpbmRNZXRob2RzJztcbmltcG9ydCBBbmltYXRlZEdhbWVPYmplY3QgZnJvbSAnLi9HYW1lT2JqZWN0cy9BbmltYXRlZEdhbWVPYmplY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0aWNsZXMgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2NlbmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLnBhcnRpY2xlcyA9IFtdO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaChwID0+IHAudXBkYXRlKCkpO1xuICAgIH1cblxuICAgIGNyZWF0ZVNub3coKSB7XG4gICAgICAgIGNvbnN0IGFyZWEgPSBuZXcgVEhSRUUuVmVjdG9yMygxMDAsIDI1LCAxMDApO1xuXG4gICAgICAgIHRoaXMuY3JlYXRlUGFydGljbGVzKHtcbiAgICAgICAgICAgIHBhcnRpY2xlQ291bnQ6IDEwMDAwLFxuICAgICAgICAgICAgY29sb3I6IDB4ODg4ODg4LFxuICAgICAgICAgICAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICAgICAgICAgICAgcG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKC1hcmVhLnggLyAyLCAwLCAtYXJlYS56IC8gMiksXG4gICAgICAgICAgICBnZXRQYXJ0aWNsZVBvc2l0aW9uOiAoaSwgcG9zaXRpb24gPSB0aGlzLmdldFJhbmRvbVBvc2l0aW9uKGFyZWEpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uLnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5nZXRSYW5kb21Qb3NpdGlvbihhcmVhKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24ueCA9IG5ld1Bvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnkgPSBhcmVhLnk7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnogPSBuZXdQb3NpdGlvbi56O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGNyZWF0ZUVmZmVjdCh7XG4gICAgICAgIHNjYWxlID0gMS41LFxuICAgICAgICBlZmZlY3QgPSAnbGV2ZWwtdXAtYWx0L2xldmVsLXVwJyxcbiAgICAgICAgcG9zaXRpb24gPSB7fSxcbiAgICAgICAgYXR0YWNoVG8sXG4gICAgICAgIGxpZmVUaW1lID0gMjA4MCxcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuc2NlbmUubW9kZWxzLmxvYWRHTFRGKHtcbiAgICAgICAgICAgIGJhc2VVcmw6ICcuL2Fzc2V0cy9tb2RlbHMvZWZmZWN0cy8nICsgZWZmZWN0LFxuICAgICAgICAgICAgbm9TY2VuZTogdHJ1ZSxcbiAgICAgICAgICAgIGNhc3RTaGFkb3c6IGZhbHNlLFxuICAgICAgICAgICAgcmVjZWl2ZVNoYWRvdzogZmFsc2UsXG4gICAgICAgICAgICBjYWxsYmFjazogbG9hZGVkT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBsb2FkZWRPYmplY3Quc2NlbmUuc2NhbGUuc2V0KHNjYWxlLCBzY2FsZSwgc2NhbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbG9hZGVkT2JqZWN0LnNjZW5lLnRyYXZlcnNlKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNNZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC5hbHBoYVRlc3QgPSAwLjU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxvYWRlZE9iamVjdC5zY2VuZS5wb3NpdGlvbi5zZXQocG9zaXRpb24ueCB8fCAwLCBwb3NpdGlvbi55IHx8IDAsIHBvc2l0aW9uLnogfHwgMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXR0YWNoVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoVG8uYWRkKGxvYWRlZE9iamVjdC5zY2VuZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgZWZmZWN0ID0gbmV3IEFuaW1hdGVkR2FtZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogbG9hZGVkT2JqZWN0LnNjZW5lLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBsb2FkZWRPYmplY3QuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlLmhvb2tHYW1lT2JqZWN0KGVmZmVjdCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmludGVydmFscy5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnNjZW5lLmdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdChlZmZlY3QpLFxuICAgICAgICAgICAgICAgICAgICBsaWZlVGltZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgXG4gICAgXG5cbiAgICBsb2FkRWZmZWN0KHtcbiAgICAgICAgcGFydGljbGVOYW1lID0gJ2Jsb29kJyxcbiAgICAgICAgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDEsIDEpXG4gICAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGdhbWVPYmplY3RzU2VydmljZSA9IHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNjZW5lLm1vZGVscy5sb2FkR0xURih7XG4gICAgICAgICAgICBiYXNlVXJsOiBgLi9hc3NldHMvbW9kZWxzL2VmZmVjdHMvJHtwYXJ0aWNsZU5hbWV9YCxcbiAgICAgICAgICAgIGNhc3RTaGFkb3c6IGZhbHNlLFxuICAgICAgICAgICAgcmVjZWl2ZVNoYWRvdzogZmFsc2UsXG4gICAgICAgICAgICBjYWxsYmFjazogKGdsdGYpID0+IHtcbiAgICAgICAgICAgICAgICBnbHRmLnNjZW5lLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGdsdGYuc2NlbmUuc2NhbGUuY29weShzY2FsZSk7XG4gICAgICAgICAgICAgICAgZ2x0Zi5zY2VuZS5yb3RhdGlvbi5zZXQoMCwgTWF0aC5yYW5kb20oKSAqIE1hdGguUEksIDApO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcGFydGljbGVTeXN0ZW0gPSBnYW1lT2JqZWN0c1NlcnZpY2UuaG9va0dhbWVPYmplY3QobmV3IEFuaW1hdGVkR2FtZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogZ2x0Zi5zY2VuZSxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uczogZ2x0Zi5hbmltYXRpb25zLFxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuaW50ZXJ2YWxzLnNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgICgpID0+IHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlLmRlc3Ryb3lHYW1lT2JqZWN0KHBhcnRpY2xlU3lzdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgNjI1XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0UmFuZG9tUG9zaXRpb24oYXJlYSkge1xuICAgICAgICBjb25zdCByYW5kb20gPSAoZnJvbSwgdG8pID0+IE1hdGgucmFuZG9tKCkgKiAodG8gLSBmcm9tKSArIGZyb207XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgICAgcmFuZG9tKDAsIGFyZWEueCksXG4gICAgICAgICAgICByYW5kb20oMCwgYXJlYS55KSxcbiAgICAgICAgICAgIHJhbmRvbSgwLCBhcmVhLnopLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNyZWF0ZVBhcnRpY2xlcyh7XG4gICAgICAgIHBhcnRpY2xlQ291bnQgPSAxMDAwLFxuICAgICAgICBub1NjZW5lID0gZmFsc2UsXG4gICAgICAgIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgNSwgMCksXG4gICAgICAgIHNpemUgPSAwLjAxLFxuICAgICAgICBjb2xvciA9IDB4RkZGRkZGLFxuICAgICAgICBibGVuZGluZyA9IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcsXG4gICAgICAgIGRlcHRoVGVzdCA9IHRydWUsXG4gICAgICAgIHRyYW5zcGFyZW50ID0gdHJ1ZSxcbiAgICAgICAgYXJlYSA9IG5ldyBUSFJFRS5WZWN0b3IzKDEwLCA1LCAxMCksXG4gICAgICAgIGdldFBhcnRpY2xlVmVsb2NpdHkgPSAoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMygtMC4wMSwgLTAuMDEsIDApLFxuICAgICAgICBnZXRQYXJ0aWNsZVBvc2l0aW9uID0gKGksIHBvc2l0aW9uID0gdGhpcy5nZXRSYW5kb21Qb3NpdGlvbihhcmVhKSkgPT4gcG9zaXRpb24sXG4gICAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlcyA9IG5ldyBUSFJFRS5HZW9tZXRyeTtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsKHsgY29sb3IsIHNpemUsIGJsZW5kaW5nLCBkZXB0aFRlc3QsIHRyYW5zcGFyZW50IH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydGljbGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IGdldFBhcnRpY2xlUG9zaXRpb24oaSk7XG4gICAgICAgICAgICBwYXJ0aWNsZXMudmVsb2NpdHkgPSBnZXRQYXJ0aWNsZVZlbG9jaXR5KGksIHBhcnRpY2xlKTtcbiAgICAgICAgICAgIHBhcnRpY2xlcy52ZXJ0aWNlcy5wdXNoKHBhcnRpY2xlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcnRpY2xlU3lzdGVtID0gbmV3IFRIUkVFLlBvaW50Q2xvdWQocGFydGljbGVzLCBtYXRlcmlhbCk7XG4gICAgICAgIHBhcnRpY2xlU3lzdGVtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMucGFydGljbGVzLnB1c2goe1xuICAgICAgICAgICAgb2JqZWN0OiBwYXJ0aWNsZVN5c3RlbSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHBhcnRpY2xlQ291bnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IHBhcnRpY2xlcy52ZXJ0aWNlc1tpbmRleF07XG5cbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUudmVsb2NpdHkgPSBnZXRQYXJ0aWNsZVZlbG9jaXR5KGluZGV4LCBwYXJ0aWNsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUueCArPSBwYXJ0aWNsZS52ZWxvY2l0eS54O1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS55ICs9IHBhcnRpY2xlLnZlbG9jaXR5Lnk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnogKz0gcGFydGljbGUudmVsb2NpdHkuejtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWNsZVBvc2l0aW9uID0gZ2V0UGFydGljbGVQb3NpdGlvbihpbmRleCwgcGFydGljbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnggPSBwYXJ0aWNsZVBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnkgPSBwYXJ0aWNsZVBvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnogPSBwYXJ0aWNsZVBvc2l0aW9uLno7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFydGljbGVzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW5vU2NlbmUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuYWRkKHBhcnRpY2xlU3lzdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJ0aWNsZVN5c3RlbTtcbiAgICB9XG59IiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5pbXBvcnQgQVN0YXIgZnJvbSAnLi9VdGlscy9BU3Rhcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbGxpZGVycyBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgY29uc3RydWN0b3Ioc2NlbmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIH1cblxuICAgIGdldE5leHRQb2ludChmcm9tLCB0bykge1xuICAgICAgICBjb25zdCBhcmVhID0gdGhpcy5nZXRBcmVhQnlQb3NpdGlvbihmcm9tKSxcbiAgICAgICAgICAgIGZyb21YID0gYXJlYS53b3JsZFhUb1dheXBvaW50WChmcm9tLngpLFxuICAgICAgICAgICAgZnJvbVkgPSBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKGZyb20ueiksXG4gICAgICAgICAgICBhcmVhVG8gPSB0aGlzLmdldEFyZWFCeVBvc2l0aW9uKHRvKTtcblxuICAgICAgICBsZXQgdG9YO1xuICAgICAgICBsZXQgdG9ZO1xuICAgICAgICBsZXQgcG9ydGFsO1xuXG4gICAgICAgIGlmIChhcmVhLmlkID09PSBhcmVhVG8uaWQpIHtcbiAgICAgICAgICAgIHRvWCA9IGFyZWEud29ybGRYVG9XYXlwb2ludFgodG8ueCk7XG4gICAgICAgICAgICB0b1kgPSBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKHRvLnopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9ydGFsID0gYXJlYS5nZXRXYXlwb2ludFBvcnRhbHMoKS5maW5kKHBvcnRhbCA9PiBwb3J0YWwudG8uYXJlYUlkID09PSBhcmVhVG8uaWQpO1xuXG4gICAgICAgICAgICBpZiAocG9ydGFsKSB7XG4gICAgICAgICAgICAgICAgdG9YID0gcG9ydGFsLmZyb20ueDtcbiAgICAgICAgICAgICAgICB0b1kgPSBwb3J0YWwuZnJvbS55O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmdldEZyZWVHcmFwaFBvaW50KGFyZWEuZ3JhcGgsIGZyb21YLCBmcm9tWSk7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLmdldEZyZWVHcmFwaFBvaW50KGFyZWEuZ3JhcGgsIHRvWCwgdG9ZKTtcblxuICAgICAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gQVN0YXIuYXN0YXIuc2VhcmNoKFxuICAgICAgICAgICAgICAgIGFyZWEuZ3JhcGgsXG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgICAgIHsgaGV1cmlzdGljOiBBU3Rhci5hc3Rhci5oZXVyaXN0aWNzLmRpYWdvbmFsIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IG5leHRHcmFwaFBvaW50ID0gcmVzdWx0WzJdIHx8IHJlc3VsdFsxXTtcblxuICAgICAgICAgICAgaWYgKG5leHRHcmFwaFBvaW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFdvcmxkUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICAgICAgICAgICAgYXJlYS53YXlwb2ludFhUb1dvcmxkWChuZXh0R3JhcGhQb2ludC54KSxcbiAgICAgICAgICAgICAgICAgICAgdG8ueSxcbiAgICAgICAgICAgICAgICAgICAgYXJlYS53YXlwb2ludFlUb1dvcmxkWihuZXh0R3JhcGhQb2ludC55KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFdvcmxkUG9pbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIGdldEZyZWVHcmFwaFBvaW50KGdyYXBoLCB4LCB5KSB7XG4gICAgICAgIGNvbnN0IGdyaWQgPSBncmFwaC5ncmlkO1xuXG4gICAgICAgIGNvbnN0IGdldFdlaWdodCA9ICh4LCB5KSA9PiBncmlkW3hdICYmIGdyaWRbeF1beV0gJiYgZ3JpZFt4XVt5XS53ZWlnaHQ7XG5cbiAgICAgICAgY29uc3QgZ2V0TmVhckZyZWVQb2ludCA9IHJhbmdlID0+IChcbiAgICAgICAgICAgIChnZXRXZWlnaHQoeCArIHJhbmdlLCB5KSAmJiBncmlkW3ggKyByYW5nZV1beV0pXG4gICAgICAgICAgICB8fCAoZ2V0V2VpZ2h0KHggLSByYW5nZSwgeSkgJiYgZ3JpZFt4IC0gcmFuZ2VdW3ldKVxuICAgICAgICAgICAgfHwgKGdldFdlaWdodCh4LCB5ICsgcmFuZ2UpICYmIGdyaWRbeF1beSArIHJhbmdlXSlcbiAgICAgICAgICAgIHx8IChnZXRXZWlnaHQoeCwgeSAtIHJhbmdlKSAmJiBncmlkW3hdW3kgLSByYW5nZV0pXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChnZXRXZWlnaHQoZ3JpZFt4XVt5XSkgJiYgZ3JpZFt4XVt5XSlcbiAgICAgICAgICAgIHx8IGdldE5lYXJGcmVlUG9pbnQoMSlcbiAgICAgICAgICAgIHx8IGdldE5lYXJGcmVlUG9pbnQoMilcbiAgICAgICAgICAgIHx8IGdldE5lYXJGcmVlUG9pbnQoMylcbiAgICAgICAgICAgIHx8IGdldE5lYXJGcmVlUG9pbnQoNClcbiAgICAgICAgICAgIHx8IG51bGxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZWJ1aWxkQXJlYXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjZW5lLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFyZWFzID0gdGhpcy5zY2VuZS5sb2NhdGlvbi5nZXRBcmVhcygpLm1hcChhcmVhID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uYXJlYSxcbiAgICAgICAgICAgICAgICBncmFwaDogbmV3IEFTdGFyLkdyYXBoKGFyZWEuZ2V0V2F5cG9pbnRzKCksIHsgZGlhZ29uYWw6IHRydWUgfSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRBcmVhQnlQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmVhcy5maW5kKGFyZWEgPT4gYXJlYS5pbmNsdWRlc1Bvc2l0aW9uKHBvc2l0aW9uKSk7XG4gICAgfVxufSIsImltcG9ydCB7IFBsYXllciB9IGZyb20gJy4vR2FtZU9iamVjdHMnO1xuLy8gaW1wb3J0IEF1ZGlvIGZyb20gJy4vQXVkaW8nO1xuaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4vQ2FtZXJhJztcbmltcG9ydCBDb25uZWN0aW9uIGZyb20gJy4vQ29ubmVjdGlvbic7XG5pbXBvcnQgR2FtZU9iamVjdHNTZXJ2aWNlIGZyb20gJy4vR2FtZU9iamVjdHMnO1xuaW1wb3J0IElucHV0IGZyb20gJy4vSW5wdXQnO1xuaW1wb3J0IEludGVydmFscyBmcm9tICcuL0ludGVydmFscyc7XG5pbXBvcnQgTG9jYXRpb24gZnJvbSAnLi9Mb2NhdGlvbnMvRHJlYW1Ub3duJztcbmltcG9ydCBDb2xsaWRlcnMgZnJvbSAnLi9Db2xsaWRlcnMnO1xuaW1wb3J0IE1vZGVscyBmcm9tICcuL01vZGVscyc7XG5pbXBvcnQgUGFydGljbGVzIGZyb20gJy4vUGFydGljbGVzJztcbmltcG9ydCBQYXRoRmluZGVyIGZyb20gJy4vUGF0aEZpbmRlcic7XG5pbXBvcnQgVW5pdHMgZnJvbSAnLi9Vbml0cyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmUgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogIHNldFJlc3RhcnRCdXR0b25WaXNpYmxlOiBmdW5jdGlvbixcbiAgICAgKiAgc2V0UGF1c2U6IGZ1bmN0aW9uLFxuICAgICAqICByZXN0YXJ0R2FtZTogZnVuY3Rpb24sXG4gICAgICogIGlzUGF1c2U6IGZ1bmN0aW9uLFxuICAgICAqICBpc1RoaXJkUGVyc29uOiBmdW5jdGlvbixcbiAgICAgKiAgdXBkYXRlOiBmdW5jdGlvbixcbiAgICAgKiAgdXBkYXRlUGxheWVyUGFyYW1zOiBmdW5jdGlvbixcbiAgICAgKiAgY2xlYXJIcEJhcnM6IGZ1bmN0aW9uLFxuICAgICAqICBzd2l0Y2hDYW1lcmE6IGZ1bmN0aW9uLFxuICAgICAqICBzZXRGcHM6IGZ1bmN0aW9uLFxuICAgICAqICBub3RpZnk6IGZ1bmN0aW9uLFxuICAgICAqIH19IHVpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIHVpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2xvY2sgPSBuZXcgVEhSRUUuQ2xvY2soKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbHMgPSBuZXcgSW50ZXJ2YWxzKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMudWkgPSB1aTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSBuZXcgTW9kZWxzKHRoaXMpO1xuICAgICAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgICAgIHRoaXMucGF0aEZpbmRlciA9IG5ldyBQYXRoRmluZGVyKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbGxpZGVycyA9IG5ldyBDb2xsaWRlcnModGhpcyk7XG4gICAgICAgIHRoaXMudW5pdHMgPSBuZXcgVW5pdHModGhpcyk7XG4gICAgICAgIHRoaXMuY2FtZXJhID0gbmV3IENhbWVyYSh0aGlzKTtcbiAgICAgICAgLy8gdGhpcy5hdWRpbyA9IG5ldyBBdWRpbyh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBJbnB1dCh7XG4gICAgICAgICAgICBvbkFjdGlvbjogKCkgPT4gdGhpcy5sZXZlbC5vbkFjdGlvbigpLFxuICAgICAgICAgICAgb25FeGl0OiAoKSA9PiB0aGlzLnVpLnNldFBhdXNlKCF0aGlzLnVpLmlzUGF1c2UoKSksXG4gICAgICAgICAgICBvblpvb206IHpvb20gPT4gdGhpcy5jYW1lcmEuYWRkWSh6b29tKSxcbiAgICAgICAgICAgIG9uU3dpdGNoQ2FtZXJhOiAoKSA9PiB0aGlzLnVpLnN3aXRjaENhbWVyYSgpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0c1NlcnZpY2UgPSBuZXcgR2FtZU9iamVjdHNTZXJ2aWNlKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcnRpY2xlcyA9IG5ldyBQYXJ0aWNsZXModGhpcyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKHRoaXMsICdsb2NhbGhvc3QucnUnKTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IG5ldyBMb2NhdGlvbih0aGlzKTtcblxuICAgICAgICB0aGlzLmludGVydmFscy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVpLnNldEZwcyh0aGlzLnJlbmRlcmVyLmZwcywgdGhpcy5yZW5kZXJlci50YXJnZXRGcHMpO1xuICAgICAgICAgICAgdGhpcy51aS51cGRhdGVQbGF5ZXJQYXJhbXMoKVxuICAgICAgICB9LCAxMDAwKTtcblxuICAgICAgICB0aGlzLmlucHV0LmlzVGhpcmRQZXJzb24gPSB1aS5pc1RoaXJkUGVyc29uKCk7XG5cbiAgICAgICAgdGhpcy5jbGVhclNjZW5lKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSgpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdTY2VuZScsIHRoaXMpO1xuICAgIH1cblxuICAgIGNsZWFyU2NlbmUoKSB7XG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdHNTZXJ2aWNlLnJlbW92ZUFsbCgpO1xuICAgICAgICB0aGlzLmxvY2F0aW9uLmFmdGVyQ2xlYXIoKTtcbiAgICB9XG5cbiAgICBhbmltYXRlKCkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBkZWx0YVRpbWUgPSB0aGlzLmludGVydmFscy5nZXREZWx0YVRpbWUobm93KTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbHMudXBkYXRlKG5vdyk7XG4gICAgICAgIGNvbnN0IGdhbWVUaW1lID0gdGhpcy5pbnRlcnZhbHMuZ2V0VGltZVBhc3NlZCgpO1xuXG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdHNTZXJ2aWNlLnVwZGF0ZShnYW1lVGltZSwgZGVsdGFUaW1lKTtcblxuICAgICAgICBpZiAoIXRoaXMudWkuaXNQYXVzZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGUoZ2FtZVRpbWUsIGRlbHRhVGltZSk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51aS51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbi51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMudXBkYXRlKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi51cGRhdGUoZ2FtZVRpbWUsIGRlbHRhVGltZSk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEuY2FtZXJhLCBkZWx0YVRpbWUpO1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZSk7XG4gICAgfVxuXG4gICAgc2V0TG9nZ2VkVXNlcih1c2VyTmFtZSwgcGFzc3dvcmQpIHtcbiAgICAgICAgdGhpcy51c2VyID0geyB1c2VyTmFtZSwgcGFzc3dvcmQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UGxheWVyfVxuICAgICAqL1xuICAgIGdldFBsYXllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pdHMuZ2V0UGxheWVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUSFJFRS5PYmplY3QzRH0gb2JqZWN0XG4gICAgICovXG4gICAgYWRkKG9iamVjdCkge1xuICAgICAgICB0aGlzLnNjZW5lLmFkZChvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VEhSRUUuT2JqZWN0M0R9IG9iamVjdFxuICAgICAqL1xuICAgIHJlbW92ZShvYmplY3QpIHtcbiAgICAgICAgdGhpcy5zY2VuZS5yZW1vdmUob2JqZWN0KTtcbiAgICB9XG5cbiAgICBub3RpZnkodGV4dCkge1xuICAgICAgICB0aGlzLnVpLm5vdGlmeSh0ZXh0KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgQXV0b0JpbmRNZXRob2RzIGZyb20gJy4vQXV0b0JpbmRNZXRob2RzJztcbmltcG9ydCB7IFBsYXllciwgQUksIEFuaW1hdGVkR2FtZU9iamVjdCB9IGZyb20gJy4vR2FtZU9iamVjdHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVbml0cyBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG5cdGNvbnN0cnVjdG9yKHNjZW5lKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdFx0dGhpcy5wbGF5ZXIgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRnZXRVbml0cygpIHtcblx0XHRyZXR1cm4gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2UuZ2V0VW5pdHMoKTtcblx0fVxuXG5cdGdldEFsaXZlVW5pdHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VW5pdHMoKS5maWx0ZXIoZ2FtZU9iamVjdCA9PiBnYW1lT2JqZWN0LmlzQWxpdmUoKSk7XG5cdH1cblxuXHRnZXRQbGF5ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGxheWVyO1xuXHR9XG5cblx0c2V0RGVmYXVsdFBsYXllclBhcmFtcyhkZWZhdWx0UGFyYW1zKSB7XG5cdFx0dGhpcy5kZWZhdWx0UGFyYW1zID0gZGVmYXVsdFBhcmFtcztcblx0fVxuXG5cdGNyZWF0ZVBsYXllcih7XG5cdFx0b25DcmVhdGUgPSAoKSA9PiBudWxsLFxuXHRcdG9uS2lsbCA9ICgpID0+IG51bGwsXG5cdFx0b25EYW1hZ2VEZWFsID0gKCkgPT4gbnVsbCxcblx0XHRvbkRhbWFnZVRha2VuID0gKCkgPT4gbnVsbCxcblx0XHRvbkRpZSA9ICgpID0+IG51bGwsXG5cdFx0b25MZXZlbFVwID0gKCkgPT4gbnVsbCxcblx0fSA9IHt9KSB7XG5cdFx0Y29uc3QgZ2FtZU9iamVjdHNTZXJ2aWNlID0gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2U7XG5cblx0XHRyZXR1cm4gdGhpcy5zY2VuZS5tb2RlbHMubG9hZEdMVEYoe1xuXHRcdFx0YmFzZVVybDogJy4vYXNzZXRzL21vZGVscy91bml0cy9wbGF5ZXInLFxuXHRcdFx0Y2FsbGJhY2s6IChsb2FkZWRNb2RlbCkgPT4ge1xuXHRcdFx0XHRjb25zdCBkZWZhdWx0UGFyYW1zID0gdGhpcy5kZWZhdWx0UGFyYW1zO1xuXHRcdFx0XHRsb2FkZWRNb2RlbC5zY2VuZS5wb3NpdGlvbi5zZXQoMCwgMC4xLCAwKTtcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQHR5cGUge1BsYXllcn1cblx0XHRcdFx0ICovXG5cdFx0XHRcdGNvbnN0IHBsYXllciA9IGdhbWVPYmplY3RzU2VydmljZS5ob29rR2FtZU9iamVjdChuZXcgUGxheWVyKHtcblx0XHRcdFx0XHRhbmltYXRpb25zOiBsb2FkZWRNb2RlbC5hbmltYXRpb25zLFxuXHRcdFx0XHRcdG9iamVjdDogbG9hZGVkTW9kZWwuc2NlbmUsXG5cdFx0XHRcdFx0aW5wdXQ6IHRoaXMuc2NlbmUuaW5wdXQsXG5cdFx0XHRcdFx0Y29tcGxleEFuaW1hdGlvbnM6IHRydWUsXG5cdFx0XHRcdFx0Y2hlY2tXYXk6IHRoaXMuc2NlbmUuY29sbGlkZXJzLmNoZWNrV2F5LFxuXHRcdFx0XHRcdG5hbWU6IHRoaXMuc2NlbmUudXNlciA/IHRoaXMuc2NlbmUudXNlci51c2VyTmFtZSA6ICcgJyxcblx0XHRcdFx0XHRvbkRhbWFnZURlYWw6IGRhbWFnZWRVbml0ID0+IG9uRGFtYWdlRGVhbChkYW1hZ2VkVW5pdCksXG5cdFx0XHRcdFx0b25EYW1hZ2VUYWtlbjogKGF0dGFja2VyKSA9PiB7XG5cdFx0XHRcdFx0XHRvbkRhbWFnZVRha2VuKGF0dGFja2VyKTtcblx0XHRcdFx0XHRcdHRoaXMuc2NlbmUucGFydGljbGVzLmxvYWRFZmZlY3Qoe1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbjogcGxheWVyLnBvc2l0aW9uLmNsb25lKCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAuNzUsIDApKVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRvbktpbGw6IChvYmplY3QpID0+IG9uS2lsbChvYmplY3QpLFxuXHRcdFx0XHRcdG9uRGllOiAoa2lsbGVyKSA9PiBvbkRpZShraWxsZXIpLFxuXHRcdFx0XHRcdG9uTGV2ZWxVcDogKCkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zY2VuZS5wYXJ0aWNsZXMuY3JlYXRlRWZmZWN0KHtcblx0XHRcdFx0XHRcdFx0ZWZmZWN0OiAnbGV2ZWwtdXAtYWx0L2xldmVsLXVwJyxcblx0XHRcdFx0XHRcdFx0c2NhbGU6IDEuNSxcblx0XHRcdFx0XHRcdFx0YXR0YWNoVG86IHRoaXMucGxheWVyLm9iamVjdCxcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0b25MZXZlbFVwKCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRhdHRhY2s6ICgpID0+IGdhbWVPYmplY3RzU2VydmljZS5hdHRhY2socGxheWVyKSxcblx0XHRcdFx0XHRmaXJlOiAoKSA9PiBnYW1lT2JqZWN0c1NlcnZpY2UuZmlyZShwbGF5ZXIpLFxuXHRcdFx0XHRcdGRlc3Ryb3k6ICgpID0+IGdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdChwbGF5ZXIpLFxuXHRcdFx0XHR9KSk7XG5cblx0XHRcdFx0dGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XG5cdFx0XHRcdG9uQ3JlYXRlKHBsYXllcik7XG5cblx0XHRcdFx0aWYgKGRlZmF1bHRQYXJhbXMgJiYgZGVmYXVsdFBhcmFtcy5wYXJhbXMpIHtcblx0XHRcdFx0XHRjb25zdCB7IHBvc2l0aW9uLCByb3RhdGlvbiwgcGFyYW1zIH0gPSBkZWZhdWx0UGFyYW1zO1xuXHRcdFx0XHRcdGNvbnN0IHBsYXllclBhcmFtcyA9IHBsYXllci5wYXJhbXM7XG5cblx0XHRcdFx0XHRwbGF5ZXIucG9zaXRpb24uc2V0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuXHRcdFx0XHRcdHBsYXllci5yb3RhdGlvbi5zZXQocm90YXRpb24ueCwgcm90YXRpb24ueSwgcm90YXRpb24ueik7XG5cdFx0XHRcdFx0cGxheWVyUGFyYW1zLmhwID0gcGFyYW1zLmhwO1xuXHRcdFx0XHRcdHBsYXllclBhcmFtcy5ocE1heCA9IHBhcmFtcy5ocE1heDtcblx0XHRcdFx0XHRwbGF5ZXJQYXJhbXMuZnJhY3Rpb24gPSBwYXJhbXMuZnJhY3Rpb247XG5cdFx0XHRcdFx0cGxheWVyUGFyYW1zLmxldmVsID0gcGFyYW1zLmxldmVsO1xuXHRcdFx0XHRcdHBsYXllclBhcmFtcy5kYW1hZ2UgPSBwYXJhbXMuZGFtYWdlO1xuXHRcdFx0XHRcdHBsYXllclBhcmFtcy5zcGVlZCA9IHBhcmFtcy5zcGVlZDtcblx0XHRcdFx0XHRwbGF5ZXJQYXJhbXMuZXhwZXJpZW5jZSA9IHBhcmFtcy5leHBlcmllbmNlO1xuXHRcdFx0XHRcdHBsYXllclBhcmFtcy5tb25leSA9IHBhcmFtcy5tb25leTtcblx0XHRcdFx0XHRwbGF5ZXJQYXJhbXMudW5zcGVudFRhbGVudHMgPSBwYXJhbXMudW5zcGVudFRhbGVudHM7XG5cblx0XHRcdFx0XHRpZiAoIXBsYXllclBhcmFtcy5ocCkge1xuXHRcdFx0XHRcdFx0cGxheWVyLmFuaW1hdGlvblN0YXRlLmlzRGllID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGNyZWF0ZUFJKHsgZnJhY3Rpb24sIGxldmVsLCBwb3NpdGlvbjogeyB4LCB5LCB6IH0sIHJvdGF0aW9uID0ge30sIHNjYWxlLCBvbkRpZSwgbmFtZSB9KSB7XG5cdFx0Y29uc3QgZ2FtZU9iamVjdHNTZXJ2aWNlID0gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2U7XG5cdFx0Y29uc3QgZ2V0UHJpb3JpdHkgPSAodW5pdCwgdGFyZ2V0KSA9PiAoXG5cdFx0XHQodGFyZ2V0IGluc3RhbmNlb2YgUGxheWVyID8gMC43NSA6IDApXG5cdFx0XHQrIDEgLyBNYXRoLmNlaWwodGFyZ2V0LnBvc2l0aW9uLmRpc3RhbmNlVG8odW5pdC5wb3NpdGlvbikpXG5cdFx0KTtcblxuXHRcdHRoaXMuc2NlbmUubW9kZWxzLmxvYWRHTFRGKHtcblx0XHRcdGJhc2VVcmw6IGZyYWN0aW9uID09PSAnZ29hdHMnXG5cdFx0XHRcdD8gJy4vYXNzZXRzL21vZGVscy91bml0cy9nb2F0LXdhcnJpb3InXG5cdFx0XHRcdDogJy4vYXNzZXRzL21vZGVscy91bml0cy9lbmVteScsXG5cdFx0XHRjYWxsYmFjazogKGdsdGYpID0+IHtcblx0XHRcdFx0Y29uc3QgbmV0d29ya0Nvbm5lY3Rpb24gPSB0aGlzLnNjZW5lLmNvbm5lY3Rpb247XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCFuZXR3b3JrQ29ubmVjdGlvblxuXHRcdFx0XHRcdHx8ICFuZXR3b3JrQ29ubmVjdGlvbi5tZXRhXG5cdFx0XHRcdFx0fHwgIW5ldHdvcmtDb25uZWN0aW9uLm1ldGEucm9sZVxuXHRcdFx0XHRcdHx8IG5ldHdvcmtDb25uZWN0aW9uLm1ldGEucm9sZSA9PT0gJ2hvc3QnXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8qKiBAdHlwZSB7QUl9ICovXG5cdFx0XHRcdFx0Y29uc3QgYWkgPSBnYW1lT2JqZWN0c1NlcnZpY2UuaG9va0dhbWVPYmplY3QobmV3IEFJKHtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbnM6IGdsdGYuYW5pbWF0aW9ucyxcblx0XHRcdFx0XHRcdG9iamVjdDogZ2x0Zi5zY2VuZSxcblx0XHRcdFx0XHRcdHNwZWVkOiAwLjM1ICsgbGV2ZWwgKiAwLjAyNSxcblx0XHRcdFx0XHRcdGRhbWFnZTogNSArIGxldmVsICogMS41LFxuXHRcdFx0XHRcdFx0aHA6IDcwICsgbGV2ZWwgKiAzMCxcblx0XHRcdFx0XHRcdGZyYWN0aW9uLFxuXHRcdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRcdGxldmVsLFxuXHRcdFx0XHRcdFx0Y2hlY2tXYXk6IHRoaXMuc2NlbmUuY29sbGlkZXJzLmNoZWNrV2F5LFxuXHRcdFx0XHRcdFx0Z2V0TmV4dFBvaW50OiB0aGlzLnNjZW5lLnBhdGhGaW5kZXIuZ2V0TmV4dFBvaW50LFxuXHRcdFx0XHRcdFx0YXR0YWNrOiAoKSA9PiBnYW1lT2JqZWN0c1NlcnZpY2UuYXR0YWNrKGFpKSxcblx0XHRcdFx0XHRcdG9uRGFtYWdlVGFrZW46ICgpID0+IHRoaXMuc2NlbmUucGFydGljbGVzLmxvYWRFZmZlY3Qoe1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbjogYWkucG9zaXRpb24uY2xvbmUoKS5hZGQobmV3IFRIUkVFLlZlY3RvcjMoMCwgMC43NSwgMCkpXG5cdFx0XHRcdFx0XHR9KSxcblx0XHRcdFx0XHRcdG9uRGllOiAoKSA9PiB0aGlzLnNjZW5lLmludGVydmFscy5zZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKGFpLmlzRGVhZCgpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Z2FtZU9iamVjdHNTZXJ2aWNlLmRlc3Ryb3lHYW1lT2JqZWN0KGFpKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChvbkRpZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b25EaWUoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIDEwMDAwKSxcblx0XHRcdFx0XHRcdGZpbmRUYXJnZXQ6ICgpID0+IHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbmVhckVuZW15VW5pdHMgPSB0aGlzLmdldEFsaXZlVW5pdHMoKVxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIodW5pdCA9PiAoXG5cdFx0XHRcdFx0XHRcdFx0XHR1bml0ICE9PSBhaVxuXHRcdFx0XHRcdFx0XHRcdFx0JiYgdW5pdC5nZXRGcmFjdGlvbigpICE9PSBmcmFjdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0JiYgdW5pdC5wb3NpdGlvbi5kaXN0YW5jZVRvKGFpLnBvc2l0aW9uKSA8IDE1XG5cdFx0XHRcdFx0XHRcdFx0KSlcblx0XHRcdFx0XHRcdFx0XHQuc29ydCgodW5pdEEsIHVuaXRCKSA9PiBnZXRQcmlvcml0eShhaSwgdW5pdEIpIC0gZ2V0UHJpb3JpdHkoYWksIHVuaXRBKSk7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5lYXJFbmVteVVuaXRzLmxlbmd0aCA/IG5lYXJFbmVteVVuaXRzWzBdIDogbnVsbDtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSkpO1xuXG5cdFx0XHRcdFx0YWkucG9zaXRpb24uc2V0KHggfHwgMCwgeSB8fCAwLCB6IHx8IDApO1xuXHRcdFx0XHRcdGFpLnJvdGF0aW9uLnNldChyb3RhdGlvbi54IHx8IDAsIHJvdGF0aW9uLnkgfHwgMCwgcm90YXRpb24ueiB8fCAwKTtcblxuXHRcdFx0XHRcdGlmIChzY2FsZSkge1xuXHRcdFx0XHRcdFx0YWkub2JqZWN0LnNjYWxlLnNldChzY2FsZSwgc2NhbGUsIHNjYWxlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSk7XG5cdH1cblxuXHRjcmVhdGVOZXR3b3JrQUkoXG5cdFx0e1xuXHRcdFx0cGFyYW1zOiB7XG5cdFx0XHRcdGZyYWN0aW9uLFxuXHRcdFx0XHR1bml0TmV0d29ya0lkLFxuXHRcdFx0XHRsZXZlbCxcblx0XHRcdFx0bmFtZSxcblx0XHRcdFx0aHAsXG5cdFx0XHRcdGhwTWF4LFxuXHRcdFx0XHRkYW1hZ2UsXG5cdFx0XHRcdGZyb21OZXR3b3JrID0gdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHBvc2l0aW9uLFxuXHRcdFx0b25EaWVcblx0XHR9LFxuXHRcdGNhbGxiYWNrID0gKCkgPT4ge1xuXHRcdH0sXG5cdCkge1xuXHRcdGNvbnN0IGdhbWVPYmplY3RzU2VydmljZSA9IHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlO1xuXHRcdGNvbnN0IGdldFByaW9yaXR5ID0gKHVuaXQsIHRhcmdldCkgPT4gKFxuXHRcdFx0KHRhcmdldCBpbnN0YW5jZW9mIFBsYXllciA/IDAuNzUgOiAwKVxuXHRcdFx0KyAxIC8gTWF0aC5jZWlsKHRhcmdldC5wb3NpdGlvbi5kaXN0YW5jZVRvKHVuaXQucG9zaXRpb24pKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcy5zY2VuZS5tb2RlbHMubG9hZEdMVEYoe1xuXHRcdFx0YmFzZVVybDogZnJhY3Rpb24gPT09ICdnb2F0cydcblx0XHRcdFx0PyAnLi9hc3NldHMvbW9kZWxzL3VuaXRzL2dvYXQtd2Fycmlvcidcblx0XHRcdFx0OiAnLi9hc3NldHMvbW9kZWxzL3VuaXRzL2VuZW15Jyxcblx0XHRcdGNhbGxiYWNrOiAobG9hZGVkT2JqZWN0KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGFpID0gZ2FtZU9iamVjdHNTZXJ2aWNlLmhvb2tHYW1lT2JqZWN0KG5ldyBBSSh7XG5cdFx0XHRcdFx0b2JqZWN0OiBsb2FkZWRPYmplY3Quc2NlbmUsXG5cdFx0XHRcdFx0YW5pbWF0aW9uczogbG9hZGVkT2JqZWN0LmFuaW1hdGlvbnMsXG5cdFx0XHRcdFx0dW5pdE5ldHdvcmtJZCxcblx0XHRcdFx0XHRmcmFjdGlvbixcblx0XHRcdFx0XHRsZXZlbCxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGhwLFxuXHRcdFx0XHRcdGhwTWF4LFxuXHRcdFx0XHRcdGRhbWFnZSxcblx0XHRcdFx0XHRmcm9tTmV0d29yayxcblx0XHRcdFx0XHRjaGVja1dheTogdGhpcy5zY2VuZS5jb2xsaWRlcnMuY2hlY2tXYXksXG5cdFx0XHRcdFx0Z2V0TmV4dFBvaW50OiB0aGlzLnNjZW5lLnBhdGhGaW5kZXIuZ2V0TmV4dFBvaW50LFxuXHRcdFx0XHRcdGF0dGFjazogKCkgPT4gZ2FtZU9iamVjdHNTZXJ2aWNlLmF0dGFjayhhaSksXG5cdFx0XHRcdFx0b25EYW1hZ2VUYWtlbjogKCkgPT4gdGhpcy5zY2VuZS5wYXJ0aWNsZXMubG9hZEVmZmVjdCh7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogYWkucG9zaXRpb24uY2xvbmUoKS5hZGQobmV3IFRIUkVFLlZlY3RvcjMoMCwgMC43NSwgMCkpXG5cdFx0XHRcdFx0fSksXG5cblx0XHRcdFx0XHRvbkRpZTogKCkgPT4gdGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoYWkuaXNEZWFkKCkpIHtcblx0XHRcdFx0XHRcdFx0Z2FtZU9iamVjdHNTZXJ2aWNlLmRlc3Ryb3lHYW1lT2JqZWN0KGFpKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIWFpLnBhcmFtcy5mcm9tTmV0d29yaykge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuY3JlYXRlTmV0d29ya0FJKHtcblx0XHRcdFx0XHRcdFx0XHRcdGZyYWN0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdFx0dW5pdE5ldHdvcmtJZCxcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRocCxcblx0XHRcdFx0XHRcdFx0XHRcdGhwTWF4LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZGFtYWdlLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZnJvbU5ldHdvcms6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdFx0bGV2ZWw6IGxldmVsICsgMSArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGxldmVsKSxcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIDEwMDAwKSxcblx0XHRcdFx0XHRmaW5kVGFyZ2V0OiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoIWFpLnBhcmFtcy5mcm9tTmV0d29yaykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBuZWFyRW5lbXlVbml0cyA9IHRoaXMuZ2V0QWxpdmVVbml0cygpXG5cdFx0XHRcdFx0XHRcdFx0LmZpbHRlcih1bml0ID0+IChcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXQgIT09IGFpXG5cdFx0XHRcdFx0XHRcdFx0XHQmJiB1bml0LmdldEZyYWN0aW9uKCkgIT09IGZyYWN0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHQmJiB1bml0LnBvc2l0aW9uLmRpc3RhbmNlVG8oYWkucG9zaXRpb24pIDwgMTVcblx0XHRcdFx0XHRcdFx0XHQpKVxuXHRcdFx0XHRcdFx0XHRcdC5zb3J0KCh1bml0QSwgdW5pdEIpID0+IGdldFByaW9yaXR5KGFpLCB1bml0QikgLSBnZXRQcmlvcml0eShhaSwgdW5pdEEpKTtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmVhckVuZW15VW5pdHMubGVuZ3RoID8gbmVhckVuZW15VW5pdHNbMF0gOiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pKTtcblxuXG5cdFx0XHRcdGNhbGxiYWNrKGFpKTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cdH1cblxuXHRjcmVhdGVOZXR3b3JrUGxheWVyKHtcblx0XHRwYXJhbXM6IHsgY29ubmVjdGlvbklkLCB1bml0TmV0d29ya0lkLCBuYW1lIH0sXG5cdFx0b25EYW1hZ2VEZWFsLFxuXHRcdG9uS2lsbCxcblx0XHRvbkRpZSxcblx0XHRvbkxldmVsVXAsXG5cdFx0b25EYW1hZ2VUYWtlbixcblx0fSwgY2FsbGJhY2spIHtcblx0XHRjb25zdCBnYW1lT2JqZWN0c1NlcnZpY2UgPSB0aGlzLnNjZW5lLmdhbWVPYmplY3RzU2VydmljZTtcblxuXHRcdHJldHVybiB0aGlzLnNjZW5lLm1vZGVscy5sb2FkR0xURih7XG5cdFx0XHRiYXNlVXJsOiAnLi9hc3NldHMvbW9kZWxzL3VuaXRzL25ldHdvcmstcGxheWVyJyxcblx0XHRcdGNhbGxiYWNrOiAobG9hZGVkT2JqZWN0KSA9PiB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7UGxheWVyfSAqL1xuXHRcdFx0XHRjb25zdCBwbGF5ZXIgPSBnYW1lT2JqZWN0c1NlcnZpY2UuaG9va0dhbWVPYmplY3QobmV3IFBsYXllcih7XG5cdFx0XHRcdFx0b2JqZWN0OiBsb2FkZWRPYmplY3Quc2NlbmUsXG5cdFx0XHRcdFx0YW5pbWF0aW9uczogbG9hZGVkT2JqZWN0LmFuaW1hdGlvbnMsXG5cdFx0XHRcdFx0dW5pdE5ldHdvcmtJZCxcblx0XHRcdFx0XHRjb25uZWN0aW9uSWQsXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRmcm9tTmV0d29yazogdHJ1ZSxcblx0XHRcdFx0XHRjb21wbGV4QW5pbWF0aW9uczogdHJ1ZSxcblx0XHRcdFx0XHRjaGVja1dheTogdGhpcy5zY2VuZS5jb2xsaWRlcnMuY2hlY2tXYXksXG5cdFx0XHRcdFx0aW5wdXQ6IHtcblx0XHRcdFx0XHRcdHZlcnRpY2FsOiAwLFxuXHRcdFx0XHRcdFx0aG9yaXpvbnRhbDogMCxcblx0XHRcdFx0XHRcdGp1bXA6IGZhbHNlLFxuXHRcdFx0XHRcdFx0Y3Vyc29yOiB7XG5cdFx0XHRcdFx0XHRcdHg6IDAsXG5cdFx0XHRcdFx0XHRcdHk6IDAsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0bG9vazoge1xuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNhbDogMCxcblx0XHRcdFx0XHRcdFx0aG9yaXpvbnRhbDogMCxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRvbkRpZTogKGtpbGxlcikgPT4gdGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAocGxheWVyLmlzRGVhZCgpKSB7XG5cdFx0XHRcdFx0XHRcdGdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdChwbGF5ZXIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b25EaWUgJiYgb25EaWUoa2lsbGVyKVxuXHRcdFx0XHRcdH0sIDEwMDAwKSxcblx0XHRcdFx0XHRvbkRhbWFnZURlYWw6IGRhbWFnZWRVbml0ID0+IG9uRGFtYWdlRGVhbCAmJiBvbkRhbWFnZURlYWwoZGFtYWdlZFVuaXQpLFxuXHRcdFx0XHRcdG9uRGFtYWdlVGFrZW46IChhdHRhY2tlcikgPT4ge1xuXHRcdFx0XHRcdFx0b25EYW1hZ2VUYWtlbiAmJiBvbkRhbWFnZVRha2VuKGF0dGFja2VyKTtcblx0XHRcdFx0XHRcdHRoaXMuc2NlbmUucGFydGljbGVzLmxvYWRFZmZlY3Qoe1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbjogcGxheWVyLnBvc2l0aW9uLmNsb25lKCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAuNzUsIDApKVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRvbktpbGw6IChvYmplY3QpID0+IG9uS2lsbCAmJiBvbktpbGwob2JqZWN0KSxcblx0XHRcdFx0XHRvbkxldmVsVXA6ICgpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2NlbmUucGFydGljbGVzLmNyZWF0ZUVmZmVjdCh7XG5cdFx0XHRcdFx0XHRcdGVmZmVjdDogJ2xldmVsLXVwLWFsdC9sZXZlbC11cCcsXG5cdFx0XHRcdFx0XHRcdHNjYWxlOiAxLjUsXG5cdFx0XHRcdFx0XHRcdGF0dGFjaFRvOiB0aGlzLnBsYXllci5vYmplY3QsXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdG9uTGV2ZWxVcCAmJiBvbkxldmVsVXAoKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGF0dGFjazogKCkgPT4gZ2FtZU9iamVjdHNTZXJ2aWNlLmF0dGFjayhwbGF5ZXIpLFxuXHRcdFx0XHRcdGZpcmU6ICgpID0+IGdhbWVPYmplY3RzU2VydmljZS5maXJlKHBsYXllciksXG5cdFx0XHRcdFx0ZGVzdHJveTogKCkgPT4gZ2FtZU9iamVjdHNTZXJ2aWNlLmRlc3Ryb3lHYW1lT2JqZWN0KHBsYXllciksXG5cdFx0XHRcdH0pKTtcblxuXHRcdFx0XHRjYWxsYmFjayhwbGF5ZXIpO1xuXHRcdFx0fSxcblx0XHR9KTtcblx0fVxufSIsIi8vIGphdmFzY3JpcHQtYXN0YXIgMC40LjFcbi8vIGh0dHA6Ly9naXRodWIuY29tL2Jncmlucy9qYXZhc2NyaXB0LWFzdGFyXG4vLyBGcmVlbHkgZGlzdHJpYnV0YWJsZSB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4vLyBJbXBsZW1lbnRzIHRoZSBhc3RhciBzZWFyY2ggYWxnb3JpdGhtIGluIGphdmFzY3JpcHQgdXNpbmcgYSBCaW5hcnkgSGVhcC5cbi8vIEluY2x1ZGVzIEJpbmFyeSBIZWFwICh3aXRoIG1vZGlmaWNhdGlvbnMpIGZyb20gTWFyaWpuIEhhdmVyYmVrZS5cbi8vIGh0dHA6Ly9lbG9xdWVudGphdmFzY3JpcHQubmV0L2FwcGVuZGl4Mi5odG1sXG4oZnVuY3Rpb24oZGVmaW5pdGlvbikge1xuICAgIC8qIGdsb2JhbCBtb2R1bGUsIGRlZmluZSAqL1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgICAgIHdpbmRvdy5hc3RhciA9IGV4cG9ydHMuYXN0YXI7XG4gICAgICAgIHdpbmRvdy5HcmFwaCA9IGV4cG9ydHMuR3JhcGg7XG4gICAgfVxufSkoZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBwYXRoVG8obm9kZSkge1xuICAgICAgICB2YXIgY3VyciA9IG5vZGU7XG4gICAgICAgIHZhciBwYXRoID0gW107XG4gICAgICAgIHdoaWxlIChjdXJyLnBhcmVudCkge1xuICAgICAgICAgICAgcGF0aC51bnNoaWZ0KGN1cnIpO1xuICAgICAgICAgICAgY3VyciA9IGN1cnIucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEhlYXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5SGVhcChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5mO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYXN0YXIgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIGFuIEEqIFNlYXJjaCBvbiBhIGdyYXBoIGdpdmVuIGEgc3RhcnQgYW5kIGVuZCBub2RlLlxuICAgICAgICAgKiBAcGFyYW0ge0dyYXBofSBncmFwaFxuICAgICAgICAgKiBAcGFyYW0ge0dyaWROb2RlfSBzdGFydFxuICAgICAgICAgKiBAcGFyYW0ge0dyaWROb2RlfSBlbmRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IFtvcHRpb25zLmNsb3Nlc3RdIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAgICAgICAgIHBhdGggdG8gdGhlIGNsb3Nlc3Qgbm9kZSBpZiB0aGUgdGFyZ2V0IGlzIHVucmVhY2hhYmxlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oZXVyaXN0aWNdIEhldXJpc3RpYyBmdW5jdGlvbiAoc2VlXG4gICAgICAgICAqICAgICAgICAgIGFzdGFyLmhldXJpc3RpY3MpLlxuICAgICAgICAgKi9cbiAgICAgICAgc2VhcmNoOiBmdW5jdGlvbihncmFwaCwgc3RhcnQsIGVuZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgZ3JhcGguY2xlYW5EaXJ0eSgpO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgaGV1cmlzdGljID0gb3B0aW9ucy5oZXVyaXN0aWMgfHwgYXN0YXIuaGV1cmlzdGljcy5tYW5oYXR0YW47XG4gICAgICAgICAgICB2YXIgY2xvc2VzdCA9IG9wdGlvbnMuY2xvc2VzdCB8fCBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIG9wZW5IZWFwID0gZ2V0SGVhcCgpO1xuICAgICAgICAgICAgdmFyIGNsb3Nlc3ROb2RlID0gc3RhcnQ7IC8vIHNldCB0aGUgc3RhcnQgbm9kZSB0byBiZSB0aGUgY2xvc2VzdCBpZiByZXF1aXJlZFxuXG4gICAgICAgICAgICBzdGFydC5oID0gaGV1cmlzdGljKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgZ3JhcGgubWFya0RpcnR5KHN0YXJ0KTtcblxuICAgICAgICAgICAgb3BlbkhlYXAucHVzaChzdGFydCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChvcGVuSGVhcC5zaXplKCkgPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBHcmFiIHRoZSBsb3dlc3QgZih4KSB0byBwcm9jZXNzIG5leHQuICBIZWFwIGtlZXBzIHRoaXMgc29ydGVkIGZvciB1cy5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBvcGVuSGVhcC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIC8vIEVuZCBjYXNlIC0tIHJlc3VsdCBoYXMgYmVlbiBmb3VuZCwgcmV0dXJuIHRoZSB0cmFjZWQgcGF0aC5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgPT09IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFRvKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgY2FzZSAtLSBtb3ZlIGN1cnJlbnROb2RlIGZyb20gb3BlbiB0byBjbG9zZWQsIHByb2Nlc3MgZWFjaCBvZiBpdHMgbmVpZ2hib3JzLlxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmNsb3NlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCBuZWlnaGJvcnMgZm9yIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICAgICAgICAgICAgdmFyIG5laWdoYm9ycyA9IGdyYXBoLm5laWdoYm9ycyhjdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBuZWlnaGJvcnMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5laWdoYm9yLmNsb3NlZCB8fCBuZWlnaGJvci5pc1dhbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdmFsaWQgbm9kZSB0byBwcm9jZXNzLCBza2lwIHRvIG5leHQgbmVpZ2hib3IuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBnIHNjb3JlIGlzIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSBmcm9tIHN0YXJ0IHRvIGN1cnJlbnQgbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGUgcGF0aCB3ZSBoYXZlIGFycml2ZWQgYXQgdGhpcyBuZWlnaGJvciBpcyB0aGUgc2hvcnRlc3Qgb25lIHdlIGhhdmUgc2VlbiB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBnU2NvcmUgPSBjdXJyZW50Tm9kZS5nICsgbmVpZ2hib3IuZ2V0Q29zdChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZWVuVmlzaXRlZCA9IG5laWdoYm9yLnZpc2l0ZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZWVuVmlzaXRlZCB8fCBnU2NvcmUgPCBuZWlnaGJvci5nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGFuIG9wdGltYWwgKHNvIGZhcikgcGF0aCB0byB0aGlzIG5vZGUuICBUYWtlIHNjb3JlIGZvciBub2RlIHRvIHNlZSBob3cgZ29vZCBpdCBpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvci5oID0gbmVpZ2hib3IuaCB8fCBoZXVyaXN0aWMobmVpZ2hib3IsIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvci5nID0gZ1Njb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IuZiA9IG5laWdoYm9yLmcgKyBuZWlnaGJvci5oO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGgubWFya0RpcnR5KG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5laWdoYm91ciBpcyBjbG9zZXIgdGhhbiB0aGUgY3VycmVudCBjbG9zZXN0Tm9kZSBvciBpZiBpdCdzIGVxdWFsbHkgY2xvc2UgYnV0IGhhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgY2hlYXBlciBwYXRoIHRoYW4gdGhlIGN1cnJlbnQgY2xvc2VzdCBub2RlIHRoZW4gaXQgYmVjb21lcyB0aGUgY2xvc2VzdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5laWdoYm9yLmggPCBjbG9zZXN0Tm9kZS5oIHx8IChuZWlnaGJvci5oID09PSBjbG9zZXN0Tm9kZS5oICYmIG5laWdoYm9yLmcgPCBjbG9zZXN0Tm9kZS5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0Tm9kZSA9IG5laWdoYm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiZWVuVmlzaXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2hpbmcgdG8gaGVhcCB3aWxsIHB1dCBpdCBpbiBwcm9wZXIgcGxhY2UgYmFzZWQgb24gdGhlICdmJyB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuSGVhcC5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBzZWVuIHRoZSBub2RlLCBidXQgc2luY2UgaXQgaGFzIGJlZW4gcmVzY29yZWQgd2UgbmVlZCB0byByZW9yZGVyIGl0IGluIHRoZSBoZWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkhlYXAucmVzY29yZUVsZW1lbnQobmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2xvc2VzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoVG8oY2xvc2VzdE5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyByZXN1bHQgd2FzIGZvdW5kIC0gZW1wdHkgYXJyYXkgc2lnbmlmaWVzIGZhaWx1cmUgdG8gZmluZCBwYXRoLlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTZWUgbGlzdCBvZiBoZXVyaXN0aWNzOiBodHRwOi8vdGhlb3J5LnN0YW5mb3JkLmVkdS9+YW1pdHAvR2FtZVByb2dyYW1taW5nL0hldXJpc3RpY3MuaHRtbFxuICAgICAgICBoZXVyaXN0aWNzOiB7XG4gICAgICAgICAgICBtYW5oYXR0YW46IGZ1bmN0aW9uKHBvczAsIHBvczEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZDEgPSBNYXRoLmFicyhwb3MxLnggLSBwb3MwLngpO1xuICAgICAgICAgICAgICAgIHZhciBkMiA9IE1hdGguYWJzKHBvczEueSAtIHBvczAueSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQxICsgZDI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlhZ29uYWw6IGZ1bmN0aW9uKHBvczAsIHBvczEpIHtcbiAgICAgICAgICAgICAgICB2YXIgRCA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIEQyID0gTWF0aC5zcXJ0KDIpO1xuICAgICAgICAgICAgICAgIHZhciBkMSA9IE1hdGguYWJzKHBvczEueCAtIHBvczAueCk7XG4gICAgICAgICAgICAgICAgdmFyIGQyID0gTWF0aC5hYnMocG9zMS55IC0gcG9zMC55KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKEQgKiAoZDEgKyBkMikpICsgKChEMiAtICgyICogRCkpICogTWF0aC5taW4oZDEsIGQyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFuTm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgbm9kZS5mID0gMDtcbiAgICAgICAgICAgIG5vZGUuZyA9IDA7XG4gICAgICAgICAgICBub2RlLmggPSAwO1xuICAgICAgICAgICAgbm9kZS52aXNpdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBub2RlLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZ3JhcGggbWVtb3J5IHN0cnVjdHVyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGdyaWRJbiAyRCBhcnJheSBvZiBpbnB1dCB3ZWlnaHRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW29wdGlvbnMuZGlhZ29uYWxdIFNwZWNpZmllcyB3aGV0aGVyIGRpYWdvbmFsIG1vdmVzIGFyZSBhbGxvd2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gR3JhcGgoZ3JpZEluLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMuZGlhZ29uYWwgPSAhIW9wdGlvbnMuZGlhZ29uYWw7XG4gICAgICAgIHRoaXMuZ3JpZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGdyaWRJbi5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgdGhpcy5ncmlkW3hdID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwLCByb3cgPSBncmlkSW5beF07IHkgPCByb3cubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBHcmlkTm9kZSh4LCB5LCByb3dbeV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFt4XVt5XSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIEdyYXBoLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlydHlOb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFzdGFyLmNsZWFuTm9kZSh0aGlzLm5vZGVzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBHcmFwaC5wcm90b3R5cGUuY2xlYW5EaXJ0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlydHlOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXN0YXIuY2xlYW5Ob2RlKHRoaXMuZGlydHlOb2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eU5vZGVzID0gW107XG4gICAgfTtcblxuICAgIEdyYXBoLnByb3RvdHlwZS5tYXJrRGlydHkgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMuZGlydHlOb2Rlcy5wdXNoKG5vZGUpO1xuICAgIH07XG5cbiAgICBHcmFwaC5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIHZhciB4ID0gbm9kZS54O1xuICAgICAgICB2YXIgeSA9IG5vZGUueTtcbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQ7XG5cbiAgICAgICAgLy8gV2VzdFxuICAgICAgICBpZiAoZ3JpZFt4IC0gMV0gJiYgZ3JpZFt4IC0gMV1beV0pIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGdyaWRbeCAtIDFdW3ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVhc3RcbiAgICAgICAgaWYgKGdyaWRbeCArIDFdICYmIGdyaWRbeCArIDFdW3ldKSB7XG4gICAgICAgICAgICByZXQucHVzaChncmlkW3ggKyAxXVt5XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb3V0aFxuICAgICAgICBpZiAoZ3JpZFt4XSAmJiBncmlkW3hdW3kgLSAxXSkge1xuICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4XVt5IC0gMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9ydGhcbiAgICAgICAgaWYgKGdyaWRbeF0gJiYgZ3JpZFt4XVt5ICsgMV0pIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGdyaWRbeF1beSArIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRpYWdvbmFsKSB7XG4gICAgICAgICAgICAvLyBTb3V0aHdlc3RcbiAgICAgICAgICAgIGlmIChncmlkW3ggLSAxXSAmJiBncmlkW3ggLSAxXVt5IC0gMV0pIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChncmlkW3ggLSAxXVt5IC0gMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTb3V0aGVhc3RcbiAgICAgICAgICAgIGlmIChncmlkW3ggKyAxXSAmJiBncmlkW3ggKyAxXVt5IC0gMV0pIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChncmlkW3ggKyAxXVt5IC0gMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3J0aHdlc3RcbiAgICAgICAgICAgIGlmIChncmlkW3ggLSAxXSAmJiBncmlkW3ggLSAxXVt5ICsgMV0pIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChncmlkW3ggLSAxXVt5ICsgMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3J0aGVhc3RcbiAgICAgICAgICAgIGlmIChncmlkW3ggKyAxXSAmJiBncmlkW3ggKyAxXVt5ICsgMV0pIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChncmlkW3ggKyAxXVt5ICsgMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgR3JhcGgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmFwaFN0cmluZyA9IFtdO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmdyaWQ7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbm9kZXMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIHZhciByb3dEZWJ1ZyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJvdyA9IG5vZGVzW3hdO1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCByb3cubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICAgICAgICByb3dEZWJ1Zy5wdXNoKHJvd1t5XS53ZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhcGhTdHJpbmcucHVzaChyb3dEZWJ1Zy5qb2luKFwiIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoU3RyaW5nLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEdyaWROb2RlKHgsIHksIHdlaWdodCkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLndlaWdodCA9IHdlaWdodDtcbiAgICB9XG5cbiAgICBHcmlkTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgdGhpcy54ICsgXCIgXCIgKyB0aGlzLnkgKyBcIl1cIjtcbiAgICB9O1xuXG4gICAgR3JpZE5vZGUucHJvdG90eXBlLmdldENvc3QgPSBmdW5jdGlvbihmcm9tTmVpZ2hib3IpIHtcbiAgICAgICAgLy8gVGFrZSBkaWFnb25hbCB3ZWlnaHQgaW50byBjb25zaWRlcmF0aW9uLlxuICAgICAgICBpZiAoZnJvbU5laWdoYm9yICYmIGZyb21OZWlnaGJvci54ICE9IHRoaXMueCAmJiBmcm9tTmVpZ2hib3IueSAhPSB0aGlzLnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlaWdodCAqIDEuNDE0MjE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2VpZ2h0O1xuICAgIH07XG5cbiAgICBHcmlkTm9kZS5wcm90b3R5cGUuaXNXYWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlaWdodCA9PT0gMDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQmluYXJ5SGVhcChzY29yZUZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgICAgICB0aGlzLnNjb3JlRnVuY3Rpb24gPSBzY29yZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIEJpbmFyeUhlYXAucHJvdG90eXBlID0ge1xuICAgICAgICBwdXNoOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5ldyBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIEFsbG93IGl0IHRvIHNpbmsgZG93bi5cbiAgICAgICAgICAgIHRoaXMuc2lua0Rvd24odGhpcy5jb250ZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICBwb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGZpcnN0IGVsZW1lbnQgc28gd2UgY2FuIHJldHVybiBpdCBsYXRlci5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRbMF07XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5jb250ZW50LnBvcCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFueSBlbGVtZW50cyBsZWZ0LCBwdXQgdGhlIGVuZCBlbGVtZW50IGF0IHRoZVxuICAgICAgICAgICAgLy8gc3RhcnQsIGFuZCBsZXQgaXQgYnViYmxlIHVwLlxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50WzBdID0gZW5kO1xuICAgICAgICAgICAgICAgIHRoaXMuYnViYmxlVXAoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5jb250ZW50LmluZGV4T2Yobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gaXQgaXMgZm91bmQsIHRoZSBwcm9jZXNzIHNlZW4gaW4gJ3BvcCcgaXMgcmVwZWF0ZWRcbiAgICAgICAgICAgIC8vIHRvIGZpbGwgdXAgdGhlIGhvbGUuXG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5jb250ZW50LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoaSAhPT0gdGhpcy5jb250ZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbaV0gPSBlbmQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zY29yZUZ1bmN0aW9uKGVuZCkgPCB0aGlzLnNjb3JlRnVuY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaW5rRG93bihpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1YmJsZVVwKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzY29yZUVsZW1lbnQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2lua0Rvd24odGhpcy5jb250ZW50LmluZGV4T2Yobm9kZSkpO1xuICAgICAgICB9LFxuICAgICAgICBzaW5rRG93bjogZnVuY3Rpb24obikge1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIGVsZW1lbnQgdGhhdCBoYXMgdG8gYmUgc3Vuay5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250ZW50W25dO1xuXG4gICAgICAgICAgICAvLyBXaGVuIGF0IDAsIGFuIGVsZW1lbnQgY2FuIG5vdCBzaW5rIGFueSBmdXJ0aGVyLlxuICAgICAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBwYXJlbnQgZWxlbWVudCdzIGluZGV4LCBhbmQgZmV0Y2ggaXQuXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudE4gPSAoKG4gKyAxKSA+PiAxKSAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuY29udGVudFtwYXJlbnROXTtcbiAgICAgICAgICAgICAgICAvLyBTd2FwIHRoZSBlbGVtZW50cyBpZiB0aGUgcGFyZW50IGlzIGdyZWF0ZXIuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NvcmVGdW5jdGlvbihlbGVtZW50KSA8IHRoaXMuc2NvcmVGdW5jdGlvbihwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtwYXJlbnROXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtuXSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlICduJyB0byBjb250aW51ZSBhdCB0aGUgbmV3IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICBuID0gcGFyZW50TjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYSBwYXJlbnQgdGhhdCBpcyBsZXNzLCBubyBuZWVkIHRvIHNpbmsgYW55IGZ1cnRoZXIuXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYnViYmxlVXA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIC8vIExvb2sgdXAgdGhlIHRhcmdldCBlbGVtZW50IGFuZCBpdHMgc2NvcmUuXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250ZW50W25dO1xuICAgICAgICAgICAgdmFyIGVsZW1TY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihlbGVtZW50KTtcblxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBpbmRpY2VzIG9mIHRoZSBjaGlsZCBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQyTiA9IChuICsgMSkgPDwgMTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQxTiA9IGNoaWxkMk4gLSAxO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LCBpZiBhbnkuXG4gICAgICAgICAgICAgICAgdmFyIHN3YXAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZDFTY29yZTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgY2hpbGQgZXhpc3RzIChpcyBpbnNpZGUgdGhlIGFycmF5KS4uLlxuICAgICAgICAgICAgICAgIGlmIChjaGlsZDFOIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2sgaXQgdXAgYW5kIGNvbXB1dGUgaXRzIHNjb3JlLlxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQxID0gdGhpcy5jb250ZW50W2NoaWxkMU5dO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZDFTY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihjaGlsZDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzY29yZSBpcyBsZXNzIHRoYW4gb3VyIGVsZW1lbnQncywgd2UgbmVlZCB0byBzd2FwLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQxU2NvcmUgPCBlbGVtU2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YXAgPSBjaGlsZDFOO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRG8gdGhlIHNhbWUgY2hlY2tzIGZvciB0aGUgb3RoZXIgY2hpbGQuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkMk4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkMiA9IHRoaXMuY29udGVudFtjaGlsZDJOXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkMlNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGNoaWxkMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZDJTY29yZSA8IChzd2FwID09PSBudWxsID8gZWxlbVNjb3JlIDogY2hpbGQxU2NvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FwID0gY2hpbGQyTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IG5lZWRzIHRvIGJlIG1vdmVkLCBzd2FwIGl0LCBhbmQgY29udGludWUuXG4gICAgICAgICAgICAgICAgaWYgKHN3YXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W25dID0gdGhpcy5jb250ZW50W3N3YXBdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbc3dhcF0gPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBuID0gc3dhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGFzdGFyOiBhc3RhcixcbiAgICAgICAgR3JhcGg6IEdyYXBoXG4gICAgfTtcbn0pOyIsImltcG9ydCBTZXJ2ZXIgZnJvbSAnLi9zdGFuZGFsb25lLXNlcnZlcic7XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBTZXJ2ZXIoKTtcbiIsIi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxudmFyIF9sdXQgPSBbXTtcblxuZm9yICggdmFyIGkgPSAwOyBpIDwgMjU2OyBpICsrICkge1xuXG5cdF9sdXRbIGkgXSA9ICggaSA8IDE2ID8gJzAnIDogJycgKSArICggaSApLnRvU3RyaW5nKCAxNiApO1xuXG59XG5cbnZhciBfTWF0aCA9IHtcblxuXHRERUcyUkFEOiBNYXRoLlBJIC8gMTgwLFxuXHRSQUQyREVHOiAxODAgLyBNYXRoLlBJLFxuXG5cdGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XG5cblx0XHR2YXIgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdFx0dmFyIGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRcdHZhciBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0XHR2YXIgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdFx0dmFyIHV1aWQgPSBfbHV0WyBkMCAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDggJiAweGZmIF0gKyBfbHV0WyBkMCA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDI0ICYgMHhmZiBdICsgJy0nICtcblx0XHRcdF9sdXRbIGQxICYgMHhmZiBdICsgX2x1dFsgZDEgPj4gOCAmIDB4ZmYgXSArICctJyArIF9sdXRbIGQxID4+IDE2ICYgMHgwZiB8IDB4NDAgXSArIF9sdXRbIGQxID4+IDI0ICYgMHhmZiBdICsgJy0nICtcblx0XHRcdF9sdXRbIGQyICYgMHgzZiB8IDB4ODAgXSArIF9sdXRbIGQyID4+IDggJiAweGZmIF0gKyAnLScgKyBfbHV0WyBkMiA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQyID4+IDI0ICYgMHhmZiBdICtcblx0XHRcdF9sdXRbIGQzICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gOCAmIDB4ZmYgXSArIF9sdXRbIGQzID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gMjQgJiAweGZmIF07XG5cblx0XHQvLyAudG9VcHBlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG5cdFx0cmV0dXJuIHV1aWQudG9VcHBlckNhc2UoKTtcblxuXHR9LFxuXG5cdGNsYW1wOiBmdW5jdGlvbiAoIHZhbHVlLCBtaW4sIG1heCApIHtcblxuXHRcdHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCB2YWx1ZSApICk7XG5cblx0fSxcblxuXHQvLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cblx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuXG5cdGV1Y2xpZGVhbk1vZHVsbzogZnVuY3Rpb24gKCBuLCBtICkge1xuXG5cdFx0cmV0dXJuICggKCBuICUgbSApICsgbSApICUgbTtcblxuXHR9LFxuXG5cdC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cblxuXHRtYXBMaW5lYXI6IGZ1bmN0aW9uICggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XG5cblx0XHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxuXHR9LFxuXG5cdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9pbnRlcnBvbGF0aW9uXG5cblx0bGVycDogZnVuY3Rpb24gKCB4LCB5LCB0ICkge1xuXG5cdFx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcblxuXHR9LFxuXG5cdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxuXG5cdHNtb290aHN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRcdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XG5cblx0fSxcblxuXHRzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRcdHJldHVybiB4ICogeCAqIHggKiAoIHggKiAoIHggKiA2IC0gMTUgKSArIDEwICk7XG5cblx0fSxcblxuXHQvLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cblx0cmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cblx0XHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xuXG5cdH0sXG5cblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuXHRyYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG5cdFx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxuXHR9LFxuXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcblxuXHRyYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uICggcmFuZ2UgKSB7XG5cblx0XHRyZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcblxuXHR9LFxuXG5cdGRlZ1RvUmFkOiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XG5cblx0XHRyZXR1cm4gZGVncmVlcyAqIF9NYXRoLkRFRzJSQUQ7XG5cblx0fSxcblxuXHRyYWRUb0RlZzogZnVuY3Rpb24gKCByYWRpYW5zICkge1xuXG5cdFx0cmV0dXJuIHJhZGlhbnMgKiBfTWF0aC5SQUQyREVHO1xuXG5cdH0sXG5cblx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cblx0fSxcblxuXHRjZWlsUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5jZWlsKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcblxuXHR9LFxuXG5cdGZsb29yUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5mbG9vciggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cblx0fVxuXG59O1xuXG5cbmV4cG9ydCB7IF9NYXRoIH07XG4iLCIvKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gKi9cblxuaW1wb3J0IHsgX01hdGggfSBmcm9tICcuL01hdGguanMnO1xuXG5mdW5jdGlvbiBRdWF0ZXJuaW9uKCB4LCB5LCB6LCB3ICkge1xuXG5cdHRoaXMuX3ggPSB4IHx8IDA7XG5cdHRoaXMuX3kgPSB5IHx8IDA7XG5cdHRoaXMuX3ogPSB6IHx8IDA7XG5cdHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggUXVhdGVybmlvbiwge1xuXG5cdHNsZXJwOiBmdW5jdGlvbiAoIHFhLCBxYiwgcW0sIHQgKSB7XG5cblx0XHRyZXR1cm4gcW0uY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcblxuXHR9LFxuXG5cdHNsZXJwRmxhdDogZnVuY3Rpb24gKCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCApIHtcblxuXHRcdC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cblxuXHRcdHZhciB4MCA9IHNyYzBbIHNyY09mZnNldDAgKyAwIF0sXG5cdFx0XHR5MCA9IHNyYzBbIHNyY09mZnNldDAgKyAxIF0sXG5cdFx0XHR6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF0sXG5cdFx0XHR3MCA9IHNyYzBbIHNyY09mZnNldDAgKyAzIF0sXG5cblx0XHRcdHgxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDAgXSxcblx0XHRcdHkxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDEgXSxcblx0XHRcdHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXSxcblx0XHRcdHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcblxuXHRcdGlmICggdzAgIT09IHcxIHx8IHgwICE9PSB4MSB8fCB5MCAhPT0geTEgfHwgejAgIT09IHoxICkge1xuXG5cdFx0XHR2YXIgcyA9IDEgLSB0LFxuXG5cdFx0XHRcdGNvcyA9IHgwICogeDEgKyB5MCAqIHkxICsgejAgKiB6MSArIHcwICogdzEsXG5cblx0XHRcdFx0ZGlyID0gKCBjb3MgPj0gMCA/IDEgOiAtIDEgKSxcblx0XHRcdFx0c3FyU2luID0gMSAtIGNvcyAqIGNvcztcblxuXHRcdFx0Ly8gU2tpcCB0aGUgU2xlcnAgZm9yIHRpbnkgc3RlcHMgdG8gYXZvaWQgbnVtZXJpYyBwcm9ibGVtczpcblx0XHRcdGlmICggc3FyU2luID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0dmFyIHNpbiA9IE1hdGguc3FydCggc3FyU2luICksXG5cdFx0XHRcdFx0bGVuID0gTWF0aC5hdGFuMiggc2luLCBjb3MgKiBkaXIgKTtcblxuXHRcdFx0XHRzID0gTWF0aC5zaW4oIHMgKiBsZW4gKSAvIHNpbjtcblx0XHRcdFx0dCA9IE1hdGguc2luKCB0ICogbGVuICkgLyBzaW47XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHREaXIgPSB0ICogZGlyO1xuXG5cdFx0XHR4MCA9IHgwICogcyArIHgxICogdERpcjtcblx0XHRcdHkwID0geTAgKiBzICsgeTEgKiB0RGlyO1xuXHRcdFx0ejAgPSB6MCAqIHMgKyB6MSAqIHREaXI7XG5cdFx0XHR3MCA9IHcwICogcyArIHcxICogdERpcjtcblxuXHRcdFx0Ly8gTm9ybWFsaXplIGluIGNhc2Ugd2UganVzdCBkaWQgYSBsZXJwOlxuXHRcdFx0aWYgKCBzID09PSAxIC0gdCApIHtcblxuXHRcdFx0XHR2YXIgZiA9IDEgLyBNYXRoLnNxcnQoIHgwICogeDAgKyB5MCAqIHkwICsgejAgKiB6MCArIHcwICogdzAgKTtcblxuXHRcdFx0XHR4MCAqPSBmO1xuXHRcdFx0XHR5MCAqPSBmO1xuXHRcdFx0XHR6MCAqPSBmO1xuXHRcdFx0XHR3MCAqPSBmO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRkc3RbIGRzdE9mZnNldCBdID0geDA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzA7XG5cblx0fVxuXG59ICk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBRdWF0ZXJuaW9uLnByb3RvdHlwZSwge1xuXG5cdHg6IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSB2YWx1ZTtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHk6IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHo6IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5fejtcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuX3ogPSB2YWx1ZTtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHc6IHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5fdztcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSB2YWx1ZTtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdH1cblxuXHR9XG5cbn0gKTtcblxuT2JqZWN0LmFzc2lnbiggUXVhdGVybmlvbi5wcm90b3R5cGUsIHtcblxuXHRpc1F1YXRlcm5pb246IHRydWUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl93ID0gdztcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcblx0XHR0aGlzLl95ID0gcXVhdGVybmlvbi55O1xuXHRcdHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XG5cdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyLCB1cGRhdGUgKSB7XG5cblx0XHRpZiAoICEgKCBldWxlciAmJiBldWxlci5pc0V1bGVyICkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuXHRcdH1cblxuXHRcdHZhciB4ID0gZXVsZXIuX3gsIHkgPSBldWxlci5feSwgeiA9IGV1bGVyLl96LCBvcmRlciA9IGV1bGVyLm9yZGVyO1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xuXHRcdC8vIFx0MjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvXG5cdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxuXG5cdFx0dmFyIGNvcyA9IE1hdGguY29zO1xuXHRcdHZhciBzaW4gPSBNYXRoLnNpbjtcblxuXHRcdHZhciBjMSA9IGNvcyggeCAvIDIgKTtcblx0XHR2YXIgYzIgPSBjb3MoIHkgLyAyICk7XG5cdFx0dmFyIGMzID0gY29zKCB6IC8gMiApO1xuXG5cdFx0dmFyIHMxID0gc2luKCB4IC8gMiApO1xuXHRcdHZhciBzMiA9IHNpbiggeSAvIDIgKTtcblx0XHR2YXIgczMgPSBzaW4oIHogLyAyICk7XG5cblx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuXHRcdH1cblxuXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cblx0XHR2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xuXG5cdFx0dGhpcy5feCA9IGF4aXMueCAqIHM7XG5cdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XG5cdFx0dGhpcy5feiA9IGF4aXMueiAqIHM7XG5cdFx0dGhpcy5fdyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdHZhciB0ZSA9IG0uZWxlbWVudHMsXG5cblx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXG5cblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxuXHRcdFx0cztcblxuXHRcdGlmICggdHJhY2UgPiAwICkge1xuXG5cdFx0XHRzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuXG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMzIgLSBtMjMgKSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xuXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xuXG5cdFx0fSBlbHNlIGlmICggbTIyID4gbTMzICkge1xuXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0xMyArIG0zMSApIC8gcztcblx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcblx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcblxuXHRcdH1cblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiAoIHZGcm9tLCB2VG8gKSB7XG5cblx0XHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcblxuXHRcdHZhciBFUFMgPSAwLjAwMDAwMTtcblxuXHRcdHZhciByID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cblx0XHRpZiAoIHIgPCBFUFMgKSB7XG5cblx0XHRcdHIgPSAwO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAtIHZGcm9tLnk7XG5cdFx0XHRcdHRoaXMuX3kgPSB2RnJvbS54O1xuXHRcdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdHRoaXMuX3kgPSAtIHZGcm9tLno7XG5cdFx0XHRcdHRoaXMuX3ogPSB2RnJvbS55O1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7IC8vIGlubGluZWQgdG8gYXZvaWQgY3ljbGljIGRlcGVuZGVuY3kgb24gVmVjdG9yM1xuXG5cdFx0XHR0aGlzLl94ID0gdkZyb20ueSAqIHZUby56IC0gdkZyb20ueiAqIHZUby55O1xuXHRcdFx0dGhpcy5feSA9IHZGcm9tLnogKiB2VG8ueCAtIHZGcm9tLnggKiB2VG8uejtcblx0XHRcdHRoaXMuX3ogPSB2RnJvbS54ICogdlRvLnkgLSB2RnJvbS55ICogdlRvLng7XG5cdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuXG5cdH0sXG5cblx0YW5nbGVUbzogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0cmV0dXJuIDIgKiBNYXRoLmFjb3MoIE1hdGguYWJzKCBfTWF0aC5jbGFtcCggdGhpcy5kb3QoIHEgKSwgLSAxLCAxICkgKSApO1xuXG5cdH0sXG5cblx0cm90YXRlVG93YXJkczogZnVuY3Rpb24gKCBxLCBzdGVwICkge1xuXG5cdFx0dmFyIGFuZ2xlID0gdGhpcy5hbmdsZVRvKCBxICk7XG5cblx0XHRpZiAoIGFuZ2xlID09PSAwICkgcmV0dXJuIHRoaXM7XG5cblx0XHR2YXIgdCA9IE1hdGgubWluKCAxLCBzdGVwIC8gYW5nbGUgKTtcblxuXHRcdHRoaXMuc2xlcnAoIHEsIHQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0aW52ZXJzZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gcXVhdGVybmlvbiBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpO1xuXG5cdH0sXG5cblx0Y29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLl94ICo9IC0gMTtcblx0XHR0aGlzLl95ICo9IC0gMTtcblx0XHR0aGlzLl96ICo9IC0gMTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cblx0fSxcblxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xuXG5cdH0sXG5cblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIGwgPT09IDAgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdHRoaXMuX3cgPSAxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bCA9IDEgLyBsO1xuXG5cdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XG5cdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XG5cdFx0XHR0aGlzLl96ID0gdGhpcy5feiAqIGw7XG5cdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHEsIHAgKSB7XG5cblx0XHRpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xuXG5cdH0sXG5cblx0cHJlbXVsdGlwbHk6IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHRoaXMgKTtcblxuXHR9LFxuXG5cdG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxuXG5cdFx0dmFyIHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XG5cdFx0dmFyIHFieCA9IGIuX3gsIHFieSA9IGIuX3ksIHFieiA9IGIuX3osIHFidyA9IGIuX3c7XG5cblx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuXHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcblx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcblxuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XG5cblx0XHR2YXIgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuXG5cdFx0dmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi5fdyArIHggKiBxYi5feCArIHkgKiBxYi5feSArIHogKiBxYi5fejtcblxuXHRcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcblxuXHRcdFx0dGhpcy5fdyA9IC0gcWIuX3c7XG5cdFx0XHR0aGlzLl94ID0gLSBxYi5feDtcblx0XHRcdHRoaXMuX3kgPSAtIHFiLl95O1xuXHRcdFx0dGhpcy5feiA9IC0gcWIuX3o7XG5cblx0XHRcdGNvc0hhbGZUaGV0YSA9IC0gY29zSGFsZlRoZXRhO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5jb3B5KCBxYiApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xuXG5cdFx0XHR0aGlzLl93ID0gdztcblx0XHRcdHRoaXMuX3ggPSB4O1xuXHRcdFx0dGhpcy5feSA9IHk7XG5cdFx0XHR0aGlzLl96ID0gejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHR2YXIgc3FyU2luSGFsZlRoZXRhID0gMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhO1xuXG5cdFx0aWYgKCBzcXJTaW5IYWxmVGhldGEgPD0gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdHZhciBzID0gMSAtIHQ7XG5cdFx0XHR0aGlzLl93ID0gcyAqIHcgKyB0ICogdGhpcy5fdztcblx0XHRcdHRoaXMuX3ggPSBzICogeCArIHQgKiB0aGlzLl94O1xuXHRcdFx0dGhpcy5feSA9IHMgKiB5ICsgdCAqIHRoaXMuX3k7XG5cdFx0XHR0aGlzLl96ID0gcyAqIHogKyB0ICogdGhpcy5fejtcblxuXHRcdFx0dGhpcy5ub3JtYWxpemUoKTtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHR2YXIgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCBzcXJTaW5IYWxmVGhldGEgKTtcblx0XHR2YXIgaGFsZlRoZXRhID0gTWF0aC5hdGFuMiggc2luSGFsZlRoZXRhLCBjb3NIYWxmVGhldGEgKTtcblx0XHR2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuXHRcdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuXHRcdHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcblx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0cmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy5feSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy5feiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl93O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0X29uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRfb25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge31cblxufSApO1xuXG5cbmV4cG9ydCB7IFF1YXRlcm5pb24gfTtcbiIsImltcG9ydCB7IF9NYXRoIH0gZnJvbSAnLi9NYXRoLmpzJztcbmltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuL1F1YXRlcm5pb24uanMnO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG52YXIgX3ZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG52YXIgX3F1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG5mdW5jdGlvbiBWZWN0b3IzKCB4LCB5LCB6ICkge1xuXG5cdHRoaXMueCA9IHggfHwgMDtcblx0dGhpcy55ID0geSB8fCAwO1xuXHR0aGlzLnogPSB6IHx8IDA7XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggVmVjdG9yMy5wcm90b3R5cGUsIHtcblxuXHRpc1ZlY3RvcjM6IHRydWUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0dGhpcy56ID0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XG5cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRaOiBmdW5jdGlvbiAoIHogKSB7XG5cblx0XHR0aGlzLnogPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gdi54O1xuXHRcdHRoaXMueSA9IHYueTtcblx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggKz0gdi54O1xuXHRcdHRoaXMueSArPSB2Lnk7XG5cdFx0dGhpcy56ICs9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHR0aGlzLnogKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cdFx0dGhpcy56ICs9IHYueiAqIHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggLT0gdi54O1xuXHRcdHRoaXMueSAtPSB2Lnk7XG5cdFx0dGhpcy56IC09IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblx0XHR0aGlzLnogLT0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblx0XHR0aGlzLnogKj0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0dGhpcy56ICo9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKiBiLng7XG5cdFx0dGhpcy55ID0gYS55ICogYi55O1xuXHRcdHRoaXMueiA9IGEueiAqIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXBwbHlFdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5hcHBseUV1bGVyKCkgbm93IGV4cGVjdHMgYW4gRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIF9xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xuXG5cdH0sXG5cblx0YXBwbHlBeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIF9xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5Tm9ybWFsTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDMoIG0gKS5ub3JtYWxpemUoKTtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dmFyIHcgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApO1xuXG5cdFx0dGhpcy54ID0gKCBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICkgKiB3O1xuXHRcdHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSApICogdztcblx0XHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdHZhciBxeCA9IHEueCwgcXkgPSBxLnksIHF6ID0gcS56LCBxdyA9IHEudztcblxuXHRcdC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXG5cblx0XHR2YXIgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG5cdFx0dmFyIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuXHRcdHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcblx0XHR2YXIgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuXHRcdC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuXHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XG5cdFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcblx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRwcm9qZWN0OiBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHR9LFxuXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cblx0fSxcblxuXHR0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cblxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogejtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHo7XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogejtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuXG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggLz0gdi54O1xuXHRcdHRoaXMueSAvPSB2Lnk7XG5cdFx0dGhpcy56IC89IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cblx0fSxcblxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWluKCB0aGlzLnosIHYueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCB0aGlzLnosIHYueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnggKSApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueSApICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy56ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xuXG5cdH0sXG5cblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcblxuXHR9LFxuXG5cdC8vIFRPRE8gbGVuZ3RoU3F1YXJlZD9cblxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblxuXHR9LFxuXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG5cblx0fSxcblxuXHRtYW5oYXR0YW5MZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XG5cblx0fSxcblxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xuXG5cdH0sXG5cblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xuXG5cdH0sXG5cblx0Y3Jvc3M6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB0aGlzLCB2ICk7XG5cblx0fSxcblxuXHRjcm9zc1ZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xuXHRcdHZhciBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG5cdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHByb2plY3RPblZlY3RvcjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0Ly8gdiBjYW5ub3QgYmUgdGhlIHplcm8gdlxuXG5cdFx0dmFyIHNjYWxhciA9IHYuZG90KCB0aGlzICkgLyB2Lmxlbmd0aFNxKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3B5KCB2ICkubXVsdGlwbHlTY2FsYXIoIHNjYWxhciApO1xuXG5cdH0sXG5cblx0cHJvamVjdE9uUGxhbmU6IGZ1bmN0aW9uICggcGxhbmVOb3JtYWwgKSB7XG5cblx0XHRfdmVjdG9yLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zdWIoIF92ZWN0b3IgKTtcblxuXHR9LFxuXG5cdHJlZmxlY3Q6IGZ1bmN0aW9uICggbm9ybWFsICkge1xuXG5cdFx0Ly8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0cmV0dXJuIHRoaXMuc3ViKCBfdmVjdG9yLmNvcHkoIG5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAyICogdGhpcy5kb3QoIG5vcm1hbCApICkgKTtcblxuXHR9LFxuXG5cdGFuZ2xlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciBkZW5vbWluYXRvciA9IE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpICk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgY29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IGFuZ2xlVG8oKSBjYW5cXCd0IGhhbmRsZSB6ZXJvIGxlbmd0aCB2ZWN0b3JzLicgKTtcblxuXHRcdHZhciB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cblx0XHRyZXR1cm4gTWF0aC5hY29zKCBfTWF0aC5jbGFtcCggdGhldGEsIC0gMSwgMSApICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR2YXIgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55LCBkeiA9IHRoaXMueiAtIHYuejtcblxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XG5cblx0fSxcblxuXHRtYW5oYXR0YW5EaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApICsgTWF0aC5hYnMoIHRoaXMueiAtIHYueiApO1xuXG5cdH0sXG5cblx0c2V0RnJvbVNwaGVyaWNhbDogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVNwaGVyaWNhbENvb3Jkcyggcy5yYWRpdXMsIHMucGhpLCBzLnRoZXRhICk7XG5cblx0fSxcblxuXHRzZXRGcm9tU3BoZXJpY2FsQ29vcmRzOiBmdW5jdGlvbiAoIHJhZGl1cywgcGhpLCB0aGV0YSApIHtcblxuXHRcdHZhciBzaW5QaGlSYWRpdXMgPSBNYXRoLnNpbiggcGhpICkgKiByYWRpdXM7XG5cblx0XHR0aGlzLnggPSBzaW5QaGlSYWRpdXMgKiBNYXRoLnNpbiggdGhldGEgKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNvcyggcGhpICkgKiByYWRpdXM7XG5cdFx0dGhpcy56ID0gc2luUGhpUmFkaXVzICogTWF0aC5jb3MoIHRoZXRhICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21DeWxpbmRyaWNhbDogZnVuY3Rpb24gKCBjICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKCBjLnJhZGl1cywgYy50aGV0YSwgYy55ICk7XG5cblx0fSxcblxuXHRzZXRGcm9tQ3lsaW5kcmljYWxDb29yZHM6IGZ1bmN0aW9uICggcmFkaXVzLCB0aGV0YSwgeSApIHtcblxuXHRcdHRoaXMueCA9IHJhZGl1cyAqIE1hdGguc2luKCB0aGV0YSApO1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21NYXRyaXhQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMTIgXTtcblx0XHR0aGlzLnkgPSBlWyAxMyBdO1xuXHRcdHRoaXMueiA9IGVbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21NYXRyaXhTY2FsZTogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dmFyIHN4ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XG5cdFx0dmFyIHN5ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAxICkubGVuZ3RoKCk7XG5cdFx0dmFyIHN6ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XG5cblx0XHR0aGlzLnggPSBzeDtcblx0XHR0aGlzLnkgPSBzeTtcblx0XHR0aGlzLnogPSBzejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbU1hdHJpeENvbHVtbjogZnVuY3Rpb24gKCBtLCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiA0ICk7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRmcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IG9mZnNldCBoYXMgYmVlbiByZW1vdmVkIGZyb20gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcblx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuZ2V0WiggaW5kZXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufSApO1xuXG5cbmV4cG9ydCB7IFZlY3RvcjMgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0Jyk7XG5cbldlYlNvY2tldC5jcmVhdGVXZWJTb2NrZXRTdHJlYW0gPSByZXF1aXJlKCcuL2xpYi9zdHJlYW0nKTtcbldlYlNvY2tldC5TZXJ2ZXIgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQtc2VydmVyJyk7XG5XZWJTb2NrZXQuUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9yZWNlaXZlcicpO1xuV2ViU29ja2V0LlNlbmRlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBFTVBUWV9CVUZGRVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGJ1ZmZlcnMgaW50byBhIG5ldyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJbXX0gbGlzdCBUaGUgYXJyYXkgb2YgYnVmZmVycyB0byBjb25jYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbExlbmd0aCBUaGUgdG90YWwgbGVuZ3RoIG9mIGJ1ZmZlcnMgaW4gdGhlIGxpc3RcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIHJlc3VsdGluZyBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY29uY2F0KGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIEVNUFRZX0JVRkZFUjtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSByZXR1cm4gbGlzdFswXTtcblxuICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBidWYgPSBsaXN0W2ldO1xuICAgIHRhcmdldC5zZXQoYnVmLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBidWYubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG9mZnNldCA8IHRvdGFsTGVuZ3RoKSByZXR1cm4gdGFyZ2V0LnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBNYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc291cmNlIFRoZSBidWZmZXIgdG8gbWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gb3V0cHV0IFRoZSBidWZmZXIgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHdyaXRpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBieXRlcyB0byBtYXNrLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogVW5tYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gdW5tYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX3VubWFzayhidWZmZXIsIG1hc2spIHtcbiAgLy8gUmVxdWlyZWQgdW50aWwgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy85MDA2IGlzIHJlc29sdmVkLlxuICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYW4gYEFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IENvbnZlcnRlZCBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcbiAgaWYgKGJ1Zi5ieXRlTGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcbiAgfVxuXG4gIHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZGF0YWAgdG8gYSBgQnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgYnVmZmVyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcbiAgdG9CdWZmZXIucmVhZE9ubHkgPSB0cnVlO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHJldHVybiBkYXRhO1xuXG4gIGxldCBidWY7XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgdG9CdWZmZXIucmVhZE9ubHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbnRyeSB7XG4gIGNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XG4gIGNvbnN0IGJ1ID0gYnVmZmVyVXRpbC5CdWZmZXJVdGlsIHx8IGJ1ZmZlclV0aWw7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29uY2F0LFxuICAgIG1hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgNDgpIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBlbHNlIGJ1Lm1hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB9LFxuICAgIHRvQXJyYXlCdWZmZXIsXG4gICAgdG9CdWZmZXIsXG4gICAgdW5tYXNrKGJ1ZmZlciwgbWFzaykge1xuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAzMikgX3VubWFzayhidWZmZXIsIG1hc2spO1xuICAgICAgZWxzZSBidS51bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICB9XG4gIH07XG59IGNhdGNoIChlKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbmNhdCxcbiAgICBtYXNrOiBfbWFzayxcbiAgICB0b0FycmF5QnVmZmVyLFxuICAgIHRvQnVmZmVyLFxuICAgIHVubWFzazogX3VubWFza1xuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQklOQVJZX1RZUEVTOiBbJ25vZGVidWZmZXInLCAnYXJyYXlidWZmZXInLCAnZnJhZ21lbnRzJ10sXG4gIEdVSUQ6ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnLFxuICBrU3RhdHVzQ29kZTogU3ltYm9sKCdzdGF0dXMtY29kZScpLFxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcbiAgTk9PUDogKCkgPT4ge31cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXMgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgTWVzc2FnZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIHJlY2VpdmVkIGRhdGFcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXMgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSwgdGFyZ2V0KSB7XG4gICAgc3VwZXIoJ21lc3NhZ2UnLCB0YXJnZXQpO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBDbG9zZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGJlaW5nIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIEEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXMgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSwgcmVhc29uLCB0YXJnZXQpIHtcbiAgICBzdXBlcignY2xvc2UnLCB0YXJnZXQpO1xuXG4gICAgdGhpcy53YXNDbGVhbiA9IHRhcmdldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmIHRhcmdldC5fY2xvc2VGcmFtZVNlbnQ7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBvcGVuIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBPcGVuRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYE9wZW5FdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViU29ja2V0fSB0YXJnZXQgQSByZWZlcmVuY2UgdG8gdGhlIHRhcmdldCB0byB3aGljaCB0aGUgZXZlbnQgd2FzIGRpc3BhdGNoZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgIHN1cGVyKCdvcGVuJywgdGFyZ2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBlcnJvciBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXJyb3JFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvciBUaGUgZXJyb3IgdGhhdCBnZW5lcmF0ZWQgdGhpcyBldmVudFxuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlcnJvciwgdGFyZ2V0KSB7XG4gICAgc3VwZXIoJ2Vycm9yJywgdGFyZ2V0KTtcblxuICAgIHRoaXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwcm92aWRlcyBtZXRob2RzIGZvciBlbXVsYXRpbmcgdGhlIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLiBJdCdzIG5vdFxuICogbWVhbnQgdG8gYmUgdXNlZCBkaXJlY3RseS5cbiAqXG4gKiBAbWl4aW5cbiAqL1xuY29uc3QgRXZlbnRUYXJnZXQgPSB7XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3JcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm9uY2UgQSBgQm9vbGVhbmBgIGluZGljYXRpbmcgdGhhdCB0aGUgbGlzdGVuZXJcbiAgICogICAgIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC4gSWYgYHRydWVgLCB0aGVcbiAgICogICAgIGxpc3RlbmVyIHdvdWxkIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCB3aGVuIGludm9rZWQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgTWVzc2FnZUV2ZW50KGRhdGEsIHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNsb3NlKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgbmV3IENsb3NlRXZlbnQoY29kZSwgbWVzc2FnZSwgdGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgbmV3IEVycm9yRXZlbnQoZXJyb3IsIHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk9wZW4oKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIG5ldyBPcGVuRXZlbnQodGhpcykpO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vbmNlID8gJ29uY2UnIDogJ29uJztcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIG9uTWVzc2FnZS5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXNbbWV0aG9kXSh0eXBlLCBvbk1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgb25DbG9zZS5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXNbbWV0aG9kXSh0eXBlLCBvbkNsb3NlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIG9uRXJyb3IuX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICB0aGlzW21ldGhvZF0odHlwZSwgb25FcnJvcik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb3BlbicpIHtcbiAgICAgIG9uT3Blbi5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXNbbWV0aG9kXSh0eXBlLCBvbk9wZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW21ldGhvZF0odHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKHR5cGUpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RlbmVyc1tpXS5fbGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XG4vL1xuLy8gJyEnLCAnIycsICckJywgJyUnLCAnJicsICcnJywgJyonLCAnKycsICctJyxcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcbi8vXG4vLyB0b2tlbkNoYXJzWzMyXSA9PT0gMCAvLyAnICdcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xuLy8gdG9rZW5DaGFyc1szNF0gPT09IDAgLy8gJ1wiJ1xuLy8gLi4uXG4vL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB0b2tlbkNoYXJzID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAwLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAvLyAzMiAtIDQ3XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAvLyA4MCAtIDk1XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dO1xuXG4vKipcbiAqIEFkZHMgYW4gb2ZmZXIgdG8gdGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIGEgcGFyYW1ldGVyIHRvIHRoZSBtYXAgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3QgVGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBleHRlbnNpb24gb3IgcGFyYW1ldGVyIG5hbWVcbiAqIEBwYXJhbSB7KE9iamVjdHxCb29sZWFufFN0cmluZyl9IGVsZW0gVGhlIGV4dGVuc2lvbiBwYXJhbWV0ZXJzIG9yIHRoZVxuICogICAgIHBhcmFtZXRlciB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVzaChkZXN0LCBuYW1lLCBlbGVtKSB7XG4gIGlmIChkZXN0W25hbWVdID09PSB1bmRlZmluZWQpIGRlc3RbbmFtZV0gPSBbZWxlbV07XG4gIGVsc2UgZGVzdFtuYW1lXS5wdXNoKGVsZW0pO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHBhcnNlZCBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIGNvbnN0IG9mZmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgaWYgKGhlYWRlciA9PT0gdW5kZWZpbmVkIHx8IGhlYWRlciA9PT0gJycpIHJldHVybiBvZmZlcnM7XG5cbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMCAvKiAnICcgKi8gfHwgY29kZSA9PT0gMHgwOSAvKiAnXFx0JyAqLykge1xuICAgICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgLyogJzsnICovIHx8IGNvZGUgPT09IDB4MmMgLyogJywnICovKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBjb25zdCBuYW1lID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBuYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgcHVzaChwYXJhbXMsIGhlYWRlci5zbGljZShzdGFydCwgZW5kKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzZCAvKiAnPScgKi8gJiYgc3RhcnQgIT09IC0xICYmIGVuZCA9PT0gLTEpIHtcbiAgICAgICAgcGFyYW1OYW1lID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL1xuICAgICAgLy8gVGhlIHZhbHVlIG9mIGEgcXVvdGVkLXN0cmluZyBhZnRlciB1bmVzY2FwaW5nIG11c3QgY29uZm9ybSB0byB0aGVcbiAgICAgIC8vIHRva2VuIEFCTkYsIHNvIG9ubHkgdG9rZW4gY2hhcmFjdGVycyBhcmUgdmFsaWQuXG4gICAgICAvLyBSZWY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NDU1I3NlY3Rpb24tOS4xXG4gICAgICAvL1xuICAgICAgaWYgKGlzRXNjYXBpbmcpIHtcbiAgICAgICAgaWYgKHRva2VuQ2hhcnNbY29kZV0gIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKCFtdXN0VW5lc2NhcGUpIG11c3RVbmVzY2FwZSA9IHRydWU7XG4gICAgICAgIGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5RdW90ZXMpIHtcbiAgICAgICAgaWYgKHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAvKiAnXCInICovICYmIHN0YXJ0ICE9PSAtMSkge1xuICAgICAgICAgIGluUXVvdGVzID0gZmFsc2U7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDVjIC8qICdcXCcgKi8pIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyICYmIGhlYWRlci5jaGFyQ29kZUF0KGkgLSAxKSA9PT0gMHgzZCkge1xuICAgICAgICBpblF1b3RlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0ICE9PSAtMSAmJiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBsZXQgdmFsdWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChtdXN0VW5lc2NhcGUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgICAgICAgIG11c3RVbmVzY2FwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbU5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGluUXVvdGVzKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gIGNvbnN0IHRva2VuID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcHVzaChvZmZlcnMsIHRva2VuLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4ucmVwbGFjZSgvXFxcXC9nLCAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG4gICAgfVxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIG9mZmVycztcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBmaWVsZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgbWFwIG9mIGV4dGVuc2lvbnMgYW5kIHBhcmFtZXRlcnMgdG8gZm9ybWF0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChleHRlbnNpb25zKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhleHRlbnNpb25zKVxuICAgIC5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgbGV0IGNvbmZpZ3VyYXRpb25zID0gZXh0ZW5zaW9uc1tleHRlbnNpb25dO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3VyYXRpb25zKSkgY29uZmlndXJhdGlvbnMgPSBbY29uZmlndXJhdGlvbnNdO1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIC5tYXAoKHBhcmFtcykgPT4ge1xuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uXVxuICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoKGspID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gcGFyYW1zW2tdO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiAodiA9PT0gdHJ1ZSA/IGsgOiBgJHtrfT0ke3Z9YCkpXG4gICAgICAgICAgICAgICAgICAuam9pbignOyAnKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICB9KVxuICAgIC5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZm9ybWF0LCBwYXJzZSB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBrRG9uZSA9IFN5bWJvbCgna0RvbmUnKTtcbmNvbnN0IGtSdW4gPSBTeW1ib2woJ2tSdW4nKTtcblxuLyoqXG4gKiBBIHZlcnkgc2ltcGxlIGpvYiBxdWV1ZSB3aXRoIGFkanVzdGFibGUgY29uY3VycmVuY3kuIEFkYXB0ZWQgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML2FzeW5jLWxpbWl0ZXJcbiAqL1xuY2xhc3MgTGltaXRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmN1cnJlbmN5IFRoZSBtYXhpbXVtIG51bWJlciBvZiBqb2JzIGFsbG93ZWQgdG8gcnVuXG4gICAqICAgICBjb25jdXJyZW50bHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmN1cnJlbmN5KSB7XG4gICAgdGhpc1trRG9uZV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmctLTtcbiAgICAgIHRoaXNba1J1bl0oKTtcbiAgICB9O1xuICAgIHRoaXMuY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeSB8fCBJbmZpbml0eTtcbiAgICB0aGlzLmpvYnMgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmcgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBqb2IgdG8gdGhlIHF1ZXVlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGQoam9iKSB7XG4gICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICB0aGlzW2tSdW5dKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGpvYiBmcm9tIHRoZSBxdWV1ZSBhbmQgcnVucyBpdCBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtrUnVuXSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMucGVuZGluZysrO1xuICAgICAgam9iKHRoaXNba0RvbmVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaW1pdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuXG5jb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgTGltaXRlciA9IHJlcXVpcmUoJy4vbGltaXRlcicpO1xuY29uc3QgeyBrU3RhdHVzQ29kZSwgTk9PUCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgVFJBSUxFUiA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweGZmLCAweGZmXSk7XG5jb25zdCBrUGVyTWVzc2FnZURlZmxhdGUgPSBTeW1ib2woJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qga1RvdGFsTGVuZ3RoID0gU3ltYm9sKCd0b3RhbC1sZW5ndGgnKTtcbmNvbnN0IGtDYWxsYmFjayA9IFN5bWJvbCgnY2FsbGJhY2snKTtcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKCdidWZmZXJzJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG5cbi8vXG4vLyBXZSBsaW1pdCB6bGliIGNvbmN1cnJlbmN5LCB3aGljaCBwcmV2ZW50cyBzZXZlcmUgbWVtb3J5IGZyYWdtZW50YXRpb25cbi8vIGFzIGRvY3VtZW50ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84ODcxI2lzc3VlY29tbWVudC0yNTA5MTU5MTNcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTIwMlxuLy9cbi8vIEludGVudGlvbmFsbHkgZ2xvYmFsOyBpdCdzIHRoZSBnbG9iYWwgdGhyZWFkIHBvb2wgdGhhdCdzIGFuIGlzc3VlLlxuLy9cbmxldCB6bGliTGltaXRlcjtcblxuLyoqXG4gKiBwZXJtZXNzYWdlLWRlZmxhdGUgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQZXJNZXNzYWdlRGVmbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciBSZXF1ZXN0L2FjY2VwdCBkaXNhYmxpbmdcbiAgICogICAgIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciBBZHZlcnRpc2UvYWNrbm93bGVkZ2VcbiAgICogICAgIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IG9wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cyBSZXF1ZXN0L2NvbmZpcm0gdGhlXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb24gZGVmbGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb24gaW5mbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy50aHJlc2hvbGQgU2l6ZSAoaW4gYnl0ZXMpIGJlbG93IHdoaWNoIG1lc3NhZ2VzXG4gICAqICAgICBzaG91bGQgbm90IGJlIGNvbXByZXNzZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuY29uY3VycmVuY3lMaW1pdCBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgY2FsbHMgdG9cbiAgICogICAgIHpsaWJcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1NlcnZlciBDcmVhdGUgdGhlIGluc3RhbmNlIGluIGVpdGhlciBzZXJ2ZXIgb3IgY2xpZW50XG4gICAqICAgICBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9XG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuICAgICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKGNvbmN1cnJlbmN5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlcigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zID0gdGhpcy5ub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlclxuICAgICAgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKVxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXG4gICAgICAgICAgKG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxuICAgICAgICAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghYWNjZXB0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgZXh0ZW5zaW9uIG9mZmVycyBjYW4gYmUgYWNjZXB0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fFxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxuICAgICkge1xuICAgICAgZGVsZXRlIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zZSBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXJhbWV0ZXIgXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIG9yIGludmFsaWQgcGFyYW1ldGVyIFwiY2xpZW50X21heF93aW5kb3dfYml0c1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgXCIke2tleX1cIiBtdXN0IGhhdmUgb25seSBhIHNpbmdsZSB2YWx1ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInIHx8XG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tQZXJNZXNzYWdlRGVmbGF0ZV0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdlcnJvcicsIGluZmxhdGVPbkVycm9yKTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcblxuICAgIHRoaXMuX2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdzZXJ2ZXInIDogJ2NsaWVudCc7XG5cbiAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZSA9IHpsaWIuY3JlYXRlRGVmbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIC8vXG4gICAgICAvLyBBbiBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCwgb25seSBvbiBOb2RlLmpzIDwgMTAuMC4wLCBpZiB0aGVcbiAgICAgIC8vIGB6bGliLkRlZmxhdGVSYXdgIGluc3RhbmNlIGlzIGNsb3NlZCB3aGlsZSBkYXRhIGlzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBgUGVyTWVzc2FnZURlZmxhdGUjY2xlYW51cCgpYCBpcyBjYWxsZWQgYXQgdGhlIHdyb25nXG4gICAgICAvLyB0aW1lIGR1ZSB0byBhbiBhYm5vcm1hbCBXZWJTb2NrZXQgY2xvc3VyZS5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdlcnJvcicsIE5PT1ApO1xuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZGF0YScsIGRlZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5fZGVmbGF0ZS53cml0ZShkYXRhKTtcbiAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAvL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmIChmaW4pIGRhdGEgPSBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gNCk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGluXG4gICAgICAvLyBgUGVyTWVzc2FnZURlZmxhdGUjY2xlYW51cCgpYC5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBudWxsO1xuXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVyTWVzc2FnZURlZmxhdGU7XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5EZWZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG5cbiAgaWYgKFxuICAgIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZCA8IDEgfHxcbiAgICB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkXG4gICkge1xuICAgIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXNba0Vycm9yXSA9IG5ldyBSYW5nZUVycm9yKCdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyk7XG4gIHRoaXNba0Vycm9yXVtrU3RhdHVzQ29kZV0gPSAxMDA5O1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvcihlcnIpIHtcbiAgLy9cbiAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGBabGliI2Nsb3NlKClgIGFzIHRoZSBoYW5kbGUgaXMgYXV0b21hdGljYWxseVxuICAvLyBjbG9zZWQgd2hlbiBhbiBlcnJvciBpcyBlbWl0dGVkLlxuICAvL1xuICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX2luZmxhdGUgPSBudWxsO1xuICBlcnJba1N0YXR1c0NvZGVdID0gMTAwNztcbiAgdGhpc1trQ2FsbGJhY2tdKGVycik7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSLFxuICBrU3RhdHVzQ29kZSxcbiAga1dlYlNvY2tldFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGNvbmNhdCwgdG9BcnJheUJ1ZmZlciwgdW5tYXNrIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCB7IGlzVmFsaWRTdGF0dXNDb2RlLCBpc1ZhbGlkVVRGOCB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbmNvbnN0IEdFVF9JTkZPID0gMDtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF8xNiA9IDE7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfNjQgPSAyO1xuY29uc3QgR0VUX01BU0sgPSAzO1xuY29uc3QgR0VUX0RBVEEgPSA0O1xuY29uc3QgSU5GTEFUSU5HID0gNTtcblxuLyoqXG4gKiBIeUJpIFJlY2VpdmVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBleHRlbmRzIHN0cmVhbS5Xcml0YWJsZVxuICovXG5jbGFzcyBSZWNlaXZlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWNlaXZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJpbmFyeVR5cGUgVGhlIHR5cGUgZm9yIGJpbmFyeSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1NlcnZlciBTcGVjaWZpZXMgd2hldGhlciB0byBvcGVyYXRlIGluIGNsaWVudCBvciBzZXJ2ZXJcbiAgICogICAgIG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFBheWxvYWQgVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3IoYmluYXJ5VHlwZSwgZXh0ZW5zaW9ucywgaXNTZXJ2ZXIsIG1heFBheWxvYWQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGUgfHwgQklOQVJZX1RZUEVTWzBdO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBtYXhQYXlsb2FkIHwgMDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyBgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIFRoZSBjaHVuayBvZiBkYXRhIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIGBjaHVua2BcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICovXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9zdGF0ZSA9PSBHRVRfSU5GTykgcmV0dXJuIGNiKCk7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLl9idWZmZXJzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBgbmAgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbnN1bWVkIGJ5dGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdW1lKG4pIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG47XG5cbiAgICBpZiAobiA9PT0gdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHJldHVybiB0aGlzLl9idWZmZXJzLnNoaWZ0KCk7XG5cbiAgICBpZiAobiA8IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IGJ1Zi5zbGljZShuKTtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMCwgbik7XG4gICAgfVxuXG4gICAgY29uc3QgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGRzdC5sZW5ndGggLSBuO1xuXG4gICAgICBpZiAobiA+PSBidWYubGVuZ3RoKSB7XG4gICAgICAgIGRzdC5zZXQodGhpcy5fYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHN0LnNldChuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gYnVmLmxlbmd0aDtcbiAgICB9IHdoaWxlIChuID4gMCk7XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wKGNiKSB7XG4gICAgbGV0IGVycjtcbiAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgY2FzZSBHRVRfSU5GTzpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldEluZm8oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRQYXlsb2FkTGVuZ3RoMTYoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRQYXlsb2FkTGVuZ3RoNjQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfTUFTSzpcbiAgICAgICAgICB0aGlzLmdldE1hc2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfREFUQTpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldERhdGEoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIGBJTkZMQVRJTkdgXG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcblxuICAgIGNiKGVycik7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIGZpcnN0IHR3byBieXRlcyBvZiBhIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSgyKTtcblxuICAgIGlmICgoYnVmWzBdICYgMHgzMCkgIT09IDB4MDApIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyJywgdHJ1ZSwgMTAwMik7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHJlc3NlZCA9IChidWZbMF0gJiAweDQwKSA9PT0gMHg0MDtcblxuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ1JTVjEgbXVzdCBiZSBjbGVhcicsIHRydWUsIDEwMDIpO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpbiA9IChidWZbMF0gJiAweDgwKSA9PT0gMHg4MDtcbiAgICB0aGlzLl9vcGNvZGUgPSBidWZbMF0gJiAweDBmO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBidWZbMV0gJiAweDdmO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMCkge1xuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ1JTVjEgbXVzdCBiZSBjbGVhcicsIHRydWUsIDEwMDIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ2ludmFsaWQgb3Bjb2RlIDAnLCB0cnVlLCAxMDAyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb3Bjb2RlID0gdGhpcy5fZnJhZ21lbnRlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMSB8fCB0aGlzLl9vcGNvZGUgPT09IDB4MDIpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLCB0cnVlLCAxMDAyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29tcHJlc3NlZCA9IGNvbXByZXNzZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3ICYmIHRoaXMuX29wY29kZSA8IDB4MGIpIHtcbiAgICAgIGlmICghdGhpcy5fZmluKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdGSU4gbXVzdCBiZSBzZXQnLCB0cnVlLCAxMDAyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ1JTVjEgbXVzdCBiZSBjbGVhcicsIHRydWUsIDEwMDIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAke3RoaXMuX3BheWxvYWRMZW5ndGh9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLCB0cnVlLCAxMDAyKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcbiAgICB0aGlzLl9tYXNrZWQgPSAoYnVmWzFdICYgMHg4MCkgPT09IDB4ODA7XG5cbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdNQVNLIG11c3QgYmUgc2V0JywgdHJ1ZSwgMTAwMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9tYXNrZWQpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnTUFTSyBtdXN0IGJlIGNsZWFyJywgdHJ1ZSwgMTAwMik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNikgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY7XG4gICAgZWxzZSBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI3KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF82NDtcbiAgICBlbHNlIHJldHVybiB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzE2KS5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDE2KCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSB0aGlzLmNvbnN1bWUoMikucmVhZFVJbnQxNkJFKDApO1xuICAgIHJldHVybiB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzY0KS5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDY0KCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgOCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSg4KTtcbiAgICBjb25zdCBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgbWF4aW11bSBzYWZlIGludGVnZXIgaW4gSmF2YVNjcmlwdCBpcyAyXjUzIC0gMS4gQW4gZXJyb3IgaXMgcmV0dXJuZWRcbiAgICAvLyBpZiBwYXlsb2FkIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhpcyBudW1iZXIuXG4gICAgLy9cbiAgICBpZiAobnVtID4gTWF0aC5wb3coMiwgNTMgLSAzMikgLSAxKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdVbnN1cHBvcnRlZCBXZWJTb2NrZXQgZnJhbWU6IHBheWxvYWQgbGVuZ3RoID4gMl41MyAtIDEnLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgMTAwOVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gbnVtICogTWF0aC5wb3coMiwgMzIpICsgYnVmLnJlYWRVSW50MzJCRSg0KTtcbiAgICByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogUGF5bG9hZCBsZW5ndGggaGFzIGJlZW4gcmVhZC5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGF2ZUxlbmd0aCgpIHtcbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCAmJiB0aGlzLl9vcGNvZGUgPCAweDA4KSB7XG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggKz0gdGhpcy5fcGF5bG9hZExlbmd0aDtcbiAgICAgIGlmICh0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJywgZmFsc2UsIDEwMDkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrZWQpIHRoaXMuX3N0YXRlID0gR0VUX01BU0s7XG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXNrKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXREYXRhKGNiKSB7XG4gICAgbGV0IGRhdGEgPSBFTVBUWV9CVUZGRVI7XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCB0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gdGhpcy5jb25zdW1lKHRoaXMuX3BheWxvYWRMZW5ndGgpO1xuICAgICAgaWYgKHRoaXMuX21hc2tlZCkgdW5tYXNrKGRhdGEsIHRoaXMuX21hc2spO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3KSByZXR1cm4gdGhpcy5jb250cm9sTWVzc2FnZShkYXRhKTtcblxuICAgIGlmICh0aGlzLl9jb21wcmVzc2VkKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IElORkxBVElORztcbiAgICAgIHRoaXMuZGVjb21wcmVzcyhkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBtZXNzYWdlIGlzIG5vdCBjb21wcmVzc2VkIHNvIGl0cyBsZW5naHQgaXMgdGhlIHN1bSBvZiB0aGUgcGF5bG9hZFxuICAgICAgLy8gbGVuZ3RoIG9mIGFsbCBmcmFnbWVudHMuXG4gICAgICAvL1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGFNZXNzYWdlKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzc2VzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBjYikge1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmRlY29tcHJlc3MoZGF0YSwgdGhpcy5fZmluLCAoZXJyLCBidWYpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICBpZiAoYnVmLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9tZXNzYWdlTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICAgIHJldHVybiBjYihcbiAgICAgICAgICAgIGVycm9yKFJhbmdlRXJyb3IsICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJywgZmFsc2UsIDEwMDkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVyID0gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICAgICAgaWYgKGVyKSByZXR1cm4gY2IoZXIpO1xuXG4gICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHJldHVybiB7KEVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9maW4pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoO1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5fZnJhZ21lbnRzO1xuXG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAyKSB7XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgICBkYXRhID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBidWYgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKEVycm9yLCAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsIHRydWUsIDEwMDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGNvbnRyb2wgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBoYW5kbGVcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udHJvbE1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcblxuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCAxMDA1LCAnJyk7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAxJywgdHJ1ZSwgMTAwMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCwgdHJ1ZSwgMTAwMik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWYgPSBkYXRhLnNsaWNlKDIpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihFcnJvciwgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLCB0cnVlLCAxMDA3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCBjb2RlLCBidWYudG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDkpIHtcbiAgICAgIHRoaXMuZW1pdCgncGluZycsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjZWl2ZXI7XG5cbi8qKlxuICogQnVpbGRzIGFuIGVycm9yIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyhFcnJvcnxSYW5nZUVycm9yKX0gRXJyb3JDdG9yIFRoZSBlcnJvciBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZml4IFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBhZGQgYSBkZWZhdWx0IHByZWZpeCB0b1xuICogICAgIGBtZXNzYWdlYFxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c0NvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcil9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXJyb3IoRXJyb3JDdG9yLCBtZXNzYWdlLCBwcmVmaXgsIHN0YXR1c0NvZGUpIHtcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yQ3RvcihcbiAgICBwcmVmaXggPyBgSW52YWxpZCBXZWJTb2NrZXQgZnJhbWU6ICR7bWVzc2FnZX1gIDogbWVzc2FnZVxuICApO1xuXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgZXJyb3IpO1xuICBlcnJba1N0YXR1c0NvZGVdID0gc3RhdHVzQ29kZTtcbiAgcmV0dXJuIGVycjtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5jb25zdCB7IG1hc2s6IGFwcGx5TWFzaywgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3QgbWFzayA9IEJ1ZmZlci5hbGxvYyg0KTtcblxuLyoqXG4gKiBIeUJpIFNlbmRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgU2VuZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTZW5kZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bmV0LlNvY2tldH0gc29ja2V0IFRoZSBjb25uZWN0aW9uIHNvY2tldFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21wcmVzcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIHRvIGZyYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yZWFkT25seSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5maW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnJzdjEgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgUlNWMSBiaXRcbiAgICogQHJldHVybiB7QnVmZmVyW119IFRoZSBmcmFtZWQgZGF0YSBhcyBhIGxpc3Qgb2YgYEJ1ZmZlcmAgaW5zdGFuY2VzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBmcmFtZShkYXRhLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbWVyZ2UgPSBvcHRpb25zLm1hc2sgJiYgb3B0aW9ucy5yZWFkT25seTtcbiAgICBsZXQgb2Zmc2V0ID0gb3B0aW9ucy5tYXNrID8gNiA6IDI7XG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmIChkYXRhLmxlbmd0aCA+PSA2NTUzNikge1xuICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3O1xuICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPiAxMjUpIHtcbiAgICAgIG9mZnNldCArPSAyO1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVyZ2UgPyBkYXRhLmxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XG5cbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMHg4MCA6IG9wdGlvbnMub3Bjb2RlO1xuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG4gICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aDtcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGEubGVuZ3RoLCAyKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDMyQkUoMCwgMik7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MzJCRShkYXRhLmxlbmd0aCwgNik7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1hc2spIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIHJhbmRvbUZpbGxTeW5jKG1hc2ssIDAsIDQpO1xuXG4gICAgdGFyZ2V0WzFdIHw9IDB4ODA7XG4gICAgdGFyZ2V0W29mZnNldCAtIDRdID0gbWFza1swXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gM10gPSBtYXNrWzFdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAyXSA9IG1hc2tbMl07XG4gICAgdGFyZ2V0W29mZnNldCAtIDFdID0gbWFza1szXTtcblxuICAgIGlmIChtZXJnZSkge1xuICAgICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIHRhcmdldCwgb2Zmc2V0LCBkYXRhLmxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuXG4gICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIGRhdGEsIDAsIGRhdGEubGVuZ3RoKTtcbiAgICByZXR1cm4gW3RhcmdldCwgZGF0YV07XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBjbG9zZSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyhOdW1iZXJ8dW5kZWZpbmVkKX0gY29kZSBUaGUgc3RhdHVzIGNvZGUgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIFRoZSBtZXNzYWdlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnVmO1xuXG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVmID0gRU1QVFlfQlVGRkVSO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8ICFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHZhbGlkIGVycm9yIGNvZGUgbnVtYmVyJyk7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gJycpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEyMykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIG1lc3NhZ2UgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyMyBieXRlcycpO1xuICAgICAgfVxuXG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGxlbmd0aCk7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcbiAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9DbG9zZSwgYnVmLCBtYXNrLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvQ2xvc2UoYnVmLCBtYXNrLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhbmQgc2VuZHMgYSBjbG9zZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvQ2xvc2UoZGF0YSwgbWFzaywgY2IpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgIG9wY29kZTogMHgwOCxcbiAgICAgICAgbWFzayxcbiAgICAgICAgcmVhZE9ubHk6IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIGNiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBpbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgY29uc3QgYnVmID0gdG9CdWZmZXIoZGF0YSk7XG5cbiAgICBpZiAoYnVmLmxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kb1BpbmcsIGJ1ZiwgbWFzaywgdG9CdWZmZXIucmVhZE9ubHksIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9QaW5nKGJ1ZiwgbWFzaywgdG9CdWZmZXIucmVhZE9ubHksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIHBpbmcgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlYWRPbmx5IFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmUgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvUGluZyhkYXRhLCBtYXNrLCByZWFkT25seSwgY2IpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgIG9wY29kZTogMHgwOSxcbiAgICAgICAgbWFzayxcbiAgICAgICAgcmVhZE9ubHlcbiAgICAgIH0pLFxuICAgICAgY2JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcG9uZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBjb25zdCBidWYgPSB0b0J1ZmZlcihkYXRhKTtcblxuICAgIGlmIChidWYubGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRvUG9uZywgYnVmLCBtYXNrLCB0b0J1ZmZlci5yZWFkT25seSwgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb1BvbmcoYnVmLCBtYXNrLCB0b0J1ZmZlci5yZWFkT25seSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYW5kIHNlbmRzIGEgcG9uZyBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVhZE9ubHkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZSBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZG9Qb25nKGRhdGEsIG1hc2ssIHJlYWRPbmx5LCBjYikge1xuICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgICAgZmluOiB0cnVlLFxuICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgb3Bjb2RlOiAweDBhLFxuICAgICAgICBtYXNrLFxuICAgICAgICByZWFkT25seVxuICAgICAgfSksXG4gICAgICBjYlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jb21wcmVzcyBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5iaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5maW4gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZSBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGRhdGEpO1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcbiAgICBsZXQgb3Bjb2RlID0gb3B0aW9ucy5iaW5hcnkgPyAyIDogMTtcbiAgICBsZXQgcnN2MSA9IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgICBpZiAodGhpcy5fZmlyc3RGcmFnbWVudCkge1xuICAgICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IGZhbHNlO1xuICAgICAgaWYgKHJzdjEgJiYgcGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgcnN2MSA9IGJ1Zi5sZW5ndGggPj0gcGVyTWVzc2FnZURlZmxhdGUuX3RocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbXByZXNzID0gcnN2MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnN2MSA9IGZhbHNlO1xuICAgICAgb3Bjb2RlID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maW4pIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuXG4gICAgaWYgKHBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICByc3YxLFxuICAgICAgICBvcGNvZGUsXG4gICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgcmVhZE9ubHk6IHRvQnVmZmVyLnJlYWRPbmx5XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgYnVmLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goYnVmLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgICAgU2VuZGVyLmZyYW1lKGJ1Ziwge1xuICAgICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgICAgb3Bjb2RlLFxuICAgICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgICByZWFkT25seTogdG9CdWZmZXIucmVhZE9ubHlcbiAgICAgICAgfSksXG4gICAgICAgIGNiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29tcHJlc3MgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzIGBkYXRhYFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucmVhZE9ubHkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZSBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlIEZJTiBiaXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yc3YxIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAoIWNvbXByZXNzKSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICB0aGlzLl9kZWZsYXRpbmcgPSB0cnVlO1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmNvbXByZXNzKGRhdGEsIG9wdGlvbnMuZmluLCAoXywgYnVmKSA9PiB7XG4gICAgICBpZiAodGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RoZSBzb2NrZXQgd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBjb21wcmVzc2VkJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIGNiKGVycik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fcXVldWVbaV1bNF07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kZWZsYXRpbmcgPSBmYWxzZTtcbiAgICAgIG9wdGlvbnMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBxdWV1ZWQgc2VuZCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVxdWV1ZSgpIHtcbiAgICB3aGlsZSAoIXRoaXMuX2RlZmxhdGluZyAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzFdLmxlbmd0aDtcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVucXVldWUocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbMV0ubGVuZ3RoO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBmcmFtZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZW5kRnJhbWUobGlzdCwgY2IpIHtcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuX3NvY2tldC5jb3JrKCk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFsxXSwgY2IpO1xuICAgICAgdGhpcy5fc29ja2V0LnVuY29yaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKipcbiAqIEVtaXRzIHRoZSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtzdHJlYW0uRHVwbGV4fSBUaGUgc3RyZWFtLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FbmQoKSB7XG4gIGlmICghdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FcnJvcihlcnIpIHtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAvLyBEbyBub3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yLlxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogV3JhcHMgYSBgV2ViU29ja2V0YCBpbiBhIGR1cGxleCBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdzIFRoZSBgV2ViU29ja2V0YCB0byB3cmFwXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIGBEdXBsZXhgIGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJuIHtzdHJlYW0uRHVwbGV4fSBUaGUgZHVwbGV4IHN0cmVhbVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRTdHJlYW0od3MsIG9wdGlvbnMpIHtcbiAgbGV0IHJlc3VtZU9uUmVjZWl2ZXJEcmFpbiA9IHRydWU7XG5cbiAgZnVuY3Rpb24gcmVjZWl2ZXJPbkRyYWluKCkge1xuICAgIGlmIChyZXN1bWVPblJlY2VpdmVyRHJhaW4pIHdzLl9zb2NrZXQucmVzdW1lKCk7XG4gIH1cblxuICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgd3MuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygnZHJhaW4nKTtcbiAgICAgIHdzLl9yZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHdzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RyYWluJyk7XG4gICAgd3MuX3JlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gIH1cblxuICBjb25zdCBkdXBsZXggPSBuZXcgRHVwbGV4KHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGF1dG9EZXN0cm95OiBmYWxzZSxcbiAgICBlbWl0Q2xvc2U6IGZhbHNlLFxuICAgIG9iamVjdE1vZGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogZmFsc2VcbiAgfSk7XG5cbiAgd3Mub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiBtZXNzYWdlKG1zZykge1xuICAgIGlmICghZHVwbGV4LnB1c2gobXNnKSkge1xuICAgICAgcmVzdW1lT25SZWNlaXZlckRyYWluID0gZmFsc2U7XG4gICAgICB3cy5fc29ja2V0LnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBkdXBsZXguZGVzdHJveShlcnIpO1xuICB9KTtcblxuICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBkdXBsZXgucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgZHVwbGV4Ll9kZXN0cm95ID0gZnVuY3Rpb24oZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DTE9TRUQpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG5cbiAgICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG5cbiAgICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcbiAgICB9KTtcbiAgICB3cy50ZXJtaW5hdGUoKTtcbiAgfTtcblxuICBkdXBsZXguX2ZpbmFsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fZmluYWwoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBgX3NvY2tldGAgcHJvcGVydHkgaXMgYG51bGxgIGl0IG1lYW5zIHRoYXQgYHdzYCBpcyBhXG4gICAgLy8gY2xpZW50IHdlYnNvY2tldCBhbmQgdGhlIGhhbmRzaGFrZSBmYWlsZWQuIEluIGZhY3QsIHdoZW4gdGhpcyBoYXBwZW5zLCBhXG4gICAgLy8gc29ja2V0IGlzIG5ldmVyIGFzc2lnbmVkIHRvIHRoZSB3ZWJzb2NrZXQuIFdhaXQgZm9yIHRoZSBgJ2Vycm9yJ2AgZXZlbnRcbiAgICAvLyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGUgd2Vic29ja2V0LlxuICAgIGlmICh3cy5fc29ja2V0ID09PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAod3MuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIGlmIChkdXBsZXguX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkgZHVwbGV4LmRlc3Ryb3koKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3MuX3NvY2tldC5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgIC8vIGBkdXBsZXhgIGlzIG5vdCBkZXN0cm95ZWQgaGVyZSBiZWNhdXNlIHRoZSBgJ2VuZCdgIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZW1pdHRlZCBvbiBgZHVwbGV4YCBhZnRlciB0aGlzIGAnZmluaXNoJ2AgZXZlbnQuIFRoZSBFT0Ygc2lnbmFsaW5nXG4gICAgICAgIC8vIGBudWxsYCBjaHVuayBpcywgaW4gZmFjdCwgcHVzaGVkIHdoZW4gdGhlIHdlYnNvY2tldCBlbWl0cyBgJ2Nsb3NlJ2AuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICAgIHdzLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIGR1cGxleC5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5PUEVOICYmICFyZXN1bWVPblJlY2VpdmVyRHJhaW4pIHtcbiAgICAgIHJlc3VtZU9uUmVjZWl2ZXJEcmFpbiA9IHRydWU7XG4gICAgICBpZiAoIXdzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pIHdzLl9zb2NrZXQucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIGR1cGxleC5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3Muc2VuZChjaHVuaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGR1cGxleC5vbignZW5kJywgZHVwbGV4T25FbmQpO1xuICBkdXBsZXgub24oJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHJldHVybiBkdXBsZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlV2ViU29ja2V0U3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG50cnkge1xuICBjb25zdCBpc1ZhbGlkVVRGOCA9IHJlcXVpcmUoJ3V0Zi04LXZhbGlkYXRlJyk7XG5cbiAgZXhwb3J0cy5pc1ZhbGlkVVRGOCA9XG4gICAgdHlwZW9mIGlzVmFsaWRVVEY4ID09PSAnb2JqZWN0J1xuICAgICAgPyBpc1ZhbGlkVVRGOC5WYWxpZGF0aW9uLmlzVmFsaWRVVEY4IC8vIHV0Zi04LXZhbGlkYXRlQDwzLjAuMFxuICAgICAgOiBpc1ZhbGlkVVRGODtcbn0gY2F0Y2ggKGUpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgZXhwb3J0cy5pc1ZhbGlkVVRGOCA9ICgpID0+IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhdHVzIGNvZGUgaXMgYWxsb3dlZCBpbiBhIGNsb3NlIGZyYW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzdGF0dXMgY29kZSBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydHMuaXNWYWxpZFN0YXR1c0NvZGUgPSAoY29kZSkgPT4ge1xuICByZXR1cm4gKFxuICAgIChjb2RlID49IDEwMDAgJiZcbiAgICAgIGNvZGUgPD0gMTAxNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNSAmJlxuICAgICAgY29kZSAhPT0gMTAwNikgfHxcbiAgICAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSlcbiAgKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgeyBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IHsgY3JlYXRlU2VydmVyLCBTVEFUVVNfQ09ERVMgfSA9IHJlcXVpcmUoJ2h0dHAnKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IHsgR1VJRCwga1dlYlNvY2tldCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga2V5UmVnZXggPSAvXlsrLzAtOUEtWmEtel17MjJ9PT0kLztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQgc2VydmVyLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXRTZXJ2ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgYFdlYlNvY2tldFNlcnZlcmAgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5iYWNrbG9nIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgcXVldWUgb2YgcGVuZGluZ1xuICAgKiAgICAgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNsaWVudFRyYWNraW5nIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byB0cmFja1xuICAgKiAgICAgY2xpZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmhhbmRsZVByb3RvY29scyBBIGhvb2sgdG8gaGFuZGxlIHByb3RvY29sc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5ob3N0IFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWF4UGF5bG9hZCBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubm9TZXJ2ZXIgRW5hYmxlIG5vIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnBhdGggQWNjZXB0IG9ubHkgY29ubmVjdGlvbnMgbWF0Y2hpbmcgdGhpcyBwYXRoXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSBFbmFibGUvZGlzYWJsZVxuICAgKiAgICAgcGVybWVzc2FnZS1kZWZsYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBvcnQgVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJ9IG9wdGlvbnMuc2VydmVyIEEgcHJlLWNyZWF0ZWQgSFRUUC9TIHNlcnZlciB0byB1c2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy52ZXJpZnlDbGllbnQgQSBob29rIHRvIHJlamVjdCBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBmYWxzZSxcbiAgICAgIGhhbmRsZVByb3RvY29sczogbnVsbCxcbiAgICAgIGNsaWVudFRyYWNraW5nOiB0cnVlLFxuICAgICAgdmVyaWZ5Q2xpZW50OiBudWxsLFxuICAgICAgbm9TZXJ2ZXI6IGZhbHNlLFxuICAgICAgYmFja2xvZzogbnVsbCwgLy8gdXNlIGRlZmF1bHQgKDUxMSBhcyBpbXBsZW1lbnRlZCBpbiBuZXQuanMpXG4gICAgICBzZXJ2ZXI6IG51bGwsXG4gICAgICBob3N0OiBudWxsLFxuICAgICAgcGF0aDogbnVsbCxcbiAgICAgIHBvcnQ6IG51bGwsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLnBvcnQgPT0gbnVsbCAmJiAhb3B0aW9ucy5zZXJ2ZXIgJiYgIW9wdGlvbnMubm9TZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucG9ydCAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9zZXJ2ZXIgPSBjcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBTVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4oXG4gICAgICAgIG9wdGlvbnMucG9ydCxcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxuICAgICAgICBvcHRpb25zLmJhY2tsb2csXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IGFkZExpc3RlbmVycyh0aGlzLl9zZXJ2ZXIsIHtcbiAgICAgICAgbGlzdGVuaW5nOiB0aGlzLmVtaXQuYmluZCh0aGlzLCAnbGlzdGVuaW5nJyksXG4gICAgICAgIGVycm9yOiB0aGlzLmVtaXQuYmluZCh0aGlzLCAnZXJyb3InKSxcbiAgICAgICAgdXBncmFkZTogKHJlcSwgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCAod3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbicsIHdzLCByZXEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZCBhZGRyZXNzLCB0aGUgYWRkcmVzcyBmYW1pbHkgbmFtZSwgYW5kIHBvcnQgb2YgdGhlIHNlcnZlclxuICAgKiBhcyByZXBvcnRlZCBieSB0aGUgb3BlcmF0aW5nIHN5c3RlbSBpZiBsaXN0ZW5pbmcgb24gYW4gSVAgc29ja2V0LlxuICAgKiBJZiB0aGUgc2VydmVyIGlzIGxpc3RlbmluZyBvbiBhIHBpcGUgb3IgVU5JWCBkb21haW4gc29ja2V0LCB0aGUgbmFtZSBpc1xuICAgKiByZXR1cm5lZCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IFRoZSBhZGRyZXNzIG9mIHRoZSBzZXJ2ZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgb3BlcmF0aW5nIGluIFwibm9TZXJ2ZXJcIiBtb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9zZXJ2ZXIuYWRkcmVzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKGNiKSB0aGlzLm9uY2UoJ2Nsb3NlJywgY2IpO1xuXG4gICAgLy9cbiAgICAvLyBUZXJtaW5hdGUgYWxsIGFzc29jaWF0ZWQgY2xpZW50cy5cbiAgICAvL1xuICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXMuY2xpZW50cykgY2xpZW50LnRlcm1pbmF0ZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcblxuICAgIGlmIChzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fc2VydmVyID0gbnVsbDtcblxuICAgICAgLy9cbiAgICAgIC8vIENsb3NlIHRoZSBodHRwIHNlcnZlciBpZiBpdCB3YXMgaW50ZXJuYWxseSBjcmVhdGVkLlxuICAgICAgLy9cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucG9ydCAhPSBudWxsKSB7XG4gICAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB0aGlzLmVtaXQoJ2Nsb3NlJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZShyZXEpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgICBjb25zdCBwYXRobmFtZSA9IGluZGV4ICE9PSAtMSA/IHJlcS51cmwuc2xpY2UoMCwgaW5kZXgpIDogcmVxLnVybDtcblxuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEhUVFAgVXBncmFkZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7bmV0LlNvY2tldH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICBjb25zdCBrZXkgPVxuICAgICAgcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddLnRyaW0oKVxuICAgICAgICA6IGZhbHNlO1xuICAgIGNvbnN0IHZlcnNpb24gPSArcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbiddO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIGlmIChcbiAgICAgIHJlcS5tZXRob2QgIT09ICdHRVQnIHx8XG4gICAgICByZXEuaGVhZGVycy51cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnIHx8XG4gICAgICAha2V5IHx8XG4gICAgICAha2V5UmVnZXgudGVzdChrZXkpIHx8XG4gICAgICAodmVyc2lvbiAhPT0gOCAmJiB2ZXJzaW9uICE9PSAxMykgfHxcbiAgICAgICF0aGlzLnNob3VsZEhhbmRsZShyZXEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgICAgIHRydWUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZlcnMgPSBwYXJzZShyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ10pO1xuXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIGNsaWVudCB2ZXJpZmljYXRpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBvcmlnaW46XG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuY29ubmVjdGlvbi5hdXRob3JpemVkIHx8IHJlcS5jb25uZWN0aW9uLmVuY3J5cHRlZCksXG4gICAgICAgIHJlcVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbywgKHZlcmlmaWVkLCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKGtleSwgZXh0ZW5zaW9ucywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8pKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDEpO1xuICAgIH1cblxuICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKGtleSwgZXh0ZW5zaW9ucywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wbGV0ZVVwZ3JhZGUoa2V5LCBleHRlbnNpb25zLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICAvL1xuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxuICAgIC8vXG4gICAgaWYgKCFzb2NrZXQucmVhZGFibGUgfHwgIXNvY2tldC53cml0YWJsZSkgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG5cbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcbiAgICAgICAgICAnc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtkaWdlc3R9YFxuICAgIF07XG5cbiAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQobnVsbCk7XG4gICAgbGV0IHByb3RvY29sID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcblxuICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgcHJvdG9jb2wgPSBwcm90b2NvbC50cmltKCkuc3BsaXQoLyAqLCAqLyk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgcHJvdG9jb2wgc2VsZWN0aW9uIGhhbmRsZXIuXG4gICAgICAvL1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMpIHtcbiAgICAgICAgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29sLCByZXEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdG9jb2wgPSBwcm90b2NvbFswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3RvY29sKSB7XG4gICAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJHtwcm90b2NvbH1gKTtcbiAgICAgICAgd3MucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdCh7XG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogW3BhcmFtc11cbiAgICAgIH0pO1xuICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnM6ICR7dmFsdWV9YCk7XG4gICAgICB3cy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBBbGxvdyBleHRlcm5hbCBtb2RpZmljYXRpb24vaW5zcGVjdGlvbiBvZiBoYW5kc2hha2UgaGVhZGVycy5cbiAgICAvL1xuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMsIHJlcSk7XG5cbiAgICBzb2NrZXQud3JpdGUoaGVhZGVycy5jb25jYXQoJ1xcclxcbicpLmpvaW4oJ1xcclxcbicpKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB3cy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZCk7XG5cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHRoaXMuY2xpZW50cy5kZWxldGUod3MpKTtcbiAgICB9XG5cbiAgICBjYih3cyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRTZXJ2ZXI7XG5cbi8qKlxuICogQWRkIGV2ZW50IGxpc3RlbmVycyBvbiBhbiBgRXZlbnRFbWl0dGVyYCB1c2luZyBhIG1hcCBvZiA8ZXZlbnQsIGxpc3RlbmVyPlxuICogcGFpcnMuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuICogQHBhcmFtIHtPYmplY3QuPFN0cmluZywgRnVuY3Rpb24+fSBtYXAgVGhlIGxpc3RlbmVycyB0byBhZGRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCByZW1vdmUgdGhlIGFkZGVkIGxpc3RlbmVycyB3aGVuIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBwcmVtYXR1cmUgc29ja2V0IGVycm9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBUaGUgSFRUUCByZXNwb25zZSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW2hlYWRlcnNdIEFkZGl0aW9uYWwgSFRUUCByZXNwb25zZSBoZWFkZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpIHtcbiAgaWYgKHNvY2tldC53cml0YWJsZSkge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IFNUQVRVU19DT0RFU1tjb2RlXTtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQ29ubmVjdGlvbjogJ2Nsb3NlJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgICAgLi4uaGVhZGVyc1xuICAgIH07XG5cbiAgICBzb2NrZXQud3JpdGUoXG4gICAgICBgSFRUUC8xLjEgJHtjb2RlfSAke1NUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXG4gICAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcbiAgICAgICAgJ1xcclxcblxcclxcbicgK1xuICAgICAgICBtZXNzYWdlXG4gICAgKTtcbiAgfVxuXG4gIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgc29ja2V0LmRlc3Ryb3koKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgcmFuZG9tQnl0ZXMsIGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXInKTtcbmNvbnN0IFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyJyk7XG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSLFxuICBHVUlELFxuICBrU3RhdHVzQ29kZSxcbiAga1dlYlNvY2tldCxcbiAgTk9PUFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIgfSA9IHJlcXVpcmUoJy4vZXZlbnQtdGFyZ2V0Jyk7XG5jb25zdCB7IGZvcm1hdCwgcGFyc2UgfSA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCB7IHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IHJlYWR5U3RhdGVzID0gWydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xuY29uc3QgY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgV2ViU29ja2V0YC5cbiAgICpcbiAgICogQHBhcmFtIHsoU3RyaW5nfHVybC5VUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLnByb3RvY29sID0gJyc7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gQklOQVJZX1RZUEVTWzBdO1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gJyc7XG4gICAgdGhpcy5fY2xvc2VUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fY2xvc2VDb2RlID0gMTAwNjtcbiAgICB0aGlzLl9leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NlbmRlciA9IG51bGw7XG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcblxuICAgIGlmIChhZGRyZXNzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9idWZmZXJlZEFtb3VudCA9IDA7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVkaXJlY3RzID0gMDtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgICAgICBwcm90b2NvbHMgPSBwcm90b2NvbHMuam9pbignLCAnKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3RvY29scyA9PT0gJ29iamVjdCcgJiYgcHJvdG9jb2xzICE9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG4gICAgICAgIHByb3RvY29scyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBnZXQgQ09OTkVDVElORygpIHtcbiAgICByZXR1cm4gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gIH1cbiAgZ2V0IENMT1NJTkcoKSB7XG4gICAgcmV0dXJuIFdlYlNvY2tldC5DTE9TSU5HO1xuICB9XG4gIGdldCBDTE9TRUQoKSB7XG4gICAgcmV0dXJuIFdlYlNvY2tldC5DTE9TRUQ7XG4gIH1cbiAgZ2V0IE9QRU4oKSB7XG4gICAgcmV0dXJuIFdlYlNvY2tldC5PUEVOO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZGV2aWF0ZXMgZnJvbSB0aGUgV0hBVFdHIGludGVyZmFjZSBzaW5jZSB3cyBkb2Vzbid0IHN1cHBvcnQgdGhlXG4gICAqIHJlcXVpcmVkIGRlZmF1bHQgXCJibG9iXCIgdHlwZSAoaW5zdGVhZCB3ZSBkZWZpbmUgYSBjdXN0b20gXCJub2RlYnVmZmVyXCJcbiAgICogdHlwZSkuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgYmluYXJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluYXJ5VHlwZTtcbiAgfVxuXG4gIHNldCBiaW5hcnlUeXBlKHR5cGUpIHtcbiAgICBpZiAoIUJJTkFSWV9UWVBFUy5pbmNsdWRlcyh0eXBlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IHR5cGU7XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IHRvIGNoYW5nZSBgYmluYXJ5VHlwZWAgb24gdGhlIGZseS5cbiAgICAvL1xuICAgIGlmICh0aGlzLl9yZWNlaXZlcikgdGhpcy5fcmVjZWl2ZXIuX2JpbmFyeVR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYnVmZmVyZWRBbW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDtcblxuICAgIC8vXG4gICAgLy8gYHNvY2tldC5idWZmZXJTaXplYCBpcyBgdW5kZWZpbmVkYCBpZiB0aGUgc29ja2V0IGlzIGNsb3NlZC5cbiAgICAvL1xuICAgIHJldHVybiAodGhpcy5fc29ja2V0LmJ1ZmZlclNpemUgfHwgMCkgKyB0aGlzLl9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBleHRlbnNpb25zKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bmV0LlNvY2tldH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFBheWxvYWQgVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNvY2tldChzb2NrZXQsIGhlYWQsIG1heFBheWxvYWQpIHtcbiAgICBjb25zdCByZWNlaXZlciA9IG5ldyBSZWNlaXZlcihcbiAgICAgIHRoaXMuX2JpbmFyeVR5cGUsXG4gICAgICB0aGlzLl9leHRlbnNpb25zLFxuICAgICAgdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBtYXhQYXlsb2FkXG4gICAgKTtcblxuICAgIHRoaXMuX3NlbmRlciA9IG5ldyBTZW5kZXIoc29ja2V0LCB0aGlzLl9leHRlbnNpb25zKTtcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHJlY2VpdmVyW2tXZWJTb2NrZXRdID0gdGhpcztcbiAgICBzb2NrZXRba1dlYlNvY2tldF0gPSB0aGlzO1xuXG4gICAgcmVjZWl2ZXIub24oJ2NvbmNsdWRlJywgcmVjZWl2ZXJPbkNvbmNsdWRlKTtcbiAgICByZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICAgIHJlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25FcnJvcik7XG4gICAgcmVjZWl2ZXIub24oJ21lc3NhZ2UnLCByZWNlaXZlck9uTWVzc2FnZSk7XG4gICAgcmVjZWl2ZXIub24oJ3BpbmcnLCByZWNlaXZlck9uUGluZyk7XG4gICAgcmVjZWl2ZXIub24oJ3BvbmcnLCByZWNlaXZlck9uUG9uZyk7XG5cbiAgICBzb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICBzb2NrZXQuc2V0Tm9EZWxheSgpO1xuXG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG5cbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gICAgc29ja2V0Lm9uKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgICBzb2NrZXQub24oJ2VuZCcsIHNvY2tldE9uRW5kKTtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0Q2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLmNsZWFudXAoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cbiAgICpcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tK1xuICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cbiAgICogICAgfCAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tKyAgICAgfFxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgICAgICAgfFxuICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICB8XG4gICAqICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLSsgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXG4gICAqICAgIHwgICAgICAgICArLS0tKyAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLStcbiAgICogICAgIC0gLSAtIC0gLXxmaW58PC0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogICAgICAgICAgICAgICstLS0rXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgQSBzdHJpbmcgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TSU5HKSB7XG4gICAgICBpZiAodGhpcy5fY2xvc2VGcmFtZVNlbnQgJiYgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkKSB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgaGFuZGxlZCBieSB0aGUgYCdlcnJvcidgIGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQuIFdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuICAgICAgLy9cbiAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCkgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgIH0pO1xuXG4gICAgLy9cbiAgICAvLyBTcGVjaWZ5IGEgdGltZW91dCBmb3IgdGhlIGNsb3NpbmcgaGFuZHNoYWtlIHRvIGNvbXBsZXRlLlxuICAgIC8vXG4gICAgdGhpcy5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveS5iaW5kKHRoaXMuX3NvY2tldCksXG4gICAgICBjbG9zZVRpbWVvdXRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBpbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBpbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcG9uZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwb25nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5wb25nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNvbXByZXNzIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5iaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5maW4gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZSBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycsXG4gICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBjb21wcmVzczogdHJ1ZSxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZGVyLnNlbmQoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG9wdHMsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5cbnJlYWR5U3RhdGVzLmZvckVhY2goKHJlYWR5U3RhdGUsIGkpID0+IHtcbiAgV2ViU29ja2V0W3JlYWR5U3RhdGVdID0gaTtcbn0pO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbGlzdGVuZXIgb2YgdGhlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7KEZ1bmN0aW9ufHVuZGVmaW5lZCl9IFRoZSBldmVudCBsaXN0ZW5lciBvciBgdW5kZWZpbmVkYFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhtZXRob2QpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5fbGlzdGVuZXIpIHJldHVybiBsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZm9yIHRoZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2V0KGxpc3RlbmVyKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhtZXRob2QpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVtb3ZlIG9ubHkgdGhlIGxpc3RlbmVycyBhZGRlZCB2aWEgYGFkZEV2ZW50TGlzdGVuZXJgLlxuICAgICAgICAvL1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldLl9saXN0ZW5lcikgdGhpcy5yZW1vdmVMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgY2xpZW50IHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7KFN0cmluZ3x1cmwuVVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgRW5hYmxlL2Rpc2FibGVcbiAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXQgVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZVxuICogICAgIGhhbmRzaGFrZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wcm90b2NvbFZlcnNpb24gVmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LVZlcnNpb25gXG4gKiAgICAgaGVhZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5vcmlnaW4gVmFsdWUgb2YgdGhlIGBPcmlnaW5gIG9yXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtT3JpZ2luYCBoZWFkZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm1heFBheWxvYWQgVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHMgV2hldGhlciBvciBub3QgdG8gZm9sbG93IHJlZGlyZWN0c1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWF4UmVkaXJlY3RzIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHMgYWxsb3dlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxuICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGZvbGxvd1JlZGlyZWN0czogZmFsc2UsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAuLi5vcHRpb25zLFxuICAgIGNyZWF0ZUNvbm5lY3Rpb246IHVuZGVmaW5lZCxcbiAgICBzb2NrZXRQYXRoOiB1bmRlZmluZWQsXG4gICAgaG9zdG5hbWU6IHVuZGVmaW5lZCxcbiAgICBwcm90b2NvbDogdW5kZWZpbmVkLFxuICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICBtZXRob2Q6IHVuZGVmaW5lZCxcbiAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgcGF0aDogdW5kZWZpbmVkLFxuICAgIHBvcnQ6IHVuZGVmaW5lZFxuICB9O1xuXG4gIGlmICghcHJvdG9jb2xWZXJzaW9ucy5pbmNsdWRlcyhvcHRzLnByb3RvY29sVmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke29wdHMucHJvdG9jb2xWZXJzaW9ufSBgICtcbiAgICAgICAgYChzdXBwb3J0ZWQgdmVyc2lvbnM6ICR7cHJvdG9jb2xWZXJzaW9ucy5qb2luKCcsICcpfSlgXG4gICAgKTtcbiAgfVxuXG4gIGxldCBwYXJzZWRVcmw7XG5cbiAgaWYgKGFkZHJlc3MgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBwYXJzZWRVcmwgPSBhZGRyZXNzO1xuICAgIHdlYnNvY2tldC51cmwgPSBhZGRyZXNzLmhyZWY7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB3ZWJzb2NrZXQudXJsID0gYWRkcmVzcztcbiAgfVxuXG4gIGNvbnN0IGlzVW5peFNvY2tldCA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzK3VuaXg6JztcblxuICBpZiAoIXBhcnNlZFVybC5ob3N0ICYmICghaXNVbml4U29ja2V0IHx8ICFwYXJzZWRVcmwucGF0aG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHt3ZWJzb2NrZXQudXJsfWApO1xuICB9XG5cbiAgY29uc3QgaXNTZWN1cmUgPVxuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzczonIHx8IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgZ2V0ID0gaXNTZWN1cmUgPyBodHRwcy5nZXQgOiBodHRwLmdldDtcbiAgbGV0IHBlck1lc3NhZ2VEZWZsYXRlO1xuXG4gIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiA9IGlzU2VjdXJlID8gdGxzQ29ubmVjdCA6IG5ldENvbm5lY3Q7XG4gIG9wdHMuZGVmYXVsdFBvcnQgPSBvcHRzLmRlZmF1bHRQb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLnBvcnQgPSBwYXJzZWRVcmwucG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxuICAgID8gcGFyc2VkVXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgIDogcGFyc2VkVXJsLmhvc3RuYW1lO1xuICBvcHRzLmhlYWRlcnMgPSB7XG4gICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6IG9wdHMucHJvdG9jb2xWZXJzaW9uLFxuICAgICdTZWMtV2ViU29ja2V0LUtleSc6IGtleSxcbiAgICBDb25uZWN0aW9uOiAnVXBncmFkZScsXG4gICAgVXBncmFkZTogJ3dlYnNvY2tldCcsXG4gICAgLi4ub3B0cy5oZWFkZXJzXG4gIH07XG4gIG9wdHMucGF0aCA9IHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XG4gIG9wdHMudGltZW91dCA9IG9wdHMuaGFuZHNoYWtlVGltZW91dDtcblxuICBpZiAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0cy5tYXhQYXlsb2FkXG4gICAgKTtcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyddID0gZm9ybWF0KHtcbiAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogcGVyTWVzc2FnZURlZmxhdGUub2ZmZXIoKVxuICAgIH0pO1xuICB9XG4gIGlmIChwcm90b2NvbHMpIHtcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHByb3RvY29scztcbiAgfVxuICBpZiAob3B0cy5vcmlnaW4pIHtcbiAgICBpZiAob3B0cy5wcm90b2NvbFZlcnNpb24gPCAxMykge1xuICAgICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LU9yaWdpbiddID0gb3B0cy5vcmlnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMuaGVhZGVycy5PcmlnaW4gPSBvcHRzLm9yaWdpbjtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcnNlZFVybC51c2VybmFtZSB8fCBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICBvcHRzLmF1dGggPSBgJHtwYXJzZWRVcmwudXNlcm5hbWV9OiR7cGFyc2VkVXJsLnBhc3N3b3JkfWA7XG4gIH1cblxuICBpZiAoaXNVbml4U29ja2V0KSB7XG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcblxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgbGV0IHJlcSA9ICh3ZWJzb2NrZXQuX3JlcSA9IGdldChvcHRzKSk7XG5cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBpZiAod2Vic29ja2V0Ll9yZXEuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuICAgIHdlYnNvY2tldC5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgY29uc3QgYWRkciA9IG5ldyBVUkwobG9jYXRpb24sIGFkZHJlc3MpO1xuXG4gICAgICBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldC5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgcmVxLCByZXMpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShcbiAgICAgICAgd2Vic29ja2V0LFxuICAgICAgICByZXEsXG4gICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgd2Vic29ja2V0LmVtaXQoJ3VwZ3JhZGUnLCByZXMpO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgdXNlciBtYXkgaGF2ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24gZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgdXBncmFkZWBcbiAgICAvLyBldmVudC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGNvbnN0IHByb3RMaXN0ID0gKHByb3RvY29scyB8fCAnJykuc3BsaXQoLywgKi8pO1xuICAgIGxldCBwcm90RXJyb3I7XG5cbiAgICBpZiAoIXByb3RvY29scyAmJiBzZXJ2ZXJQcm90KSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcbiAgICB9IGVsc2UgaWYgKHByb3RvY29scyAmJiAhc2VydmVyUHJvdCkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcbiAgICB9IGVsc2UgaWYgKHNlcnZlclByb3QgJiYgIXByb3RMaXN0LmluY2x1ZGVzKHNlcnZlclByb3QpKSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XG4gICAgfVxuXG4gICAgaWYgKHByb3RFcnJvcikge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIHByb3RFcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlcnZlclByb3QpIHdlYnNvY2tldC5wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBwYXJzZShyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ10pO1xuXG4gICAgICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIHdlYnNvY2tldC5fZXh0ZW5zaW9uc1tcbiAgICAgICAgICAgIFBlck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVcbiAgICAgICAgICBdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBhYm9ydEhhbmRzaGFrZShcbiAgICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgb3B0cy5tYXhQYXlsb2FkKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXQpfSBzdHJlYW0gVGhlIHJlcXVlc3QgdG8gYWJvcnQgb3IgdGhlXG4gKiAgICAgc29ja2V0IHRvIGRlc3Ryb3lcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHN0cmVhbSwgbWVzc2FnZSkge1xuICB3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XG5cbiAgaWYgKHN0cmVhbS5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW0uYWJvcnQoKTtcbiAgICBzdHJlYW0ub25jZSgnYWJvcnQnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpO1xuICAgIHN0cmVhbS5vbmNlKCdlcnJvcicsIHdlYnNvY2tldC5lbWl0LmJpbmQod2Vic29ja2V0LCAnZXJyb3InKSk7XG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgd2Vic29ja2V0LmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldCkpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGNhc2VzIHdoZXJlIHRoZSBgcGluZygpYCwgYHBvbmcoKWAsIG9yIGBzZW5kKClgIG1ldGhvZHMgYXJlIGNhbGxlZFxuICogd2hlbiB0aGUgYHJlYWR5U3RhdGVgIGF0dHJpYnV0ZSBpcyBgQ0xPU0lOR2Agb3IgYENMT1NFRGAuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0b0J1ZmZlcihkYXRhKS5sZW5ndGg7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBgX2J1ZmZlcmVkQW1vdW50YCBwcm9wZXJ0eSBpcyB1c2VkIG9ubHkgd2hlbiB0aGUgcGVlciBpcyBhIGNsaWVudCBhbmRcbiAgICAvLyB0aGUgb3BlbmluZyBoYW5kc2hha2UgZmFpbHMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGZhY3QsIHRoZVxuICAgIC8vIGBzZXRTb2NrZXQoKWAgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHNvIHRoZSBgX3NvY2tldGAgYW5kIGBfc2VuZGVyYFxuICAgIC8vIHByb3BlcnRpZXMgYXJlIHNldCB0byBgbnVsbGAuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0Ll9zb2NrZXQpIHdlYnNvY2tldC5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzICs9IGxlbmd0aDtcbiAgICBlbHNlIHdlYnNvY2tldC5fYnVmZmVyZWRBbW91bnQgKz0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKGNiKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgYFdlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAke3dlYnNvY2tldC5yZWFkeVN0YXRlfSBgICtcbiAgICAgICAgYCgke3JlYWR5U3RhdGVzW3dlYnNvY2tldC5yZWFkeVN0YXRlXX0pYFxuICAgICk7XG4gICAgY2IoZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHdlYnNvY2tldC5fc29ja2V0LnJlc3VtZSgpO1xuXG4gIHdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0Ll9jbG9zZU1lc3NhZ2UgPSByZWFzb247XG4gIHdlYnNvY2tldC5fY2xvc2VDb2RlID0gY29kZTtcblxuICBpZiAoY29kZSA9PT0gMTAwNSkgd2Vic29ja2V0LmNsb3NlKCk7XG4gIGVsc2Ugd2Vic29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZHJhaW4nYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uX3NvY2tldC5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFJhbmdlRXJyb3J8RXJyb3IpfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG5cbiAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBlcnJba1N0YXR1c0NvZGVdO1xuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB3ZWJzb2NrZXQuX3NvY2tldC5kZXN0cm95KCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZmluaXNoJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkZpbmlzaCgpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdtZXNzYWdlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25NZXNzYWdlKGRhdGEpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncGluZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwaW5nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0LnBvbmcoZGF0YSwgIXdlYnNvY2tldC5faXNTZXJ2ZXIsIE5PT1ApO1xuICB3ZWJzb2NrZXQuZW1pdCgncGluZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcG9uZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBvbmcoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25DbG9zZSgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG5cbiAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICAvL1xuICAvLyBUaGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGhhdmUgYmVlbiByZWNlaXZlZCBvciB0aGUgYCdlbmQnYCBldmVudCBlbWl0dGVkLFxuICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHNvY2tldCB3YXMgZGVzdHJveWVkIGR1ZSB0byBhbiBlcnJvci4gRW5zdXJlIHRoYXQgdGhlXG4gIC8vIGByZWNlaXZlcmAgc3RyZWFtIGlzIGNsb3NlZCBhZnRlciB3cml0aW5nIGFueSByZW1haW5pbmcgYnVmZmVyZWQgZGF0YSB0b1xuICAvLyBpdC4gSWYgdGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHNvY2tldCBpcyBpbiBmbG93aW5nIG1vZGUgdGhlbiB0aGVyZSBpcyBub1xuICAvLyBidWZmZXJlZCBkYXRhIGFzIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gYWxyZWFkeSB3cml0dGVuIGFuZCBgcmVhZGFibGUucmVhZCgpYFxuICAvLyB3aWxsIHJldHVybiBgbnVsbGAuIElmIGluc3RlYWQsIHRoZSBzb2NrZXQgaXMgcGF1c2VkLCBhbnkgcG9zc2libGUgYnVmZmVyZWRcbiAgLy8gZGF0YSB3aWxsIGJlIHJlYWQgYXMgYSBzaW5nbGUgY2h1bmsgYW5kIGVtaXR0ZWQgc3luY2hyb25vdXNseSBpbiBhIHNpbmdsZVxuICAvLyBgJ2RhdGEnYCBldmVudC5cbiAgLy9cbiAgd2Vic29ja2V0Ll9zb2NrZXQucmVhZCgpO1xuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuXG4gIGNsZWFyVGltZW91dCh3ZWJzb2NrZXQuX2Nsb3NlVGltZXIpO1xuXG4gIGlmIChcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkIHx8XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgKSB7XG4gICAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZmluaXNoJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkRhdGEoY2h1bmspIHtcbiAgaWYgKCF0aGlzW2tXZWJTb2NrZXRdLl9yZWNlaXZlci53cml0ZShjaHVuaykpIHtcbiAgICB0aGlzLnBhdXNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2VuZCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRW5kKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgbmV0LlNvY2tldGAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgdGhpcy5vbignZXJyb3InLCBOT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ3RocmVlL3NyYy9tYXRoL1ZlY3RvcjMnO1xuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJ3RocmVlL3NyYy9tYXRoL1F1YXRlcm5pb24nO1xuXG5nbG9iYWwuZGVidWcgPSAoLi4ucGFyYW1zKSA9PiBjb25zb2xlLmxvZyhgWyR7KG5ldyBEYXRlKS50b0xvY2FsZVRpbWVTdHJpbmcoKX1dYCwgLi4ucGFyYW1zKTtcblxuY29uc3QgT2JqZWN0M0QgPSAocGFyYW1zID0ge30pID0+IHtcblx0bGV0IG9iamVjdHMgPSBbXTtcblx0Y29uc3QgYWRkID0gb2JqZWN0ID0+IG9iamVjdHMucHVzaChvYmplY3QpO1xuXHRjb25zdCByZW1vdmUgPSBvYmplY3QgPT4gb2JqZWN0cyA9IG9iamVjdC5maWx0ZXIobyA9PiBvICE9PSBvYmplY3QpO1xuXG5cdGNvbnN0IG9iamVjdCA9ICh7XG5cdFx0cG9zaXRpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0c2NhbGU6IG5ldyBWZWN0b3IzKCksXG5cdFx0cm90YXRpb246IG5ldyBRdWF0ZXJuaW9uKCksXG5cdFx0YWRkLFxuXHRcdHJlbW92ZSxcblx0XHRsb29rQXQ6ICgpID0+ICh7fSksXG5cdFx0dHJhdmVyc2U6ICgpID0+ICh7fSksXG5cdFx0dXBkYXRlTWF0cml4OiAoKSA9PiAoe30pLFxuXHRcdGdldE9iamVjdEJ5TmFtZTogKCkgPT4gb2JqZWN0LFxuXHRcdC4uLnBhcmFtcyxcblx0fSk7XG5cblx0b2JqZWN0LnF1YXRlcm5pb24gPSBvYmplY3Qucm90YXRpb247XG5cdG9iamVjdC5zY2VuZSA9IG9iamVjdDtcblx0b2JqZWN0LmNsb25lID0gKCkgPT4ge1xuXHRcdGNvbnN0IGNsb25lZCA9IE9iamVjdDNEKCk7XG5cdFx0Y2xvbmVkLnBvc2l0aW9uLmNsb25lKG9iamVjdC5wb3NpdGlvbik7XG5cdFx0Y2xvbmVkLnNjYWxlLmNsb25lKG9iamVjdC5zY2FsZSk7XG5cdFx0Y2xvbmVkLnJvdGF0aW9uLmNsb25lKG9iamVjdC5yb3RhdGlvbik7XG5cdFx0cmV0dXJuIGNsb25lZDtcblx0fTtcblxuXHRyZXR1cm4gb2JqZWN0O1xufTtcblxuZ2xvYmFsLlRIUkVFID0ge1xuXHRWZWN0b3IzLFxuXHRRdWF0ZXJuaW9uLFxuXHRPYmplY3QzRCxcblx0V2ViR0xSZW5kZXJlcjogKCkgPT4gKHtcblx0XHRyZW5kZXI6ICgpID0+ICh7fSksXG5cdFx0c2V0U2l6ZTogKCkgPT4gKHt9KSxcblx0XHRnZXRDb250ZXh0OiAoKSA9PiAoe1xuXHRcdFx0Y2FudmFzOiB7XG5cdFx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0XHRoZWlnaHQ6IDBcblx0XHRcdH0sXG5cdFx0fSksXG5cdFx0c2hhZG93TWFwOiB7fSxcblx0fSksXG5cdFNjZW5lOiAoKSA9PiBPYmplY3QzRCgpLFxuXHRDYWNoZToge30sXG5cdENsb2NrOiAoKSA9PiAoe30pLFxuXHRBbmltYXRpb25NaXhlcjogKCkgPT4gKHtcblx0XHR1cGRhdGU6ICgpID0+ICh7fSksXG5cdFx0Y2xpcEFjdGlvbjogKCkgPT4gKHtcblx0XHRcdHN0b3A6ICgpID0+ICh7fSksXG5cdFx0fSksXG5cdH0pLFxuXHRQQ0ZTb2Z0U2hhZG93TWFwOiAoKSA9PiAoe30pLFxuXHRQZXJzcGVjdGl2ZUNhbWVyYTogKCkgPT4gT2JqZWN0M0QoKSxcblx0UmF5Y2FzdGVyOiAoKSA9PiAoe30pLFxuXHRUZXh0dXJlTG9hZGVyOiAoKSA9PiAoe1xuXHRcdGxvYWQ6ICgpID0+ICh7fSksXG5cdH0pLFxuXHRGb2c6ICgpID0+ICh7fSksXG5cdFJlcGVhdFdyYXBwaW5nOiAoKSA9PiAoe30pLFxuXHRDb2xvcjogKCkgPT4gKHt9KSxcblx0TWVzaDogKCkgPT4gT2JqZWN0M0QoKSxcblx0Q3ViZUdlb21ldHJ5OiAoKSA9PiAoe30pLFxuXHRNZXNoTGFtYmVydE1hdGVyaWFsOiAoKSA9PiAoe30pLFxuXHROb3JtYWxCbGVuZGluZzogKCkgPT4gKHt9KSxcblx0QWRkaXRpdmVCbGVuZGluZzogKCkgPT4gKHt9KSxcblx0R2VvbWV0cnk6ICgpID0+ICh7fSksXG5cdFBvaW50Q2xvdWRNYXRlcmlhbDogKCkgPT4gKHt9KSxcblx0UG9pbnRDbG91ZDogKCkgPT4gKHt9KSxcblx0QW1iaWVudExpZ2h0OiAoKSA9PiAoe30pLFxuXHREaXJlY3Rpb25hbExpZ2h0OiAoKSA9PiB7XG5cdFx0Y29uc3QgbGlnaHQgPSBPYmplY3QzRCgpO1xuXHRcdGxpZ2h0LnNoYWRvdyA9IHtcblx0XHRcdGNhbWVyYToge30sXG5cdFx0XHRtYXBTaXplOiB7fSxcblx0XHR9O1xuXHRcdHJldHVybiBsaWdodDtcblx0fSxcblx0TWVzaEJhc2ljTWF0ZXJpYWw6ICgpID0+ICh7fSksXG5cdEJhY2tTaWRlOiAoKSA9PiAoe30pLFxuXHRNZXNoRmFjZU1hdGVyaWFsOiAoKSA9PiAoe30pLFxufTtcblxuZ2xvYmFsLkdMVEZMb2FkZXIgPSAoKSA9PiAoe1xuXHRsb2FkOiAodXJsLCBjYWxsYmFjaykgPT4gY2FsbGJhY2soT2JqZWN0M0QoKSksXG59KTtcblxuZ2xvYmFsLndpbmRvdyA9IHtcblx0aW5uZXJXaWR0aDogMCxcblx0aW5uZXJIZWlnaHQ6IDAsXG5cdGNsZWFyVGltZW91dDogMCxcblx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBmbiA9PiBzZXRUaW1lb3V0KGZuLCAxMDAwIC8gNjApLFxuXHRsb2NhdGlvbjoge1xuXHRcdHJlbG9hZDogKCkgPT4gZGVidWcoJ3JlbG9hZCBwYWdlJyksXG5cdH0sXG5cdGFkZEV2ZW50TGlzdGVuZXI6ICguLi5wYXJhbXMpID0+IGRlYnVnKCd3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcicsIC4uLnBhcmFtcyksXG5cdHNldFRpbWVvdXQ6IHNldFRpbWVvdXQsXG5cdFdlYlNvY2tldDogKCkgPT4gKHtcblx0XHRvbm9wZW46ICguLi5wYXJhbXMpID0+IGRlYnVnKCd3aW5kb3cuV2ViU29ja2V0Lm9ub3BlbicsIC4uLnBhcmFtcyksXG5cdFx0b25lcnJvcjogKC4uLnBhcmFtcykgPT4gZGVidWcoJ3dpbmRvdy5XZWJTb2NrZXQub25lcnJvcicsIC4uLnBhcmFtcyksXG5cdFx0b25tZXNzYWdlOiAoLi4ucGFyYW1zKSA9PiBkZWJ1Zygnd2luZG93LldlYlNvY2tldC5vbm1lc3NhZ2UnLCAuLi5wYXJhbXMpLFxuXHR9KSxcbn07XG5cbmdsb2JhbC5kb2N1bWVudCA9IHtcblx0Ym9keToge1xuXHRcdGFkZEV2ZW50TGlzdGVuZXI6ICguLi5wYXJhbXMpID0+IGRlYnVnKCdkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXInLCAuLi5wYXJhbXMpLFxuXHRcdHJlbW92ZUV2ZW50TGlzdGVuZXI6ICguLi5wYXJhbXMpID0+IGRlYnVnKCdkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXInLCAuLi5wYXJhbXMpLFxuXHR9LFxuXHRkaXNwYXRjaEV2ZW50OiAoLi4ucGFyYW1zKSA9PiBkZWJ1ZygnZG9jdW1lbnQuZGlzcGF0Y2hFdmVudCcsIC4uLnBhcmFtcyksXG5cdGdldEVsZW1lbnRCeUlkOiAoLi4ucGFyYW1zKSA9PiBkZWJ1ZygnZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQnLCAuLi5wYXJhbXMpLFxuXHRhZGRFdmVudExpc3RlbmVyOiAoLi4ucGFyYW1zKSA9PiBkZWJ1ZygnZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcicsIC4uLnBhcmFtcyksXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6ICguLi5wYXJhbXMpID0+IGRlYnVnKCdkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyJywgLi4ucGFyYW1zKSxcbn07XG5cbmV4cG9ydCBjb25zdCBNb2NrR1VJID0ge1xuXHRcdGlzU2VydmVyOiB0cnVlLFxuXHRcdHNldFJlc3RhcnRCdXR0b25WaXNpYmxlOiAoKSA9PiBudWxsLFxuXHRcdHNldFBhdXNlOiAoKSA9PiBudWxsLFxuXHRcdHJlc3RhcnRHYW1lOiAoKSA9PiBudWxsLFxuXHRcdGlzUGF1c2U6ICgpID0+IGZhbHNlLFxuXHRcdGlzVGhpcmRQZXJzb246ICgpID0+IGZhbHNlLFxuXHRcdHVwZGF0ZTogKCkgPT4gbnVsbCxcblx0XHRzZXRDb25uZWN0aW9uUm9sZTogZGVidWcsXG5cdFx0dXBkYXRlUGxheWVyUGFyYW1zOiAoKSA9PiBudWxsLFxuXHRcdGNsZWFySHBCYXJzOiAoKSA9PiBudWxsLFxuXHRcdHN3aXRjaENhbWVyYTogKCkgPT4gbnVsbCxcblx0XHRzZXRGcHM6ICgpID0+IG51bGwsXG5cdFx0bm90aWZ5OiBkZWJ1Zyxcblx0XHRzZXRMb2FkaW5nOiAoKSA9PiBudWxsLFxufTtcblxuZXhwb3J0IGNvbnN0IE1vY2tSZW5kZXJlciA9IHtcblx0ZnBzOiAxLFxuXHRcdHRhcmdldEZwczogMSxcblx0XHRyZW5kZXJlcjogbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKSxcblx0XHRyZW5kZXI6ICgpID0+ICh7fSksXG59O1xuIiwiaW1wb3J0ICogYXMgd3MgZnJvbSAnd3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuY29uc3QgV2ViU29ja2V0U2VydmVyID0gd3MuU2VydmVyO1xuXG5jbGFzcyBTb2NrZXRTZXJ2ZXIge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmNyZWF0ZVNvY2tldFNlcnZlciA9IHRoaXMuY3JlYXRlU29ja2V0U2VydmVyLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5zYXZlVXNlckRhdGEgPSB0aGlzLnNhdmVVc2VyRGF0YS5iaW5kKHRoaXMpO1xuXHRcdHRoaXMubG9hZFVzZXJEYXRhID0gdGhpcy5sb2FkVXNlckRhdGEuYmluZCh0aGlzKTtcblxuXHRcdHRoaXMuY29uZmlnID0ge1xuXHRcdFx0c3NsOiB0cnVlLFxuXHRcdFx0cG9ydDogMTMzNyxcblx0XHRcdHNzbEtleTogcGF0aC5qb2luKF9fZGlybmFtZSwgJy4vcHJpdmF0ZS5rZXknKSxcblx0XHRcdHNzbENlcnRpZmljYXRlOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi9mdWxsY2hhaW4uY2VydCcpLFxuXHRcdFx0c2Vzc2lvbnNQYXRoOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi9zZXNzaW9ucy8nKSxcblx0XHRcdGRlYnVnOiBmYWxzZVxuXHRcdH07XG5cblx0XHRjb25zb2xlLmxvZyhfX2Rpcm5hbWUsIGZzLnJlYWRkaXJTeW5jKF9fZGlybmFtZSkpO1xuXG5cdFx0dGhpcy5kYiA9IHtcblx0XHRcdHNlcXVlbmNlSWQ6IDAsXG5cdFx0XHRob3N0SWQ6IG51bGwsXG5cdFx0XHRjb25uZWN0aW9uczoge30sXG5cdFx0XHRwbGF5ZXJzOiB7fSxcblx0XHRcdGdhbWVPYmplY3RzOiBbXSxcblx0XHR9O1xuXG5cdFx0Y29uc3Qgc29ja2V0U2VydmVyID0gdGhpcy5jcmVhdGVTb2NrZXRTZXJ2ZXIodGhpcy5jb25maWcpO1xuXHRcdHRoaXMuc3RhcnRTb2NrZXRTZXJ2ZXIoc29ja2V0U2VydmVyKTtcblx0fVxuXG5cdGNyZWF0ZVNvY2tldFNlcnZlcihjb25maWcpIHtcblx0XHRjb25zdCBodHRwU2VydiA9IGNvbmZpZy5zc2wgPyByZXF1aXJlKCdodHRwcycpIDogcmVxdWlyZSgnaHR0cCcpO1xuXG5cdFx0bGV0IHNlcnZlciA9IG51bGw7XG5cblx0XHRjb25zdCBwcm9jZXNzUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcSwgcmVzKSB7XG5cdFx0XHRyZXMud3JpdGVIZWFkKDIwMCk7XG5cdFx0XHRyZXMuZW5kKFwiQWxsIGdsb3J5IHRvIFdlYlNvY2tldHMhXFxuXCIpO1xuXHRcdH07XG5cblx0XHRpZiAoY29uZmlnLnNzbCkge1xuXHRcdFx0c2VydmVyID0gaHR0cFNlcnYuY3JlYXRlU2VydmVyKHtcblx0XHRcdFx0a2V5OiBmcy5yZWFkRmlsZVN5bmMoY29uZmlnLnNzbEtleSksXG5cdFx0XHRcdGNlcnQ6IGZzLnJlYWRGaWxlU3luYyhjb25maWcuc3NsQ2VydGlmaWNhdGUpLFxuXHRcdFx0fSwgcHJvY2Vzc1JlcXVlc3QpLmxpc3Rlbihjb25maWcucG9ydCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlcnZlciA9IGh0dHBTZXJ2LmNyZWF0ZVNlcnZlcihwcm9jZXNzUmVxdWVzdCkubGlzdGVuKGNvbmZpZy5wb3J0KTtcblx0XHR9XG5cblx0XHRjb25zdCB3ZWJTb2NrZXRTZXJ2ZXIgPSBuZXcgV2ViU29ja2V0U2VydmVyKHsgc2VydmVyIH0pO1xuXHRcdGRlYnVnKGBTZXJ2ZXIgaXMgcnVubmluZyBvbiBwb3J0ICR7Y29uZmlnLnBvcnR9YCk7XG5cblx0XHRyZXR1cm4gd2ViU29ja2V0U2VydmVyO1xuXHR9XG5cblx0c2F2ZVVzZXJEYXRhKHRva2VuLCBkYXRhKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghZnMuZXhpc3RzU3luYyh0aGlzLmNvbmZpZy5zZXNzaW9uc1BhdGgpKSB7XG5cdFx0XHRcdGZzLm1rZGlyU3luYyh0aGlzLmNvbmZpZy5zZXNzaW9uc1BhdGgpO1xuXHRcdFx0fVxuXG5cdFx0XHRmcy53cml0ZUZpbGVTeW5jKGAke3RoaXMuY29uZmlnLnNlc3Npb25zUGF0aH0vJHt0b2tlbn1gLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRkZWJ1ZygnU2F2ZSB1c2VyIGRhdGEgZXJyb3InLCBlKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRsb2FkVXNlckRhdGEodG9rZW4pIHtcblx0XHRjb25zdCB0b2tlblBhdGggPSBgJHt0aGlzLmNvbmZpZy5zZXNzaW9uc1BhdGh9LyR7dG9rZW59YDtcblxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoZnMuZXhpc3RzU3luYyh0b2tlblBhdGgpKSB7XG5cdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyh0b2tlblBhdGgsICd1dGY4JykpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGRlYnVnKCdMb2FkIHVzZXIgZGF0YSBlcnJvcicsIGUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHN0YXJ0U29ja2V0U2VydmVyKHNvY2tldFNlcnZlcikge1xuXHRcdGNvbnN0IGdldENvbm5lY3Rpb25JZCA9IGMgPT4gYy5faWQ7XG5cdFx0Y29uc3QgZ2V0Q29ubmVjdGlvblRva2VuID0gYyA9PiBjLl9tZXRhLnRva2VuO1xuXG5cdFx0Y29uc3Qgc2VuZCA9IChjb25uZWN0aW9uLCBtZXNzYWdlVHlwZSwgZGF0YSkgPT4gY29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdG1ldGE6IHtcblx0XHRcdFx0c2VydmVyOiB7IHZlcnNpb246IDEgfSxcblx0XHRcdFx0cm9sZTogZ2V0Q29ubmVjdGlvbklkKGNvbm5lY3Rpb24pID09PSB0aGlzLmRiLmhvc3RJZCA/ICdob3N0JyA6ICdjbGllbnQnLFxuXHRcdFx0XHRpZDogZ2V0Q29ubmVjdGlvbklkKGNvbm5lY3Rpb24pLFxuXHRcdFx0XHR0b2tlbjogY29ubmVjdGlvbi5fbWV0YS50b2tlbixcblx0XHRcdFx0ZGVidWc6IHRoaXMuY29uZmlnLmRlYnVnLFxuXHRcdFx0fSxcblx0XHRcdGRhdGEsXG5cdFx0XHRtZXNzYWdlVHlwZSxcblx0XHR9KSk7XG5cblx0XHRzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHRjb25zdCBpc0hvc3QgPSBjb25uZWN0aW9uID0+IGdldENvbm5lY3Rpb25JZChjb25uZWN0aW9uKSA9PT0gdGhpcy5kYi5ob3N0SWQ7XG5cblx0XHRcdE9iamVjdC52YWx1ZXModGhpcy5kYi5jb25uZWN0aW9ucykuZm9yRWFjaCgoY29ubmVjdGlvbikgPT4ge1xuXHRcdFx0XHRjb25zdCBjb25uZWN0aW9uUGxheWVyID0gdGhpcy5kYi5wbGF5ZXJzW2dldENvbm5lY3Rpb25JZChjb25uZWN0aW9uKV07XG5cdFx0XHRcdGNvbnN0IG5ldHdvcmtQbGF5ZXJzID0gT2JqZWN0LnZhbHVlcyh0aGlzLmRiLnBsYXllcnMpXG5cdFx0XHRcdFx0LmZpbHRlcihwbGF5ZXIgPT4gcGxheWVyICE9PSBjb25uZWN0aW9uUGxheWVyKTtcblxuXHRcdFx0XHRpZiAoaXNIb3N0KGNvbm5lY3Rpb24pKSB7XG5cdFx0XHRcdFx0c2VuZChjb25uZWN0aW9uLCAndXBkYXRlR2FtZU9iamVjdHMnLCBuZXR3b3JrUGxheWVycyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VuZChjb25uZWN0aW9uLCAndXBkYXRlR2FtZU9iamVjdHMnLCBbLi4udGhpcy5kYi5nYW1lT2JqZWN0cywgLi4ubmV0d29ya1BsYXllcnNdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSwgMTAwKTtcblxuXG5cdFx0c2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHRcdFx0Y29uc3QgaXNIb3N0ID0gY29ubmVjdGlvbiA9PiBnZXRDb25uZWN0aW9uSWQoY29ubmVjdGlvbikgPT09IHRoaXMuZGIuaG9zdElkO1xuXG5cdFx0XHRPYmplY3QudmFsdWVzKHRoaXMuZGIuY29ubmVjdGlvbnMpLmZvckVhY2goKGNvbm5lY3Rpb24pID0+IHtcblx0XHRcdFx0Y29uc3QgY29ubmVjdGlvblBsYXllciA9IHRoaXMuZGIucGxheWVyc1tnZXRDb25uZWN0aW9uSWQoY29ubmVjdGlvbildO1xuXHRcdFx0XHRjb25zdCB0b2tlbiA9IGdldENvbm5lY3Rpb25Ub2tlbihjb25uZWN0aW9uKTtcblxuXHRcdFx0XHRpZiAoY29ubmVjdGlvblBsYXllciAmJiB0b2tlbikge1xuXHRcdFx0XHRcdHRoaXMuc2F2ZVVzZXJEYXRhKHRva2VuLCBjb25uZWN0aW9uUGxheWVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSwgMTAwMDApO1xuXG5cdFx0c29ja2V0U2VydmVyLm9uKCdjb25uZWN0aW9uJywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuXHRcdFx0Y29uc3QgaWQgPSArK3RoaXMuZGIuc2VxdWVuY2VJZDtcblxuXHRcdFx0ZGVidWcoJ05ldyBjb25uZWN0aW9uLCBpZDonLCBpZCk7XG5cblx0XHRcdHRoaXMuZGIuY29ubmVjdGlvbnNbaWRdID0gY29ubmVjdGlvbjtcblx0XHRcdGNvbm5lY3Rpb24uX21ldGEgPSB7IGlkIH07XG5cdFx0XHRjb25uZWN0aW9uLl9pZCA9IGlkO1xuXG5cdFx0XHRpZiAoIXRoaXMuZGIuaG9zdElkKSB7XG5cdFx0XHRcdHRoaXMuZGIuaG9zdElkID0gaWQ7XG5cdFx0XHRcdGRlYnVnKCdIb3N0IGNoYW5nZWQgdG8nLCBpZCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG9uU29ja2V0Q2xvc2UgPSAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGlkID0gZ2V0Q29ubmVjdGlvbklkKGNvbm5lY3Rpb24pO1xuXHRcdFx0XHRkZWJ1ZygnQ29ubmVjdGlvbiBjbG9zZWQsIGlkOicsIGlkKTtcblxuXHRcdFx0XHRpZiAoaWQgPT09IHRoaXMuZGIuaG9zdElkKSB7XG5cdFx0XHRcdFx0Y29uc3QgYWN0aXZlQ29ubmVjdGlvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMuZGIuY29ubmVjdGlvbnMpLmZpbHRlcihjID0+IGMuX2lkICE9PSBpZCk7XG5cdFx0XHRcdFx0dGhpcy5kYi5ob3N0SWQgPSBhY3RpdmVDb25uZWN0aW9ucy5sZW5ndGggPyBhY3RpdmVDb25uZWN0aW9uc1swXS5faWQgOiBudWxsO1xuXHRcdFx0XHRcdGRlYnVnKCdIb3N0IGNoYW5nZWQgdG8nLCB0aGlzLmRiLmhvc3RJZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRPYmplY3QudmFsdWVzKHRoaXMuZGIuY29ubmVjdGlvbnMpLmZvckVhY2goKGMpID0+IHtcblx0XHRcdFx0XHRzZW5kKGMsICdkaXNjb25uZWN0ZWQnLCB7IGNvbm5lY3Rpb25JZDogaWQgfSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmRiLmNvbm5lY3Rpb25zW2lkXTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuZGIucGxheWVyc1tpZF07XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBvblNvY2tldE1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuXHRcdFx0XHRjb25zdCB7IGRhdGEsIG1lc3NhZ2VUeXBlLCBtZXRhIH0gPSBKU09OLnBhcnNlKG1lc3NhZ2UpO1xuXHRcdFx0XHRjb25zdCBjb25uZWN0aW9uSWQgPSBnZXRDb25uZWN0aW9uSWQoY29ubmVjdGlvbik7XG5cblx0XHRcdFx0aWYgKG1ldGEgJiYgbWV0YS50b2tlbiAmJiBtZXRhLnRva2VuICE9PSBjb25uZWN0aW9uLl9tZXRhLnRva2VuKSB7XG5cdFx0XHRcdFx0ZGVidWcoYFVzZXIgIyR7Y29ubmVjdGlvbklkfSB0b2tlbiBjaGFuZ2VkIGZyb20gJHtjb25uZWN0aW9uLl9tZXRhLnRva2VufSB0byAke21ldGEudG9rZW59YCk7XG5cdFx0XHRcdFx0Y29ubmVjdGlvbi5fbWV0YS50b2tlbiA9IG1ldGEudG9rZW47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB1cGRhdGVHYW1lT2JqZWN0c0RhdGEgPSAoZ2FtZU9iamVjdHMpID0+IHtcblx0XHRcdFx0XHRpZiAoY29ubmVjdGlvbklkID09PSB0aGlzLmRiLmhvc3RJZCkge1xuXHRcdFx0XHRcdFx0dGhpcy5kYi5nYW1lT2JqZWN0cyA9IGdhbWVPYmplY3RzLmZpbHRlcihnYW1lT2JqZWN0ID0+IGdhbWVPYmplY3QudHlwZSAhPT0gJ3BsYXllcicpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBwbGF5ZXIgPSBnYW1lT2JqZWN0cy5maW5kKGdhbWVPYmplY3QgPT4gZ2FtZU9iamVjdC50eXBlID09PSAncGxheWVyJyk7XG5cdFx0XHRcdFx0XHR0aGlzLmRiLnBsYXllcnNbY29ubmVjdGlvbklkXSA9IHBsYXllcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Y29uc3Qgc2VuZFVzZXJEYXRhID0gKCkgPT4ge1xuXHRcdFx0XHRcdHNlbmQoY29ubmVjdGlvbiwgJ3NldFVzZXJQbGF5ZXInLCB0aGlzLmxvYWRVc2VyRGF0YShjb25uZWN0aW9uLl9tZXRhLnRva2VuKSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Y29uc3QgdXBkYXRlUGxheWVyRGF0YSA9IChwbGF5ZXIpID0+IHtcblx0XHRcdFx0XHR0aGlzLmRiLnBsYXllcnNbY29ubmVjdGlvbklkXSA9IHBsYXllcjtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRjb25zdCB0YWtlSG9zdCA9ICgpID0+IHtcblx0XHRcdFx0XHRkZWJ1ZyhgIyR7Y29ubmVjdGlvbklkfSB0YWtlcyB0aGUgaG9zdGApO1xuXHRcdFx0XHRcdHRoaXMuZGIuaG9zdElkID0gY29ubmVjdGlvbklkO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGNvbnN0IHJlc3RhcnRTZXJ2ZXIgPSAoKSA9PiB7XG5cdFx0XHRcdFx0ZGVidWcoYCMke2Nvbm5lY3Rpb25JZH0gcmVsb2FkcyBzZXJ2ZXJgKTtcblx0XHRcdFx0XHRPYmplY3QudmFsdWVzKHRoaXMuZGIuY29ubmVjdGlvbnMpLmZvckVhY2goYyA9PiBzZW5kKGMsICdyZXN0YXJ0U2VydmVyJykpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHN3aXRjaCAobWVzc2FnZVR5cGUpIHtcblx0XHRcdFx0XHRjYXNlICdsb2FkQ3VycmVudFVzZXInOiB7XG5cdFx0XHRcdFx0XHRzZW5kVXNlckRhdGEoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXNlICd1cGRhdGVHYW1lT2JqZWN0cyc6IHtcblx0XHRcdFx0XHRcdHVwZGF0ZUdhbWVPYmplY3RzRGF0YShkYXRhKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXNlICd1cGRhdGVQbGF5ZXInOiB7XG5cdFx0XHRcdFx0XHR1cGRhdGVQbGF5ZXJEYXRhKGRhdGEpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhc2UgJ3Rha2VIb3N0Jzoge1xuXHRcdFx0XHRcdFx0dGFrZUhvc3QoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXNlICdyZXN0YXJ0U2VydmVyJzoge1xuXHRcdFx0XHRcdFx0cmVzdGFydFNlcnZlcigpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25uZWN0aW9uLm9uKCdtZXNzYWdlJywgb25Tb2NrZXRNZXNzYWdlKTtcblx0XHRcdGNvbm5lY3Rpb24ub24oJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSk7XG5cblx0XHRcdHNlbmQoY29ubmVjdGlvbiwgJ2hhbmRzaGFrZScpO1xuXHRcdH0pO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNvY2tldFNlcnZlcjtcbiIsImltcG9ydCB7IE1vY2tHVUksIE1vY2tSZW5kZXJlciB9IGZyb20gJy4vc3JjL01vY2tEZXBlbmRlbmNpZXMnO1xuaW1wb3J0IFNvY2tldFNlcnZlciBmcm9tICcuL3NyYy9Tb2NrZXRTZXJ2ZXInO1xuaW1wb3J0IFNjZW5lIGZyb20gJy4uL2NsaWVudC9zcmMvanMvU2NlbmUnO1xuXG5mdW5jdGlvbiBTZXJ2ZXIoKSB7XG5cdGRlYnVnKCdTdGFydGluZyBzZXJ2ZXIgc2NlbmUgaW5pdGlhbGl6YXRpb24gLi4uJyk7XG5cblx0Y29uc3Qgc2NlbmUgPSBuZXcgU2NlbmUoTW9ja1JlbmRlcmVyLCBNb2NrR1VJKTtcblxuXHRkZWJ1ZygnU2NlbmUgaXMgbG9hZGVkJywge1xuXHRcdFRIUkVFOiBCb29sZWFuKFRIUkVFKSxcblx0XHRkb2N1bWVudDogQm9vbGVhbihkb2N1bWVudCksXG5cdFx0d2luZG93OiBCb29sZWFuKHdpbmRvdyksXG5cdFx0R0xURkxvYWRlcjogQm9vbGVhbihHTFRGTG9hZGVyKSxcblx0XHRzY2VuZTogQm9vbGVhbihzY2VuZSksXG5cdH0pO1xuXG5cdGNvbnN0IGxvZ1NlcnZlclN0YXR1cyA9ICgpID0+IGRlYnVnKFxuXHRcdCdTZXJ2ZXIgc3RhdHVzIC4uLiBDb3VudCBhbGl2ZSB1bml0czonLFxuXHRcdHNjZW5lLnVuaXRzLmdldEFsaXZlVW5pdHMoKS5sZW5ndGgsXG5cdFx0JzsgaXMgcGxheWVyIGxvYWRlZDogJyxcblx0XHRCb29sZWFuKHNjZW5lLnVuaXRzLmdldFBsYXllcigpKSxcblx0XHQnOyB1bml0cyBwb3NpdGlvbnM6ICcsXG5cdFx0c2NlbmUudW5pdHMuZ2V0QWxpdmVVbml0cygpLm1hcCh1ID0+IFt1LnBhcmFtcy5uYW1lLCAnOiAnLCB1LnBvc2l0aW9uXSksXG5cdCk7XG5cblx0Y29uc3Qgc3RhcnRTb2NrZXRTZXJ2ZXIgPSAoKSA9PiB7XG5cdFx0ZGVidWcoJ1N0YXJ0aW5nIHNvY2tldCBzZXJ2ZXIgLi4uJyk7XG5cdFx0dGhpcy5zb2NrZXRTZXJ2ZXIgPSBuZXcgU29ja2V0U2VydmVyKCk7XG5cdH07XG5cblx0c2V0VGltZW91dChcblx0XHRmdW5jdGlvbiBpbml0KCkge1xuXHRcdFx0Y29uc3QgcGxheWVyID0gc2NlbmUuZ2V0UGxheWVyKCk7XG5cblx0XHRcdGlmIChwbGF5ZXIpIHtcblx0XHRcdFx0cGxheWVyLnBhcmFtcy5ocCA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdHN0YXJ0U29ja2V0U2VydmVyKCk7XG5cdFx0XHRzZXRJbnRlcnZhbChsb2dTZXJ2ZXJTdGF0dXMsIDMwMDAwKTtcblx0XHR9LFxuXHRcdDUwMDAsXG5cdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlcnZlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW1cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidGxzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ6bGliXCIpOyJdLCJzb3VyY2VSb290IjoiIn0=