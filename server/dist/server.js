/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../client/src/js/AutoBindMethods.js":
/*!*******************************************!*\
  !*** ../client/src/js/AutoBindMethods.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AutoBindMethods; });
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AutoBindMethods = function AutoBindMethods() {
  var _this = this;

  _classCallCheck(this, AutoBindMethods);

  var functionNames = [];
  var obj = Object.getPrototypeOf(this);

  while (obj) {
    if (obj === Object.prototype || obj === AutoBindMethods.prototype) {
      obj = Object.getPrototypeOf(obj);
      continue;
    }

    functionNames = functionNames.concat(Object.getOwnPropertyNames(obj).filter(function (name) {
      return name !== 'constructor' && functionNames.indexOf(name) === -1 && typeof _this[name] === 'function';
    }));
    obj = Object.getPrototypeOf(obj);
  }

  var _iterator = _createForOfIteratorHelper(functionNames),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var functionName = _step.value;
      this[functionName] = this[functionName].bind(this);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};



/***/ }),

/***/ "../client/src/js/Camera.js":
/*!**********************************!*\
  !*** ../client/src/js/Camera.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Camera; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Camera = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Camera, _AutoBindMethods);

  var _super = _createSuper(Camera);

  /**
   * @param {Scene} scene
   */
  function Camera(scene) {
    var _this;

    _classCallCheck(this, Camera);

    _this = _super.call(this);
    _this.scene = scene;

    var ratio = _this.getWidth() / _this.getHeight();

    _this.camera = new THREE.PerspectiveCamera(45, ratio, 1, 100);

    _this.camera.position.set(5, 3, 15);

    _this.deltaY = 10;
    _this.rotateY = 0.25;
    _this.defaultDistance = 10;
    _this.distance = _this.defaultDistance;
    _this.raycaster = new THREE.Raycaster();
    return _this;
  }

  _createClass(Camera, [{
    key: "update",
    value: function update(gameTime, deltaTime) {
      var input = this.scene.input;
      var player = this.scene.getPlayer();
      if (!player) return; // Enabled if "F" is pressed

      if (input.look.cinematic) {
        this.camera.position.set(-40, 15, 10);
        this.camera.lookAt(new THREE.Vector3(-50, 0, 0));
        return;
      }

      var rotateY = this.rotateY + input.look.sensitivity * input.look.vertical / 2000;

      if (rotateY > -0.75 && rotateY < 1.25) {
        this.rotateY = rotateY;
      }

      if (input.isThirdPerson) {
        this.updateThirdPerson(player);
      } else {
        this.camera.position.copy(player.position.clone().add(new THREE.Vector3(7.5, this.deltaY, 0)));
        this.camera.lookAt(player.position);
      }
    }
  }, {
    key: "addY",
    value: function addY(y) {
      if (this.deltaY + y > 1 && this.deltaY + y < 25) {
        this.deltaY += y;
      }
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      var renderer = this.scene.renderer.renderer;
      return renderer.getContext().canvas.width;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      var renderer = this.scene.renderer.renderer;
      return renderer.getContext().canvas.height;
    }
  }, {
    key: "updateThirdPerson",
    value: function updateThirdPerson(player) {
      var _this2 = this;

      var children = this.scene.scene.children,
          deltaY = this.deltaY,
          playerHeadPosition = player.position.clone().add(new THREE.Vector3(0, 1.5, 0)),
          origin = playerHeadPosition,
          destination = this.camera.position,
          direction = new THREE.Vector3();

      var getChildrenFlat = function getChildrenFlat(objects) {
        var _ref;

        return (_ref = []).concat.apply(_ref, _toConsumableArray(objects.map(function (obj) {
          return obj.children ? [obj].concat(_toConsumableArray(getChildrenFlat(obj.children))) : [obj];
        })));
      };

      var environment = [children.find(function (c) {
        return c.name === 'LEVEL_ENVIRONMENT';
      })];
      var flatChildrenMeshes = getChildrenFlat(environment).filter(function (obj) {
        return obj.type === 'Mesh';
      });
      this.raycaster.set(origin, direction.subVectors(destination, origin).normalize());
      this.raycaster.far = deltaY * 1.5;
      var intersects = this.raycaster.intersectObjects(flatChildrenMeshes);
      var distance = Math.min.apply(Math, [deltaY].concat(_toConsumableArray(intersects.map(function (i) {
        return i.distance - _this2.distance * 0.5;
      }))));
      this.distance += (distance - this.distance) / 2;
      var playerForward = player.getForward().multiplyScalar(this.scene.input.look.back ? 1 : -1);
      playerForward.y = this.rotateY;
      this.camera.position.copy(playerHeadPosition.clone().add(playerForward));
      this.camera.lookAt(playerHeadPosition);
      var cameraForward = new THREE.Vector3(0, 0, -1);
      cameraForward.applyQuaternion(this.camera.quaternion);
      this.camera.position.sub(cameraForward.multiplyScalar(this.distance));
    }
  }, {
    key: "toScreenPosition",
    value: function toScreenPosition(position) {
      var widthHalf = 0.5 * this.getWidth();
      var heightHalf = 0.5 * this.getHeight();
      var copiedProjectVector = position.clone().project(this.camera);
      return {
        x: Math.round((copiedProjectVector.x + 1) * widthHalf),
        y: Math.round((-copiedProjectVector.y + 1) * heightHalf),
        z: copiedProjectVector.z
      };
    }
  }]);

  return Camera;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Colliders.js":
/*!*************************************!*\
  !*** ../client/src/js/Colliders.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Colliders; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Colliders = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Colliders, _AutoBindMethods);

  var _super = _createSuper(Colliders);

  function Colliders(scene) {
    var _this;

    _classCallCheck(this, Colliders);

    _this = _super.call(this);
    _this.scene = scene;
    _this.colliders = [];
    _this.nextId = 0;
    return _this;
  }

  _createClass(Colliders, [{
    key: "checkWay",
    value: function checkWay(position, gameObject) {
      var _iterator = _createForOfIteratorHelper(this.colliders),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var collider = _step.value;

          if (collider.fn(position, gameObject)) {
            return false;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return true;
    }
  }, {
    key: "resetColliders",
    value: function resetColliders() {
      this.colliders = [];
    }
  }, {
    key: "removeCollider",
    value: function removeCollider(id) {
      var idx = this.colliders.findIndex(function (c) {
        return c.id === id;
      });

      if (idx > -1) {
        this.colliders.splice(idx, 1);
      }
    }
  }, {
    key: "addColliderFunction",
    value: function addColliderFunction(fn) {
      this.colliders.push({
        id: this.nextId++,
        fn: fn
      });
      this.scene.pathFinder.rebuildAreas();
    }
  }]);

  return Colliders;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Connection.js":
/*!**************************************!*\
  !*** ../client/src/js/Connection.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Connection; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _GameObjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObjects */ "../client/src/js/GameObjects.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Connection = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Connection, _AutoBindMethods);

  var _super = _createSuper(Connection);

  /**
   * @param {Scene} scene
   * @param {string|number} ip
   * @param {string|number} port
   * @param {boolean} isSecure
   */
  function Connection(scene) {
    var _this;

    var ip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'localhost';
    var port = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '1337';
    var isSecure = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    _classCallCheck(this, Connection);

    _this = _super.call(this);
    _this.scene = scene;
    _this.meta = {};
    _this.networkPlayers = {};
    _this.networkAIs = {};
    _this.lastRequest = Date.now();
    _this.ping = 0;
    var WebSocket = window.WebSocket || window.MozWebSocket;
    _this.connection = new WebSocket("".concat(isSecure ? 'wss' : 'ws', "://").concat(ip, ":").concat(port));

    _this.connection.onopen = function () {
      return console.log('open connection');
    };

    _this.connection.onerror = function (error) {
      return console.log('error connection', error);
    };

    _this.connection.onmessage = _this.onMessage;

    _this.scene.intervals.setInterval(function () {
      _this.sendGameObjects();

      _this.lastRequest = Date.now();
    }, 100);

    return _this;
  }

  _createClass(Connection, [{
    key: "update",
    value: function update() {}
  }, {
    key: "onMessage",
    value: function onMessage(_ref) {
      var data = _ref.data;

      /**
       * @param {object} meta
       * @param {any} response
       * @param {string} messageType
       */
      var _JSON$parse = JSON.parse(data),
          meta = _JSON$parse.meta,
          response = _JSON$parse.data,
          messageType = _JSON$parse.messageType;

      if (meta.role && this.meta.role !== meta.role) {
        this.scene.ui.setConnectionRole(meta.role);

        if (this.meta.role && meta.role === 'host') {
          this.hostUnitsFromNetwork();
        } else if (!this.meta.debug) {
          this.clearLocalGameObjects();
        }
      }

      this.meta = meta;

      try {
        switch (messageType) {
          case 'handshake':
            {
              this.processHandshake();
              break;
            }

          case 'restartServer':
            {
              window.location.reload();
              break;
            }

          case 'setUserPlayer':
            {
              var player = this.scene.getPlayer();

              if (player) {
                this.setPlayerParams(player, response);
              } else {
                this.scene.units.setDefaultPlayerParams(response);
              }

              break;
            }

          case 'updateGameObjects':
            {
              this.ping = Date.now() - this.lastRequest;
              this.updateGameObjects(response);
              break;
            }

          case 'disconnected':
            {
              this.removeDisconnectedPlayer(response);
              break;
            }
        }
      } catch (e) {
        console.log('Connection error', e);
      }
    }
  }, {
    key: "takeHost",
    value: function takeHost() {
      this.send('takeHost');
    }
  }, {
    key: "restartServer",
    value: function restartServer() {
      this.send('restartServer');
    } // There is race condition between
    // clearLocalGameObjects and Location.createInteractiveGameObjects

  }, {
    key: "clearLocalGameObjects",
    value: function clearLocalGameObjects() {
      var gameObjectsService = this.scene.gameObjectsService;
      var player = this.scene.getPlayer(); // Clear local gameObjects to replace them by network units (except player)

      gameObjectsService.getUnits().forEach(function (unit) {
        if (!unit.params.fromNetwork && unit !== player) {
          gameObjectsService.destroyGameObject(unit);
        }
      });
    }
  }, {
    key: "send",
    value: function send(messageType, data) {
      var _this$scene$user = this.scene.user,
          userName = _this$scene$user.userName,
          password = _this$scene$user.password;
      var meta = {
        token: this.getHash(userName + password)
      };
      this.connection.send(JSON.stringify({
        messageType: messageType,
        meta: meta,
        data: data
      }));
    }
  }, {
    key: "processHandshake",
    value: function processHandshake() {
      this.send('loadCurrentUser');
    }
  }, {
    key: "updateGameObjects",
    value: function updateGameObjects(gameObjects) {
      var _this2 = this;

      gameObjects.forEach(function (gameObject) {
        switch (gameObject.type) {
          case 'player':
            {
              _this2.updateNetworkPlayer(gameObject);

              break;
            }

          case 'ai':
            {
              _this2.updateNetworkAI(gameObject);

              break;
            }
        }
      });
    }
  }, {
    key: "removeDisconnectedPlayer",
    value: function removeDisconnectedPlayer(_ref2) {
      var connectionId = _ref2.connectionId;
      var gameObjectsService = this.scene.gameObjectsService;
      var disconnectedPlayer = gameObjectsService.getUnits().find(function (unit) {
        return unit instanceof _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"] && unit.params.connectionId === connectionId;
      });
      console.log('Player disconnected', connectionId);

      if (disconnectedPlayer) {
        disconnectedPlayer.die();
      }
    }
    /**
     * @param {String} str
     * @returns {string}
     */

  }, {
    key: "getHash",
    value: function getHash(str) {
      function hash32(str) {
        var i;
        var l;
        var hval = 0x811c9dc5;

        for (i = 0, l = str.length; i < l; i++) {
          hval ^= str.charCodeAt(i);
          hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
        }

        return ("0000000" + (hval >>> 0).toString(16)).substr(-8);
      }

      var h1 = hash32(str);
      return h1 + hash32(h1 + str);
    }
  }, {
    key: "hostUnitsFromNetwork",
    value: function hostUnitsFromNetwork() {
      this.scene.units.getAliveUnits().forEach(function (unit) {
        if (unit.params.fromNetwork) {
          unit.params.fromNetwork = false;
        }
      });
    }
  }, {
    key: "updateNetworkPlayer",
    value: function updateNetworkPlayer(playerData) {
      var _this3 = this;

      var locationName = playerData.locationName,
          position = playerData.position,
          rotation = playerData.rotation,
          animationState = playerData.animationState,
          params = playerData.params;
      var unitNetworkId = playerData.params.unitNetworkId;

      if (unitNetworkId === this.meta.unitNetworkId && !this.meta.debug) {
        return;
      }

      if (locationName !== this.scene.location.getLocationName()) {
        return;
      }
      /**
       * @type Player | string
       */


      var networkPlayer = this.networkPlayers[unitNetworkId];

      if (!networkPlayer) {
        this.networkPlayers[unitNetworkId] = 'loading';
        this.scene.units.createNetworkPlayer(playerData, function (networkPlayer) {
          _this3.networkPlayers[unitNetworkId] = networkPlayer;
        });
      } else if (networkPlayer !== 'loading') {
        this.setPlayerParams(networkPlayer, {
          position: position,
          rotation: rotation,
          animationState: animationState,
          params: params
        });
      }
    }
  }, {
    key: "setPlayerParams",
    value: function setPlayerParams(player, _ref3) {
      var position = _ref3.position,
          rotation = _ref3.rotation,
          animationState = _ref3.animationState,
          params = _ref3.params;
      player.position.set(position.x, position.y, position.z);
      player.rotation.set(rotation.x, rotation.y, rotation.z);
      player.animationState = animationState;

      if (params) {
        var input = params.input,
            acceleration = params.acceleration;
        var playerParams = player.params;
        playerParams.input.vertical = input.vertical;
        playerParams.input.horizontal = input.horizontal;
        playerParams.input.attack1 = input.attack1;
        playerParams.input.attack2 = input.attack2;
        playerParams.hp = params.hp;
        playerParams.hpMax = params.hpMax;
        playerParams.fraction = params.fraction;
        playerParams.damage = params.damage;
        playerParams.speed = params.speed;
        playerParams.money = params.money;
        playerParams.level = params.level;
        playerParams.unspentTalents = params.unspentTalents;
        playerParams.experience = params.experience;
        playerParams.acceleration.set(acceleration.x, acceleration.y, acceleration.z);
      }
    }
  }, {
    key: "updateNetworkAI",
    value: function updateNetworkAI(unitData) {
      var _this4 = this;

      var locationName = unitData.locationName,
          position = unitData.position,
          rotation = unitData.rotation,
          isRunning = unitData.isRunning,
          isAttack = unitData.isAttack,
          animationState = unitData.animationState,
          scale = unitData.scale,
          params = unitData.params;
      var unitNetworkId = params.unitNetworkId;

      if (locationName !== this.scene.location.getLocationName()) {
        return;
      }
      /**
       * @type AI | string
       */


      var networkAI = this.networkAIs[unitNetworkId];

      if (!networkAI) {
        this.networkAIs[unitNetworkId] = 'loading';
        this.scene.units.createNetworkAI(unitData, function (networkAI) {
          _this4.networkAIs[unitNetworkId] = networkAI;
        });
      } else if (networkAI !== 'loading') {
        networkAI.position.set(position.x, position.y, position.z);
        networkAI.rotation.set(rotation.x, rotation.y, rotation.z);
        networkAI.object.scale.set(scale.x, scale.y, scale.z);
        networkAI.isRunning = isRunning;
        networkAI.isAttack = isAttack;
        networkAI.animationState = animationState;

        if (params) {
          var acceleration = params.acceleration;
          var networkAIParams = networkAI.params;
          networkAIParams.hp = params.hp;
          networkAIParams.hpMax = params.hpMax;
          networkAIParams.fraction = params.fraction;
          networkAIParams.damage = params.damage;
          networkAIParams.level = params.level;
          networkAIParams.acceleration.set(acceleration.x, acceleration.y, acceleration.z);
        }
      }
    }
  }, {
    key: "sendGameObjects",
    value: function sendGameObjects() {
      var _this5 = this;

      var connectionId = this.meta.id;

      if (this.connection.readyState !== 1 || !connectionId) {
        return;
      }

      var player = this.scene.getPlayer();
      var units = this.meta.role === 'host' ? [player].concat(_toConsumableArray(this.scene.units.getAliveUnits().filter(function (unit) {
        return !unit.params.fromNetwork;
      }))) : [player];
      var data = [];
      units.forEach(function (unit) {
        var unitData = Connection.unitToNetwork(unit, connectionId, _this5.scene.location.getLocationName());

        if (unitData) {
          data.push(unitData);
        }
      });

      if (this.meta.role === 'host') {
        this.send('updateGameObjects', data);
      } else if (data[0]) {
        this.send('updatePlayer', data[0]);
      }
    }
  }], [{
    key: "unitToNetwork",
    value: function unitToNetwork(unit, connectionId, locationName) {
      if (unit) {
        var unitRotation = unit.object.rotation.toVector3();

        if (!unit.params.unitNetworkId) {
          var getRandomString = function getRandomString() {
            return Math.random().toString(36).substr(2);
          };

          unit.params.unitNetworkId = getRandomString() + getRandomString();
        }

        var unitNetworkId = unit.params.unitNetworkId;
        var isRunning = unit.isRunning,
            isAttack = unit.isAttack;
        var _unit$params = unit.params,
            hp = _unit$params.hp,
            hpMax = _unit$params.hpMax,
            acceleration = _unit$params.acceleration,
            damage = _unit$params.damage,
            level = _unit$params.level,
            experience = _unit$params.experience,
            fraction = _unit$params.fraction,
            name = _unit$params.name,
            speed = _unit$params.speed,
            unspentTalents = _unit$params.unspentTalents,
            money = _unit$params.money;

        var _ref4 = unit.params.input || {},
            vertical = _ref4.vertical,
            horizontal = _ref4.horizontal,
            attack1 = _ref4.attack1,
            attack2 = _ref4.attack2;

        var vectorToObject = function vectorToObject(vector) {
          var eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
          return {
            x: Math.round(vector.x * eps) / eps,
            y: Math.round(vector.y * eps) / eps,
            z: Math.round(vector.z * eps) / eps
          };
        };

        return {
          type: unit instanceof _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"] ? 'player' : 'ai',
          locationName: locationName,
          animationState: unit.animationState,
          isRunning: isRunning,
          isAttack: isAttack,
          position: vectorToObject(unit.position),
          rotation: vectorToObject(unitRotation),
          scale: vectorToObject(unit.object.scale),
          params: {
            connectionId: connectionId,
            unitNetworkId: unitNetworkId,
            name: name,
            hp: hp,
            hpMax: hpMax,
            fraction: fraction,
            damage: damage,
            level: level,
            experience: experience,
            speed: speed,
            money: money,
            unspentTalents: unspentTalents,
            acceleration: vectorToObject(acceleration),
            input: {
              vertical: vertical,
              horizontal: horizontal,
              attack1: attack1,
              attack2: attack2
            }
          }
        };
      }
    }
  }]);

  return Connection;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects.js":
/*!***************************************!*\
  !*** ../client/src/js/GameObjects.js ***!
  \***************************************/
/*! exports provided: AI, Player, Fire, Unit, AnimatedGameObject, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GameObjectsService; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _GameObjects_AI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObjects/AI */ "../client/src/js/GameObjects/AI.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AI", function() { return _GameObjects_AI__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _GameObjects_Player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameObjects/Player */ "../client/src/js/GameObjects/Player.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Player", function() { return _GameObjects_Player__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _GameObjects_Fire__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GameObjects/Fire */ "../client/src/js/GameObjects/Fire.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fire", function() { return _GameObjects_Fire__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _GameObjects_Unit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GameObjects/Unit */ "../client/src/js/GameObjects/Unit.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Unit", function() { return _GameObjects_Unit__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GameObjects/AnimatedGameObject */ "../client/src/js/GameObjects/AnimatedGameObject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimatedGameObject", function() { return _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_5__["default"]; });

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }









var GameObjectsService = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(GameObjectsService, _AutoBindMethods);

  var _super = _createSuper(GameObjectsService);

  /**
   * @param {Scene} scene
   */
  function GameObjectsService(scene) {
    var _this;

    _classCallCheck(this, GameObjectsService);

    _this = _super.call(this);
    _this.gameObjects = [];
    _this.nextGameObjectId = 0;
    _this.scene = scene;
    return _this;
  }

  _createClass(GameObjectsService, [{
    key: "update",
    value: function update(time, deltaTime) {
      this.gameObjects.forEach(function (gameObject) {
        return gameObject.update(time, deltaTime);
      });
    }
    /**
     * @param {Unit} attackingUnit
     */

  }, {
    key: "attack",
    value: function attack(attackingUnit) {
      var _this2 = this;

      if (attackingUnit.isDead()) {
        return;
      }

      this.scene.intervals.setTimeout(function () {
        var gameTime = _this2.scene.intervals.getTimePassed();

        if (attackingUnit.isAttackInterrupted(gameTime)) {
          attackingUnit.releaseAttack(gameTime);
          return;
        }

        var attackedUnits = _this2.getUnits().filter(function (gameObject) {
          return gameObject !== attackingUnit && gameObject.isAlive() && gameObject.isEnemy(attackingUnit) && gameObject.position.distanceTo(attackingUnit.position) < 2;
        });

        attackedUnits.forEach(function (collisionGameObject) {
          collisionGameObject.damageTaken({
            damage: attackingUnit.params.damage,
            unit: attackingUnit
          }, gameTime);
        }); // if (attackedUnits.length) {
        //     this.scene.audio.playSound(attackingUnit.position, 'Attack Soft');
        // }
      }, attackingUnit.getAttackTimeout());
    }
    /**
     * @param {Unit} firingGameObject
     */

  }, {
    key: "fire",
    value: function fire(firingGameObject) {
      var _this3 = this;

      if (firingGameObject.isDead()) {
        return;
      }

      var createLightCube = function createLightCube(left) {
        return _this3.scene.models.createCube({
          x: 0.02,
          y: 0.02,
          z: 0.3,
          emissive: '#ff0000',
          position: new THREE.Vector3(0.05 - Number(left) * 0.1, 0, 0),
          noScene: true
        });
      };

      var object = new THREE.Object3D();
      object.position.copy(firingGameObject.getFireInitialPosition());
      object.quaternion.copy(firingGameObject.getFireInitialRotation());
      object.add(createLightCube(true));
      object.add(createLightCube(false));
      this.scene.add(object);
      var fireGameObject = this.hookGameObject(new _GameObjects_Fire__WEBPACK_IMPORTED_MODULE_3__["default"]({
        object: object,
        throttling: new THREE.Vector3(1, 1, 1),
        speed: firingGameObject.params.fireShellSpeed,
        damage: firingGameObject.params.fireDamage,
        parent: firingGameObject,
        checkWay: this.scene.colliders.checkWay,
        getCollisions: function getCollisions() {
          return _this3.gameObjects.filter(function (gameObject) {
            return gameObject instanceof _GameObjects_Unit__WEBPACK_IMPORTED_MODULE_4__["default"] && gameObject.isAlive() && fireGameObject.params.parent !== gameObject && fireGameObject.position.distanceTo(gameObject.position) < 3;
          });
        },
        destroy: function destroy() {
          return _this3.destroyGameObject(fireGameObject);
        }
      }));
      this.scene.intervals.setTimeout(function () {
        return _this3.destroyGameObject(fireGameObject);
      }, 2000); // this.scene.audio.playSound(firingGameObject.position, 'Lasers');
    }
  }, {
    key: "createItem",
    value: function createItem(_ref) {
      var _this4 = this;

      var _ref$scale = _ref.scale,
          scale = _ref$scale === void 0 ? 1.5 : _ref$scale,
          _ref$model = _ref.model,
          model = _ref$model === void 0 ? 'item-heal' : _ref$model,
          _ref$position = _ref.position,
          position = _ref$position === void 0 ? {} : _ref$position,
          canPickup = _ref.canPickup,
          onPickup = _ref.onPickup;
      this.scene.models.loadGLTF({
        baseUrl: './assets/models/items/' + model,
        noScene: true,
        callback: function callback(loadedObject) {
          var positionVector = new THREE.Vector3(position.x || 0, position.y || 0, position.z || 0);
          loadedObject.scene.scale.set(scale, scale, scale);
          loadedObject.scene.traverse(function (child) {
            if (child.isMesh) {
              child.material.transparent = true;
              child.material.alphaTest = 0.5;
            }
          });
          loadedObject.scene.position.set(positionVector.x, positionVector.y, positionVector.z);

          _this4.scene.scene.add(loadedObject.scene);

          var gameItem = new _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_5__["default"]({
            object: loadedObject.scene,
            animations: loadedObject.animations
          });

          _this4.scene.gameObjectsService.hookGameObject(gameItem);

          var checkPickup = function checkPickup() {
            _this4.scene.intervals.setTimeout(function () {
              var getPriority = function getPriority(unit) {
                return 1 / Math.ceil(positionVector.distanceTo(unit.position));
              };

              var nearUnits = _this4.scene.units.getAliveUnits().filter(function (unit) {
                return (!canPickup || canPickup(unit)) && positionVector.distanceTo(unit.position) < 2;
              }).sort(function (unitA, unitB) {
                return getPriority(unitB) - getPriority(unitA);
              });

              if (nearUnits.length) {
                if (onPickup) {
                  onPickup(nearUnits[0]);
                }

                gameItem.animationState.isDie = true;

                _this4.scene.intervals.setTimeout(function () {
                  return _this4.scene.gameObjectsService.destroyGameObject(gameItem);
                }, 500);
              } else {
                checkPickup();
              }
            }, 1000);
          };

          checkPickup();
        }
      });
    }
    /**
     * @param {GameObject} gameObject
     */

  }, {
    key: "hookGameObject",
    value: function hookGameObject(gameObject) {
      this.gameObjects.push(gameObject);
      gameObject.__game_object_id = this.nextGameObjectId++;
      return gameObject;
    }
  }, {
    key: "removeAll",
    value: function removeAll() {
      while (this.gameObjects.length) {
        this.destroyGameObject(this.gameObjects[0]);
      }
    }
  }, {
    key: "removeAllExceptPlayer",
    value: function removeAllExceptPlayer() {
      var _this5 = this;

      var getNextNonPlayerIndex = function getNextNonPlayerIndex() {
        return _this5.gameObjects.findIndex(function (go) {
          return go !== _this5.scene.getPlayer();
        });
      };

      var removeIdx = getNextNonPlayerIndex();

      while (removeIdx > -1) {
        var gameObject = this.gameObjects[removeIdx];
        this.gameObjects.splice(removeIdx, 1);
        this.removeGameObjectFromScene(gameObject);
        removeIdx = getNextNonPlayerIndex();
      }
    }
    /**
     * @param {GameObject} gameObject
     */

  }, {
    key: "destroyGameObject",
    value: function destroyGameObject(gameObject) {
      var index = this.gameObjects.indexOf(gameObject);

      if (index > -1) {
        this.gameObjects.splice(index, 1);
      }

      this.removeGameObjectFromScene(gameObject);
    }
    /**
     * @param {GameObject} gameObject
     */

  }, {
    key: "removeGameObjectFromScene",
    value: function removeGameObjectFromScene(gameObject) {
      var parent = gameObject.object && gameObject.object.parent || this.scene;

      if (parent.remove) {
        parent.remove(gameObject.object);
      } else {
        console.error('Cannot find object parent to remove the object', gameObject);
      }
    }
  }, {
    key: "getUnits",
    value: function getUnits() {
      return this.gameObjects.filter(function (go) {
        return go instanceof _GameObjects_Unit__WEBPACK_IMPORTED_MODULE_4__["default"];
      });
    }
  }]);

  return GameObjectsService;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/AI.js":
/*!******************************************!*\
  !*** ../client/src/js/GameObjects/AI.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AI; });
/* harmony import */ var _FiringUnit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FiringUnit */ "../client/src/js/GameObjects/FiringUnit.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var AI = /*#__PURE__*/function (_FiringUnit) {
  _inherits(AI, _FiringUnit);

  var _super = _createSuper(AI);

  function AI() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AI);

    _this = _super.call(this, _objectSpread({
      speed: 0.5,
      damage: 10,
      mas: 1,
      hp: 100,
      name: 'Unnamed Unit',
      fraction: 'neutral',
      fireTimeout: 1.5,
      attackTimeout: 1.5,
      jumpTimeout: 1.5,
      startRunTimeout: 1,
      nextPointUpdateTimeout: 0.1,
      updateTargetTimeout: 3
    }, params));
    var _this$params = _this.params,
        hp = _this$params.hp,
        damage = _this$params.damage,
        speed = _this$params.speed;
    _this.params.bounty = hp / 4 + damage + speed * 30;
    _this.lastRun = 0;
    _this.lastTargetUpdate = 0;
    _this.lastNextPointUpdate = 0;
    _this.lastJumpTimestamp = 0;
    _this.isRunning = false;
    _this.isAttack = false;
    return _this;
  }

  _createClass(AI, [{
    key: "update",
    value: function update(time, deltaTime) {
      var _this2 = this;

      _get(_getPrototypeOf(AI.prototype), "update", this).call(this, time, deltaTime);

      if (this.isDead()) {
        return;
      }

      if (this.params.findTarget && this.isUpdateTargetReleased(time)) {
        this.params.target = this.params.findTarget();
      }

      var _this$params2 = this.params,
          object = _this$params2.object,
          target = _this$params2.target,
          acceleration = _this$params2.acceleration,
          speed = _this$params2.speed,
          getNextPoint = _this$params2.getNextPoint;

      if (!this.params.fromNetwork) {
        if (target) {
          if (getNextPoint) {
            if (this.isNextPointUpdateReleased(time)) {
              this.lastNextPointUpdate = time;
              this.nextPoint = getNextPoint(this.position, target.position);
            }
          } else {
            this.nextPoint = target.position;
          }
        }

        var isTargetNear = target && object.position.distanceTo(target.position) < 1.75;
        this.isAttack = isTargetNear && this.isEnemy(target) && target.isAlive();

        if (this.isAttack) {
          this.rotateToPosition(target.position);
        } else if (this.nextPoint) {
          this.rotateToPosition(this.nextPoint);
        }

        var isNextPointNear = !this.nextPoint;
        this.isRunning = target && !isTargetNear && !isNextPointNear && (this.isRunning || this.isRunReleased(time)) && this.isAttackReleased(time) && this.isHitReleased(time);
      }

      if (this.isAttack) {
        this.attack();
      }

      this.animationState.isMovingForward = this.isRunning && this.isAcceleration();

      if (this.isRunning) {
        var checkWay = function checkWay(jumpHeight) {
          var _this2$params$acceler = _this2.params.acceleration,
              dx = _this2$params$acceler.x,
              dy = _this2$params$acceler.y,
              dz = _this2$params$acceler.z;
          return _this2.checkWay(dx, dy + jumpHeight, dz);
        };

        this.lastRun = time;
        acceleration.add(this.getForward().multiplyScalar(speed * 0.1 * (deltaTime * 0.06)));
        var isJumpNeeded = this.isGrounded && (acceleration.x || acceleration.z) && time - this.lastJumpTimestamp > this.params.jumpTimeout * 1000 && !checkWay(0.1) && checkWay(1.5);

        if (isJumpNeeded) {
          this.lastJumpTimestamp = time;
          acceleration.y += 0.25;
        }
      }
    }
  }, {
    key: "rotateToPosition",
    value: function rotateToPosition(position) {
      var object = this.params.object;
      var rotationToTargetRadians = Math.atan2(position.x - object.position.x, position.z - object.position.z); // this.animationState.isRotateLeft = rotationToTargetRadians - object.rotation.y > 0.1;
      // this.animationState.isRotateRight = rotationToTargetRadians - object.rotation.y < -0.1;

      var targetQuaternion = new THREE.Quaternion();
      targetQuaternion.setFromEuler(object.rotation.clone().set(0, rotationToTargetRadians, 0));
      object.quaternion.slerp(targetQuaternion, 0.1);
    }
  }, {
    key: "isAcceleration",
    value: function isAcceleration() {
      return Math.abs(this.params.acceleration.x) + Math.abs(this.params.acceleration.y) + Math.abs(this.params.acceleration.z) > 0.01;
    }
  }, {
    key: "isRunReleased",
    value: function isRunReleased(time) {
      return time - this.lastRun > this.params.startRunTimeout * 1000;
    }
  }, {
    key: "isNextPointUpdateReleased",
    value: function isNextPointUpdateReleased(time) {
      return time - this.lastNextPointUpdate > this.params.nextPointUpdateTimeout * 1000;
    }
  }, {
    key: "isUpdateTargetReleased",
    value: function isUpdateTargetReleased(time) {
      return time - this.lastTargetUpdate > this.params.updateTargetTimeout * 1000;
    }
  }, {
    key: "damageTaken",
    value: function damageTaken() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          damage = _ref.damage,
          attacker = _ref.unit;

      var time = arguments.length > 1 ? arguments[1] : undefined;

      _get(_getPrototypeOf(AI.prototype), "damageTaken", this).call(this, {
        damage: damage,
        unit: attacker
      }, time);

      if (!this.params.target) {
        this.params.target = attacker;
        this.lastTargetUpdate = time;
      }
    }
  }]);

  return AI;
}(_FiringUnit__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/AnimatedGameObject.js":
/*!**********************************************************!*\
  !*** ../client/src/js/GameObjects/AnimatedGameObject.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimatedGameObject; });
/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameObject */ "../client/src/js/GameObjects/GameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var animationNames = {
  stand: 'Stand',
  run: 'Run',
  jump: 'Jump',
  attack: 'Attack',
  rotateLeft: 'Rotate Left',
  rotateRight: 'Rotate Right',
  runLeft: 'Run Left',
  runRight: 'Run Right',
  walkBack: 'Walk Back',
  die: 'Die',
  spawn: 'Spawn',
  hit: 'Hit',
  // Complex animimations
  topRun: 'Top Run',
  bottomRun: 'Bottom Run',
  topWalkBack: 'Top Walk Back',
  bottomWalkBack: 'Bottom Walk Back',
  topAttack: 'Top Attack',
  bottomAttack: 'Bottom Attack',
  topStand: 'Top Stand',
  bottomStand: 'Bottom Stand',
  topRunRight: 'Top Run Right',
  topRunLeft: 'Top Run Left',
  topJump: 'Top Jump',
  topHit: 'Top Hit',
  bottomRunRight: 'Bottom Run Right',
  bottomRunLeft: 'Bottom Run Left',
  bottomJump: 'Bottom Jump',
  bottomHit: 'Bottom Hit',
  topDie: 'Top Die',
  bottomDie: 'Bottom Die',
  topSpawn: 'Top Spawn',
  bottomSpawn: 'Bottom Spawn'
};
var topAnimations = ['topRun', 'topWalkBack', 'topAttack', 'topStand', 'topRunRight', 'topRunLeft', 'topJump', 'topHit', 'topDie'];
var bottomAnimations = ['bottomRun', 'bottomWalkBack', 'bottomAttack', 'bottomStand', 'bottomRunRight', 'bottomRunLeft', 'bottomJump', 'bottomHit', 'bottomDie'];
var topBones = ['Right_Forearm', 'Right_Arm', 'Right_Hand', 'Right_Hand_end', 'Right_Shoulder', 'Left_Shoulder', 'Left_Forearm', 'Left_Arm', 'Left_Hand', 'Left_Hand_end', 'Chest', 'Neck', 'Head', 'Head_end'];
var bottomBones = ['Main_Bone', 'Right_Leg', 'Right_Middle_Foot', 'Right_Foot', 'Right_Foot_end', 'Left_Leg', 'Left_Middle_Foot', 'Left_Foot', 'Left_Foot_end', 'Legs_Rotation'];

var AnimatedGameObject = /*#__PURE__*/function (_GameObject) {
  _inherits(AnimatedGameObject, _GameObject);

  var _super = _createSuper(AnimatedGameObject);

  function AnimatedGameObject() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimatedGameObject);

    _this = _super.call(this, _objectSpread({
      animationNames: _objectSpread({}, animationNames),
      topBones: [].concat(topBones),
      bottomBones: [].concat(bottomBones),
      topAnimations: [].concat(topAnimations),
      bottomAnimations: [].concat(bottomAnimations),
      spawnTimeout: 1
    }, params));
    _this.animationState = {
      isMovingForward: false,
      isMovingRight: false,
      isMovingLeft: false,
      isMovingBackward: false,
      isRotateLeft: false,
      isRotateRight: false,
      isAttack: false,
      isJump: false,
      isDie: false,
      isHit: false,
      isSpawn: true
    };
    _this.playingAnimations = {};
    _this.legsRotationY = 0;
    _this.spawnTime = 0;
    _this.mixer = new THREE.AnimationMixer(_this.params.object);

    _this.initAnimations(_this.params.animationNames);

    return _this;
  }

  _createClass(AnimatedGameObject, [{
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(AnimatedGameObject.prototype), "update", this).call(this, time, deltaTime);

      if (!this.spawnTime) {
        this.spawnTime = time;
      } else if (this.animationState.isSpawn && this.isSpawnFinished(time)) {
        this.animationState.isSpawn = false;
      }

      if (this.mixer) {
        this.mixer.update(deltaTime / 1000);
      }

      if (this.params.complexAnimations) {
        this.updateComplexAnimations();
      } else {
        var animation = this.getCurrentAnimation();
        animation && this.playAnimation(animation);
      }
    }
  }, {
    key: "playAnimation",
    value: function playAnimation(animation) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          force = _ref.force;

      if (!animation || !animation._clip) return;
      var animationName = animation._clip.name;
      var shouldUpdate = this.playingAnimationName !== animationName || force;

      if (shouldUpdate) {
        this.playingAnimationName = animationName;
        animation.reset();
        animation.play();

        if (this.playingAnimation) {
          var from = this.playingAnimation;
          from.enabled = true;
          animation.enabled = true;
          from.crossFadeTo(animation, 0.3);
        }

        this.playingAnimation = animation;
      }
    }
  }, {
    key: "initAnimations",
    value: function initAnimations(animationNames) {
      var _this2 = this;

      var _this$params = this.params,
          topAnimations = _this$params.topAnimations,
          bottomAnimations = _this$params.bottomAnimations,
          topBones = _this$params.topBones,
          bottomBones = _this$params.bottomBones,
          complexAnimations = _this$params.complexAnimations;
      this.animations = Object.keys(animationNames).reduce(function (result, key) {
        var excludedBones = [];

        if (complexAnimations) {
          if (topAnimations.includes(key)) {
            excludedBones = bottomBones;
          } else if (bottomAnimations.includes(key)) {
            excludedBones = topBones;
          }
        }

        var modelAnimation = _this2.findModelAnimation(animationNames[key], {
          excludedBones: excludedBones
        });

        var initedAnimation = _this2.createClipAction(modelAnimation);

        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, key, initedAnimation));
      }, {});
      var _this$animations = this.animations;
      _this$animations = _this$animations === void 0 ? {} : _this$animations;
      var jump = _this$animations.jump,
          attack = _this$animations.attack,
          topAttack = _this$animations.topAttack,
          die = _this$animations.die,
          spawn = _this$animations.spawn,
          topDie = _this$animations.topDie,
          bottomDie = _this$animations.bottomDie,
          topJump = _this$animations.topJump,
          bottomJump = _this$animations.bottomJump,
          bottomAttack = _this$animations.bottomAttack;
      [jump, die, spawn, topDie, bottomDie, topJump, bottomJump].forEach(function (clampAnimation) {
        if (clampAnimation) {
          clampAnimation.setLoop(THREE.LoopOnce, 0);
          clampAnimation.clampWhenFinished = true;
        }
      });
      [attack, topAttack, bottomAttack].forEach(function (attackAnimation) {
        if (attackAnimation) {
          attackAnimation.setDuration(_this2.params.attackTimeout);
        }
      });
    }
  }, {
    key: "createClipAction",
    value: function createClipAction(action) {
      return action && this.mixer.clipAction(action).stop();
    }
  }, {
    key: "findModelAnimation",
    value: function findModelAnimation(name) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$excludedBones = _ref2.excludedBones,
          excludedBones = _ref2$excludedBones === void 0 ? [] : _ref2$excludedBones;

      var _this$params$animatio = this.params.animations,
          animations = _this$params$animatio === void 0 ? [] : _this$params$animatio;
      var animation = animations.find(function (animation) {
        return animation.name === name;
      });

      if (animation && excludedBones.length) {
        return this.clearAnimationBones(animation, excludedBones);
      }

      return animation;
    }
  }, {
    key: "isMoving",
    value: function isMoving() {
      return this.animationState.isMovingLeft || this.animationState.isMovingRight || this.animationState.isMovingForward || this.animationState.isMovingBackward;
    }
  }, {
    key: "isSpawnFinished",
    value: function isSpawnFinished(time) {
      return time - this.spawnTime > this.params.spawnTimeout * 1000;
    }
  }, {
    key: "clearAnimationBones",
    value: function clearAnimationBones(animation, bones) {
      if (animation) {
        var getBoneName = function getBoneName(item) {
          return item.name.split('.')[0];
        },
            isNotExcluded = function isNotExcluded(item) {
          return !bones.includes(getBoneName(item));
        };

        animation.tracks = animation.tracks.filter(isNotExcluded);
        return animation;
      }
    }
  }, {
    key: "updateComplexAnimations",
    value: function updateComplexAnimations() {
      var _this$animations2 = this.animations;
      _this$animations2 = _this$animations2 === void 0 ? {} : _this$animations2;
      var topAttack = _this$animations2.topAttack,
          bottomAttack = _this$animations2.bottomAttack,
          topWalkBack = _this$animations2.topWalkBack,
          bottomWalkBack = _this$animations2.bottomWalkBack,
          topRun = _this$animations2.topRun,
          bottomRun = _this$animations2.bottomRun,
          topRunRight = _this$animations2.topRunRight,
          topRunLeft = _this$animations2.topRunLeft,
          topStand = _this$animations2.topStand,
          bottomStand = _this$animations2.bottomStand,
          topJump = _this$animations2.topJump,
          bottomJump = _this$animations2.bottomJump,
          topHit = _this$animations2.topHit,
          bottomHit = _this$animations2.bottomHit,
          topDie = _this$animations2.topDie,
          bottomDie = _this$animations2.bottomDie,
          topSpawn = _this$animations2.topSpawn,
          bottomSpawn = _this$animations2.bottomSpawn;
      var _this$animationState = this.animationState,
          isAttack = _this$animationState.isAttack,
          isMovingRight = _this$animationState.isMovingRight,
          isMovingLeft = _this$animationState.isMovingLeft,
          isMovingBackward = _this$animationState.isMovingBackward,
          isMovingForward = _this$animationState.isMovingForward,
          isJump = _this$animationState.isJump,
          isDie = _this$animationState.isDie,
          isHit = _this$animationState.isHit,
          isSpawn = _this$animationState.isSpawn;
      var playingAnimations = {
        top: isDie && topDie || isHit && topHit || isAttack && topAttack || isJump && topJump || isMovingBackward && isMovingRight && topRunLeft || isMovingBackward && isMovingLeft && topRunRight || isMovingBackward && topWalkBack || isMovingRight && topRunRight || isMovingLeft && topRunLeft || isMovingForward && topRun || isSpawn && topSpawn || topStand,
        bottom: isDie && bottomDie || isJump && bottomJump || isMovingBackward && isMovingRight && bottomWalkBack || isMovingBackward && isMovingLeft && bottomWalkBack || isMovingBackward && bottomWalkBack || isMovingRight && bottomRun || isMovingLeft && bottomRun || isMovingForward && bottomRun || isAttack && bottomAttack || isHit && bottomHit || isSpawn && bottomSpawn || bottomStand
      };
      var legsRotationBone = this.getChildByName('Legs_Rotation');

      if (legsRotationBone) {
        var rotation = legsRotationBone.rotation;
        var y = -0.3;

        if (isMovingLeft) {
          y = isMovingForward ? 0.5 : isMovingBackward ? -0.7 : 1;
        } else if (isMovingRight) {
          y = isMovingForward ? -1.2 : isMovingBackward ? 0.4 : -1.7;
        }

        this.legsRotationY = this.legsRotationY - (this.legsRotationY - y) / 10;
        rotation.set(rotation.x, this.legsRotationY, rotation.z);
      }

      this.blendAnimations(playingAnimations);
    }
  }, {
    key: "blendAnimations",
    value: function blendAnimations(_ref3) {
      var top = _ref3.top,
          bottom = _ref3.bottom;
      if (!(top && bottom && top._clip && bottom._clip)) return;

      var getAnimationName = function getAnimationName(a) {
        return a._clip.name;
      },
          playAnimation = function playAnimation(fromAnimation, animation) {
        var animationName = getAnimationName(animation);
        var fromAnimationName = fromAnimation && getAnimationName(fromAnimation);

        if (fromAnimationName !== animationName) {
          animation.reset();
          animation.play();

          if (fromAnimation) {
            fromAnimation.crossFadeTo(animation, 0.3);
          }
        }
      };

      playAnimation(this.playingAnimations.top, top);
      playAnimation(this.playingAnimations.bottom, bottom);
      this.playingAnimations.top = top;
      this.playingAnimations.bottom = bottom;
    }
  }, {
    key: "getCurrentAnimation",
    value: function getCurrentAnimation() {
      var _this$animations3 = this.animations;
      _this$animations3 = _this$animations3 === void 0 ? {} : _this$animations3;
      var stand = _this$animations3.stand,
          attack = _this$animations3.attack,
          walkBack = _this$animations3.walkBack,
          runLeft = _this$animations3.runLeft,
          runRight = _this$animations3.runRight,
          run = _this$animations3.run,
          jump = _this$animations3.jump,
          hit = _this$animations3.hit,
          rotateLeft = _this$animations3.rotateLeft,
          rotateRight = _this$animations3.rotateRight,
          die = _this$animations3.die,
          spawn = _this$animations3.spawn;
      var _this$animationState2 = this.animationState,
          isAttack = _this$animationState2.isAttack,
          isMovingForward = _this$animationState2.isMovingForward,
          isJump = _this$animationState2.isJump,
          isMovingLeft = _this$animationState2.isMovingLeft,
          isMovingRight = _this$animationState2.isMovingRight,
          isMovingBackward = _this$animationState2.isMovingBackward,
          isRotateLeft = _this$animationState2.isRotateLeft,
          isRotateRight = _this$animationState2.isRotateRight,
          isDie = _this$animationState2.isDie,
          isHit = _this$animationState2.isHit,
          isSpawn = _this$animationState2.isSpawn;
      return isDie && die || isHit && hit || isAttack && attack || isJump && jump || isMovingBackward && walkBack || isMovingLeft && runLeft || isMovingRight && runRight || isMovingForward && run || isRotateLeft && rotateLeft || isRotateRight && rotateRight || isSpawn && spawn || stand;
    }
  }]);

  return AnimatedGameObject;
}(_GameObject__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/Fire.js":
/*!********************************************!*\
  !*** ../client/src/js/GameObjects/Fire.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Fire; });
/* harmony import */ var _Unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Unit */ "../client/src/js/GameObjects/Unit.js");
/* harmony import */ var _MovingGameObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MovingGameObject */ "../client/src/js/GameObjects/MovingGameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Fire = /*#__PURE__*/function (_MovingGameObject) {
  _inherits(Fire, _MovingGameObject);

  var _super = _createSuper(Fire);

  function Fire() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Fire);

    _this = _super.call(this, params);

    _this.params.acceleration.add(_this.getForward().multiplyScalar(_this.params.speed * 0.1));

    return _this;
  }

  _createClass(Fire, [{
    key: "update",
    value: function update(time, deltaTime) {
      var _this2 = this;

      _get(_getPrototypeOf(Fire.prototype), "update", this).call(this, time, deltaTime);

      if (this.params.getCollisions) {
        var collisions = this.params.getCollisions(this);
        collisions.filter(function (collisionGameObject) {
          return collisionGameObject instanceof _Unit__WEBPACK_IMPORTED_MODULE_0__["default"] && collisionGameObject.isEnemy(_this2.params.parent);
        }).forEach(function (collisionGameObject) {
          return collisionGameObject.damageTaken({
            damage: _this2.params.damage,
            unit: _this2.params.parent
          }, time);
        });

        if (collisions.length && this.params.destroy) {
          this.params.destroy(this);
        }
      }
    }
  }]);

  return Fire;
}(_MovingGameObject__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/FiringUnit.js":
/*!**************************************************!*\
  !*** ../client/src/js/GameObjects/FiringUnit.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FiringUnit; });
/* harmony import */ var _Unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Unit */ "../client/src/js/GameObjects/Unit.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var FiringUnit = /*#__PURE__*/function (_Unit) {
  _inherits(FiringUnit, _Unit);

  var _super = _createSuper(FiringUnit);

  function FiringUnit() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, FiringUnit);

    _this = _super.call(this, _objectSpread({
      fireDamage: 10,
      fireTimeout: 1.5,
      fireShellSpeed: 3
    }, params));
    _this.shouldFire = false;
    _this.latestFire = 0;
    return _this;
  }

  _createClass(FiringUnit, [{
    key: "getFireInitialPosition",
    value: function getFireInitialPosition() {
      return this.position.clone().add(this.getUp().multiplyScalar(1.5).add(this.getForward().multiplyScalar(0.3)));
    }
  }, {
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(FiringUnit.prototype), "update", this).call(this, time, deltaTime);

      if (this.isDead()) {
        return;
      }

      this.isFire = false;

      if (this.shouldFire && this.params.fire && this.isFireReleased(time) && this.isAttackReleased(time)) {
        this.isFire = true;
        this.shouldFire = false;
        this.latestFire = time;
        this.params.fire();
      } else {
        this.shouldFire = false;
      }
    }
  }, {
    key: "isFireReleased",
    value: function isFireReleased(time) {
      return time - this.latestFire >= this.params.fireTimeout * 1000;
    }
  }, {
    key: "fire",
    value: function fire() {
      this.shouldFire = true;
    }
  }]);

  return FiringUnit;
}(_Unit__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/GameObject.js":
/*!**************************************************!*\
  !*** ../client/src/js/GameObjects/GameObject.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GameObject; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var GameObject = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(GameObject, _AutoBindMethods);

  var _super = _createSuper(GameObject);

  function GameObject() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GameObject);

    _this = _super.call(this);
    _this.params = _objectSpread({}, params);
    _this.object = params.object;

    if (params.object) {
      _this.position = params.object.position;
      _this.rotation = params.object.rotation;
    }

    _this.events = {};
    return _this;
  }

  _createClass(GameObject, [{
    key: "update",
    value: function update() {}
    /**
     * @param {string} eventName
     * @param {object[]} args
     */

  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(eventName) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this.events[eventName]) {
        this.events[eventName].forEach(function (callback) {
          return callback.apply(void 0, args);
        });
      }
    }
    /**
     * @param {string} eventName
     * @param {function} callback
     */

  }, {
    key: "addEventListener",
    value: function addEventListener(eventName, callback) {
      if (typeof callback === 'function') {
        if (this.events[eventName]) {
          this.events[eventName].push(callback);
        } else {
          this.events[eventName] = [callback];
        }
      }
    }
  }, {
    key: "getChildByName",
    value: function getChildByName(name) {
      return this.object.getObjectByName(name, true);
    }
  }, {
    key: "getChildDirection",
    value: function getChildDirection(arg) {
      var vector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3(0, 0, 1);
      var child = typeof arg === 'string' ? this.getChildByName(arg) : arg;
      return vector.applyQuaternion(this.getChildRotation(child));
    }
  }, {
    key: "getChildPosition",
    value: function getChildPosition(arg) {
      var child = typeof arg === 'string' ? this.getChildByName(arg) : arg;
      return new THREE.Vector3().setFromMatrixPosition(child.matrixWorld);
    }
  }, {
    key: "getChildRotation",
    value: function getChildRotation(arg) {
      var child = typeof arg === 'string' ? this.getChildByName(arg) : arg;
      var target = new THREE.Quaternion();
      child.getWorldQuaternion(target);
      return target;
    }
  }]);

  return GameObject;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/MovingGameObject.js":
/*!********************************************************!*\
  !*** ../client/src/js/GameObjects/MovingGameObject.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MovingGameObject; });
/* harmony import */ var _AnimatedGameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimatedGameObject */ "../client/src/js/GameObjects/AnimatedGameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var MovingGameObject = /*#__PURE__*/function (_AnimatedGameObject) {
  _inherits(MovingGameObject, _AnimatedGameObject);

  var _super = _createSuper(MovingGameObject);

  function MovingGameObject() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MovingGameObject);

    return _super.call(this, _objectSpread({
      speed: 0.1,
      throttling: new THREE.Vector3(0.5, 0.95, 0.5),
      acceleration: new THREE.Vector3(),
      mas: 0,
      checkWay: function checkWay() {
        return true;
      }
    }, params));
  }

  _createClass(MovingGameObject, [{
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(MovingGameObject.prototype), "update", this).call(this, time, deltaTime);

      var _this$params = this.params,
          acceleration = _this$params.acceleration,
          throttling = _this$params.throttling;

      if (this.params.mas) {
        acceleration.y -= 0.01;
        this.isGrounded = !this.checkWay(0, -0.2, 0);
        this.animationState.isJump = !this.isGrounded;
      }

      var isX = Boolean(acceleration.x) && this.checkWay(acceleration.x, 0, 0);
      var isY = Boolean(acceleration.y) && this.checkWay(0, acceleration.y, 0);
      var isZ = Boolean(acceleration.z) && this.checkWay(0, 0, acceleration.z);

      if (!isX || !isY || !isZ) {
        if (!this.params.mas) {
          // Stop object smoothly because of Collider hit
          acceleration.multiplyScalar(0.75);
        }

        if (!isX) {
          var isClimbing = acceleration.x && acceleration.y <= 0 && this.checkWay(acceleration.x, 0.04, 0);

          if (isClimbing) {
            acceleration.y = 0.04 / throttling.y;
          } else {
            acceleration.x = 0;
          }
        }

        if (!isY) {
          acceleration.y = 0;
        }

        if (!isZ) {
          var _isClimbing = acceleration.z && acceleration.y <= 0 && this.checkWay(0, 0.04, acceleration.z);

          if (_isClimbing) {
            acceleration.y = 0.04 / throttling.y;
          } else {
            acceleration.z = 0;
          }
        }
      }

      acceleration.x *= throttling.x;
      acceleration.y *= throttling.y;
      acceleration.z *= throttling.z;
      var isMoving = Math.abs(acceleration.x) > 0.001 || Math.abs(acceleration.y) > 0.001 || Math.abs(acceleration.z) > 0.001;

      if (isMoving) {
        // acceleration.multiplyScalar(deltaTime * 60)
        this.position.add(acceleration);
      }
    }
  }, {
    key: "checkWay",
    value: function checkWay() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var position = this.position,
          checkWay = this.params.checkWay;
      var nextPosition = new THREE.Vector3(position.x + x, position.y + y + 0.1, position.z + z);
      return checkWay(nextPosition, this);
    }
  }, {
    key: "getLeft",
    value: function getLeft() {
      return this.getDirection(new THREE.Vector3(1, 0, 0));
    }
  }, {
    key: "getUp",
    value: function getUp() {
      return this.getDirection(new THREE.Vector3(0, 1, 0));
    }
  }, {
    key: "getForward",
    value: function getForward() {
      return this.getDirection(new THREE.Vector3(0, 0, 1));
    }
    /**
     * @param {THREE.Vector3} direction
     */

  }, {
    key: "getDirection",
    value: function getDirection(direction) {
      direction.applyQuaternion(this.object.quaternion);
      return direction;
    }
  }, {
    key: "getScalarAcceleration",
    value: function getScalarAcceleration() {
      return this.params.acceleration.toArray().map(Math.abs).reduce(function (r, v) {
        return r + v;
      }, 0);
    }
  }]);

  return MovingGameObject;
}(_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/Player.js":
/*!**********************************************!*\
  !*** ../client/src/js/GameObjects/Player.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Player; });
/* harmony import */ var _FiringUnit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FiringUnit */ "../client/src/js/GameObjects/FiringUnit.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Player = /*#__PURE__*/function (_FiringUnit) {
  _inherits(Player, _FiringUnit);

  var _super = _createSuper(Player);

  function Player() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Player);

    _this = _super.call(this, _objectSpread({
      speed: 0.54,
      fireTimeout: 1,
      fireDamage: 25,
      damage: 50,
      hp: 100,
      experience: 0,
      unspentTalents: 0,
      money: 500,
      isFire: false,
      mas: 1,
      level: 1,
      jumpTimeout: 0.9,
      fraction: 'friendly',
      sensitivity: 1
    }, params));
    _this.lastJumpTimestamp = 0;
    _this.rotationAcceleration = 0; // console.log('Player', this);

    params.onLevelUp && _this.addEventListener('onLevelUp', params.onLevelUp);
    return _this;
  }

  _createClass(Player, [{
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(Player.prototype), "update", this).call(this, time, deltaTime);

      if (this.isDead()) {
        return;
      }

      var _this$params = this.params,
          input = _this$params.input,
          object = _this$params.object,
          acceleration = _this$params.acceleration,
          fromNetwork = _this$params.fromNetwork;
      acceleration.add(this.getMovingAcceleration(time, deltaTime));

      if (input.attack1) {
        this.attack();
      }

      if (input.attack2) {
        this.fire();
      }

      this.animationState.isMovingLeft = input.horizontal === -1;
      this.animationState.isMovingRight = input.horizontal === 1;
      this.animationState.isMovingForward = input.vertical === 1;
      this.animationState.isMovingBackward = input.vertical === -1;

      if (!fromNetwork) {
        if (input.isThirdPerson) {
          if (input.look.horizontal) {
            var horizontalLook = input.look.horizontal;
            this.animationState.isRotateLeft = horizontalLook < 0;
            this.animationState.isRotateRight = horizontalLook > 0;
            this.rotationAcceleration += -horizontalLook / 5000 * input.look.sensitivity;
            input.resetHorizontalLook();
          }

          var CALC_ROTATE_THRESHOLD = 0.0000001;

          if (Math.abs(this.rotationAcceleration) > CALC_ROTATE_THRESHOLD) {
            object.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), this.rotationAcceleration);
            this.rotationAcceleration *= 0.7;
          }
        } else {
          var deltaX = window.innerWidth / 2 - input.cursor.x;
          var deltaY = input.cursor.y - window.innerHeight / 2;
          var rotationY = Math.atan2(deltaY, deltaX);
          this.animationState.isRotateLeft = rotationY > object.rotation.y;
          this.animationState.isRotateRight = rotationY < object.rotation.y;
          object.rotation.set(0, rotationY, 0);
        }
      }
    }
  }, {
    key: "getUnspentTalents",
    value: function getUnspentTalents() {
      return this.params.unspentTalents;
    }
  }, {
    key: "decreaseUnspentTalents",
    value: function decreaseUnspentTalents() {
      return this.params.unspentTalents--;
    }
  }, {
    key: "getFireInitialPosition",
    value: function getFireInitialPosition() {
      var head = this.getChildByName('Head');
      var headForward = this.getChildDirection(head, new THREE.Vector3(0, 0, 1));
      var headUp = new THREE.Vector3(0, 1, 0);
      headUp.applyQuaternion(head.quaternion);
      return this.getChildPosition(head).add(headUp.multiplyScalar(0.15)).add(headForward.multiplyScalar(0.25));
    }
  }, {
    key: "getFireInitialRotation",
    value: function getFireInitialRotation() {
      return this.getChildRotation('Head');
    }
  }, {
    key: "addExperience",
    value: function addExperience(experience) {
      this.params.experience += experience;
      var level = this.getLevel();

      if (this.params.level !== level) {
        var levelsUp = level - this.params.level;
        this.params.level = level;
        this.params.unspentTalents += 3 * levelsUp;
        this.params.hp = this.params.hpMax;
        this.dispatchEvent('onLevelUp', level);
      }
    }
  }, {
    key: "getExperience",
    value: function getExperience() {
      return this.params.experience;
    }
  }, {
    key: "getLevelExperience",
    value: function getLevelExperience() {
      return Math.pow(this.getLevel(), 2) * 100;
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return Math.floor(Math.sqrt(this.params.experience / 100)) + 1;
    }
  }, {
    key: "getMovingAcceleration",
    value: function getMovingAcceleration(time, deltaTime) {
      var _this$params$input = this.params.input,
          horizontal = _this$params$input.horizontal,
          vertical = _this$params$input.vertical,
          jump = _this$params$input.jump;
      var speed = vertical && horizontal ? this.params.speed * 0.1 * 0.7 * (deltaTime * 0.06) : this.params.speed * 0.1 * (deltaTime * 0.06);
      var addForward = vertical === 1 ? speed : vertical === -1 ? -speed * 0.6 : 0;
      var addSide = vertical === -1 ? -horizontal * speed * 0.6 : -horizontal * speed;
      var isJump = time - this.lastJumpTimestamp > this.params.jumpTimeout * 1000 && jump && this.isGrounded;

      if (isJump) {
        this.lastJumpTimestamp = time;
      }

      return this.getDirection(new THREE.Vector3(addSide, Number(isJump) * 0.25, addForward));
    }
  }]);

  return Player;
}(_FiringUnit__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/GameObjects/Unit.js":
/*!********************************************!*\
  !*** ../client/src/js/GameObjects/Unit.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Unit; });
/* harmony import */ var _MovingGameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MovingGameObject */ "../client/src/js/GameObjects/MovingGameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Unit = /*#__PURE__*/function (_MovingGameObject) {
  _inherits(Unit, _MovingGameObject);

  var _super = _createSuper(Unit);

  function Unit() {
    var _this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Unit);

    _this = _super.call(this, _objectSpread({
      hp: 100,
      hpMax: params.hp || 100,
      damage: 10,
      attackTimeout: 0.9,
      hitTime: 0.3,
      attackDamageTimeout: 0.3
    }, params));
    _this.shouldAttack = false;
    _this.latestAttackTimestamp = 0;
    _this.latestHitTimestamp = 0;
    ['onDamageTaken', 'onDamageDeal', 'onKill', 'onDie'].forEach(function (eventName) {
      if (typeof params[eventName] === 'function') {
        _this.addEventListener(eventName, params[eventName]);
      }
    });
    return _this;
  }

  _createClass(Unit, [{
    key: "update",
    value: function update(time, deltaTime) {
      _get(_getPrototypeOf(Unit.prototype), "update", this).call(this, time, deltaTime);

      if (this.isDead()) {
        return;
      }

      var hitReleased = this.isHitReleased(time);
      this.animationState.isHit = !hitReleased;

      if (this.isAttackReleased(time) && hitReleased) {
        this.animationState.isAttack = false;

        if (this.shouldAttack) {
          this.animationState.isAttack = true;
          this.latestAttackTimestamp = time;
          this.params.attack && this.params.attack();
        }
      } else {
        this.shouldAttack = false;
      }
    }
  }, {
    key: "getFraction",
    value: function getFraction() {
      return this.params.fraction;
    }
  }, {
    key: "getCollider",
    value: function getCollider(position) {
      var diffY = position.y - this.position.y;
      return Math.sqrt(Math.pow(position.x - this.position.x, 2) + Math.pow(position.z - this.position.z, 2)) < 1 && diffY >= 0 && diffY < 1.7;
    }
  }, {
    key: "releaseAttack",
    value: function releaseAttack(time) {
      this.latestAttackTimestamp = time - this.params.attackTimeout * 1000;
      this.animationState.isAttack = false;
    }
  }, {
    key: "isAttackReleased",
    value: function isAttackReleased(time) {
      return time - this.latestAttackTimestamp >= this.params.attackTimeout * 1000;
    }
  }, {
    key: "isAttackInterrupted",
    value: function isAttackInterrupted(time) {
      return time - this.latestHitTimestamp <= this.params.attackDamageTimeout * 1000;
    }
  }, {
    key: "isHitReleased",
    value: function isHitReleased(time) {
      return time - this.latestHitTimestamp >= this.params.hitTime * 1000;
    }
  }, {
    key: "attack",
    value: function attack() {
      this.shouldAttack = true;
    }
  }, {
    key: "isDead",
    value: function isDead() {
      return this.params.hp <= 0;
    }
  }, {
    key: "isAlive",
    value: function isAlive() {
      return !this.isDead();
    }
  }, {
    key: "isEnemy",
    value: function isEnemy(unit) {
      return unit.params.fraction !== this.params.fraction && unit.params.fraction !== 'neutral' && this.params.fraction !== 'neutral';
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this.params.level;
    }
  }, {
    key: "getName",
    value: function getName() {
      return this.params.name;
    }
  }, {
    key: "getAttackTimeout",
    value: function getAttackTimeout() {
      return this.params.attackDamageTimeout * 1000;
    }
  }, {
    key: "damageTaken",
    value: function damageTaken() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          damage = _ref.damage,
          attacker = _ref.unit;

      var time = arguments.length > 1 ? arguments[1] : undefined;

      if (damage && attacker) {
        this.params.hp -= damage;
        this.dispatchEvent('onDamageTaken', attacker);

        if (attacker) {
          attacker.dispatchEvent('onDamageDeal', this);
        }

        var interruptByChance = Math.random() < 0.33;
        var interruptByLevel = attacker.getLevel() - this.getLevel() > 2;
        var shouldBeInterrupted = interruptByLevel || interruptByChance;

        if (shouldBeInterrupted) {
          this.latestHitTimestamp = time;
        }

        if (this.isDead()) {
          this.die(attacker);
        }
      }
    }
  }, {
    key: "die",
    value: function die(killingUnit) {
      this.params.hp = 0;
      this.dispatchEvent('onDie', killingUnit);
      this.animationState.isDie = true;

      if (killingUnit) {
        killingUnit.dispatchEvent('onKill', this);
      }
    }
  }, {
    key: "addSpeed",
    value: function addSpeed(speed) {
      this.params.speed += speed;
    }
  }, {
    key: "addDamage",
    value: function addDamage(damage) {
      this.params.damage += damage;
    }
  }, {
    key: "addHP",
    value: function addHP(hp) {
      if (this.isAlive()) {
        this.params.hp = Math.min(this.params.hp + hp, this.params.hpMax);
      }
    }
  }, {
    key: "getMoney",
    value: function getMoney() {
      return this.params.money;
    }
  }, {
    key: "addMoney",
    value: function addMoney(money) {
      this.params.money += money;
    }
  }, {
    key: "addMaxHP",
    value: function addMaxHP(hp) {
      if (this.isAlive()) {
        this.params.hpMax += hp;
        this.params.hp += hp;
      }
    }
  }, {
    key: "getHP",
    value: function getHP() {
      return this.params.hp;
    }
  }, {
    key: "getMaxHP",
    value: function getMaxHP() {
      return this.params.hpMax;
    }
  }, {
    key: "getSpeed",
    value: function getSpeed() {
      return this.params.speed;
    }
  }, {
    key: "getDamage",
    value: function getDamage() {
      return this.params.damage;
    }
  }]);

  return Unit;
}(_MovingGameObject__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Input.js":
/*!*********************************!*\
  !*** ../client/src/js/Input.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Input; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var KEYS = {
  MOUSE_LEFT: 1,
  MOUSE_RIGHT: 3,
  SPACE: 32,
  ENTER: 13,
  ESC: 27,
  C: 67,
  W: 87,
  A: 65,
  S: 83,
  D: 68,
  X: 88,
  Z: 90,
  Q: 81,
  E: 69,
  R: 82,
  F: 70,
  V: 86,
  1: 49,
  2: 50,
  ARROW_LEFT: 37,
  ARROW_RIGHT: 39,
  ARROW_UP: 38,
  ARROW_DOWN: 40
};

var Input = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Input, _AutoBindMethods);

  var _super = _createSuper(Input);

  function Input(params) {
    var _this;

    _classCallCheck(this, Input);

    _this = _super.call(this);
    _this.params = params;
    _this.vertical = 0;
    _this.horizontal = 0;
    _this.attack1 = false;
    _this.attack2 = false;
    _this.look = {
      vertical: 0,
      horizontal: 0,
      back: false,
      sensitivity: 1
    };

    _this.resetHorizontalLook = function () {
      return _this.look.horizontal = 0;
    };

    _this.isThirdPerson = true;
    _this.cursor = {
      x: 0,
      y: 0
    };
    _this.mouse = {
      x: 0,
      y: 0
    };

    _this.addEventListeners();

    return _this;
  }

  _createClass(Input, [{
    key: "update",
    value: function update() {
      this.look.horizontal = 0;
      this.look.vertical = 0;
    }
  }, {
    key: "addEventListeners",
    value: function addEventListeners() {
      var _this2 = this;

      document.addEventListener('mousedown', function (e) {
        if (e.which === KEYS.MOUSE_LEFT) {
          _this2.attack1 = true;
        }

        if (e.which === KEYS.MOUSE_RIGHT) {
          _this2.attack2 = true;
        }
      });
      document.addEventListener('mouseup', function (e) {
        if (e.which === KEYS.MOUSE_LEFT) {
          _this2.attack1 = false;
        }

        if (e.which === KEYS.MOUSE_RIGHT) {
          _this2.attack2 = false;
        }
      });
      var timeout;
      document.addEventListener('mousemove', function (e) {
        _this2.look.horizontal += e.movementX || 0;
        _this2.look.vertical += e.movementY || 0;
        _this2.mouse.x = e.x;
        _this2.mouse.y = e.y;
        var cursorX = _this2.cursor.x + (e.movementX || 0);
        var cursorY = _this2.cursor.y + (e.movementY || 0);

        if (cursorX > 0 && cursorX < window.innerWidth) {
          _this2.cursor.x = cursorX;
        }

        if (cursorY > 0 && cursorY < window.innerHeight) {
          _this2.cursor.y = cursorY;
        }

        if (timeout !== undefined) {
          window.clearTimeout(timeout);
        }

        timeout = window.setTimeout(function () {
          document.dispatchEvent(new Event('onmousemoveend'));
        }, 100);
      });
      document.addEventListener('onmousemoveend', function (e) {
        // Horizontal look is cleaning by Player.update after rotation is applied
        // this.look.horizontal = 0;
        _this2.look.vertical = 0;
      });
      document.addEventListener('keydown', function (e) {
        switch (e.which) {
          case KEYS.ENTER:
            _this2.params.onAction && _this2.params.onAction();
            break;

          case KEYS.ESC:
            _this2.params.onExit && _this2.params.onExit();
            break;

          case KEYS.C:
            _this2.params.onSwitchCamera && _this2.params.onSwitchCamera();
            break;

          case KEYS.W:
          case KEYS.ARROW_UP:
            _this2.vertical = 1;
            break;

          case KEYS.S:
          case KEYS.ARROW_DOWN:
            _this2.vertical = -1;
            break;

          case KEYS.A:
          case KEYS.ARROW_LEFT:
            _this2.horizontal = -1;
            break;

          case KEYS.D:
          case KEYS.ARROW_RIGHT:
            _this2.horizontal = 1;
            break;

          case KEYS.X:
            _this2.look.back = true;
            break;

          case KEYS.F:
            _this2.look.cinematic = true;
            break;

          case KEYS.SPACE:
            _this2.jump = 1;
            break;
        }
      });
      document.addEventListener('keyup', function (e) {
        switch (e.which) {
          case KEYS.W:
          case KEYS.ARROW_UP:
            if (_this2.vertical === 1) {
              _this2.vertical = 0;
            }

            break;

          case KEYS.S:
          case KEYS.ARROW_DOWN:
            if (_this2.vertical === -1) {
              _this2.vertical = 0;
            }

            break;

          case KEYS.A:
          case KEYS.ARROW_LEFT:
            if (_this2.horizontal === -1) {
              _this2.horizontal = 0;
            }

            break;

          case KEYS.D:
          case KEYS.ARROW_RIGHT:
            if (_this2.horizontal === 1) {
              _this2.horizontal = 0;
            }

            break;

          case KEYS.X:
            _this2.look.back = false;
            break;

          case KEYS.F:
            _this2.look.cinematic = false;
            break;

          case KEYS.SPACE:
            _this2.jump = 0;
            break;
        }
      });
      window.addEventListener('wheel', function (e) {
        return _this2.params.onZoom && _this2.params.onZoom(e.deltaY / 100);
      });
      return this;
    }
  }]);

  return Input;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Intervals.js":
/*!*************************************!*\
  !*** ../client/src/js/Intervals.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Intervals; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Intervals = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Intervals, _AutoBindMethods);

  var _super = _createSuper(Intervals);

  function Intervals(scene) {
    var _this;

    _classCallCheck(this, Intervals);

    _this = _super.call(this);
    _this.scene = scene;
    _this.timePassed = 0;
    _this.lastFrame = 0;
    _this.intervals = [];
    _this.intervalIndex = 0;
    return _this;
  }

  _createClass(Intervals, [{
    key: "update",
    value: function update(now) {
      var _this2 = this;

      this.timePassed += now - this.lastFrame;
      this.intervals.filter(function (i) {
        return _this2.timePassed - i.calledAt > i.interval;
      }).forEach(function (interval) {
        interval.calledAt = _this2.timePassed;
        interval.fn();

        if (interval.loops && --interval.loops === 0) {
          _this2.clearInterval(interval.id);
        }
      });
      this.lastFrame = now;
    }
  }, {
    key: "getTimePassed",
    value: function getTimePassed() {
      return this.timePassed;
    }
  }, {
    key: "getDeltaTime",
    value: function getDeltaTime(now) {
      return now - this.lastFrame;
    }
  }, {
    key: "setInterval",
    value: function setInterval(fn, interval, immediately, loops) {
      if (fn && interval) {
        var calledAt = immediately ? this.timePassed - interval : this.timePassed;
        this.intervals.push({
          fn: fn,
          interval: interval,
          calledAt: calledAt,
          loops: loops,
          id: ++this.intervalIndex
        });
      }
    }
  }, {
    key: "setTimeout",
    value: function setTimeout(fn, timeout) {
      if (fn && timeout) {
        this.intervals.push({
          fn: fn,
          interval: timeout,
          loops: 1,
          calledAt: this.timePassed,
          id: ++this.intervalIndex
        });
      }
    }
  }, {
    key: "clearInterval",
    value: function clearInterval(id) {
      var intervalIdx = this.intervals.findIndex(function (i) {
        return i.id === id;
      });

      if (intervalIdx > -1) {
        this.intervals.splice(intervalIdx, 1);
      }
    }
  }]);

  return Intervals;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Locations/AbstractLocation.js":
/*!******************************************************!*\
  !*** ../client/src/js/Locations/AbstractLocation.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AbstractLocation; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var AbstractLocation = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(AbstractLocation, _AutoBindMethods);

  var _super = _createSuper(AbstractLocation);

  /**
   * @param {Scene} scene
   */
  function AbstractLocation(scene) {
    var _this;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unknown-level';

    _classCallCheck(this, AbstractLocation);

    _this = _super.call(this);
    _this.scene = scene;
    _this.id = id;
    return _this;
  }

  _createClass(AbstractLocation, [{
    key: "update",
    value: function update() {}
  }, {
    key: "startLocation",
    value: function startLocation() {}
  }, {
    key: "restartLocation",
    value: function restartLocation() {}
  }, {
    key: "stopLocation",
    value: function stopLocation() {}
  }, {
    key: "onAction",
    value: function onAction() {}
  }, {
    key: "getLocationName",
    value: function getLocationName() {
      return this.id;
    }
  }, {
    key: "createAmbientLight",
    value: function createAmbientLight() {
      var ambientLight = new THREE.AmbientLight(0x888888);
      ambientLight.castShadow = false;
      return ambientLight;
    }
  }, {
    key: "createShadowLight",
    value: function createShadowLight() {
      var light = new THREE.DirectionalLight(0xffffff, 10, 150);
      light.intensity = 1;
      light.shadow.bias = -0.00001;
      var shadowSize = 25;
      light.castShadow = true;
      light.shadow.camera.left = -shadowSize;
      light.shadow.camera.right = shadowSize;
      light.shadow.camera.top = shadowSize;
      light.shadow.camera.bottom = -shadowSize;
      light.shadow.mapSize.width = 512;
      light.shadow.mapSize.height = 512;
      light.shadow.camera.near = 10;
      light.shadow.camera.far = 150;
      light.shadow.camera.visible = true;
      return light;
    }
  }, {
    key: "createSkybox",
    value: function createSkybox() {
      var materialArray = ['xpos', 'xneg', 'ypos', 'yneg', 'zpos', 'zneg'].map(function (direction) {
        var url = "./assets/textures/sky-nebula/nebula-".concat(direction, ".png");
        return new THREE.MeshBasicMaterial({
          map: new THREE.TextureLoader().load(url),
          side: THREE.BackSide,
          fog: false
        });
      });
      var skyGeometry = new THREE.CubeGeometry(75000, 75000, 75000);
      var skyMaterial = new THREE.MeshFaceMaterial(materialArray);
      return new THREE.Mesh(skyGeometry, skyMaterial);
    }
  }]);

  return AbstractLocation;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Locations/DreamTown/Areas.js":
/*!*****************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/Areas.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var buildArea = function buildArea(areaId, map) {
  var _AreaSizes$areaId = AreaSizes[areaId],
      width = _AreaSizes$areaId.width,
      height = _AreaSizes$areaId.height;

  var waypointXToWorldX = function waypointXToWorldX(position) {
    return position - width / 2;
  };

  var waypointYToWorldZ = function waypointYToWorldZ(position) {
    return position - height / 2;
  };

  var worldXToWaypointX = function worldXToWaypointX(position) {
    var graphX = Math.round(position + width / 2);
    return Math.min(Math.max(graphX, 4), width - 5);
  };

  var worldZToWaypointY = function worldZToWaypointY(position) {
    var graphY = Math.round(position + height / 2);
    return Math.min(Math.max(graphY, 4), height - 5);
  };

  var area = {
    id: areaId,
    waypointXToWorldX: waypointXToWorldX,
    waypointYToWorldZ: waypointYToWorldZ,
    worldXToWaypointX: worldXToWaypointX,
    worldZToWaypointY: worldZToWaypointY,
    width: width,
    height: height
  };
  return map(area);
};

var AreaSizes = {
  FLOOR_0: {
    width: 150,
    height: 150
  },
  FLOOR_1: {
    width: 270,
    height: 270
  },
  FLOOR_2: {
    width: 270,
    height: 270
  }
};
var Areas = {
  FLOOR_0: buildArea('FLOOR_0', function (area) {
    return _objectSpread(_objectSpread({}, area), {}, {
      includesPosition: function includesPosition(position) {
        return position.y < 100;
      },
      getWorldWaypointByXY: function getWorldWaypointByXY(x, y) {
        return {
          x: area.waypointXToWorldX(x),
          y: 0.2,
          z: area.waypointYToWorldZ(y)
        };
      },
      getWaypointPortals: function getWaypointPortals() {
        return [{
          from: {
            x: area.worldXToWaypointX(-49),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-49),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_1'
          }
        }, {
          from: {
            x: area.worldXToWaypointX(-49),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-49),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_2'
          }
        }];
      }
    });
  }),
  FLOOR_1: buildArea('FLOOR_1', function (area) {
    return _objectSpread(_objectSpread({}, area), {}, {
      includesPosition: function includesPosition(position) {
        return position.y < 200;
      },
      getWorldWaypointByXY: function getWorldWaypointByXY(x, y) {
        return {
          x: area.waypointXToWorldX(x),
          y: 100.2,
          z: area.waypointYToWorldZ(y)
        };
      },
      getWaypointPortals: function getWaypointPortals() {
        return [{
          from: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_0'
          }
        }, {
          from: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_2'
          }
        }];
      }
    });
  }),
  FLOOR_2: buildArea('FLOOR_2', function (area) {
    return _objectSpread(_objectSpread({}, area), {}, {
      includesPosition: function includesPosition(position) {
        return position.y >= 200;
      },
      getWorldWaypointByXY: function getWorldWaypointByXY(x, y) {
        return {
          x: area.waypointXToWorldX(x),
          y: 200.2,
          z: area.waypointYToWorldZ(y)
        };
      },
      getWaypointPortals: function getWaypointPortals() {
        return [{
          from: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_0'
          }
        }, {
          from: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0)
          },
          to: {
            x: area.worldXToWaypointX(-48),
            y: area.worldZToWaypointY(0),
            areaId: 'FLOOR_1'
          }
        }];
      }
    });
  })
};
/* harmony default export */ __webpack_exports__["default"] = (Areas);

/***/ }),

/***/ "../client/src/js/Locations/DreamTown/Elevator.js":
/*!********************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/Elevator.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Elevator; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Elevator = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Elevator, _AutoBindMethods);

  var _super = _createSuper(Elevator);

  function Elevator(scene, params) {
    var _this;

    _classCallCheck(this, Elevator);

    _this = _super.call(this);
    _this.scene = scene;
    _this.params = params;
    _this.currentFloor = 1;
    _this.target = 0;
    _this.direction = -1;
    _this.speed = 0.3;
    _this.standTime = 10;
    _this.object = _this.scene.models.createCube(params);
    _this.standAt = _this.scene.intervals.getTimePassed();
    return _this;
  }

  _createClass(Elevator, [{
    key: "isReleased",
    value: function isReleased() {
      return this.scene.intervals.getTimePassed() - this.standAt > this.standTime * 1000;
    }
  }, {
    key: "isCarrying",
    value: function isCarrying(_ref) {
      var x = _ref.x,
          y = _ref.y,
          z = _ref.z;
      var _this$object = this.object,
          position = _this$object.position,
          scale = _this$object.scale;
      return Math.abs(x - position.x) < scale.x / 2 && Math.abs(z - position.z) < scale.z / 2 && y - position.y < scale.y / 2 // && (y + 1.7) - position.y > -scale.y / 2
      ;
    }
  }, {
    key: "getFloor",
    value: function getFloor() {
      return this.direction > 0 ? this.object.position.y >= 200 && 2 || this.object.position.y >= 100 && 1 || 0 : this.object.position.y > 100 && 2 || this.object.position.y > 0 && 1 || 0;
    }
  }, {
    key: "update",
    value: function update() {
      var _this2 = this;

      if (this.isReleased()) {
        var floor = this.getFloor();

        if (floor !== this.currentFloor) {
          this.standAt = this.scene.intervals.getTimePassed();
          this.currentFloor = floor;

          if (floor === 2) {
            this.direction = -1;
          } else if (floor === 0) {
            this.direction = 1;
          }

          this.target = floor + this.direction;
        } else {
          var getCarryingPosition = function getCarryingPosition(unit) {
            return _objectSpread(_objectSpread({}, unit.position), {}, {
              y: unit.position.y - (_this2.direction > 0 ? 2 : 0.1)
            });
          };

          var carryingUnits = this.scene.gameObjectsService.getUnits().filter(function (unit) {
            return _this2.isCarrying(getCarryingPosition(unit));
          });
          var thisAcceleration = this.speed * this.direction;
          carryingUnits.forEach(function (unit) {
            unit.position.y += thisAcceleration;
          });
          this.object.position.y += thisAcceleration;
        }
      }
    }
  }]);

  return Elevator;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Locations/DreamTown/Environment.js":
/*!***********************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/Environment.js ***!
  \***********************************************************/
/*! exports provided: createEnvironment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEnvironment", function() { return createEnvironment; });
var createEnvironment = function createEnvironment(_ref) {
  var load = _ref.load,
      trees = _ref.trees,
      houses = _ref.houses,
      addColliderFunction = _ref.addColliderFunction,
      onLoad = _ref.onLoad;
  var pivot = new THREE.Object3D();
  pivot.matrixAutoUpdate = false;
  pivot.name = 'LEVEL_ENVIRONMENT';
  var isEnvironmentLoaded = false;
  var isTreeLoaded = false;
  var isHouseLoaded = false;

  var checkIsAllLoaded = function checkIsAllLoaded() {
    if (isEnvironmentLoaded && isTreeLoaded && isHouseLoaded) {
      onLoad && onLoad();
    }
  };

  load({
    baseUrl: './assets/models/environment/enviroment',
    noScene: true,
    castShadow: false,
    callback: function callback(object) {
      pivot.add(object.scene);
      object.scene.matrixAutoUpdate = false;
      object.scene.updateMatrix();
      isEnvironmentLoaded = true;
      checkIsAllLoaded();
    }
  });
  load({
    baseUrl: './assets/models/environment/tree',
    noScene: true,
    receiveShadow: false,
    callback: function callback(loadedModel) {
      isTreeLoaded = true;
      checkIsAllLoaded();
      trees.forEach(function (position) {
        var model = loadedModel.scene.clone();
        model.name = 'Tree';
        model.position.set(position.x, position.y, position.z);
        model.matrixAutoUpdate = false;
        model.updateMatrix();
        var _model$position = model.position,
            x = _model$position.x,
            z = _model$position.z;
        addColliderFunction(function (position) {
          return Math.abs(position.x - x) < 2 && Math.abs(position.z - z) < 2;
        });
        pivot.add(model);
      });
    }
  });
  load({
    baseUrl: './assets/models/environment/house1',
    receiveShadow: false,
    noScene: true,
    callback: function callback(loadedModel) {
      isHouseLoaded = true;
      checkIsAllLoaded();
      houses.forEach(function (position) {
        var model = loadedModel.scene.clone();
        model.name = 'House1';
        model.position.set(position.x, position.y, position.z);
        model.rotation.set(position.rx || 0, position.ry || 0, position.rz || 0);
        model.matrixAutoUpdate = false;
        model.updateMatrix();
        var _model$position2 = model.position,
            x = _model$position2.x,
            z = _model$position2.z;
        addColliderFunction(function (unitPosition) {
          return Math.abs(unitPosition.x - x) < (position.ry < -3.13 ? 4 : 3) && Math.abs(unitPosition.z - z) < (position.ry < -3.13 ? 3 : 4);
        });
        pivot.add(model);
      });
    }
  });
  return pivot;
};



/***/ }),

/***/ "../client/src/js/Locations/DreamTown/Location.js":
/*!********************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/Location.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Location; });
/* harmony import */ var _AbstractLocation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AbstractLocation */ "../client/src/js/Locations/AbstractLocation.js");
/* harmony import */ var _GameObjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../GameObjects */ "../client/src/js/GameObjects.js");
/* harmony import */ var _Elevator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Elevator */ "../client/src/js/Locations/DreamTown/Elevator.js");
/* harmony import */ var _Environment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Environment */ "../client/src/js/Locations/DreamTown/Environment.js");
/* harmony import */ var _Areas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Areas */ "../client/src/js/Locations/DreamTown/Areas.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }







var Location = /*#__PURE__*/function (_AbstractLocation) {
  _inherits(Location, _AbstractLocation);

  var _super = _createSuper(Location);

  /**
   * @param {Scene} scene
   */
  function Location(scene) {
    var _this;

    _classCallCheck(this, Location);

    _this = _super.call(this, scene);
    _this.id = 'dream-town';
    _this.shadowLightPosition = new THREE.Vector3(25, 50, 25);

    _this.scene.ui.setLoading(true);

    _this.scene.ui.setPause(true);

    _this.environment = Object(_Environment__WEBPACK_IMPORTED_MODULE_3__["createEnvironment"])({
      load: _this.scene.models.loadGLTF,
      addColliderFunction: _this.scene.colliders.addColliderFunction,
      trees: [{
        x: 0,
        y: 0,
        z: 15
      }, {
        x: 0,
        y: 0,
        z: -15
      }, {
        x: 15,
        y: 0,
        z: 0
      }, {
        x: -15,
        y: 0,
        z: 0
      }, {
        x: 15,
        y: 0,
        z: 15
      }, {
        x: 15,
        y: 0,
        z: -15
      }, {
        x: 30,
        y: 0,
        z: 20
      }, {
        x: 30,
        y: 0,
        z: -20
      }, {
        x: 45,
        y: 0,
        z: -35
      }, {
        x: 45,
        y: 0,
        z: 35
      }],
      houses: [{
        x: 0,
        y: 0,
        z: 40,
        ry: -Math.PI
      }, {
        x: -10,
        y: 0,
        z: 30,
        ry: Math.PI / 2
      }, {
        x: 10,
        y: 0,
        z: 30,
        ry: -Math.PI / 2
      } // { x: 75, y: 100, z: 75 },
      // { x: 75, y: 200, z: 75 },
      ],
      onLoad: function onLoad() {
        _this.scene.ui.setLoading(false);

        _this.scene.ui.setPause(false);

        _this.scene.notify('Dream Town');

        _this.startLocation();
      }
    });
    _this.ambientLight = _this.createAmbientLight();
    _this.shadowLight = _this.createShadowLight();

    _this.scene.add(_this.environment);

    _this.scene.add(_this.ambientLight);

    _this.scene.add(_this.shadowLight);

    _this.elevator = new _Elevator__WEBPACK_IMPORTED_MODULE_2__["default"](scene, {
      position: {
        x: -48,
        y: 100,
        z: 0
      },
      x: 4,
      y: 1,
      z: 4
    });
    var color = 0x000000;
    var near = 10;
    var far = 100;
    _this.scene.scene.fog = new THREE.Fog(color, near, far);

    _this.createLocationColliders();

    return _this;
  }

  _createClass(Location, [{
    key: "update",
    value: function update() {
      _get(_getPrototypeOf(Location.prototype), "update", this).call(this);

      var player = this.scene.getPlayer();

      if (player) {
        this.elevator.update();
        this.shadowLight.position.copy(player.position).add(this.shadowLightPosition);

        if (this.shadowLight.target !== player.object) {
          this.shadowLight.target = player.object;
        }
      }
    }
  }, {
    key: "reviveHero",
    value: function reviveHero() {
      var player = this.scene.getPlayer();
      player.params.hp = 10;
      player.position.set(0, 0.3, 30);
      player.animationState.isDie = false;
      this.scene.particles.createEffect({
        effect: 'level-up/level-up',
        scale: 1.5,
        attachTo: player.object
      });
    }
  }, {
    key: "afterClear",
    value: function afterClear() {
      var _this2 = this;

      this.scene.units.createPlayer({
        /**
         * @param {Player} player
         */
        onCreate: function onCreate(player) {
          _this2.scene.camera.player = player;

          _this2.scene.ui.updatePlayerParams();

          player.position.set(0, 0.3, 30);
        },
        onDie: function onDie() {
          return window.setTimeout(function () {
            _this2.scene.ui.setPause(true);
          }, 2500);
        },
        onKill: function onKill(object) {
          var player = _this2.scene.getPlayer();

          player.addExperience(object.params.bounty);
          player.addMoney(object.params.bounty);
        },
        onDamageTaken: function onDamageTaken() {
          return _this2.scene.ui.updatePlayerParams();
        },
        onLocationUp: function onLocationUp() {
          return _this2.scene.ui.updatePlayerParams();
        }
      });
      this.createInteractiveGameObjects();
    }
  }, {
    key: "startLocation",
    value: function startLocation() {
      if (this.interval) {
        clearInterval(this.interval);
      }
    }
  }, {
    key: "restartLocation",
    value: function restartLocation() {
      this.scene.clearScene();
    }
  }, {
    key: "stopLocation",
    value: function stopLocation() {
      this.scene.remove(this.environment); // this.scene.remove(this.skybox);

      this.scene.remove(this.ambientLight);
      this.scene.remove(this.shadowLight);
      this.scene.gameObjectsService.removeAllExceptPlayer();

      if (this.interval) {
        clearInterval(this.interval);
      }
    }
  }, {
    key: "createInteractiveGameObjects",
    value: function createInteractiveGameObjects() {
      var _this3 = this;

      var createHealItem = function createHealItem() {
        return _this3.scene.intervals.setTimeout(function () {
          var itemHealPosition = new THREE.Vector3(-6.5, 0.1, 32.8);

          _this3.scene.gameObjectsService.createItem({
            model: 'item-heal',
            position: itemHealPosition,
            canPickup: function canPickup(unit) {
              return unit.getMaxHP() - unit.getHP() > 0;
            },
            onPickup: function onPickup(unit) {
              unit.addHP(25);
              createHealItem();
            }
          });
        }, 10000);
      };

      createHealItem();

      var getAIParams = function getAIParams(_ref) {
        var level = _ref.level,
            params = _objectWithoutProperties(_ref, ["level"]);

        return _objectSpread(_objectSpread({}, params), {}, {
          level: level,
          scale: 0.7 + level / 10,
          onDie: function onDie() {
            return _this3.scene.units.createAI(getAIParams(_objectSpread(_objectSpread({}, params), {}, {
              level: level + 1 + Math.round(Math.random() * level)
            })));
          }
        });
      };

      var getGoatsParams = function getGoatsParams(level, position) {
        return getAIParams({
          level: level,
          position: position,
          fraction: 'goats',
          name: level <= 10 ? 'Goat Warrior' : level <= 20 ? 'Goat Elite' : 'Goat Destroyer'
        });
      };

      var getFriendlyParams = function getFriendlyParams(level, position, rotation) {
        return getAIParams({
          level: level,
          position: position,
          rotation: rotation,
          fraction: 'friendly',
          name: 'Friendly Citizen'
        });
      };

      this.units = [getGoatsParams(3, {
        x: -17,
        y: 0.2,
        z: -5
      }), getGoatsParams(3, {
        x: 17,
        y: 0.2,
        z: -5
      }), getGoatsParams(2, {
        x: -15,
        y: 0.2,
        z: -30
      }), getGoatsParams(2, {
        x: 15,
        y: 0.2,
        z: -30
      }), getGoatsParams(5, {
        x: -30,
        y: 0.2,
        z: -9
      }), getGoatsParams(5, {
        x: 30,
        y: 0.2,
        z: -9
      }), getGoatsParams(4, {
        x: -45,
        y: 0.2,
        z: -30
      }), getGoatsParams(4, {
        x: 45,
        y: 0.2,
        z: -30
      }), getGoatsParams(1, {
        x: 45,
        y: 0.2,
        z: 45
      }), getGoatsParams(1, {
        x: 45,
        y: 0.2,
        z: -45
      }), getGoatsParams(25, {
        x: 0,
        y: 0.2,
        z: 0
      }), getFriendlyParams(5, {
        x: -0.8,
        y: 0.2,
        z: 40 - 4.03
      }, {
        y: Math.PI
      }), getFriendlyParams(5, {
        x: -10 + 3.5,
        y: 0.2,
        z: 29.2
      }, {
        y: Math.PI / 2
      }), getFriendlyParams(5, {
        x: 10 - 3.5,
        y: 0.2,
        z: 30.8
      }, {
        y: -Math.PI / 2
      })].forEach(this.scene.units.createAI);
    }
  }, {
    key: "createLocationColliders",
    value: function createLocationColliders() {
      var _this4 = this;

      var isBetween = function isBetween(v, min, max) {
        return v > min && v < max;
      };

      this.scene.colliders.addColliderFunction(function (position, gameObject) {
        var x = position.x,
            y = position.y,
            z = position.z;
        var absX = Math.abs(x);
        var absZ = Math.abs(z);

        if (y < 0.1 && absX < 50 && absZ < 50 || // floor 0
        y < (absX - 50) / 1.5 && absX > 50 || y < (absZ - 50) / 1.5 && absZ > 50 // out of floor 0
        || y < 90 && absX > 96 && absZ > 96 // out of floor 0
        || isBetween(y, 90, 100) && (absX > 50 || absZ > 50) // floor 1
        || isBetween(y, 90, 190) && (absX > 135 || absZ > 135) // out of floor 1
        || isBetween(y, 190, 200) && (absX > 50 || absZ > 50) // floor 2
        || y > 190 && (absX > 133 || absZ > 133) // out of floor 2
        || _this4.elevator.isCarrying(position)) {
          return true;
        } // TODO: Check if we need units colliders
        // const units = this.scene.units.getAliveUnits();
        //
        // for(let unit of units) {
        //     if (
        //         unit !== gameObject
        //         && (
        //             !(gameObject instanceof Fire)
        //             || gameObject.params.parent !== unit
        //         )
        //         && unit.getCollider(position)
        //     ) {
        //         return true;
        //     }
        // }


        return false;
      });
    }
  }, {
    key: "getAreas",
    value: function getAreas() {
      var _this5 = this;

      var areas = Object.values(_Areas__WEBPACK_IMPORTED_MODULE_4__["default"]);

      var generateWaypoints = function generateWaypoints(width, height, map) {
        return new Array(width).fill(null).map(function (null1, x) {
          return new Array(height).fill(null).map(function (null2, y) {
            return map(x, y);
          });
        });
      };

      return areas.map(function (area) {
        var result = _objectSpread({}, area);

        result.getWaypoints = function () {
          return generateWaypoints(area.width, area.height, function (x, y) {
            if ( // Elevator
            Math.abs(area.waypointXToWorldX(x) - _this5.elevator.params.position.x) <= 5 && Math.abs(area.waypointYToWorldZ(y) - _this5.elevator.params.position.z) <= 1) {
              return 1;
            }

            if (area.id !== 'FLOOR_0' && ( // Center hole
            Math.abs(area.waypointXToWorldX(x)) < 51 && Math.abs(area.waypointYToWorldZ(y)) < 51 || Math.abs(area.waypointXToWorldX(x)) <= 51 && Math.abs(area.waypointYToWorldZ(y)) <= 51 && Math.abs(area.waypointXToWorldX(x)) >= 50 && Math.abs(area.waypointYToWorldZ(y)) >= 50)) {
              return 0;
            }

            if (area.id === 'FLOOR_0' && ( // Floor out
            Math.abs(area.waypointXToWorldX(x)) >= 49 || Math.abs(area.waypointYToWorldZ(y)) >= 49)) {
              return 1;
            }

            return Number(_this5.checkWayForWaypoint(area.getWorldWaypointByXY(x, y)));
          });
        };

        return result;
      });
    }
  }, {
    key: "checkWayForWaypoint",
    value: function checkWayForWaypoint(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          z = _ref2.z;
      var checkWay = this.scene.colliders.checkWay;

      var checkNear = function checkNear(range, diagonal) {
        return checkWay(new THREE.Vector3(x + range, y, z)) && checkWay(new THREE.Vector3(x - range, y, z)) && checkWay(new THREE.Vector3(x, y, z + range)) && checkWay(new THREE.Vector3(x, y, z - range)) && (!diagonal || checkWay(new THREE.Vector3(x + range, y, z + range)) && checkWay(new THREE.Vector3(x - range, y, z - range)) && checkWay(new THREE.Vector3(x - range, y, z + range)) && checkWay(new THREE.Vector3(x + range, y, z - range)));
      };

      return checkWay(new THREE.Vector3(x, y, z)) && checkNear(1, true) && checkNear(2);
    }
  }]);

  return Location;
}(_AbstractLocation__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Locations/DreamTown/index.js":
/*!*****************************************************!*\
  !*** ../client/src/js/Locations/DreamTown/index.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Location__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Location */ "../client/src/js/Locations/DreamTown/Location.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _Location__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/***/ }),

/***/ "../client/src/js/Models.js":
/*!**********************************!*\
  !*** ../client/src/js/Models.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Models; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var Models = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Models, _AutoBindMethods);

  var _super = _createSuper(Models);

  function Models(scene) {
    var _this;

    _classCallCheck(this, Models);

    _this = _super.call(this);
    _this.scene = scene;
    return _this;
  }
  /**
   * @param {Object} params
   * @param {number} params.repeatX
   * @param {number} params.repeatY
   * @param {number} params.emissive
   * @param {THREE.Vector3} params.position
   * @returns {THREE.Mesh}
   */


  _createClass(Models, [{
    key: "createCube",
    value: function createCube(params) {
      params = params || {};
      var materialParams = {};

      if (params.image) {
        var texture = new THREE.TextureLoader().load(params.image);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(params.repeatX || 1, params.repeatY || 1);
        materialParams.map = texture;
      }

      if (params.emissive) {
        materialParams.emissive = new THREE.Color(params.emissive);
        materialParams.emissiveIntensity = 1.0;
        materialParams.emissiveMap = null;
      }

      var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1), new THREE.MeshLambertMaterial(materialParams));
      cube.scale.set(params.x || 1, params.y || 1, params.z || 1);

      if (params.position) {
        cube.position.set(params.position.x || 0, params.position.y || 0, params.position.z || 0);
      }

      if (params.rotation) {
        cube.rotation.set(params.rotation.x || 0, params.rotation.y || 0, params.rotation.z || 0);
      }

      if (!params.noScene) {
        this.scene.add(cube);
      }

      return cube;
    }
  }, {
    key: "loadGLTF",
    value: function loadGLTF(_ref) {
      var _this2 = this;

      var baseUrl = _ref.baseUrl,
          _ref$isGLTF = _ref.isGLTF,
          isGLTF = _ref$isGLTF === void 0 ? false : _ref$isGLTF,
          _ref$noScene = _ref.noScene,
          noScene = _ref$noScene === void 0 ? false : _ref$noScene,
          _ref$callback = _ref.callback,
          callback = _ref$callback === void 0 ? function () {
        return null;
      } : _ref$callback,
          _ref$castShadow = _ref.castShadow,
          castShadow = _ref$castShadow === void 0 ? true : _ref$castShadow,
          _ref$receiveShadow = _ref.receiveShadow,
          receiveShadow = _ref$receiveShadow === void 0 ? true : _ref$receiveShadow;
      var loader = new GLTFLoader();
      var url = "".concat(baseUrl, ".glb").concat(isGLTF ? '.gltf' : '');
      loader.load(url, function (loadedModel) {
        loadedModel.scene.traverse(function (child) {
          if (child instanceof THREE.Mesh) {
            child.castShadow = castShadow;
            child.receiveShadow = receiveShadow;
          }
        });
        callback(loadedModel);

        if (!noScene) {
          _this2.scene.add(loadedModel.scene);
        }
      });
    }
  }]);

  return Models;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Particles.js":
/*!*************************************!*\
  !*** ../client/src/js/Particles.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Particles; });
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scene */ "../client/src/js/Scene.js");
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameObjects/AnimatedGameObject */ "../client/src/js/GameObjects/AnimatedGameObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var Particles = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Particles, _AutoBindMethods);

  var _super = _createSuper(Particles);

  /**
   * @param {Scene} scene
   */
  function Particles(scene) {
    var _this;

    _classCallCheck(this, Particles);

    _this = _super.call(this);
    _this.scene = scene;
    _this.particles = [];
    return _this;
  }

  _createClass(Particles, [{
    key: "update",
    value: function update() {
      this.particles.forEach(function (p) {
        return p.update();
      });
    }
  }, {
    key: "createSnow",
    value: function createSnow() {
      var _this2 = this;

      var area = new THREE.Vector3(100, 25, 100);
      this.createParticles({
        particleCount: 10000,
        color: 0x888888,
        blending: THREE.NormalBlending,
        position: new THREE.Vector3(-area.x / 2, 0, -area.z / 2),
        getParticlePosition: function getParticlePosition(i) {
          var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this2.getRandomPosition(area);

          if (position.y < 0) {
            var newPosition = _this2.getRandomPosition(area);

            position.x = newPosition.x;
            position.y = area.y;
            position.z = newPosition.z;
          }

          return position;
        }
      });
    }
  }, {
    key: "createEffect",
    value: function createEffect(_ref) {
      var _this3 = this;

      var _ref$scale = _ref.scale,
          scale = _ref$scale === void 0 ? 1.5 : _ref$scale,
          _ref$effect = _ref.effect,
          effect = _ref$effect === void 0 ? 'level-up-alt/level-up' : _ref$effect,
          _ref$position = _ref.position,
          position = _ref$position === void 0 ? {} : _ref$position,
          attachTo = _ref.attachTo,
          _ref$lifeTime = _ref.lifeTime,
          lifeTime = _ref$lifeTime === void 0 ? 2080 : _ref$lifeTime;
      this.scene.models.loadGLTF({
        baseUrl: './assets/models/effects/' + effect,
        noScene: true,
        castShadow: false,
        receiveShadow: false,
        callback: function callback(loadedObject) {
          loadedObject.scene.scale.set(scale, scale, scale);
          loadedObject.scene.traverse(function (child) {
            if (child.isMesh) {
              child.material.transparent = true;
              child.material.alphaTest = 0.5;
            }
          });
          loadedObject.scene.position.set(position.x || 0, position.y || 0, position.z || 0);

          if (attachTo) {
            attachTo.add(loadedObject.scene);
          }

          var effect = new _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_2__["default"]({
            object: loadedObject.scene,
            animations: loadedObject.animations
          });

          _this3.scene.gameObjectsService.hookGameObject(effect);

          _this3.scene.intervals.setTimeout(function () {
            return _this3.scene.gameObjectsService.destroyGameObject(effect);
          }, lifeTime);
        }
      });
    }
  }, {
    key: "loadEffect",
    value: function loadEffect() {
      var _this4 = this;

      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$particleName = _ref2.particleName,
          particleName = _ref2$particleName === void 0 ? 'blood' : _ref2$particleName,
          _ref2$position = _ref2.position,
          position = _ref2$position === void 0 ? new THREE.Vector3() : _ref2$position,
          _ref2$scale = _ref2.scale,
          scale = _ref2$scale === void 0 ? new THREE.Vector3(1, 1, 1) : _ref2$scale;

      var gameObjectsService = this.scene.gameObjectsService;
      return this.scene.models.loadGLTF({
        baseUrl: "./assets/models/effects/".concat(particleName),
        castShadow: false,
        receiveShadow: false,
        callback: function callback(gltf) {
          gltf.scene.position.copy(position);
          gltf.scene.scale.copy(scale);
          gltf.scene.rotation.set(0, Math.random() * Math.PI, 0);
          var particleSystem = gameObjectsService.hookGameObject(new _GameObjects_AnimatedGameObject__WEBPACK_IMPORTED_MODULE_2__["default"]({
            object: gltf.scene,
            animations: gltf.animations
          }));

          _this4.scene.intervals.setTimeout(function () {
            return _this4.scene.gameObjectsService.destroyGameObject(particleSystem);
          }, 625);
        }
      });
    }
  }, {
    key: "getRandomPosition",
    value: function getRandomPosition(area) {
      var random = function random(from, to) {
        return Math.random() * (to - from) + from;
      };

      return new THREE.Vector3(random(0, area.x), random(0, area.y), random(0, area.z));
    }
  }, {
    key: "createParticles",
    value: function createParticles() {
      var _this5 = this;

      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$particleCount = _ref3.particleCount,
          particleCount = _ref3$particleCount === void 0 ? 1000 : _ref3$particleCount,
          _ref3$noScene = _ref3.noScene,
          noScene = _ref3$noScene === void 0 ? false : _ref3$noScene,
          _ref3$position = _ref3.position,
          position = _ref3$position === void 0 ? new THREE.Vector3(0, 5, 0) : _ref3$position,
          _ref3$size = _ref3.size,
          size = _ref3$size === void 0 ? 0.01 : _ref3$size,
          _ref3$color = _ref3.color,
          color = _ref3$color === void 0 ? 0xFFFFFF : _ref3$color,
          _ref3$blending = _ref3.blending,
          blending = _ref3$blending === void 0 ? THREE.AdditiveBlending : _ref3$blending,
          _ref3$depthTest = _ref3.depthTest,
          depthTest = _ref3$depthTest === void 0 ? true : _ref3$depthTest,
          _ref3$transparent = _ref3.transparent,
          transparent = _ref3$transparent === void 0 ? true : _ref3$transparent,
          _ref3$area = _ref3.area,
          area = _ref3$area === void 0 ? new THREE.Vector3(10, 5, 10) : _ref3$area,
          _ref3$getParticleVelo = _ref3.getParticleVelocity,
          getParticleVelocity = _ref3$getParticleVelo === void 0 ? function () {
        return new THREE.Vector3(-0.01, -0.01, 0);
      } : _ref3$getParticleVelo,
          _ref3$getParticlePosi = _ref3.getParticlePosition,
          getParticlePosition = _ref3$getParticlePosi === void 0 ? function (i) {
        var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this5.getRandomPosition(area);
        return position;
      } : _ref3$getParticlePosi;

      var particles = new THREE.Geometry();
      var material = new THREE.PointCloudMaterial({
        color: color,
        size: size,
        blending: blending,
        depthTest: depthTest,
        transparent: transparent
      });

      for (var i = 0; i < particleCount; i++) {
        var particle = getParticlePosition(i);
        particles.velocity = getParticleVelocity(i, particle);
        particles.vertices.push(particle);
      }

      var particleSystem = new THREE.PointCloud(particles, material);
      particleSystem.position.copy(position);
      this.particles.push({
        object: particleSystem,
        update: function update() {
          var index = particleCount;

          while (index--) {
            var _particle = particles.vertices[index];
            _particle.velocity = getParticleVelocity(index, _particle);
            _particle.x += _particle.velocity.x;
            _particle.y += _particle.velocity.y;
            _particle.z += _particle.velocity.z;
            var particlePosition = getParticlePosition(index, _particle);
            _particle.x = particlePosition.x;
            _particle.y = particlePosition.y;
            _particle.z = particlePosition.z;
          }

          particles.verticesNeedUpdate = true;
        }
      });

      if (!noScene) {
        this.scene.add(particleSystem);
      }

      return particleSystem;
    }
  }]);

  return Particles;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "../client/src/js/PathFinder.js":
/*!**************************************!*\
  !*** ../client/src/js/PathFinder.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Colliders; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _Utils_AStar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils/AStar */ "../client/src/js/Utils/AStar.js");
/* harmony import */ var _Utils_AStar__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Utils_AStar__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Colliders = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Colliders, _AutoBindMethods);

  var _super = _createSuper(Colliders);

  function Colliders(scene) {
    var _this;

    _classCallCheck(this, Colliders);

    _this = _super.call(this);
    _this.scene = scene;
    _this.areas = [];
    return _this;
  }

  _createClass(Colliders, [{
    key: "getNextPoint",
    value: function getNextPoint(from, to) {
      var area = this.getAreaByPosition(from),
          fromX = area.worldXToWaypointX(from.x),
          fromY = area.worldZToWaypointY(from.z),
          areaTo = this.getAreaByPosition(to);
      var toX;
      var toY;
      var portal;

      if (area.id === areaTo.id) {
        toX = area.worldXToWaypointX(to.x);
        toY = area.worldZToWaypointY(to.z);
      } else {
        portal = area.getWaypointPortals().find(function (portal) {
          return portal.to.areaId === areaTo.id;
        });

        if (portal) {
          toX = portal.from.x;
          toY = portal.from.y;
        } else {
          return to;
        }
      }

      var start = this.getFreeGraphPoint(area.graph, fromX, fromY);
      var end = this.getFreeGraphPoint(area.graph, toX, toY);

      if (start && end) {
        var result = _Utils_AStar__WEBPACK_IMPORTED_MODULE_1___default.a.astar.search(area.graph, start, end, {
          heuristic: _Utils_AStar__WEBPACK_IMPORTED_MODULE_1___default.a.astar.heuristics.diagonal
        });
        var nextGraphPoint = result[2] || result[1];

        if (nextGraphPoint) {
          var nextWorldPoint = new THREE.Vector3(area.waypointXToWorldX(nextGraphPoint.x), to.y, area.waypointYToWorldZ(nextGraphPoint.y));
          return nextWorldPoint;
        } else {
          return null;
        }
      }

      return to;
    }
  }, {
    key: "getFreeGraphPoint",
    value: function getFreeGraphPoint(graph, x, y) {
      var grid = graph.grid;

      var getWeight = function getWeight(x, y) {
        return grid[x] && grid[x][y] && grid[x][y].weight;
      };

      var getNearFreePoint = function getNearFreePoint(range) {
        return getWeight(x + range, y) && grid[x + range][y] || getWeight(x - range, y) && grid[x - range][y] || getWeight(x, y + range) && grid[x][y + range] || getWeight(x, y - range) && grid[x][y - range];
      };

      return getWeight(grid[x][y]) && grid[x][y] || getNearFreePoint(1) || getNearFreePoint(2) || getNearFreePoint(3) || getNearFreePoint(4) || null;
    }
  }, {
    key: "rebuildAreas",
    value: function rebuildAreas() {
      if (this.scene.location) {
        this.areas = this.scene.location.getAreas().map(function (area) {
          return _objectSpread(_objectSpread({}, area), {}, {
            graph: new _Utils_AStar__WEBPACK_IMPORTED_MODULE_1___default.a.Graph(area.getWaypoints(), {
              diagonal: true
            })
          });
        });
      }
    }
  }, {
    key: "getAreaByPosition",
    value: function getAreaByPosition(position) {
      return this.areas.find(function (area) {
        return area.includesPosition(position);
      });
    }
  }]);

  return Colliders;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Scene.js":
/*!*********************************!*\
  !*** ../client/src/js/Scene.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Scene; });
/* harmony import */ var _GameObjects__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameObjects */ "../client/src/js/GameObjects.js");
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Camera */ "../client/src/js/Camera.js");
/* harmony import */ var _Connection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Connection */ "../client/src/js/Connection.js");
/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Input */ "../client/src/js/Input.js");
/* harmony import */ var _Intervals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Intervals */ "../client/src/js/Intervals.js");
/* harmony import */ var _Locations_DreamTown__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Locations/DreamTown */ "../client/src/js/Locations/DreamTown/index.js");
/* harmony import */ var _Colliders__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Colliders */ "../client/src/js/Colliders.js");
/* harmony import */ var _Models__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Models */ "../client/src/js/Models.js");
/* harmony import */ var _Particles__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Particles */ "../client/src/js/Particles.js");
/* harmony import */ var _PathFinder__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PathFinder */ "../client/src/js/PathFinder.js");
/* harmony import */ var _Units__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Units */ "../client/src/js/Units.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

 // import Audio from './Audio';














var Scene = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Scene, _AutoBindMethods);

  var _super = _createSuper(Scene);

  /**
   * @param {Renderer} renderer
   * @param {{
   *  setRestartButtonVisible: function,
   *  setPause: function,
   *  restartGame: function,
   *  isPause: function,
   *  isThirdPerson: function,
   *  update: function,
   *  updatePlayerParams: function,
   *  clearHpBars: function,
   *  switchCamera: function,
   *  setFps: function,
   *  notify: function,
   * }} ui
   */
  function Scene(renderer, ui) {
    var _this;

    _classCallCheck(this, Scene);

    _this = _super.call(this);
    _this.clock = new THREE.Clock();
    _this.intervals = new _Intervals__WEBPACK_IMPORTED_MODULE_5__["default"](_assertThisInitialized(_this));
    _this.renderer = renderer;
    _this.ui = ui;
    _this.models = new _Models__WEBPACK_IMPORTED_MODULE_8__["default"](_assertThisInitialized(_this));
    _this.scene = new THREE.Scene();
    _this.pathFinder = new _PathFinder__WEBPACK_IMPORTED_MODULE_10__["default"](_assertThisInitialized(_this));
    _this.colliders = new _Colliders__WEBPACK_IMPORTED_MODULE_7__["default"](_assertThisInitialized(_this));
    _this.units = new _Units__WEBPACK_IMPORTED_MODULE_11__["default"](_assertThisInitialized(_this));
    _this.camera = new _Camera__WEBPACK_IMPORTED_MODULE_2__["default"](_assertThisInitialized(_this)); // this.audio = new Audio(this);

    _this.input = new _Input__WEBPACK_IMPORTED_MODULE_4__["default"]({
      onAction: function onAction() {
        return _this.level.onAction();
      },
      onExit: function onExit() {
        return _this.ui.setPause(!_this.ui.isPause());
      },
      onZoom: function onZoom(zoom) {
        return _this.camera.addY(zoom);
      },
      onSwitchCamera: function onSwitchCamera() {
        return _this.ui.switchCamera();
      }
    });
    _this.gameObjectsService = new _GameObjects__WEBPACK_IMPORTED_MODULE_0__["default"](_assertThisInitialized(_this));
    _this.particles = new _Particles__WEBPACK_IMPORTED_MODULE_9__["default"](_assertThisInitialized(_this));
    var connectionHostname = window.location.hostname === 'localhost' ? 'localhost' : 'gohtml.ru';
    var isSSL = window.location.hostname !== 'localhost';
    _this.connection = new _Connection__WEBPACK_IMPORTED_MODULE_3__["default"](_assertThisInitialized(_this), connectionHostname, 1337, isSSL);
    _this.location = new _Locations_DreamTown__WEBPACK_IMPORTED_MODULE_6__["default"](_assertThisInitialized(_this));

    _this.intervals.setInterval(function () {
      _this.ui.setFps(_this.renderer.fps, _this.renderer.targetFps);

      _this.ui.setPing(_this.connection.ping);

      _this.ui.updatePlayerParams();
    }, 1000);

    _this.input.isThirdPerson = ui.isThirdPerson();

    _this.pathFinder.rebuildAreas();

    _this.clearScene();

    _this.animate(); // console.log('Scene', this);


    return _this;
  }

  _createClass(Scene, [{
    key: "clearScene",
    value: function clearScene() {
      this.gameObjectsService.removeAll();
      this.location.afterClear();
    }
  }, {
    key: "animate",
    value: function animate() {
      var now = Date.now();
      var deltaTime = this.intervals.getDeltaTime(now);
      this.intervals.update(now);
      var gameTime = this.intervals.getTimePassed();
      this.gameObjectsService.update(gameTime, deltaTime);

      if (!this.ui.isPause()) {
        this.camera.update(gameTime, deltaTime);
        this.input.update();
      }

      this.ui.update();
      this.location.update();
      this.particles.update();
      this.connection.update(gameTime, deltaTime);
      this.renderer.render(this.scene, this.camera.camera, deltaTime);
      window.requestAnimationFrame(this.animate);
    }
  }, {
    key: "setLoggedUser",
    value: function setLoggedUser(userName, password) {
      this.user = {
        userName: userName,
        password: password
      };
    }
    /**
     * @returns {Player}
     */

  }, {
    key: "getPlayer",
    value: function getPlayer() {
      return this.units.getPlayer();
    }
    /**
     * @param {THREE.Object3D} object
     */

  }, {
    key: "add",
    value: function add(object) {
      this.scene.add(object);
    }
    /**
     * @param {THREE.Object3D} object
     */

  }, {
    key: "remove",
    value: function remove(object) {
      this.scene.remove(object);
    }
  }, {
    key: "notify",
    value: function notify(text) {
      this.ui.notify(text);
    }
  }]);

  return Scene;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "../client/src/js/Units.js":
/*!*********************************!*\
  !*** ../client/src/js/Units.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Units; });
/* harmony import */ var _AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoBindMethods */ "../client/src/js/AutoBindMethods.js");
/* harmony import */ var _GameObjects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObjects */ "../client/src/js/GameObjects.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Units = /*#__PURE__*/function (_AutoBindMethods) {
  _inherits(Units, _AutoBindMethods);

  var _super = _createSuper(Units);

  function Units(scene) {
    var _this;

    _classCallCheck(this, Units);

    _this = _super.call(this);
    _this.scene = scene;
    _this.player = undefined;
    return _this;
  }

  _createClass(Units, [{
    key: "getUnits",
    value: function getUnits() {
      return this.scene.gameObjectsService.getUnits();
    }
  }, {
    key: "getAliveUnits",
    value: function getAliveUnits() {
      return this.getUnits().filter(function (gameObject) {
        return gameObject.isAlive();
      });
    }
  }, {
    key: "getPlayer",
    value: function getPlayer() {
      return this.player;
    }
  }, {
    key: "setDefaultPlayerParams",
    value: function setDefaultPlayerParams(defaultParams) {
      this.defaultParams = defaultParams;
    }
  }, {
    key: "createPlayer",
    value: function createPlayer() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$onCreate = _ref.onCreate,
          onCreate = _ref$onCreate === void 0 ? function () {
        return null;
      } : _ref$onCreate,
          _ref$onKill = _ref.onKill,
          _onKill = _ref$onKill === void 0 ? function () {
        return null;
      } : _ref$onKill,
          _ref$onDamageDeal = _ref.onDamageDeal,
          _onDamageDeal = _ref$onDamageDeal === void 0 ? function () {
        return null;
      } : _ref$onDamageDeal,
          _ref$onDamageTaken = _ref.onDamageTaken,
          _onDamageTaken = _ref$onDamageTaken === void 0 ? function () {
        return null;
      } : _ref$onDamageTaken,
          _ref$onDie = _ref.onDie,
          _onDie = _ref$onDie === void 0 ? function () {
        return null;
      } : _ref$onDie,
          _ref$onLevelUp = _ref.onLevelUp,
          _onLevelUp = _ref$onLevelUp === void 0 ? function () {
        return null;
      } : _ref$onLevelUp;

      var gameObjectsService = this.scene.gameObjectsService;
      return this.scene.models.loadGLTF({
        baseUrl: './assets/models/units/player',
        callback: function callback(loadedModel) {
          var defaultParams = _this2.defaultParams;
          loadedModel.scene.position.set(0, 0.1, 0);
          /**
           * @type {Player}
           */

          var player = gameObjectsService.hookGameObject(new _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"]({
            animations: loadedModel.animations,
            object: loadedModel.scene,
            input: _this2.scene.input,
            complexAnimations: true,
            checkWay: _this2.scene.colliders.checkWay,
            name: _this2.scene.user ? _this2.scene.user.userName : ' ',
            onDamageDeal: function onDamageDeal(damagedUnit) {
              return _onDamageDeal(damagedUnit);
            },
            onDamageTaken: function onDamageTaken(attacker) {
              _onDamageTaken(attacker);

              _this2.scene.particles.loadEffect({
                position: player.position.clone().add(new THREE.Vector3(0, 0.75, 0))
              });
            },
            onKill: function onKill(object) {
              return _onKill(object);
            },
            onDie: function onDie(killer) {
              return _onDie(killer);
            },
            onLevelUp: function onLevelUp() {
              _this2.scene.particles.createEffect({
                effect: 'level-up-alt/level-up',
                scale: 1.5,
                attachTo: _this2.player.object
              });

              _onLevelUp();
            },
            attack: function attack() {
              return gameObjectsService.attack(player);
            },
            fire: function fire() {
              return gameObjectsService.fire(player);
            },
            destroy: function destroy() {
              return gameObjectsService.destroyGameObject(player);
            }
          }));
          _this2.player = player;
          onCreate(player);

          if (defaultParams && defaultParams.params) {
            var position = defaultParams.position,
                rotation = defaultParams.rotation,
                params = defaultParams.params;
            var playerParams = player.params;
            player.position.set(position.x, position.y, position.z);
            player.rotation.set(rotation.x, rotation.y, rotation.z);
            playerParams.hp = params.hp;
            playerParams.hpMax = params.hpMax;
            playerParams.fraction = params.fraction;
            playerParams.level = params.level;
            playerParams.damage = params.damage;
            playerParams.speed = params.speed;
            playerParams.experience = params.experience;
            playerParams.money = params.money;
            playerParams.unspentTalents = params.unspentTalents;

            if (!playerParams.hp) {
              player.animationState.isDie = true;
            }
          }
        }
      });
    }
  }, {
    key: "createAI",
    value: function createAI(_ref2) {
      var _this3 = this;

      var fraction = _ref2.fraction,
          level = _ref2.level,
          _ref2$position = _ref2.position,
          x = _ref2$position.x,
          y = _ref2$position.y,
          z = _ref2$position.z,
          _ref2$rotation = _ref2.rotation,
          rotation = _ref2$rotation === void 0 ? {} : _ref2$rotation,
          scale = _ref2.scale,
          _onDie2 = _ref2.onDie,
          name = _ref2.name;
      var gameObjectsService = this.scene.gameObjectsService;

      var getPriority = function getPriority(unit, target) {
        return (target instanceof _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"] ? 0.75 : 0) + 1 / Math.ceil(target.position.distanceTo(unit.position));
      };

      this.scene.models.loadGLTF({
        baseUrl: fraction === 'goats' ? './assets/models/units/goat-warrior' : './assets/models/units/enemy',
        callback: function callback(gltf) {
          var networkConnection = _this3.scene.connection;

          if (!networkConnection || !networkConnection.meta || !networkConnection.meta.role || networkConnection.meta.role === 'host') {
            /** @type {AI} */
            var ai = gameObjectsService.hookGameObject(new _GameObjects__WEBPACK_IMPORTED_MODULE_1__["AI"]({
              animations: gltf.animations,
              object: gltf.scene,
              speed: 0.35 + level * 0.025,
              damage: 5 + level * 1.5,
              hp: 70 + level * 30,
              fraction: fraction,
              name: name,
              level: level,
              checkWay: _this3.scene.colliders.checkWay,
              getNextPoint: _this3.scene.pathFinder.getNextPoint,
              attack: function attack() {
                return gameObjectsService.attack(ai);
              },
              onDamageTaken: function onDamageTaken() {
                return _this3.scene.particles.loadEffect({
                  position: ai.position.clone().add(new THREE.Vector3(0, 0.75, 0))
                });
              },
              onDie: function onDie() {
                return _this3.scene.intervals.setTimeout(function () {
                  if (ai.isDead()) {
                    gameObjectsService.destroyGameObject(ai);

                    if (_onDie2) {
                      _onDie2();
                    }
                  }
                }, 10000);
              },
              findTarget: function findTarget() {
                var nearEnemyUnits = _this3.getAliveUnits().filter(function (unit) {
                  return unit !== ai && unit.getFraction() !== fraction && unit.position.distanceTo(ai.position) < 15;
                }).sort(function (unitA, unitB) {
                  return getPriority(ai, unitB) - getPriority(ai, unitA);
                });

                return nearEnemyUnits.length ? nearEnemyUnits[0] : null;
              }
            }));
            ai.position.set(x || 0, y || 0, z || 0);
            ai.rotation.set(rotation.x || 0, rotation.y || 0, rotation.z || 0);

            if (scale) {
              ai.object.scale.set(scale, scale, scale);
            }
          }
        }
      });
    }
  }, {
    key: "createNetworkAI",
    value: function createNetworkAI(_ref3) {
      var _this4 = this;

      var _ref3$params = _ref3.params,
          fraction = _ref3$params.fraction,
          unitNetworkId = _ref3$params.unitNetworkId,
          level = _ref3$params.level,
          name = _ref3$params.name,
          hp = _ref3$params.hp,
          hpMax = _ref3$params.hpMax,
          damage = _ref3$params.damage,
          _ref3$params$fromNetw = _ref3$params.fromNetwork,
          fromNetwork = _ref3$params$fromNetw === void 0 ? true : _ref3$params$fromNetw,
          position = _ref3.position,
          onDie = _ref3.onDie;

      var _callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

      var gameObjectsService = this.scene.gameObjectsService;

      var getPriority = function getPriority(unit, target) {
        return (target instanceof _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"] ? 0.75 : 0) + 1 / Math.ceil(target.position.distanceTo(unit.position));
      };

      return this.scene.models.loadGLTF({
        baseUrl: fraction === 'goats' ? './assets/models/units/goat-warrior' : './assets/models/units/enemy',
        callback: function callback(loadedObject) {
          var ai = gameObjectsService.hookGameObject(new _GameObjects__WEBPACK_IMPORTED_MODULE_1__["AI"]({
            object: loadedObject.scene,
            animations: loadedObject.animations,
            unitNetworkId: unitNetworkId,
            fraction: fraction,
            level: level,
            name: name,
            hp: hp,
            hpMax: hpMax,
            damage: damage,
            fromNetwork: fromNetwork,
            checkWay: _this4.scene.colliders.checkWay,
            getNextPoint: _this4.scene.pathFinder.getNextPoint,
            attack: function attack() {
              return gameObjectsService.attack(ai);
            },
            onDamageTaken: function onDamageTaken() {
              return _this4.scene.particles.loadEffect({
                position: ai.position.clone().add(new THREE.Vector3(0, 0.75, 0))
              });
            },
            onDie: function onDie() {
              return _this4.scene.intervals.setTimeout(function () {
                if (ai.isDead()) {
                  gameObjectsService.destroyGameObject(ai);

                  if (!ai.params.fromNetwork) {
                    _this4.createNetworkAI({
                      fraction: fraction,
                      unitNetworkId: unitNetworkId,
                      name: name,
                      hp: hp,
                      hpMax: hpMax,
                      damage: damage,
                      fromNetwork: false,
                      level: level + 1 + Math.round(Math.random() * level)
                    });
                  }
                }
              }, 10000);
            },
            findTarget: function findTarget() {
              if (!ai.params.fromNetwork) {
                var nearEnemyUnits = _this4.getAliveUnits().filter(function (unit) {
                  return unit !== ai && unit.getFraction() !== fraction && unit.position.distanceTo(ai.position) < 15;
                }).sort(function (unitA, unitB) {
                  return getPriority(ai, unitB) - getPriority(ai, unitA);
                });

                return nearEnemyUnits.length ? nearEnemyUnits[0] : null;
              }
            }
          }));

          _callback(ai);
        }
      });
    }
  }, {
    key: "createNetworkPlayer",
    value: function createNetworkPlayer(_ref4, _callback2) {
      var _this5 = this;

      var _ref4$params = _ref4.params,
          connectionId = _ref4$params.connectionId,
          unitNetworkId = _ref4$params.unitNetworkId,
          name = _ref4$params.name,
          _onDamageDeal2 = _ref4.onDamageDeal,
          _onKill2 = _ref4.onKill,
          _onDie3 = _ref4.onDie,
          _onLevelUp2 = _ref4.onLevelUp,
          _onDamageTaken2 = _ref4.onDamageTaken;
      var gameObjectsService = this.scene.gameObjectsService;
      return this.scene.models.loadGLTF({
        baseUrl: './assets/models/units/network-player',
        callback: function callback(loadedObject) {
          /** @type {Player} */
          var player = gameObjectsService.hookGameObject(new _GameObjects__WEBPACK_IMPORTED_MODULE_1__["Player"]({
            object: loadedObject.scene,
            animations: loadedObject.animations,
            unitNetworkId: unitNetworkId,
            connectionId: connectionId,
            name: name,
            fromNetwork: true,
            complexAnimations: true,
            checkWay: _this5.scene.colliders.checkWay,
            input: {
              vertical: 0,
              horizontal: 0,
              jump: false,
              cursor: {
                x: 0,
                y: 0
              },
              look: {
                vertical: 0,
                horizontal: 0
              }
            },
            onDie: function onDie(killer) {
              return _this5.scene.intervals.setTimeout(function () {
                if (player.isDead()) {
                  gameObjectsService.destroyGameObject(player);
                }

                _onDie3 && _onDie3(killer);
              }, 10000);
            },
            onDamageDeal: function onDamageDeal(damagedUnit) {
              return _onDamageDeal2 && _onDamageDeal2(damagedUnit);
            },
            onDamageTaken: function onDamageTaken(attacker) {
              _onDamageTaken2 && _onDamageTaken2(attacker);

              _this5.scene.particles.loadEffect({
                position: player.position.clone().add(new THREE.Vector3(0, 0.75, 0))
              });
            },
            onKill: function onKill(object) {
              return _onKill2 && _onKill2(object);
            },
            onLevelUp: function onLevelUp() {
              _this5.scene.particles.createEffect({
                effect: 'level-up-alt/level-up',
                scale: 1.5,
                attachTo: _this5.player.object
              });

              _onLevelUp2 && _onLevelUp2();
            },
            attack: function attack() {
              return gameObjectsService.attack(player);
            },
            fire: function fire() {
              return gameObjectsService.fire(player);
            },
            destroy: function destroy() {
              return gameObjectsService.destroyGameObject(player);
            }
          }));

          _callback2(player);
        }
      });
    }
  }]);

  return Units;
}(_AutoBindMethods__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "../client/src/js/Utils/AStar.js":
/*!***************************************!*\
  !*** ../client/src/js/Utils/AStar.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// javascript-astar 0.4.1
// http://github.com/bgrins/javascript-astar
// Freely distributable under the MIT License.
// Implements the astar search algorithm in javascript using a Binary Heap.
// Includes Binary Heap (with modifications) from Marijn Haverbeke.
// http://eloquentjavascript.net/appendix2.html
(function (definition) {
  /* global module, define */
  if (( false ? undefined : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {
    module.exports = definition();
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var exports; }
})(function () {
  function pathTo(node) {
    var curr = node;
    var path = [];

    while (curr.parent) {
      path.unshift(curr);
      curr = curr.parent;
    }

    return path;
  }

  function getHeap() {
    return new BinaryHeap(function (node) {
      return node.f;
    });
  }

  var astar = {
    /**
     * Perform an A* Search on a graph given a start and end node.
     * @param {Graph} graph
     * @param {GridNode} start
     * @param {GridNode} end
     * @param {Object} [options]
     * @param {bool} [options.closest] Specifies whether to return the
     path to the closest node if the target is unreachable.
     * @param {Function} [options.heuristic] Heuristic function (see
     *          astar.heuristics).
     */
    search: function search(graph, start, end, options) {
      graph.cleanDirty();
      options = options || {};
      var heuristic = options.heuristic || astar.heuristics.manhattan;
      var closest = options.closest || false;
      var openHeap = getHeap();
      var closestNode = start; // set the start node to be the closest if required

      start.h = heuristic(start, end);
      graph.markDirty(start);
      openHeap.push(start);

      while (openHeap.size() > 0) {
        // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
        var currentNode = openHeap.pop(); // End case -- result has been found, return the traced path.

        if (currentNode === end) {
          return pathTo(currentNode);
        } // Normal case -- move currentNode from open to closed, process each of its neighbors.


        currentNode.closed = true; // Find all neighbors for the current node.

        var neighbors = graph.neighbors(currentNode);

        for (var i = 0, il = neighbors.length; i < il; ++i) {
          var neighbor = neighbors[i];

          if (neighbor.closed || neighbor.isWall()) {
            // Not a valid node to process, skip to next neighbor.
            continue;
          } // The g score is the shortest distance from start to current node.
          // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.


          var gScore = currentNode.g + neighbor.getCost(currentNode);
          var beenVisited = neighbor.visited;

          if (!beenVisited || gScore < neighbor.g) {
            // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
            neighbor.visited = true;
            neighbor.parent = currentNode;
            neighbor.h = neighbor.h || heuristic(neighbor, end);
            neighbor.g = gScore;
            neighbor.f = neighbor.g + neighbor.h;
            graph.markDirty(neighbor);

            if (closest) {
              // If the neighbour is closer than the current closestNode or if it's equally close but has
              // a cheaper path than the current closest node then it becomes the closest node
              if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
                closestNode = neighbor;
              }
            }

            if (!beenVisited) {
              // Pushing to heap will put it in proper place based on the 'f' value.
              openHeap.push(neighbor);
            } else {
              // Already seen the node, but since it has been rescored we need to reorder it in the heap
              openHeap.rescoreElement(neighbor);
            }
          }
        }
      }

      if (closest) {
        return pathTo(closestNode);
      } // No result was found - empty array signifies failure to find path.


      return [];
    },
    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    heuristics: {
      manhattan: function manhattan(pos0, pos1) {
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return d1 + d2;
      },
      diagonal: function diagonal(pos0, pos1) {
        var D = 1;
        var D2 = Math.sqrt(2);
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
      }
    },
    cleanNode: function cleanNode(node) {
      node.f = 0;
      node.g = 0;
      node.h = 0;
      node.visited = false;
      node.closed = false;
      node.parent = null;
    }
  };
  /**
   * A graph memory structure
   * @param {Array} gridIn 2D array of input weights
   * @param {Object} [options]
   * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed
   */

  function Graph(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];

    for (var x = 0; x < gridIn.length; x++) {
      this.grid[x] = [];

      for (var y = 0, row = gridIn[x]; y < row.length; y++) {
        var node = new GridNode(x, y, row[y]);
        this.grid[x][y] = node;
        this.nodes.push(node);
      }
    }

    this.init();
  }

  Graph.prototype.init = function () {
    this.dirtyNodes = [];

    for (var i = 0; i < this.nodes.length; i++) {
      astar.cleanNode(this.nodes[i]);
    }
  };

  Graph.prototype.cleanDirty = function () {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
      astar.cleanNode(this.dirtyNodes[i]);
    }

    this.dirtyNodes = [];
  };

  Graph.prototype.markDirty = function (node) {
    this.dirtyNodes.push(node);
  };

  Graph.prototype.neighbors = function (node) {
    var ret = [];
    var x = node.x;
    var y = node.y;
    var grid = this.grid; // West

    if (grid[x - 1] && grid[x - 1][y]) {
      ret.push(grid[x - 1][y]);
    } // East


    if (grid[x + 1] && grid[x + 1][y]) {
      ret.push(grid[x + 1][y]);
    } // South


    if (grid[x] && grid[x][y - 1]) {
      ret.push(grid[x][y - 1]);
    } // North


    if (grid[x] && grid[x][y + 1]) {
      ret.push(grid[x][y + 1]);
    }

    if (this.diagonal) {
      // Southwest
      if (grid[x - 1] && grid[x - 1][y - 1]) {
        ret.push(grid[x - 1][y - 1]);
      } // Southeast


      if (grid[x + 1] && grid[x + 1][y - 1]) {
        ret.push(grid[x + 1][y - 1]);
      } // Northwest


      if (grid[x - 1] && grid[x - 1][y + 1]) {
        ret.push(grid[x - 1][y + 1]);
      } // Northeast


      if (grid[x + 1] && grid[x + 1][y + 1]) {
        ret.push(grid[x + 1][y + 1]);
      }
    }

    return ret;
  };

  Graph.prototype.toString = function () {
    var graphString = [];
    var nodes = this.grid;

    for (var x = 0; x < nodes.length; x++) {
      var rowDebug = [];
      var row = nodes[x];

      for (var y = 0; y < row.length; y++) {
        rowDebug.push(row[y].weight);
      }

      graphString.push(rowDebug.join(" "));
    }

    return graphString.join("\n");
  };

  function GridNode(x, y, weight) {
    this.x = x;
    this.y = y;
    this.weight = weight;
  }

  GridNode.prototype.toString = function () {
    return "[" + this.x + " " + this.y + "]";
  };

  GridNode.prototype.getCost = function (fromNeighbor) {
    // Take diagonal weight into consideration.
    if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {
      return this.weight * 1.41421;
    }

    return this.weight;
  };

  GridNode.prototype.isWall = function () {
    return this.weight === 0;
  };

  function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
  }

  BinaryHeap.prototype = {
    push: function push(element) {
      // Add the new element to the end of the array.
      this.content.push(element); // Allow it to sink down.

      this.sinkDown(this.content.length - 1);
    },
    pop: function pop() {
      // Store the first element so we can return it later.
      var result = this.content[0]; // Get the element at the end of the array.

      var end = this.content.pop(); // If there are any elements left, put the end element at the
      // start, and let it bubble up.

      if (this.content.length > 0) {
        this.content[0] = end;
        this.bubbleUp(0);
      }

      return result;
    },
    remove: function remove(node) {
      var i = this.content.indexOf(node); // When it is found, the process seen in 'pop' is repeated
      // to fill up the hole.

      var end = this.content.pop();

      if (i !== this.content.length - 1) {
        this.content[i] = end;

        if (this.scoreFunction(end) < this.scoreFunction(node)) {
          this.sinkDown(i);
        } else {
          this.bubbleUp(i);
        }
      }
    },
    size: function size() {
      return this.content.length;
    },
    rescoreElement: function rescoreElement(node) {
      this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function sinkDown(n) {
      // Fetch the element that has to be sunk.
      var element = this.content[n]; // When at 0, an element can not sink any further.

      while (n > 0) {
        // Compute the parent element's index, and fetch it.
        var parentN = (n + 1 >> 1) - 1;
        var parent = this.content[parentN]; // Swap the elements if the parent is greater.

        if (this.scoreFunction(element) < this.scoreFunction(parent)) {
          this.content[parentN] = element;
          this.content[n] = parent; // Update 'n' to continue at the new position.

          n = parentN;
        } // Found a parent that is less, no need to sink any further.
        else {
            break;
          }
      }
    },
    bubbleUp: function bubbleUp(n) {
      // Look up the target element and its score.
      var length = this.content.length;
      var element = this.content[n];
      var elemScore = this.scoreFunction(element);

      while (true) {
        // Compute the indices of the child elements.
        var child2N = n + 1 << 1;
        var child1N = child2N - 1; // This is used to store the new position of the element, if any.

        var swap = null;
        var child1Score; // If the first child exists (is inside the array)...

        if (child1N < length) {
          // Look it up and compute its score.
          var child1 = this.content[child1N];
          child1Score = this.scoreFunction(child1); // If the score is less than our element's, we need to swap.

          if (child1Score < elemScore) {
            swap = child1N;
          }
        } // Do the same checks for the other child.


        if (child2N < length) {
          var child2 = this.content[child2N];
          var child2Score = this.scoreFunction(child2);

          if (child2Score < (swap === null ? elemScore : child1Score)) {
            swap = child2N;
          }
        } // If the element needs to be moved, swap it, and continue.


        if (swap !== null) {
          this.content[n] = this.content[swap];
          this.content[swap] = element;
          n = swap;
        } // Otherwise, we are done.
        else {
            break;
          }
      }
    }
  };
  return {
    astar: astar,
    Graph: Graph
  };
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../server/node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _standalone_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./standalone-server */ "./standalone-server.js");

/* harmony default export */ __webpack_exports__["default"] = (new _standalone_server__WEBPACK_IMPORTED_MODULE_0__["default"]());

/***/ }),

/***/ "./node_modules/three/src/constants.js":
/*!*********************************************!*\
  !*** ./node_modules/three/src/constants.js ***!
  \*********************************************/
/*! exports provided: REVISION, MOUSE, TOUCH, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, FrontFaceDirectionCW, FrontFaceDirectionCCW, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, SmoothShading, NoColors, FaceColors, VertexColors, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, Uncharted2ToneMapping, CineonToneMapping, ACESFilmicToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, SphericalReflectionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipMapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedInt248Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, RGBEFormat, DepthFormat, DepthStencilFormat, RedFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, GammaEncoding, RGBEEncoding, LogLuvEncoding, RGBM7Encoding, RGBM16Encoding, RGBDEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, ZeroStencilOp, KeepStencilOp, ReplaceStencilOp, IncrementStencilOp, DecrementStencilOp, IncrementWrapStencilOp, DecrementWrapStencilOp, InvertStencilOp, NeverStencilFunc, LessStencilFunc, EqualStencilFunc, LessEqualStencilFunc, GreaterStencilFunc, NotEqualStencilFunc, GreaterEqualStencilFunc, AlwaysStencilFunc, StaticDrawUsage, DynamicDrawUsage, StreamDrawUsage, StaticReadUsage, DynamicReadUsage, StreamReadUsage, StaticCopyUsage, DynamicCopyUsage, StreamCopyUsage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCW", function() { return FrontFaceDirectionCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCCW", function() { return FrontFaceDirectionCCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSMShadowMap", function() { return VSMShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return FlatShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return SmoothShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return NoColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return FaceColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return VertexColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uncharted2ToneMapping", function() { return Uncharted2ToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACESFilmicToneMapping", function() { return ACESFilmicToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalReflectionMapping", function() { return SphericalReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapNearestFilter", function() { return NearestMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapLinearFilter", function() { return NearestMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapNearestFilter", function() { return LinearMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapLinearFilter", function() { return LinearMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return RGBEFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedFormat", function() { return RedFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function() { return RGBA_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function() { return RGBA_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function() { return RGBA_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function() { return RGBA_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function() { return RGBA_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function() { return RGBA_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function() { return RGBA_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function() { return RGBA_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function() { return RGBA_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function() { return RGBA_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function() { return RGBA_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function() { return RGBA_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function() { return RGBA_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function() { return RGBA_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return sRGBEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return RGBEEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return LogLuvEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function() { return TangentSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function() { return ObjectSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroStencilOp", function() { return ZeroStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeepStencilOp", function() { return KeepStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaceStencilOp", function() { return ReplaceStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementStencilOp", function() { return IncrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementStencilOp", function() { return DecrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementWrapStencilOp", function() { return IncrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementWrapStencilOp", function() { return DecrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InvertStencilOp", function() { return InvertStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverStencilFunc", function() { return NeverStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessStencilFunc", function() { return LessStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualStencilFunc", function() { return EqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualStencilFunc", function() { return LessEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterStencilFunc", function() { return GreaterStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualStencilFunc", function() { return NotEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualStencilFunc", function() { return GreaterEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysStencilFunc", function() { return AlwaysStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticDrawUsage", function() { return StaticDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicDrawUsage", function() { return DynamicDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamDrawUsage", function() { return StreamDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticReadUsage", function() { return StaticReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicReadUsage", function() { return DynamicReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamReadUsage", function() { return StreamReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticCopyUsage", function() { return StaticCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicCopyUsage", function() { return DynamicCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamCopyUsage", function() { return StreamCopyUsage; });
var REVISION = '111';
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var FrontFaceDirectionCW = 0;
var FrontFaceDirectionCCW = 1;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var ACESFilmicToneMapping = 5;

var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipMapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipMapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;

var ZeroStencilOp = 0;
var KeepStencilOp = 7680;
var ReplaceStencilOp = 7681;
var IncrementStencilOp = 7682;
var DecrementStencilOp = 7683;
var IncrementWrapStencilOp = 34055;
var DecrementWrapStencilOp = 34056;
var InvertStencilOp = 5386;

var NeverStencilFunc = 512;
var LessStencilFunc = 513;
var EqualStencilFunc = 514;
var LessEqualStencilFunc = 515;
var GreaterStencilFunc = 516;
var NotEqualStencilFunc = 517;
var GreaterEqualStencilFunc = 518;
var AlwaysStencilFunc = 519;

var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var StreamDrawUsage = 35040;
var StaticReadUsage = 35045;
var DynamicReadUsage = 35049;
var StreamReadUsage = 35041;
var StaticCopyUsage = 35046;
var DynamicCopyUsage = 35050;
var StreamCopyUsage = 35042;


/***/ }),

/***/ "./node_modules/three/src/core/EventDispatcher.js":
/*!********************************************************!*\
  !*** ./node_modules/three/src/core/EventDispatcher.js ***!
  \********************************************************/
/*! exports provided: EventDispatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher() {}

Object.assign( EventDispatcher.prototype, {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = listenerArray.slice( 0 );

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

} );





/***/ }),

/***/ "./node_modules/three/src/core/Layers.js":
/*!***********************************************!*\
  !*** ./node_modules/three/src/core/Layers.js ***!
  \***********************************************/
/*! exports provided: Layers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return Layers; });
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Layers() {

	this.mask = 1 | 0;

}

Object.assign( Layers.prototype, {

	set: function ( channel ) {

		this.mask = 1 << channel | 0;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel | 0;

	},

	enableAll: function () {

		this.mask = 0xffffffff | 0;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel | 0;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	},

	disableAll: function () {

		this.mask = 0;

	},

	test: function ( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

} );





/***/ }),

/***/ "./node_modules/three/src/core/Object3D.js":
/*!*************************************************!*\
  !*** ./node_modules/three/src/core/Object3D.js ***!
  \*************************************************/
/*! exports provided: Object3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return Object3D; });
/* harmony import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "./node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventDispatcher.js */ "./node_modules/three/src/core/EventDispatcher.js");
/* harmony import */ var _math_Euler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Euler.js */ "./node_modules/three/src/math/Euler.js");
/* harmony import */ var _Layers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Layers.js */ "./node_modules/three/src/core/Layers.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Matrix3.js */ "./node_modules/three/src/math/Matrix3.js");
/* harmony import */ var _math_Math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Math.js */ "./node_modules/three/src/math/Math.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../constants.js */ "./node_modules/three/src/constants.js");










var _object3DId = 0;

var _v1 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
var _q1 = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
var _m1 = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
var _target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

var _position = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
var _scale = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
var _quaternion = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

var _xAxis = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 1, 0, 0 );
var _yAxis = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, 1, 0 );
var _zAxis = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, 0, 1 );

var _addedEvent = { type: 'added' };
var _removedEvent = { type: 'removed' };

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

function Object3D() {

	Object.defineProperty( this, 'id', { value: _object3DId ++ } );

	this.uuid = _math_Math_js__WEBPACK_IMPORTED_MODULE_7__["_Math"].generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	var position = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
	var rotation = new _math_Euler_js__WEBPACK_IMPORTED_MODULE_4__["Euler"]();
	var quaternion = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
	var scale = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation._onChange( onRotationChange );
	quaternion._onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			configurable: true,
			enumerable: true,
			value: position
		},
		rotation: {
			configurable: true,
			enumerable: true,
			value: rotation
		},
		quaternion: {
			configurable: true,
			enumerable: true,
			value: quaternion
		},
		scale: {
			configurable: true,
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]()
		},
		normalMatrix: {
			value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__["Matrix3"]()
		}
	} );

	this.matrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
	this.matrixWorld = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new _Layers_js__WEBPACK_IMPORTED_MODULE_5__["Layers"]();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};

}

Object3D.DefaultUp = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype = Object.assign( Object.create( _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__["EventDispatcher"].prototype ), {

	constructor: Object3D,

	isObject3D: true,

	onBeforeRender: function () {},
	onAfterRender: function () {},

	applyMatrix: function ( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	applyQuaternion: function ( q ) {

		this.quaternion.premultiply( q );

		return this;

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function ( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	},

	rotateOnWorldAxis: function ( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	},

	rotateX: function ( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	},

	rotateY: function ( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	},

	rotateZ: function ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	},

	translateOnAxis: function ( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1.multiplyScalar( distance ) );

		return this;

	},

	translateX: function ( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	},

	translateY: function ( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	},

	translateZ: function ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	},

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function ( vector ) {

		return vector.applyMatrix4( _m1.getInverse( this.matrixWorld ) );

	},

	lookAt: function ( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		var parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1.lookAt( _position, _target, this.up );

		} else {

			_m1.lookAt( _target, _position, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1 );

		if ( parent ) {

			_m1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1 );
			this.quaternion.premultiply( _q1.inverse() );

		}

	},

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( ( object && object.isObject3D ) ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	},

	attach: function ( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1.getInverse( this.matrixWorld );

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix( _m1 );

		object.updateWorldMatrix( false, false );

		this.add( object );

		return this;

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
			target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		this.updateMatrixWorld( true );

		return target.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
			target = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

		}

		this.updateMatrixWorld( true );

		this.matrixWorld.decompose( _position, target, _scale );

		return target;

	},

	getWorldScale: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
			target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		this.updateMatrixWorld( true );

		this.matrixWorld.decompose( _position, _quaternion, target );

		return target;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
			target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		this.updateMatrixWorld( true );

		var e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	},

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		var parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	},

	toJSON: function ( meta ) {

		// meta is a string when called from JSON.stringify
		var isRootObject = ( meta === undefined || typeof meta === 'string' );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isMesh && this.drawMode !== _constants_js__WEBPACK_IMPORTED_MODULE_8__["TrianglesDrawMode"] ) object.drawMode = this.drawMode;

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			var parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				var shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( var i = 0, l = shapes.length; i < l; i ++ ) {

						var shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				var uuids = [];

				for ( var i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );
			var shapes = extractFromCache( meta.shapes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}
			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) recursive = true;

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

} );





/***/ }),

/***/ "./node_modules/three/src/math/Euler.js":
/*!**********************************************!*\
  !*** ./node_modules/three/src/math/Euler.js ***!
  \**********************************************/
/*! exports provided: Euler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return Euler; });
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector3.js */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Matrix4.js */ "./node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Math.js */ "./node_modules/three/src/math/Math.js");





/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

var _matrix = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
var _quaternion = new _Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

function Euler( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || Euler.DefaultOrder;

}

Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

Euler.DefaultOrder = 'XYZ';

Object.defineProperties( Euler.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this._onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this._onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this._onChangeCallback();

		}

	},

	order: {

		get: function () {

			return this._order;

		},

		set: function ( value ) {

			this._order = value;
			this._onChangeCallback();

		}

	}

} );

Object.assign( Euler.prototype, {

	isEuler: true,

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order );

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = _Math_js__WEBPACK_IMPORTED_MODULE_3__["_Math"].clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.9999999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.9999999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.9999999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.9999999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.9999999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.9999999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this._onChangeCallback();

		return this;

	},

	setFromQuaternion: function ( q, order, update ) {

		_matrix.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix, order, update );

	},

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function ( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion.setFromEuler( this );

		return this.setFromQuaternion( _quaternion, newOrder );

	},

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( this._x, this._y, this._z );

		}

	},

	_onChange: function ( callback ) {

		this._onChangeCallback = callback;

		return this;

	},

	_onChangeCallback: function () {}

} );





/***/ }),

/***/ "./node_modules/three/src/math/Math.js":
/*!*********************************************!*\
  !*** ./node_modules/three/src/math/Math.js ***!
  \*********************************************/
/*! exports provided: _Math */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_Math", function() { return _Math; });
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _lut = [];

for ( var i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

var _Math = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

		var d0 = Math.random() * 0xffffffff | 0;
		var d1 = Math.random() * 0xffffffff | 0;
		var d2 = Math.random() * 0xffffffff | 0;
		var d3 = Math.random() * 0xffffffff | 0;
		var uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toUpperCase() here flattens concatenated strings to save heap memory space.
		return uuid.toUpperCase();

	},

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function ( degrees ) {

		return degrees * _Math.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * _Math.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	ceilPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	},

	floorPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	}

};





/***/ }),

/***/ "./node_modules/three/src/math/Matrix3.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Matrix3.js ***!
  \************************************************/
/*! exports provided: Matrix3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "./node_modules/three/src/math/Vector3.js");


/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

var _vector = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

function Matrix3() {

	this.elements = [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	];

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Object.assign( Matrix3.prototype, {

	isMatrix3: true,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	},

	setFromMatrix4: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	},

	applyToBufferAttribute: function ( attribute ) {

		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

			_vector.x = attribute.getX( i );
			_vector.y = attribute.getY( i );
			_vector.z = attribute.getZ( i );

			_vector.applyMatrix3( this );

			attribute.setXYZ( i, _vector.x, _vector.y, _vector.z );

		}

		return attribute;

	},

	multiply: function ( m ) {

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnDegenerate ) {

		if ( matrix && matrix.isMatrix4 ) {

			console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

		}

		var me = matrix.elements,
			te = this.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) {

			var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	getNormalMatrix: function ( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

		var c = Math.cos( rotation );
		var s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

	},

	scale: function ( sx, sy ) {

		var te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	},

	rotate: function ( theta ) {

		var c = Math.cos( theta );
		var s = Math.sin( theta );

		var te = this.elements;

		var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	},

	translate: function ( tx, ty ) {

		var te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for ( var i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

} );





/***/ }),

/***/ "./node_modules/three/src/math/Matrix4.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Matrix4.js ***!
  \************************************************/
/*! exports provided: Matrix4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return Matrix4; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "./node_modules/three/src/math/Vector3.js");


var _v1 = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var _m1 = new Matrix4();
var _zero = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( 0, 0, 0 );
var _one = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( 1, 1, 1 );
var _x = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var _y = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var _z = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Matrix4() {

	this.elements = [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	];

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Object.assign( Matrix4.prototype, {

	isMatrix4: true,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	},

	copyPosition: function ( m ) {

		var te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	},

	extractRotation: function ( m ) {

		// this method does not support reflection matrices

		var te = this.elements;
		var me = m.elements;

		var scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
		var scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
		var scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromEuler: function ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromQuaternion: function ( q ) {

		return this.compose( _zero, q, _one );

	},

	lookAt: function ( eye, target, up ) {

		var te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	},

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	applyToBufferAttribute: function ( attribute ) {

		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

			_v1.x = attribute.getX( i );
			_v1.y = attribute.getY( i );
			_v1.z = attribute.getZ( i );

			_v1.applyMatrix4( this );

			attribute.setXYZ( i, _v1.x, _v1.y, _v1.z );

		}

		return attribute;

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	setPosition: function ( x, y, z ) {

		var te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	},

	getInverse: function ( m, throwOnDegenerate ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements,
			me = m.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) {

			var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeShear: function ( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		var te = this.elements;

		var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		var x2 = x + x,	y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		var sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	},

	decompose: function ( position, quaternion, scale ) {

		var te = this.elements;

		var sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		var sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		var sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		var det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1.copy( this );

		var invSX = 1 / sx;
		var invSY = 1 / sy;
		var invSZ = 1 / sz;

		_m1.elements[ 0 ] *= invSX;
		_m1.elements[ 1 ] *= invSX;
		_m1.elements[ 2 ] *= invSX;

		_m1.elements[ 4 ] *= invSY;
		_m1.elements[ 5 ] *= invSY;
		_m1.elements[ 6 ] *= invSY;

		_m1.elements[ 8 ] *= invSZ;
		_m1.elements[ 9 ] *= invSZ;
		_m1.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	},

	makePerspective: function ( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = 1.0 / ( right - left );
		var h = 1.0 / ( top - bottom );
		var p = 1.0 / ( far - near );

		var x = ( right + left ) * w;
		var y = ( top + bottom ) * h;
		var z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for ( var i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

} );





/***/ }),

/***/ "./node_modules/three/src/math/Quaternion.js":
/*!***************************************************!*\
  !*** ./node_modules/three/src/math/Quaternion.js ***!
  \***************************************************/
/*! exports provided: Quaternion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math.js */ "./node_modules/three/src/math/Math.js");
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */



function Quaternion( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

}

Object.assign( Quaternion, {

	slerp: function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	},

	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ],

			x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			var s = 1 - t,

				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			var tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

} );

Object.defineProperties( Quaternion.prototype, {

	x: {

		get: function () {

			return this._x;

		},

		set: function ( value ) {

			this._x = value;
			this._onChangeCallback();

		}

	},

	y: {

		get: function () {

			return this._y;

		},

		set: function ( value ) {

			this._y = value;
			this._onChangeCallback();

		}

	},

	z: {

		get: function () {

			return this._z;

		},

		set: function ( value ) {

			this._z = value;
			this._onChangeCallback();

		}

	},

	w: {

		get: function () {

			return this._w;

		},

		set: function ( value ) {

			this._w = value;
			this._onChangeCallback();

		}

	}

} );

Object.assign( Quaternion.prototype, {

	isQuaternion: true,

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var cos = Math.cos;
		var sin = Math.sin;

		var c1 = cos( x / 2 );
		var c2 = cos( y / 2 );
		var c3 = cos( z / 2 );

		var s1 = sin( x / 2 );
		var s2 = sin( y / 2 );
		var s3 = sin( z / 2 );

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	},

	setFromUnitVectors: function ( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		var EPS = 0.000001;

		var r = vFrom.dot( vTo ) + 1;

		if ( r < EPS ) {

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	},

	angleTo: function ( q ) {

		return 2 * Math.acos( Math.abs( _Math_js__WEBPACK_IMPORTED_MODULE_0__["_Math"].clamp( this.dot( q ), - 1, 1 ) ) );

	},

	rotateTowards: function ( q, step ) {

		var angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		var t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	},

	inverse: function () {

		// quaternion is assumed to have unit length

		return this.conjugate();

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	premultiply: function ( q ) {

		return this.multiplyQuaternions( q, this );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			var s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	_onChange: function ( callback ) {

		this._onChangeCallback = callback;

		return this;

	},

	_onChangeCallback: function () {}

} );





/***/ }),

/***/ "./node_modules/three/src/math/Vector3.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Vector3.js ***!
  \************************************************/
/*! exports provided: Vector3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math.js */ "./node_modules/three/src/math/Math.js");
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");



/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

var _vector = new Vector3();
var _quaternion = new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__["Quaternion"]();

function Vector3( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

}

Object.assign( Vector3.prototype, {

	isVector3: true,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function ( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

	},

	applyAxisAngle: function ( axis, angle ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

	},

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyNormalMatrix: function ( m ) {

		return this.applyMatrix3( m ).normalize();

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x, y = this.y, z = this.z;
		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		var ix = qw * x + qy * z - qz * y;
		var iy = qw * y + qz * x - qx * z;
		var iz = qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function ( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	},

	unproject: function ( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	},

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function ( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	},

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	// TODO lengthSquared?

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	manhattanLength: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() || 1 );

	},

	setLength: function ( length ) {

		return this.normalize().multiplyScalar( length );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function ( v ) {

		// v cannot be the zero v

		var scalar = v.dot( this ) / v.lengthSq();

		return this.copy( v ).multiplyScalar( scalar );

	},

	projectOnPlane: function ( planeNormal ) {

		_vector.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector );

	},

	reflect: function ( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	},

	angleTo: function ( v ) {

		var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) console.error( 'THREE.Vector3: angleTo() can\'t handle zero length vectors.' );

		var theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( _Math_js__WEBPACK_IMPORTED_MODULE_0__["_Math"].clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	manhattanDistanceTo: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	},

	setFromSpherical: function ( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	},

	setFromSphericalCoords: function ( radius, phi, theta ) {

		var sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	},

	setFromCylindrical: function ( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	},

	setFromCylindricalCoords: function ( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	},

	setFromMatrixPosition: function ( m ) {

		var e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromBufferAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

} );





/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const WebSocket = __webpack_require__(/*! ./lib/websocket */ "./node_modules/ws/lib/websocket.js");

WebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ "./node_modules/ws/lib/stream.js");
WebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ "./node_modules/ws/lib/websocket-server.js");
WebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ "./node_modules/ws/lib/receiver.js");
WebSocket.Sender = __webpack_require__(/*! ./lib/sender */ "./node_modules/ws/lib/sender.js");

module.exports = WebSocket;


/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (let i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

try {
  const bufferUtil = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'bufferutil'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = {
    concat,
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    toArrayBuffer,
    toBuffer,
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
}


/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  EMPTY_BUFFER: Buffer.alloc(0),
  NOOP: () => {}
};


/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Class representing an event.
 *
 * @private
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was dispatched
   */
  constructor(type, target) {
    this.target = target;
    this.type = type;
  }
}

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(data, target) {
    super('message', target);

    this.data = data;
  }
}

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {Number} code The status code explaining why the connection is being closed
   * @param {String} reason A human-readable string explaining why the connection is closing
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  }
}

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event {
  /**
   * Create a new `OpenEvent`.
   *
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(target) {
    super('open', target);
  }
}

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {Object} error The error that generated this event
   * @param {WebSocket} target A reference to the target to which the event was dispatched
   */
  constructor(error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  }
}

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @param {Object} options An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} options.once A `Boolean`` indicating that the listener
   *     should be invoked at most once after being added. If `true`, the
   *     listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, listener, options) {
    if (typeof listener !== 'function') return;

    function onMessage(data) {
      listener.call(this, new MessageEvent(data, this));
    }

    function onClose(code, message) {
      listener.call(this, new CloseEvent(code, message, this));
    }

    function onError(error) {
      listener.call(this, new ErrorEvent(error, this));
    }

    function onOpen() {
      listener.call(this, new OpenEvent(this));
    }

    const method = options && options.once ? 'once' : 'on';

    if (type === 'message') {
      onMessage._listener = listener;
      this[method](type, onMessage);
    } else if (type === 'close') {
      onClose._listener = listener;
      this[method](type, onClose);
    } else if (type === 'error') {
      onError._listener = listener;
      this[method](type, onError);
    } else if (type === 'open') {
      onOpen._listener = listener;
      this[method](type, onOpen);
    } else {
      this[method](type, listener);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {Function} listener The listener to remove
   * @public
   */
  removeEventListener(type, listener) {
    const listeners = this.listeners(type);

    for (let i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(type, listeners[i]);
      }
    }
  }
};

module.exports = EventTarget;


/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);

  if (header === undefined || header === '') return offers;

  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ "./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} concurrency The maximum number of jobs allowed to run
   *     concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const zlib = __webpack_require__(/*! zlib */ "zlib");

const bufferUtil = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");
const Limiter = __webpack_require__(/*! ./limiter */ "./node_modules/ws/lib/limiter.js");
const { kStatusCode, NOOP } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling
   *     of server context takeover
   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge
   *     disabling of client context takeover
   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the
   *     use of a custom server window size
   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support
   *     for, or request, a custom client window size
   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate
   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate
   * @param {Number} options.threshold Size (in bytes) below which messages
   *     should not be compressed
   * @param {Number} options.concurrencyLimit The number of concurrent calls to
   *     zlib
   * @param {Boolean} isServer Create the instance in either server or client
   *     mode
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      //
      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
      // `zlib.DeflateRaw` instance is closed while data is being processed.
      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
      // time due to an abnormal WebSocket closure.
      //
      this._deflate.on('error', NOOP);
      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.close();
        this._deflate = null;
      } else {
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { Writable } = __webpack_require__(/*! stream */ "stream");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends stream.Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {String} binaryType The type for binary data
   * @param {Object} extensions An object containing the negotiated extensions
   * @param {Boolean} isServer Specifies whether to operate in client or server
   *     mode
   * @param {Number} maxPayload The maximum allowed message length
   */
  constructor(binaryType, extensions, isServer, maxPayload) {
    super();

    this._binaryType = binaryType || BINARY_TYPES[0];
    this[kWebSocket] = undefined;
    this._extensions = extensions || {};
    this._isServer = !!isServer;
    this._maxPayload = maxPayload | 0;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(RangeError, 'RSV1 must be clear', true, 1002);
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(RangeError, 'invalid opcode 0', true, 1002);
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(RangeError, 'FIN must be set', true, 1002);
      }

      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002
        );
      }
    } else {
      this._loop = false;
      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error(RangeError, 'MASK must be set', true, 1002);
      }
    } else if (this._masked) {
      this._loop = false;
      return error(RangeError, 'MASK must be clear', true, 1002);
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(RangeError, 'Max payload size exceeded', false, 1009);
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);
      if (this._masked) unmask(data, this._mask);
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its lenght is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(RangeError, 'Max payload size exceeded', false, 1009)
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        let data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data);
      } else {
        const buf = concat(fragments, messageLength);

        if (!isValidUTF8(buf)) {
          this._loop = false;
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('message', buf.toString());
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, '');
        this.end();
      } else if (data.length === 1) {
        return error(RangeError, 'invalid payload length 1', true, 1002);
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          return error(RangeError, `invalid status code ${code}`, true, 1002);
        }

        const buf = data.slice(2);

        if (!isValidUTF8(buf)) {
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('conclude', code, buf.toString());
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {(Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err[kStatusCode] = statusCode;
  return err;
}


/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { randomFillSync } = __webpack_require__(/*! crypto */ "crypto");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { isValidStatusCode } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");
const { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

const mask = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} extensions An object containing the negotiated extensions
   */
  constructor(socket, extensions) {
    this._extensions = extensions || {};
    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame(data, options) {
    const merge = options.mask && options.readOnly;
    let offset = options.mask ? 6 : 2;
    let payloadLength = data.length;

    if (data.length >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2);
      target.writeUInt32BE(data.length, 6);
    }

    if (!options.mask) return [target, data];

    randomFillSync(mask, 0, 4);

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      applyMask(data, mask, target, offset, data.length);
      return [target];
    }

    applyMask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {(Number|undefined)} code The status code component of the body
   * @param {String} data The message component of the body
   * @param {Boolean} mask Specifies whether or not to mask the message
   * @param {Function} cb Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || data === '') {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);
      buf.write(data, 2);
    }

    if (this._deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @private
   */
  doClose(data, mask, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask,
        readOnly: false
      }),
      cb
    );
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  ping(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPing(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a ping message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPing(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  pong(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPong(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a pong message.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Boolean} readOnly Specifies whether `data` can be modified
   * @param {Function} cb Callback
   * @private
   */
  doPong(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @public
   */
  send(data, options, cb) {
    const buf = toBuffer(data);
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate) {
        rsv1 = buf.length >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        fin: options.fin,
        rsv1,
        opcode,
        mask: options.mask,
        readOnly: toBuffer.readOnly
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
      } else {
        this.dispatch(buf, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a data message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} compress Specifies whether or not to compress `data`
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @param {Function} cb Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const callback = this._queue[i][4];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[1].length;
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[1].length;
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} cb Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const { Duplex } = __webpack_require__(/*! stream */ "stream");

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {stream.Duplex} The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} options The options for the `Duplex` constructor
 * @return {stream.Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let resumeOnReceiverDrain = true;

  function receiverOnDrain() {
    if (resumeOnReceiverDrain) ws._socket.resume();
  }

  if (ws.readyState === ws.CONNECTING) {
    ws.once('open', function open() {
      ws._receiver.removeAllListeners('drain');
      ws._receiver.on('drain', receiverOnDrain);
    });
  } else {
    ws._receiver.removeAllListeners('drain');
    ws._receiver.on('drain', receiverOnDrain);
  }

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg) {
    if (!duplex.push(msg)) {
      resumeOnReceiverDrain = false;
      ws._socket.pause();
    }
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function(err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });
    ws.terminate();
  };

  duplex._final = function(callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function() {
    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
      resumeOnReceiverDrain = true;
      if (!ws._receiver._writableState.needDrain) ws._socket.resume();
    }
  };

  duplex._write = function(chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


try {
  const isValidUTF8 = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module 'utf-8-validate'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

  exports.isValidUTF8 =
    typeof isValidUTF8 === 'object'
      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0
      : isValidUTF8;
} catch (e) /* istanbul ignore next */ {
  exports.isValidUTF8 = () => true;
}

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
exports.isValidStatusCode = (code) => {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
};


/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events");
const { createHash } = __webpack_require__(/*! crypto */ "crypto");
const { createServer, STATUS_CODES } = __webpack_require__(/*! http */ "http");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const WebSocket = __webpack_require__(/*! ./websocket */ "./node_modules/ws/lib/websocket.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");
const { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} options.backlog The maximum length of the queue of pending
   *     connections
   * @param {Boolean} options.clientTracking Specifies whether or not to track
   *     clients
   * @param {Function} options.handleProtocols A hook to handle protocols
   * @param {String} options.host The hostname where to bind the server
   * @param {Number} options.maxPayload The maximum allowed message size
   * @param {Boolean} options.noServer Enable no server mode
   * @param {String} options.path Accept only connections matching this path
   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable
   *     permessage-deflate
   * @param {Number} options.port The port where to bind the server
   * @param {http.Server} options.server A pre-created HTTP/S server to use
   * @param {Function} options.verifyClient A hook to reject connections
   * @param {Function} callback A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      ...options
    };

    if (options.port == null && !options.server && !options.noServer) {
      throw new TypeError(
        'One of the "port", "server", or "noServer" options must be specified'
      );
    }

    if (options.port != null) {
      this._server = createServer((req, res) => {
        const body = STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, (ws) => {
            this.emit('connection', ws, req);
          });
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) this.clients = new Set();
    this.options = options;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Close the server.
   *
   * @param {Function} cb Callback
   * @public
   */
  close(cb) {
    if (cb) this.once('close', cb);

    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) {
        server.close(() => this.emit('close'));
        return;
      }
    }

    process.nextTick(emitClose, this);
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key =
      req.headers['sec-websocket-key'] !== undefined
        ? req.headers['sec-websocket-key'].trim()
        : false;
    const version = +req.headers['sec-websocket-version'];
    const extensions = {};

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !key ||
      !keyRegex.test(key) ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    if (this.options.perMessageDeflate) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = parse(req.headers['sec-websocket-extensions']);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.connection.authorized || req.connection.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(key, extensions, req, socket, head, cb);
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(key, extensions, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Object} extensions The accepted extensions
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(key, extensions, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new WebSocket(null);
    let protocol = req.headers['sec-websocket-protocol'];

    if (protocol) {
      protocol = protocol.trim().split(/ *, */);

      //
      // Optionally call external protocol selection handler.
      //
      if (this.options.handleProtocols) {
        protocol = this.options.handleProtocols(protocol, req);
      } else {
        protocol = protocol[0];
      }

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws.protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => this.clients.delete(ws));
    }

    cb(ws);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server.emit('close');
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {net.Socket} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || STATUS_CODES[code];
    headers = {
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message),
      ...headers
    };

    socket.write(
      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\r\n` +
        Object.keys(headers)
          .map((h) => `${h}: ${headers[h]}`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}


/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events");
const https = __webpack_require__(/*! https */ "https");
const http = __webpack_require__(/*! http */ "http");
const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { randomBytes, createHash } = __webpack_require__(/*! crypto */ "crypto");
const { URL } = __webpack_require__(/*! url */ "url");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const Receiver = __webpack_require__(/*! ./receiver */ "./node_modules/ws/lib/receiver.js");
const Sender = __webpack_require__(/*! ./sender */ "./node_modules/ws/lib/sender.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { addEventListener, removeEventListener } = __webpack_require__(/*! ./event-target */ "./node_modules/ws/lib/event-target.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");
const { toBuffer } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|url.URL)} address The URL to which to connect
   * @param {(String|String[])} protocols The subprotocols
   * @param {Object} options Connection options
   */
  constructor(address, protocols, options) {
    super();

    this.readyState = WebSocket.CONNECTING;
    this.protocol = '';

    this._binaryType = BINARY_TYPES[0];
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = '';
    this._closeTimer = null;
    this._closeCode = 1006;
    this._extensions = {};
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (Array.isArray(protocols)) {
        protocols = protocols.join(', ');
      } else if (typeof protocols === 'object' && protocols !== null) {
        options = protocols;
        protocols = undefined;
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  get CONNECTING() {
    return WebSocket.CONNECTING;
  }
  get CLOSING() {
    return WebSocket.CLOSING;
  }
  get CLOSED() {
    return WebSocket.CLOSED;
  }
  get OPEN() {
    return WebSocket.OPEN;
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    //
    // `socket.bufferSize` is `undefined` if the socket is closed.
    //
    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Number} maxPayload The maximum allowed message size
   * @private
   */
  setSocket(socket, head, maxPayload) {
    const receiver = new Receiver(
      this._binaryType,
      this._extensions,
      this._isServer,
      maxPayload
    );

    this._sender = new Sender(socket, this._extensions);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this.readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this.readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this.readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} code Status code explaining why the connection is closing
   * @param {String} data A string explaining why the connection is closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
      return;
    }

    this.readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;
      if (this._closeFrameReceived) this._socket.end();
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Send a ping.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} data The data to send
   * @param {Boolean} mask Indicates whether or not to mask `data`
   * @param {Function} cb Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} options.compress Specifies whether or not to compress
   *     `data`
   * @param {Boolean} options.binary Specifies whether `data` is binary or text
   * @param {Boolean} options.fin Specifies whether the fragment is the last one
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this.readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

readyStates.forEach((readyState, i) => {
  WebSocket[readyState] = i;
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    /**
     * Return the listener of the event.
     *
     * @return {(Function|undefined)} The event listener or `undefined`
     * @public
     */
    get() {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        if (listeners[i]._listener) return listeners[i]._listener;
      }

      return undefined;
    },
    /**
     * Add a listener for the event.
     *
     * @param {Function} listener The listener to add
     * @public
     */
    set(listener) {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.addEventListener(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|url.URL)} address The URL to which to connect
 * @param {String} protocols The subprotocols
 * @param {Object} options Connection options
 * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable
 *     permessage-deflate
 * @param {Number} options.handshakeTimeout Timeout in milliseconds for the
 *     handshake request
 * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version`
 *     header
 * @param {String} options.origin Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {Number} options.maxPayload The maximum allowed message size
 * @param {Boolean} options.followRedirects Whether or not to follow redirects
 * @param {Number} options.maxRedirects The maximum number of redirects allowed
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket.url = address.href;
  } else {
    parsedUrl = new URL(address);
    websocket.url = address;
  }

  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
    throw new Error(`Invalid URL: ${websocket.url}`);
  }

  const isSecure =
    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const get = isSecure ? https.get : http.get;
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket',
    ...opts.headers
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols) {
    opts.headers['Sec-WebSocket-Protocol'] = protocols;
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req = (websocket._req = get(opts));

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (websocket._req.aborted) return;

    req = websocket._req = null;
    websocket.readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      const addr = new URL(location, address);

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    const protList = (protocols || '').split(/, */);
    let protError;

    if (!protocols && serverProt) {
      protError = 'Server sent a subprotocol but none was requested';
    } else if (protocols && !serverProt) {
      protError = 'Server sent no subprotocol';
    } else if (serverProt && !protList.includes(serverProt)) {
      protError = 'Server sent an invalid subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket.protocol = serverProt;

    if (perMessageDeflate) {
      try {
        const extensions = parse(res.headers['sec-websocket-extensions']);

        if (extensions[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          websocket._extensions[
            PerMessageDeflate.extensionName
          ] = perMessageDeflate;
        }
      } catch (err) {
        abortHandshake(
          websocket,
          socket,
          'Invalid Sec-WebSocket-Extensions header'
        );
        return;
      }
    }

    websocket.setSocket(socket, head, opts.maxPayload);
  });
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the
 *     socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket.readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();
    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} data The data to send
 * @param {Function} cb Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    cb(err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {String} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);
  websocket._socket.resume();

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  this[kWebSocket]._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);

  websocket.readyState = WebSocket.CLOSING;
  websocket._closeCode = err[kStatusCode];
  websocket.emit('error', err);
  websocket._socket.destroy();
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
 * @private
 */
function receiverOnMessage(data) {
  this[kWebSocket].emit('message', data);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('end', socketOnEnd);

  websocket.readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk and emitted synchronously in a single
  // `'data'` event.
  //
  websocket._socket.read();
  websocket._receiver.end();

  this.removeListener('data', socketOnData);
  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket.readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket.readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ "./src/MockDependencies.js":
/*!*********************************!*\
  !*** ./src/MockDependencies.js ***!
  \*********************************/
/*! exports provided: MockGUI, MockRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MockGUI", function() { return MockGUI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MockRenderer", function() { return MockRenderer; });
/* harmony import */ var three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/src/math/Vector3 */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/src/math/Quaternion */ "./node_modules/three/src/math/Quaternion.js");
/* harmony import */ var three_src_core_Object3D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/src/core/Object3D */ "./node_modules/three/src/core/Object3D.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





global.debug = function () {
  var _console;

  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return (_console = console).log.apply(_console, ["[".concat(new Date().toLocaleTimeString(), "]")].concat(params));
};

var Obj3D = /*#__PURE__*/function (_Object3D) {
  _inherits(Obj3D, _Object3D);

  var _super = _createSuper(Obj3D);

  function Obj3D() {
    var _this;

    _classCallCheck(this, Obj3D);

    for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      props[_key2] = arguments[_key2];
    }

    _this = _super.call.apply(_super, [this].concat(props));
    _this.scene = _assertThisInitialized(_this);
    return _this;
  }

  return Obj3D;
}(three_src_core_Object3D__WEBPACK_IMPORTED_MODULE_2__["Object3D"]);

global.THREE = {
  Vector3: three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_0__["Vector3"],
  Quaternion: three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_1__["Quaternion"],
  Object3D: Obj3D,
  WebGLRenderer: function WebGLRenderer() {
    return {
      render: function render() {
        return {};
      },
      setSize: function setSize() {
        return {};
      },
      getContext: function getContext() {
        return {
          canvas: {
            width: 0,
            height: 0
          }
        };
      },
      shadowMap: {}
    };
  },
  Scene: Obj3D,
  Cache: {},
  Clock: function Clock() {
    return {};
  },
  AnimationMixer: function AnimationMixer() {
    return {
      update: function update() {
        return {};
      },
      clipAction: function clipAction() {
        return {
          stop: function stop() {
            return {};
          }
        };
      }
    };
  },
  PCFSoftShadowMap: function PCFSoftShadowMap() {
    return {};
  },
  PerspectiveCamera: Obj3D,
  Raycaster: function Raycaster() {
    return {};
  },
  TextureLoader: function TextureLoader() {
    return {
      load: function load() {
        return {};
      }
    };
  },
  Fog: function Fog() {
    return {};
  },
  RepeatWrapping: function RepeatWrapping() {
    return {};
  },
  Color: function Color() {
    return {};
  },
  Mesh: Obj3D,
  CubeGeometry: function CubeGeometry() {
    return {};
  },
  MeshLambertMaterial: function MeshLambertMaterial() {
    return {};
  },
  NormalBlending: function NormalBlending() {
    return {};
  },
  AdditiveBlending: function AdditiveBlending() {
    return {};
  },
  Geometry: function Geometry() {
    return {};
  },
  PointCloudMaterial: function PointCloudMaterial() {
    return {};
  },
  PointCloud: function PointCloud() {
    return {};
  },
  AmbientLight: function AmbientLight() {
    return {};
  },
  DirectionalLight: function DirectionalLight() {
    var light = new Obj3D();
    light.shadow = {
      camera: {},
      mapSize: {}
    };
    return light;
  },
  MeshBasicMaterial: function MeshBasicMaterial() {
    return {};
  },
  BackSide: function BackSide() {
    return {};
  },
  MeshFaceMaterial: function MeshFaceMaterial() {
    return {};
  }
};

global.GLTFLoader = function () {
  return {
    load: function load(url, callback) {
      return callback(new Obj3D());
    }
  };
};

global.window = {
  innerWidth: 0,
  innerHeight: 0,
  clearTimeout: 0,
  requestAnimationFrame: function requestAnimationFrame(fn) {
    return setTimeout(fn, 1000 / 60);
  },
  location: {
    reload: function reload() {
      return debug('reload page');
    }
  },
  addEventListener: function addEventListener() {
    for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      params[_key3] = arguments[_key3];
    }

    return debug.apply(void 0, ['window.addEventListener'].concat(params));
  },
  setTimeout: setTimeout,
  WebSocket: function WebSocket() {
    return {
      onopen: function onopen() {
        for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          params[_key4] = arguments[_key4];
        }

        return debug.apply(void 0, ['window.WebSocket.onopen'].concat(params));
      },
      onerror: function onerror() {
        for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          params[_key5] = arguments[_key5];
        }

        return debug.apply(void 0, ['window.WebSocket.onerror'].concat(params));
      },
      onmessage: function onmessage() {
        for (var _len6 = arguments.length, params = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          params[_key6] = arguments[_key6];
        }

        return debug.apply(void 0, ['window.WebSocket.onmessage'].concat(params));
      }
    };
  }
};
global.document = {
  body: {
    addEventListener: function addEventListener() {
      for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        params[_key7] = arguments[_key7];
      }

      return debug.apply(void 0, ['document.body.addEventListener'].concat(params));
    },
    removeEventListener: function removeEventListener() {
      for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        params[_key8] = arguments[_key8];
      }

      return debug.apply(void 0, ['document.body.removeEventListener'].concat(params));
    }
  },
  dispatchEvent: function dispatchEvent() {
    for (var _len9 = arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      params[_key9] = arguments[_key9];
    }

    return debug.apply(void 0, ['document.dispatchEvent'].concat(params));
  },
  getElementById: function getElementById() {
    for (var _len10 = arguments.length, params = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      params[_key10] = arguments[_key10];
    }

    return debug.apply(void 0, ['document.getElementById'].concat(params));
  },
  addEventListener: function addEventListener() {
    for (var _len11 = arguments.length, params = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      params[_key11] = arguments[_key11];
    }

    return debug.apply(void 0, ['document.addEventListener'].concat(params));
  },
  removeEventListener: function removeEventListener() {
    for (var _len12 = arguments.length, params = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      params[_key12] = arguments[_key12];
    }

    return debug.apply(void 0, ['document.removeEventListener'].concat(params));
  }
};
var MockGUI = {
  isServer: true,
  setRestartButtonVisible: function setRestartButtonVisible() {
    return null;
  },
  setPause: function setPause() {
    return null;
  },
  restartGame: function restartGame() {
    return null;
  },
  isPause: function isPause() {
    return false;
  },
  isThirdPerson: function isThirdPerson() {
    return false;
  },
  update: function update() {
    return null;
  },
  setConnectionRole: debug,
  updatePlayerParams: function updatePlayerParams() {
    return null;
  },
  clearHpBars: function clearHpBars() {
    return null;
  },
  switchCamera: function switchCamera() {
    return null;
  },
  setFps: function setFps() {
    return null;
  },
  setPing: function setPing() {
    return null;
  },
  notify: debug,
  setLoading: function setLoading() {
    return null;
  }
};
var MockRenderer = {
  fps: 1,
  targetFps: 1,
  renderer: new THREE.WebGLRenderer(),
  render: function render() {
    return {};
  }
};

/***/ }),

/***/ "./src/SocketServer.js":
/*!*****************************!*\
  !*** ./src/SocketServer.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ "./node_modules/ws/index.js");
/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var WebSocketServer = ws__WEBPACK_IMPORTED_MODULE_0__["Server"];

var SocketServer = /*#__PURE__*/function () {
  function SocketServer() {
    _classCallCheck(this, SocketServer);

    this.createWebServer = this.createWebServer.bind(this);
    this.createSocketServer = this.createSocketServer.bind(this);
    this.saveUserData = this.saveUserData.bind(this);
    this.loadUserData = this.loadUserData.bind(this);
    this.startSocketServer = this.startSocketServer.bind(this);
    this.getConnectionId = this.getConnectionId.bind(this);
    this.sendToConnection = this.sendToConnection.bind(this);
    this.send = this.send.bind(this);
    var isProduction = "development" === 'production';
    this.config = {
      ssl: isProduction,
      port: 1337,
      sslKey: path__WEBPACK_IMPORTED_MODULE_2__["join"](__dirname, './private.pem'),
      sslCertificate: path__WEBPACK_IMPORTED_MODULE_2__["join"](__dirname, './fullchain.pem'),
      sessionsPath: path__WEBPACK_IMPORTED_MODULE_2__["join"](__dirname, './sessions/'),
      debug: false
    };
    this.db = {
      sequenceId: 0,
      hostId: null,
      connections: {},
      players: {},
      gameObjects: []
    };
    var socketServer = this.createSocketServer(this.config);
    this.startSocketServer(socketServer);
  }

  _createClass(SocketServer, [{
    key: "createWebServer",
    value: function createWebServer(config) {
      var processRequest = function processRequest(req, res) {
        res.writeHead(200);
        res.end("All glory to WebSockets!\n");
      };

      if (config.ssl) {
        var sslParams = {
          key: fs__WEBPACK_IMPORTED_MODULE_1__["readFileSync"](config.sslKey),
          cert: fs__WEBPACK_IMPORTED_MODULE_1__["readFileSync"](config.sslCertificate)
        };
        return __webpack_require__(/*! https */ "https").createServer(sslParams, processRequest).listen(config.port);
      } else {
        return __webpack_require__(/*! http */ "http").createServer(processRequest).listen(config.port);
      }
    }
  }, {
    key: "createSocketServer",
    value: function createSocketServer(config) {
      var server = this.createWebServer(config);
      var webSocketServer = new WebSocketServer({
        server: server
      });
      debug("Server is running on port ".concat(config.port, ". SSL is ").concat(config.ssl ? 'enabled' : 'disabled', "."));
      return webSocketServer;
    }
  }, {
    key: "saveUserData",
    value: function saveUserData(token, data) {
      try {
        if (!fs__WEBPACK_IMPORTED_MODULE_1__["existsSync"](this.config.sessionsPath)) {
          fs__WEBPACK_IMPORTED_MODULE_1__["mkdirSync"](this.config.sessionsPath);
        }

        fs__WEBPACK_IMPORTED_MODULE_1__["writeFileSync"]("".concat(this.config.sessionsPath, "/").concat(token), JSON.stringify(data));
        return true;
      } catch (e) {
        debug('Save user data error', e);
        return false;
      }
    }
  }, {
    key: "loadUserData",
    value: function loadUserData(token) {
      var tokenPath = "".concat(this.config.sessionsPath, "/").concat(token);

      try {
        if (fs__WEBPACK_IMPORTED_MODULE_1__["existsSync"](tokenPath)) {
          return JSON.parse(fs__WEBPACK_IMPORTED_MODULE_1__["readFileSync"](tokenPath, 'utf8'));
        }
      } catch (e) {
        debug('Load user data error', e);
      }

      return false;
    }
  }, {
    key: "getConnectionId",
    value: function getConnectionId(c) {
      return c._id;
    }
  }, {
    key: "sendToConnection",
    value: function sendToConnection(connectionId) {
      var players = this.db.players;
      var connection = this.db.connections[connectionId];
      var gameObjects = this.db.gameObjects.filter(function (gameObject) {
        return gameObject.type !== 'player';
      });
      var networkPlayers = Object.keys(players).filter(function (playerConnectionId) {
        return playerConnectionId !== String(connectionId);
      }).map(function (playerConnectionId) {
        return players[playerConnectionId];
      });
      this.send(connection, 'updateGameObjects', [].concat(gameObjects, networkPlayers));
    }
  }, {
    key: "send",
    value: function send(connection, messageType, data) {
      connection.send(JSON.stringify({
        meta: {
          server: {
            version: 1
          },
          role: this.getConnectionId(connection) === this.db.hostId ? 'host' : 'client',
          id: this.getConnectionId(connection),
          token: connection._meta.token,
          debug: this.config.debug
        },
        data: data,
        messageType: messageType
      }));
    }
  }, {
    key: "startSocketServer",
    value: function startSocketServer(socketServer) {
      var _this = this;

      var db = this.db;
      var loadUserData = this.loadUserData;
      var getConnectionId = this.getConnectionId;
      var send = this.send;
      var sendToConnection = this.sendToConnection;

      var getConnectionToken = function getConnectionToken(c) {
        return c._meta.token;
      };

      setInterval(function () {
        Object.values(db.connections).forEach(function (connection) {
          var connectionPlayer = db.players[getConnectionId(connection)];
          var token = getConnectionToken(connection);

          if (connectionPlayer && token) {
            _this.saveUserData(token, connectionPlayer);
          }
        });
      }, 10000);
      socketServer.on('connection', function (connection) {
        var id = ++db.sequenceId;
        debug('New connection, id:', id);
        db.connections[id] = connection;
        connection._meta = {
          id: id
        };
        connection._id = id;

        var onSocketClose = function onSocketClose() {
          var id = getConnectionId(connection);
          debug('Connection closed, id:', id);
          Object.values(db.connections).forEach(function (c) {
            send(c, 'disconnected', {
              connectionId: id
            });
          });
          delete db.connections[id];
          delete db.players[id];
        };

        var onSocketMessage = function onSocketMessage(message) {
          var _JSON$parse = JSON.parse(message),
              data = _JSON$parse.data,
              messageType = _JSON$parse.messageType,
              meta = _JSON$parse.meta;

          var connectionId = getConnectionId(connection);

          if (meta && meta.token && meta.token !== connection._meta.token) {
            debug("User #".concat(connectionId, " token changed from ").concat(connection._meta.token, " to ").concat(meta.token));
            connection._meta.token = meta.token;
          }

          var sendUserData = function sendUserData() {
            send(connection, 'setUserPlayer', loadUserData(connection._meta.token));
          };

          var updatePlayerData = function updatePlayerData(player) {
            db.players[connectionId] = player;
          };

          switch (messageType) {
            case 'loadCurrentUser':
              {
                sendUserData();
                break;
              }

            case 'updatePlayer':
              {
                // Process request
                updatePlayerData(data); // Send response

                sendToConnection(connectionId);
                break;
              }

            case 'restartServer':
              {
                // restartServer();
                break;
              }
          }
        };

        connection.on('message', onSocketMessage);
        connection.on('close', onSocketClose);
        send(connection, 'handshake');
      });
    }
  }]);

  return SocketServer;
}();

/* harmony default export */ __webpack_exports__["default"] = (SocketServer);

/***/ }),

/***/ "./standalone-server.js":
/*!******************************!*\
  !*** ./standalone-server.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_MockDependencies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/MockDependencies */ "./src/MockDependencies.js");
/* harmony import */ var _src_SocketServer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/SocketServer */ "./src/SocketServer.js");
/* harmony import */ var _client_src_js_Scene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../client/src/js/Scene */ "../client/src/js/Scene.js");
/* harmony import */ var _client_src_js_Connection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../client/src/js/Connection */ "../client/src/js/Connection.js");
/* harmony import */ var _client_src_js_GameObjects__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../client/src/js/GameObjects */ "../client/src/js/GameObjects.js");






function Server() {
  debug('Starting server scene initialization ...');
  var scene = new _client_src_js_Scene__WEBPACK_IMPORTED_MODULE_2__["default"](_src_MockDependencies__WEBPACK_IMPORTED_MODULE_0__["MockRenderer"], _src_MockDependencies__WEBPACK_IMPORTED_MODULE_0__["MockGUI"]);
  debug('Scene is loaded', {
    THREE: Boolean(THREE),
    document: Boolean(document),
    window: Boolean(window),
    GLTFLoader: Boolean(GLTFLoader),
    scene: Boolean(scene),
    sceneLocation: Boolean(scene.location),
    sceneColliders: scene.colliders.colliders.length,
    sceneAreas: scene.pathFinder.areas.length,
    aliveUnits: scene.units.getAliveUnits().length
  });
  var player = scene.getPlayer();

  if (player) {
    player.params.hp = 0;
  }

  debug('Starting socket server ...');
  var socketServer = new _src_SocketServer__WEBPACK_IMPORTED_MODULE_1__["default"]();

  var updateGameObjects = function updateGameObjects() {
    var data = [];
    scene.units.getAliveUnits().forEach(function (unit) {
      if (!(unit instanceof _client_src_js_GameObjects__WEBPACK_IMPORTED_MODULE_4__["Player"])) {
        var unitData = _client_src_js_Connection__WEBPACK_IMPORTED_MODULE_3__["default"].unitToNetwork(unit, null, 'dream-town');

        if (unitData) {
          data.push(unitData);
        }
      }
    });
    socketServer.db.gameObjects = data;
    Object.values(socketServer.db.players).forEach(scene.connection.updateNetworkPlayer);
  };

  setInterval(updateGameObjects, 100);
}

/* harmony default export */ __webpack_exports__["default"] = (Server);

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvQXV0b0JpbmRNZXRob2RzLmpzIiwid2VicGFjazovLy8uLi9jbGllbnQvc3JjL2pzL0NhbWVyYS5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9Db2xsaWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvQ29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy9BSS5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy9BbmltYXRlZEdhbWVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvR2FtZU9iamVjdHMvRmlyZS5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy9GaXJpbmdVbml0LmpzIiwid2VicGFjazovLy8uLi9jbGllbnQvc3JjL2pzL0dhbWVPYmplY3RzL0dhbWVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvR2FtZU9iamVjdHMvTW92aW5nR2FtZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cy9QbGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvR2FtZU9iamVjdHMvVW5pdC5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9JbnRlcnZhbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvTG9jYXRpb25zL0Fic3RyYWN0TG9jYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvTG9jYXRpb25zL0RyZWFtVG93bi9BcmVhcy5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9Mb2NhdGlvbnMvRHJlYW1Ub3duL0VsZXZhdG9yLmpzIiwid2VicGFjazovLy8uLi9jbGllbnQvc3JjL2pzL0xvY2F0aW9ucy9EcmVhbVRvd24vRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvTG9jYXRpb25zL0RyZWFtVG93bi9Mb2NhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9Mb2NhdGlvbnMvRHJlYW1Ub3duL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9jbGllbnQvc3JjL2pzL01vZGVscy5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9QYXJ0aWNsZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL2NsaWVudC9zcmMvanMvUGF0aEZpbmRlci5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9TY2VuZS5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9Vbml0cy5qcyIsIndlYnBhY2s6Ly8vLi4vY2xpZW50L3NyYy9qcy9VdGlscy9BU3Rhci5qcyIsIndlYnBhY2s6Ly8vLi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aHJlZS9zcmMvY29yZS9MYXllcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb3JlL09iamVjdDNELmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9FdWxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvTWF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvTWF0cml4My5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvTWF0cml4NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvUXVhdGVybmlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvVmVjdG9yMy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvZXZlbnQtdGFyZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvZXh0ZW5zaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvc2VuZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvc3RyZWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93cy9saWIvdmFsaWRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL01vY2tEZXBlbmRlbmNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvY2tldFNlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9zdGFuZGFsb25lLXNlcnZlci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldmVudHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5ldFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInBhdGhcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzdHJlYW1cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ0bHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1cmxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ6bGliXCIiXSwibmFtZXMiOlsiQXV0b0JpbmRNZXRob2RzIiwiZnVuY3Rpb25OYW1lcyIsIm9iaiIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiY29uY2F0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZpbHRlciIsIm5hbWUiLCJpbmRleE9mIiwiZnVuY3Rpb25OYW1lIiwiYmluZCIsIkNhbWVyYSIsInNjZW5lIiwicmF0aW8iLCJnZXRXaWR0aCIsImdldEhlaWdodCIsImNhbWVyYSIsIlRIUkVFIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJwb3NpdGlvbiIsInNldCIsImRlbHRhWSIsInJvdGF0ZVkiLCJkZWZhdWx0RGlzdGFuY2UiLCJkaXN0YW5jZSIsInJheWNhc3RlciIsIlJheWNhc3RlciIsImdhbWVUaW1lIiwiZGVsdGFUaW1lIiwiaW5wdXQiLCJwbGF5ZXIiLCJnZXRQbGF5ZXIiLCJsb29rIiwiY2luZW1hdGljIiwibG9va0F0IiwiVmVjdG9yMyIsInNlbnNpdGl2aXR5IiwidmVydGljYWwiLCJpc1RoaXJkUGVyc29uIiwidXBkYXRlVGhpcmRQZXJzb24iLCJjb3B5IiwiY2xvbmUiLCJhZGQiLCJ5IiwicmVuZGVyZXIiLCJnZXRDb250ZXh0IiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJjaGlsZHJlbiIsInBsYXllckhlYWRQb3NpdGlvbiIsIm9yaWdpbiIsImRlc3RpbmF0aW9uIiwiZGlyZWN0aW9uIiwiZ2V0Q2hpbGRyZW5GbGF0Iiwib2JqZWN0cyIsIm1hcCIsImVudmlyb25tZW50IiwiZmluZCIsImMiLCJmbGF0Q2hpbGRyZW5NZXNoZXMiLCJ0eXBlIiwic3ViVmVjdG9ycyIsIm5vcm1hbGl6ZSIsImZhciIsImludGVyc2VjdHMiLCJpbnRlcnNlY3RPYmplY3RzIiwiTWF0aCIsIm1pbiIsImkiLCJwbGF5ZXJGb3J3YXJkIiwiZ2V0Rm9yd2FyZCIsIm11bHRpcGx5U2NhbGFyIiwiYmFjayIsImNhbWVyYUZvcndhcmQiLCJhcHBseVF1YXRlcm5pb24iLCJxdWF0ZXJuaW9uIiwic3ViIiwid2lkdGhIYWxmIiwiaGVpZ2h0SGFsZiIsImNvcGllZFByb2plY3RWZWN0b3IiLCJwcm9qZWN0IiwieCIsInJvdW5kIiwieiIsIkNvbGxpZGVycyIsImNvbGxpZGVycyIsIm5leHRJZCIsImdhbWVPYmplY3QiLCJjb2xsaWRlciIsImZuIiwiaWQiLCJpZHgiLCJmaW5kSW5kZXgiLCJzcGxpY2UiLCJwdXNoIiwicGF0aEZpbmRlciIsInJlYnVpbGRBcmVhcyIsIkNvbm5lY3Rpb24iLCJpcCIsInBvcnQiLCJpc1NlY3VyZSIsIm1ldGEiLCJuZXR3b3JrUGxheWVycyIsIm5ldHdvcmtBSXMiLCJsYXN0UmVxdWVzdCIsIkRhdGUiLCJub3ciLCJwaW5nIiwiV2ViU29ja2V0Iiwid2luZG93IiwiTW96V2ViU29ja2V0IiwiY29ubmVjdGlvbiIsIm9ub3BlbiIsImNvbnNvbGUiLCJsb2ciLCJvbmVycm9yIiwiZXJyb3IiLCJvbm1lc3NhZ2UiLCJvbk1lc3NhZ2UiLCJpbnRlcnZhbHMiLCJzZXRJbnRlcnZhbCIsInNlbmRHYW1lT2JqZWN0cyIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJyZXNwb25zZSIsIm1lc3NhZ2VUeXBlIiwicm9sZSIsInVpIiwic2V0Q29ubmVjdGlvblJvbGUiLCJob3N0VW5pdHNGcm9tTmV0d29yayIsImRlYnVnIiwiY2xlYXJMb2NhbEdhbWVPYmplY3RzIiwicHJvY2Vzc0hhbmRzaGFrZSIsImxvY2F0aW9uIiwicmVsb2FkIiwic2V0UGxheWVyUGFyYW1zIiwidW5pdHMiLCJzZXREZWZhdWx0UGxheWVyUGFyYW1zIiwidXBkYXRlR2FtZU9iamVjdHMiLCJyZW1vdmVEaXNjb25uZWN0ZWRQbGF5ZXIiLCJlIiwic2VuZCIsImdhbWVPYmplY3RzU2VydmljZSIsImdldFVuaXRzIiwiZm9yRWFjaCIsInVuaXQiLCJwYXJhbXMiLCJmcm9tTmV0d29yayIsImRlc3Ryb3lHYW1lT2JqZWN0IiwidXNlciIsInVzZXJOYW1lIiwicGFzc3dvcmQiLCJ0b2tlbiIsImdldEhhc2giLCJzdHJpbmdpZnkiLCJnYW1lT2JqZWN0cyIsInVwZGF0ZU5ldHdvcmtQbGF5ZXIiLCJ1cGRhdGVOZXR3b3JrQUkiLCJjb25uZWN0aW9uSWQiLCJkaXNjb25uZWN0ZWRQbGF5ZXIiLCJQbGF5ZXIiLCJkaWUiLCJzdHIiLCJoYXNoMzIiLCJsIiwiaHZhbCIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJ0b1N0cmluZyIsInN1YnN0ciIsImgxIiwiZ2V0QWxpdmVVbml0cyIsInBsYXllckRhdGEiLCJsb2NhdGlvbk5hbWUiLCJyb3RhdGlvbiIsImFuaW1hdGlvblN0YXRlIiwidW5pdE5ldHdvcmtJZCIsImdldExvY2F0aW9uTmFtZSIsIm5ldHdvcmtQbGF5ZXIiLCJjcmVhdGVOZXR3b3JrUGxheWVyIiwiYWNjZWxlcmF0aW9uIiwicGxheWVyUGFyYW1zIiwiaG9yaXpvbnRhbCIsImF0dGFjazEiLCJhdHRhY2syIiwiaHAiLCJocE1heCIsImZyYWN0aW9uIiwiZGFtYWdlIiwic3BlZWQiLCJtb25leSIsImxldmVsIiwidW5zcGVudFRhbGVudHMiLCJleHBlcmllbmNlIiwidW5pdERhdGEiLCJpc1J1bm5pbmciLCJpc0F0dGFjayIsInNjYWxlIiwibmV0d29ya0FJIiwiY3JlYXRlTmV0d29ya0FJIiwib2JqZWN0IiwibmV0d29ya0FJUGFyYW1zIiwicmVhZHlTdGF0ZSIsInVuaXRUb05ldHdvcmsiLCJ1bml0Um90YXRpb24iLCJ0b1ZlY3RvcjMiLCJnZXRSYW5kb21TdHJpbmciLCJyYW5kb20iLCJ2ZWN0b3JUb09iamVjdCIsInZlY3RvciIsImVwcyIsIkdhbWVPYmplY3RzU2VydmljZSIsIm5leHRHYW1lT2JqZWN0SWQiLCJ0aW1lIiwidXBkYXRlIiwiYXR0YWNraW5nVW5pdCIsImlzRGVhZCIsInNldFRpbWVvdXQiLCJnZXRUaW1lUGFzc2VkIiwiaXNBdHRhY2tJbnRlcnJ1cHRlZCIsInJlbGVhc2VBdHRhY2siLCJhdHRhY2tlZFVuaXRzIiwiaXNBbGl2ZSIsImlzRW5lbXkiLCJkaXN0YW5jZVRvIiwiY29sbGlzaW9uR2FtZU9iamVjdCIsImRhbWFnZVRha2VuIiwiZ2V0QXR0YWNrVGltZW91dCIsImZpcmluZ0dhbWVPYmplY3QiLCJjcmVhdGVMaWdodEN1YmUiLCJsZWZ0IiwibW9kZWxzIiwiY3JlYXRlQ3ViZSIsImVtaXNzaXZlIiwiTnVtYmVyIiwibm9TY2VuZSIsIk9iamVjdDNEIiwiZ2V0RmlyZUluaXRpYWxQb3NpdGlvbiIsImdldEZpcmVJbml0aWFsUm90YXRpb24iLCJmaXJlR2FtZU9iamVjdCIsImhvb2tHYW1lT2JqZWN0IiwiRmlyZSIsInRocm90dGxpbmciLCJmaXJlU2hlbGxTcGVlZCIsImZpcmVEYW1hZ2UiLCJwYXJlbnQiLCJjaGVja1dheSIsImdldENvbGxpc2lvbnMiLCJVbml0IiwiZGVzdHJveSIsIm1vZGVsIiwiY2FuUGlja3VwIiwib25QaWNrdXAiLCJsb2FkR0xURiIsImJhc2VVcmwiLCJjYWxsYmFjayIsImxvYWRlZE9iamVjdCIsInBvc2l0aW9uVmVjdG9yIiwidHJhdmVyc2UiLCJjaGlsZCIsImlzTWVzaCIsIm1hdGVyaWFsIiwidHJhbnNwYXJlbnQiLCJhbHBoYVRlc3QiLCJnYW1lSXRlbSIsIkFuaW1hdGVkR2FtZU9iamVjdCIsImFuaW1hdGlvbnMiLCJjaGVja1BpY2t1cCIsImdldFByaW9yaXR5IiwiY2VpbCIsIm5lYXJVbml0cyIsInNvcnQiLCJ1bml0QSIsInVuaXRCIiwiaXNEaWUiLCJfX2dhbWVfb2JqZWN0X2lkIiwiZ2V0TmV4dE5vblBsYXllckluZGV4IiwiZ28iLCJyZW1vdmVJZHgiLCJyZW1vdmVHYW1lT2JqZWN0RnJvbVNjZW5lIiwiaW5kZXgiLCJyZW1vdmUiLCJBSSIsIm1hcyIsImZpcmVUaW1lb3V0IiwiYXR0YWNrVGltZW91dCIsImp1bXBUaW1lb3V0Iiwic3RhcnRSdW5UaW1lb3V0IiwibmV4dFBvaW50VXBkYXRlVGltZW91dCIsInVwZGF0ZVRhcmdldFRpbWVvdXQiLCJib3VudHkiLCJsYXN0UnVuIiwibGFzdFRhcmdldFVwZGF0ZSIsImxhc3ROZXh0UG9pbnRVcGRhdGUiLCJsYXN0SnVtcFRpbWVzdGFtcCIsImZpbmRUYXJnZXQiLCJpc1VwZGF0ZVRhcmdldFJlbGVhc2VkIiwidGFyZ2V0IiwiZ2V0TmV4dFBvaW50IiwiaXNOZXh0UG9pbnRVcGRhdGVSZWxlYXNlZCIsIm5leHRQb2ludCIsImlzVGFyZ2V0TmVhciIsInJvdGF0ZVRvUG9zaXRpb24iLCJpc05leHRQb2ludE5lYXIiLCJpc1J1blJlbGVhc2VkIiwiaXNBdHRhY2tSZWxlYXNlZCIsImlzSGl0UmVsZWFzZWQiLCJhdHRhY2siLCJpc01vdmluZ0ZvcndhcmQiLCJpc0FjY2VsZXJhdGlvbiIsImp1bXBIZWlnaHQiLCJkeCIsImR5IiwiZHoiLCJpc0p1bXBOZWVkZWQiLCJpc0dyb3VuZGVkIiwicm90YXRpb25Ub1RhcmdldFJhZGlhbnMiLCJhdGFuMiIsInRhcmdldFF1YXRlcm5pb24iLCJRdWF0ZXJuaW9uIiwic2V0RnJvbUV1bGVyIiwic2xlcnAiLCJhYnMiLCJhdHRhY2tlciIsIkZpcmluZ1VuaXQiLCJhbmltYXRpb25OYW1lcyIsInN0YW5kIiwicnVuIiwianVtcCIsInJvdGF0ZUxlZnQiLCJyb3RhdGVSaWdodCIsInJ1bkxlZnQiLCJydW5SaWdodCIsIndhbGtCYWNrIiwic3Bhd24iLCJoaXQiLCJ0b3BSdW4iLCJib3R0b21SdW4iLCJ0b3BXYWxrQmFjayIsImJvdHRvbVdhbGtCYWNrIiwidG9wQXR0YWNrIiwiYm90dG9tQXR0YWNrIiwidG9wU3RhbmQiLCJib3R0b21TdGFuZCIsInRvcFJ1blJpZ2h0IiwidG9wUnVuTGVmdCIsInRvcEp1bXAiLCJ0b3BIaXQiLCJib3R0b21SdW5SaWdodCIsImJvdHRvbVJ1bkxlZnQiLCJib3R0b21KdW1wIiwiYm90dG9tSGl0IiwidG9wRGllIiwiYm90dG9tRGllIiwidG9wU3Bhd24iLCJib3R0b21TcGF3biIsInRvcEFuaW1hdGlvbnMiLCJib3R0b21BbmltYXRpb25zIiwidG9wQm9uZXMiLCJib3R0b21Cb25lcyIsInNwYXduVGltZW91dCIsImlzTW92aW5nUmlnaHQiLCJpc01vdmluZ0xlZnQiLCJpc01vdmluZ0JhY2t3YXJkIiwiaXNSb3RhdGVMZWZ0IiwiaXNSb3RhdGVSaWdodCIsImlzSnVtcCIsImlzSGl0IiwiaXNTcGF3biIsInBsYXlpbmdBbmltYXRpb25zIiwibGVnc1JvdGF0aW9uWSIsInNwYXduVGltZSIsIm1peGVyIiwiQW5pbWF0aW9uTWl4ZXIiLCJpbml0QW5pbWF0aW9ucyIsImlzU3Bhd25GaW5pc2hlZCIsImNvbXBsZXhBbmltYXRpb25zIiwidXBkYXRlQ29tcGxleEFuaW1hdGlvbnMiLCJhbmltYXRpb24iLCJnZXRDdXJyZW50QW5pbWF0aW9uIiwicGxheUFuaW1hdGlvbiIsImZvcmNlIiwiX2NsaXAiLCJhbmltYXRpb25OYW1lIiwic2hvdWxkVXBkYXRlIiwicGxheWluZ0FuaW1hdGlvbk5hbWUiLCJyZXNldCIsInBsYXkiLCJwbGF5aW5nQW5pbWF0aW9uIiwiZnJvbSIsImVuYWJsZWQiLCJjcm9zc0ZhZGVUbyIsImtleXMiLCJyZWR1Y2UiLCJyZXN1bHQiLCJrZXkiLCJleGNsdWRlZEJvbmVzIiwiaW5jbHVkZXMiLCJtb2RlbEFuaW1hdGlvbiIsImZpbmRNb2RlbEFuaW1hdGlvbiIsImluaXRlZEFuaW1hdGlvbiIsImNyZWF0ZUNsaXBBY3Rpb24iLCJjbGFtcEFuaW1hdGlvbiIsInNldExvb3AiLCJMb29wT25jZSIsImNsYW1wV2hlbkZpbmlzaGVkIiwiYXR0YWNrQW5pbWF0aW9uIiwic2V0RHVyYXRpb24iLCJhY3Rpb24iLCJjbGlwQWN0aW9uIiwic3RvcCIsImNsZWFyQW5pbWF0aW9uQm9uZXMiLCJib25lcyIsImdldEJvbmVOYW1lIiwiaXRlbSIsInNwbGl0IiwiaXNOb3RFeGNsdWRlZCIsInRyYWNrcyIsInRvcCIsImJvdHRvbSIsImxlZ3NSb3RhdGlvbkJvbmUiLCJnZXRDaGlsZEJ5TmFtZSIsImJsZW5kQW5pbWF0aW9ucyIsImdldEFuaW1hdGlvbk5hbWUiLCJhIiwiZnJvbUFuaW1hdGlvbiIsImZyb21BbmltYXRpb25OYW1lIiwiR2FtZU9iamVjdCIsImNvbGxpc2lvbnMiLCJNb3ZpbmdHYW1lT2JqZWN0Iiwic2hvdWxkRmlyZSIsImxhdGVzdEZpcmUiLCJnZXRVcCIsImlzRmlyZSIsImZpcmUiLCJpc0ZpcmVSZWxlYXNlZCIsImV2ZW50cyIsImV2ZW50TmFtZSIsImFyZ3MiLCJnZXRPYmplY3RCeU5hbWUiLCJhcmciLCJnZXRDaGlsZFJvdGF0aW9uIiwic2V0RnJvbU1hdHJpeFBvc2l0aW9uIiwibWF0cml4V29ybGQiLCJnZXRXb3JsZFF1YXRlcm5pb24iLCJpc1giLCJCb29sZWFuIiwiaXNZIiwiaXNaIiwiaXNDbGltYmluZyIsImlzTW92aW5nIiwibmV4dFBvc2l0aW9uIiwiZ2V0RGlyZWN0aW9uIiwidG9BcnJheSIsInIiLCJ2Iiwicm90YXRpb25BY2NlbGVyYXRpb24iLCJvbkxldmVsVXAiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0TW92aW5nQWNjZWxlcmF0aW9uIiwiaG9yaXpvbnRhbExvb2siLCJyZXNldEhvcml6b250YWxMb29rIiwiQ0FMQ19ST1RBVEVfVEhSRVNIT0xEIiwicm90YXRlT25Xb3JsZEF4aXMiLCJkZWx0YVgiLCJpbm5lcldpZHRoIiwiY3Vyc29yIiwiaW5uZXJIZWlnaHQiLCJyb3RhdGlvblkiLCJoZWFkIiwiaGVhZEZvcndhcmQiLCJnZXRDaGlsZERpcmVjdGlvbiIsImhlYWRVcCIsImdldENoaWxkUG9zaXRpb24iLCJnZXRMZXZlbCIsImxldmVsc1VwIiwiZGlzcGF0Y2hFdmVudCIsInBvdyIsImZsb29yIiwic3FydCIsImFkZEZvcndhcmQiLCJhZGRTaWRlIiwiaGl0VGltZSIsImF0dGFja0RhbWFnZVRpbWVvdXQiLCJzaG91bGRBdHRhY2siLCJsYXRlc3RBdHRhY2tUaW1lc3RhbXAiLCJsYXRlc3RIaXRUaW1lc3RhbXAiLCJoaXRSZWxlYXNlZCIsImRpZmZZIiwiaW50ZXJydXB0QnlDaGFuY2UiLCJpbnRlcnJ1cHRCeUxldmVsIiwic2hvdWxkQmVJbnRlcnJ1cHRlZCIsImtpbGxpbmdVbml0IiwiS0VZUyIsIk1PVVNFX0xFRlQiLCJNT1VTRV9SSUdIVCIsIlNQQUNFIiwiRU5URVIiLCJFU0MiLCJDIiwiVyIsIkEiLCJTIiwiRCIsIlgiLCJaIiwiUSIsIkUiLCJSIiwiRiIsIlYiLCJBUlJPV19MRUZUIiwiQVJST1dfUklHSFQiLCJBUlJPV19VUCIsIkFSUk9XX0RPV04iLCJJbnB1dCIsIm1vdXNlIiwiYWRkRXZlbnRMaXN0ZW5lcnMiLCJkb2N1bWVudCIsIndoaWNoIiwidGltZW91dCIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsImN1cnNvclgiLCJjdXJzb3JZIiwidW5kZWZpbmVkIiwiY2xlYXJUaW1lb3V0IiwiRXZlbnQiLCJvbkFjdGlvbiIsIm9uRXhpdCIsIm9uU3dpdGNoQ2FtZXJhIiwib25ab29tIiwiSW50ZXJ2YWxzIiwidGltZVBhc3NlZCIsImxhc3RGcmFtZSIsImludGVydmFsSW5kZXgiLCJjYWxsZWRBdCIsImludGVydmFsIiwibG9vcHMiLCJjbGVhckludGVydmFsIiwiaW1tZWRpYXRlbHkiLCJpbnRlcnZhbElkeCIsIkFic3RyYWN0TG9jYXRpb24iLCJhbWJpZW50TGlnaHQiLCJBbWJpZW50TGlnaHQiLCJjYXN0U2hhZG93IiwibGlnaHQiLCJEaXJlY3Rpb25hbExpZ2h0IiwiaW50ZW5zaXR5Iiwic2hhZG93IiwiYmlhcyIsInNoYWRvd1NpemUiLCJyaWdodCIsIm1hcFNpemUiLCJuZWFyIiwidmlzaWJsZSIsIm1hdGVyaWFsQXJyYXkiLCJ1cmwiLCJNZXNoQmFzaWNNYXRlcmlhbCIsIlRleHR1cmVMb2FkZXIiLCJsb2FkIiwic2lkZSIsIkJhY2tTaWRlIiwiZm9nIiwic2t5R2VvbWV0cnkiLCJDdWJlR2VvbWV0cnkiLCJza3lNYXRlcmlhbCIsIk1lc2hGYWNlTWF0ZXJpYWwiLCJNZXNoIiwiYnVpbGRBcmVhIiwiYXJlYUlkIiwiQXJlYVNpemVzIiwid2F5cG9pbnRYVG9Xb3JsZFgiLCJ3YXlwb2ludFlUb1dvcmxkWiIsIndvcmxkWFRvV2F5cG9pbnRYIiwiZ3JhcGhYIiwibWF4Iiwid29ybGRaVG9XYXlwb2ludFkiLCJncmFwaFkiLCJhcmVhIiwiRkxPT1JfMCIsIkZMT09SXzEiLCJGTE9PUl8yIiwiQXJlYXMiLCJpbmNsdWRlc1Bvc2l0aW9uIiwiZ2V0V29ybGRXYXlwb2ludEJ5WFkiLCJnZXRXYXlwb2ludFBvcnRhbHMiLCJ0byIsIkVsZXZhdG9yIiwiY3VycmVudEZsb29yIiwic3RhbmRUaW1lIiwic3RhbmRBdCIsImlzUmVsZWFzZWQiLCJnZXRGbG9vciIsImdldENhcnJ5aW5nUG9zaXRpb24iLCJjYXJyeWluZ1VuaXRzIiwiaXNDYXJyeWluZyIsInRoaXNBY2NlbGVyYXRpb24iLCJjcmVhdGVFbnZpcm9ubWVudCIsInRyZWVzIiwiaG91c2VzIiwiYWRkQ29sbGlkZXJGdW5jdGlvbiIsIm9uTG9hZCIsInBpdm90IiwibWF0cml4QXV0b1VwZGF0ZSIsImlzRW52aXJvbm1lbnRMb2FkZWQiLCJpc1RyZWVMb2FkZWQiLCJpc0hvdXNlTG9hZGVkIiwiY2hlY2tJc0FsbExvYWRlZCIsInVwZGF0ZU1hdHJpeCIsInJlY2VpdmVTaGFkb3ciLCJsb2FkZWRNb2RlbCIsInJ4IiwicnkiLCJyeiIsInVuaXRQb3NpdGlvbiIsIkxvY2F0aW9uIiwic2hhZG93TGlnaHRQb3NpdGlvbiIsInNldExvYWRpbmciLCJzZXRQYXVzZSIsIlBJIiwibm90aWZ5Iiwic3RhcnRMb2NhdGlvbiIsImNyZWF0ZUFtYmllbnRMaWdodCIsInNoYWRvd0xpZ2h0IiwiY3JlYXRlU2hhZG93TGlnaHQiLCJlbGV2YXRvciIsImNvbG9yIiwiRm9nIiwiY3JlYXRlTG9jYXRpb25Db2xsaWRlcnMiLCJwYXJ0aWNsZXMiLCJjcmVhdGVFZmZlY3QiLCJlZmZlY3QiLCJhdHRhY2hUbyIsImNyZWF0ZVBsYXllciIsIm9uQ3JlYXRlIiwidXBkYXRlUGxheWVyUGFyYW1zIiwib25EaWUiLCJvbktpbGwiLCJhZGRFeHBlcmllbmNlIiwiYWRkTW9uZXkiLCJvbkRhbWFnZVRha2VuIiwib25Mb2NhdGlvblVwIiwiY3JlYXRlSW50ZXJhY3RpdmVHYW1lT2JqZWN0cyIsImNsZWFyU2NlbmUiLCJyZW1vdmVBbGxFeGNlcHRQbGF5ZXIiLCJjcmVhdGVIZWFsSXRlbSIsIml0ZW1IZWFsUG9zaXRpb24iLCJjcmVhdGVJdGVtIiwiZ2V0TWF4SFAiLCJnZXRIUCIsImFkZEhQIiwiZ2V0QUlQYXJhbXMiLCJjcmVhdGVBSSIsImdldEdvYXRzUGFyYW1zIiwiZ2V0RnJpZW5kbHlQYXJhbXMiLCJpc0JldHdlZW4iLCJhYnNYIiwiYWJzWiIsImFyZWFzIiwidmFsdWVzIiwiZ2VuZXJhdGVXYXlwb2ludHMiLCJBcnJheSIsImZpbGwiLCJudWxsMSIsIm51bGwyIiwiZ2V0V2F5cG9pbnRzIiwiY2hlY2tXYXlGb3JXYXlwb2ludCIsImNoZWNrTmVhciIsInJhbmdlIiwiZGlhZ29uYWwiLCJNb2RlbHMiLCJtYXRlcmlhbFBhcmFtcyIsImltYWdlIiwidGV4dHVyZSIsIndyYXBTIiwiUmVwZWF0V3JhcHBpbmciLCJ3cmFwVCIsInJlcGVhdCIsInJlcGVhdFgiLCJyZXBlYXRZIiwiQ29sb3IiLCJlbWlzc2l2ZUludGVuc2l0eSIsImVtaXNzaXZlTWFwIiwiY3ViZSIsIk1lc2hMYW1iZXJ0TWF0ZXJpYWwiLCJpc0dMVEYiLCJsb2FkZXIiLCJHTFRGTG9hZGVyIiwiUGFydGljbGVzIiwicCIsImNyZWF0ZVBhcnRpY2xlcyIsInBhcnRpY2xlQ291bnQiLCJibGVuZGluZyIsIk5vcm1hbEJsZW5kaW5nIiwiZ2V0UGFydGljbGVQb3NpdGlvbiIsImdldFJhbmRvbVBvc2l0aW9uIiwibmV3UG9zaXRpb24iLCJsaWZlVGltZSIsInBhcnRpY2xlTmFtZSIsImdsdGYiLCJwYXJ0aWNsZVN5c3RlbSIsInNpemUiLCJBZGRpdGl2ZUJsZW5kaW5nIiwiZGVwdGhUZXN0IiwiZ2V0UGFydGljbGVWZWxvY2l0eSIsIkdlb21ldHJ5IiwiUG9pbnRDbG91ZE1hdGVyaWFsIiwicGFydGljbGUiLCJ2ZWxvY2l0eSIsInZlcnRpY2VzIiwiUG9pbnRDbG91ZCIsInBhcnRpY2xlUG9zaXRpb24iLCJ2ZXJ0aWNlc05lZWRVcGRhdGUiLCJnZXRBcmVhQnlQb3NpdGlvbiIsImZyb21YIiwiZnJvbVkiLCJhcmVhVG8iLCJ0b1giLCJ0b1kiLCJwb3J0YWwiLCJzdGFydCIsImdldEZyZWVHcmFwaFBvaW50IiwiZ3JhcGgiLCJlbmQiLCJBU3RhciIsImFzdGFyIiwic2VhcmNoIiwiaGV1cmlzdGljIiwiaGV1cmlzdGljcyIsIm5leHRHcmFwaFBvaW50IiwibmV4dFdvcmxkUG9pbnQiLCJncmlkIiwiZ2V0V2VpZ2h0Iiwid2VpZ2h0IiwiZ2V0TmVhckZyZWVQb2ludCIsImdldEFyZWFzIiwiR3JhcGgiLCJTY2VuZSIsImNsb2NrIiwiQ2xvY2siLCJQYXRoRmluZGVyIiwiVW5pdHMiLCJpc1BhdXNlIiwiem9vbSIsImFkZFkiLCJzd2l0Y2hDYW1lcmEiLCJjb25uZWN0aW9uSG9zdG5hbWUiLCJob3N0bmFtZSIsImlzU1NMIiwic2V0RnBzIiwiZnBzIiwidGFyZ2V0RnBzIiwic2V0UGluZyIsImFuaW1hdGUiLCJyZW1vdmVBbGwiLCJhZnRlckNsZWFyIiwiZ2V0RGVsdGFUaW1lIiwicmVuZGVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGV4dCIsImRlZmF1bHRQYXJhbXMiLCJvbkRhbWFnZURlYWwiLCJkYW1hZ2VkVW5pdCIsImxvYWRFZmZlY3QiLCJraWxsZXIiLCJuZXR3b3JrQ29ubmVjdGlvbiIsImFpIiwibmVhckVuZW15VW5pdHMiLCJnZXRGcmFjdGlvbiIsImRlZmluaXRpb24iLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmaW5lIiwicGF0aFRvIiwibm9kZSIsImN1cnIiLCJwYXRoIiwidW5zaGlmdCIsImdldEhlYXAiLCJCaW5hcnlIZWFwIiwiZiIsIm9wdGlvbnMiLCJjbGVhbkRpcnR5IiwibWFuaGF0dGFuIiwiY2xvc2VzdCIsIm9wZW5IZWFwIiwiY2xvc2VzdE5vZGUiLCJoIiwibWFya0RpcnR5IiwiY3VycmVudE5vZGUiLCJwb3AiLCJjbG9zZWQiLCJuZWlnaGJvcnMiLCJpbCIsIm5laWdoYm9yIiwiaXNXYWxsIiwiZ1Njb3JlIiwiZyIsImdldENvc3QiLCJiZWVuVmlzaXRlZCIsInZpc2l0ZWQiLCJyZXNjb3JlRWxlbWVudCIsInBvczAiLCJwb3MxIiwiZDEiLCJkMiIsIkQyIiwiY2xlYW5Ob2RlIiwiZ3JpZEluIiwibm9kZXMiLCJyb3ciLCJHcmlkTm9kZSIsImluaXQiLCJkaXJ0eU5vZGVzIiwicmV0IiwiZ3JhcGhTdHJpbmciLCJyb3dEZWJ1ZyIsImpvaW4iLCJmcm9tTmVpZ2hib3IiLCJzY29yZUZ1bmN0aW9uIiwiY29udGVudCIsImVsZW1lbnQiLCJzaW5rRG93biIsImJ1YmJsZVVwIiwibiIsInBhcmVudE4iLCJlbGVtU2NvcmUiLCJjaGlsZDJOIiwiY2hpbGQxTiIsInN3YXAiLCJjaGlsZDFTY29yZSIsImNoaWxkMSIsImNoaWxkMiIsImNoaWxkMlNjb3JlIiwiU2VydmVyIiwiZ2xvYmFsIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiT2JqM0QiLCJwcm9wcyIsIldlYkdMUmVuZGVyZXIiLCJzZXRTaXplIiwic2hhZG93TWFwIiwiQ2FjaGUiLCJQQ0ZTb2Z0U2hhZG93TWFwIiwiYm9keSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJnZXRFbGVtZW50QnlJZCIsIk1vY2tHVUkiLCJpc1NlcnZlciIsInNldFJlc3RhcnRCdXR0b25WaXNpYmxlIiwicmVzdGFydEdhbWUiLCJjbGVhckhwQmFycyIsIk1vY2tSZW5kZXJlciIsIldlYlNvY2tldFNlcnZlciIsIndzIiwiU29ja2V0U2VydmVyIiwiY3JlYXRlV2ViU2VydmVyIiwiY3JlYXRlU29ja2V0U2VydmVyIiwic2F2ZVVzZXJEYXRhIiwibG9hZFVzZXJEYXRhIiwic3RhcnRTb2NrZXRTZXJ2ZXIiLCJnZXRDb25uZWN0aW9uSWQiLCJzZW5kVG9Db25uZWN0aW9uIiwiaXNQcm9kdWN0aW9uIiwicHJvY2VzcyIsImNvbmZpZyIsInNzbCIsInNzbEtleSIsIl9fZGlybmFtZSIsInNzbENlcnRpZmljYXRlIiwic2Vzc2lvbnNQYXRoIiwiZGIiLCJzZXF1ZW5jZUlkIiwiaG9zdElkIiwiY29ubmVjdGlvbnMiLCJwbGF5ZXJzIiwic29ja2V0U2VydmVyIiwicHJvY2Vzc1JlcXVlc3QiLCJyZXEiLCJyZXMiLCJ3cml0ZUhlYWQiLCJzc2xQYXJhbXMiLCJmcyIsImNlcnQiLCJyZXF1aXJlIiwiY3JlYXRlU2VydmVyIiwibGlzdGVuIiwic2VydmVyIiwid2ViU29ja2V0U2VydmVyIiwidG9rZW5QYXRoIiwiX2lkIiwicGxheWVyQ29ubmVjdGlvbklkIiwiU3RyaW5nIiwidmVyc2lvbiIsIl9tZXRhIiwiZ2V0Q29ubmVjdGlvblRva2VuIiwiY29ubmVjdGlvblBsYXllciIsIm9uIiwib25Tb2NrZXRDbG9zZSIsIm9uU29ja2V0TWVzc2FnZSIsIm1lc3NhZ2UiLCJzZW5kVXNlckRhdGEiLCJ1cGRhdGVQbGF5ZXJEYXRhIiwic2NlbmVMb2NhdGlvbiIsInNjZW5lQ29sbGlkZXJzIiwic2NlbmVBcmVhcyIsImFsaXZlVW5pdHMiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNB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QTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBTztBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pMUDtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVB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LEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsY0FBYyw4Q0FBSzs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7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RTdCOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxhQUFhLGFBQWE7QUFDeEMsY0FBYyxhQUFhLGFBQWE7QUFDeEMsY0FBYyxhQUFhLGNBQWM7QUFDekMsY0FBYyxhQUFhLGdCQUFnQjs7QUFFM0M7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGFBQWEsYUFBYTtBQUM1QyxjQUFjLGlCQUFpQixhQUFhO0FBQzVDLGNBQWMsYUFBYSxvQkFBb0I7QUFDL0MsY0FBYyxhQUFhLGNBQWM7O0FBRXpDOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7OztBQUdrQjs7Ozs7Ozs7Ozs7OztBQ3o1Qm5CO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSxrQ0FBa0MsOENBQUs7O0FBRXZDLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSxDQUFDOzs7QUFHcUI7Ozs7Ozs7Ozs7Ozs7QUMzbkJ0QjtBQUFBO0FBQUE7QUFBQTtBQUFrQztBQUNXOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHlEQUFVOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiw4Q0FBSzs7QUFFekIsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOzs7QUFHa0I7Ozs7Ozs7Ozs7OztBQ3ZzQm5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQywyREFBaUI7O0FBRTNDLGtDQUFrQyxtQkFBTyxDQUFDLHFEQUFjO0FBQ3hELG1CQUFtQixtQkFBTyxDQUFDLHlFQUF3QjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQyx5REFBZ0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMscURBQWM7O0FBRXpDOzs7Ozs7Ozs7Ozs7O0FDVGE7O0FBRWIsT0FBTyxlQUFlLEdBQUcsbUJBQU8sQ0FBQyx1REFBYTs7QUFFOUM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxvSUFBWTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoSWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1RhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDaExhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLG1CQUFtQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPLDZCQUE2QjtBQUNwQztBQUNBLGlFQUFpRSxFQUFFO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCwrREFBK0QsRUFBRTtBQUNqRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCwrREFBK0QsRUFBRTtBQUNqRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxFQUFFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxpRUFBaUUsRUFBRTtBQUNuRTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLGlFQUFpRSxFQUFFO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEVBQUUsR0FBRyxFQUFFO0FBQzFELDBCQUEwQjtBQUMxQixlQUFlO0FBQ2Y7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsa0JBQWtCOzs7Ozs7Ozs7Ozs7O0FDOU5MOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNyRGE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQixtQkFBbUIsbUJBQU8sQ0FBQywyREFBZTtBQUMxQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtREFBVztBQUNuQyxPQUFPLG9CQUFvQixHQUFHLG1CQUFPLENBQUMsdURBQWE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxJQUFJLEtBQUssTUFBTTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw4Q0FBOEMsSUFBSSxLQUFLLE1BQU07QUFDN0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSSxLQUFLLE1BQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSSxLQUFLLE1BQU07QUFDN0Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxnREFBZ0QsSUFBSTtBQUNwRDs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9mYTs7QUFFYixPQUFPLFdBQVcsR0FBRyxtQkFBTyxDQUFDLHNCQUFROztBQUVyQywwQkFBMEIsbUJBQU8sQ0FBQyx5RUFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRyxtQkFBTyxDQUFDLHVEQUFhO0FBQ3pCLE9BQU8sZ0NBQWdDLEdBQUcsbUJBQU8sQ0FBQywyREFBZTtBQUNqRSxPQUFPLGlDQUFpQyxHQUFHLG1CQUFPLENBQUMseURBQWM7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNB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QWtCO0FBQy9CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FB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OztBQW1CQXJDLGFBQVcsQ0FBQ21CLGlCQUFELEVBQW9CLEdBQXBCLENBQVg7QUFDQTs7QUFFY3lyQixxRUFBZixFOzs7Ozs7Ozs7OztBQ3REQSxtQzs7Ozs7Ozs7Ozs7QUNBQSxtQzs7Ozs7Ozs7Ozs7QUNBQSwrQjs7Ozs7Ozs7Ozs7QUNBQSxpQzs7Ozs7Ozs7Ozs7QUNBQSxrQzs7Ozs7Ozs7Ozs7QUNBQSxnQzs7Ozs7Ozs7Ozs7QUNBQSxpQzs7Ozs7Ozs7Ozs7QUNBQSxtQzs7Ozs7Ozs7Ozs7QUNBQSxnQzs7Ozs7Ozs7Ozs7QUNBQSxnQzs7Ozs7Ozs7Ozs7QUNBQSxpQyIsImZpbGUiOiJzZXJ2ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2luZGV4LmpzXCIpO1xuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0b0JpbmRNZXRob2RzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9uTmFtZXMgPSBbXTtcbiAgICAgICAgbGV0IG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcblxuICAgICAgICB3aGlsZSAob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqID09PSBPYmplY3QucHJvdG90eXBlIHx8IG9iaiA9PT0gQXV0b0JpbmRNZXRob2RzLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWVzID0gZnVuY3Rpb25OYW1lcy5jb25jYXQoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5maWx0ZXIobmFtZSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgIT09ICdjb25zdHJ1Y3RvcidcbiAgICAgICAgICAgICAgICAgICAgJiYgZnVuY3Rpb25OYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMVxuICAgICAgICAgICAgICAgICAgICAmJiB0eXBlb2YgdGhpc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGZ1bmN0aW9uTmFtZSBvZiBmdW5jdGlvbk5hbWVzKSB7XG4gICAgICAgICAgICB0aGlzW2Z1bmN0aW9uTmFtZV0gPSB0aGlzW2Z1bmN0aW9uTmFtZV0uYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuIiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYSBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzY2VuZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gdGhpcy5nZXRXaWR0aCgpIC8gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNDUsIHJhdGlvLCAxLCAxMDApO1xuICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXQoNSwgMywgMTUpO1xuICAgICAgICB0aGlzLmRlbHRhWSA9IDEwO1xuICAgICAgICB0aGlzLnJvdGF0ZVkgPSAwLjI1O1xuICAgICAgICB0aGlzLmRlZmF1bHREaXN0YW5jZSA9IDEwO1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gdGhpcy5kZWZhdWx0RGlzdGFuY2U7XG4gICAgICAgIHRoaXMucmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuICAgIH1cblxuICAgIHVwZGF0ZShnYW1lVGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgIGNvbnN0IHsgc2NlbmU6IHsgaW5wdXQgfSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5zY2VuZS5nZXRQbGF5ZXIoKTtcblxuICAgICAgICBpZiAoIXBsYXllcikgcmV0dXJuO1xuICAgIFxuICAgICAgICAvLyBFbmFibGVkIGlmIFwiRlwiIGlzIHByZXNzZWRcbiAgICAgICAgaWYgKGlucHV0Lmxvb2suY2luZW1hdGljKSB7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXQoLTQwLCAxNSwgMTApO1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEubG9va0F0KG5ldyBUSFJFRS5WZWN0b3IzKC01MCwgMCwgMCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGNvbnN0IHJvdGF0ZVkgPSB0aGlzLnJvdGF0ZVkgKyAoaW5wdXQubG9vay5zZW5zaXRpdml0eSAqIGlucHV0Lmxvb2sudmVydGljYWwgLyAyMDAwKTtcblxuICAgICAgICBpZiAocm90YXRlWSA+IC0wLjc1ICYmIHJvdGF0ZVkgPCAxLjI1KSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZVkgPSByb3RhdGVZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0LmlzVGhpcmRQZXJzb24pIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGhpcmRQZXJzb24ocGxheWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmNvcHkoXG4gICAgICAgICAgICAgICAgcGxheWVyLnBvc2l0aW9uLmNsb25lKClcbiAgICAgICAgICAgICAgICAgICAgLmFkZChuZXcgVEhSRUUuVmVjdG9yMyg3LjUsIHRoaXMuZGVsdGFZLCAwKSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLmxvb2tBdChwbGF5ZXIucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkWSh5KSB7XG4gICAgICAgIGlmICh0aGlzLmRlbHRhWSArIHkgPiAxICYmIHRoaXMuZGVsdGFZICsgeSA8IDI1KSB7XG4gICAgICAgICAgICB0aGlzLmRlbHRhWSArPSB5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5zY2VuZS5yZW5kZXJlci5yZW5kZXJlcjtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyLmdldENvbnRleHQoKS5jYW52YXMud2lkdGg7XG4gICAgfVxuXG4gICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuc2NlbmUucmVuZGVyZXIucmVuZGVyZXI7XG4gICAgICAgIHJldHVybiByZW5kZXJlci5nZXRDb250ZXh0KCkuY2FudmFzLmhlaWdodDtcbiAgICB9XG5cbiAgICB1cGRhdGVUaGlyZFBlcnNvbihwbGF5ZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY2VuZTogeyBzY2VuZTogeyBjaGlsZHJlbiB9IH0sIGRlbHRhWSB9ID0gdGhpcyxcbiAgICAgICAgICAgIHBsYXllckhlYWRQb3NpdGlvbiA9IHBsYXllci5wb3NpdGlvbi5jbG9uZSgpLmFkZChuZXcgVEhSRUUuVmVjdG9yMygwLCAxLjUsIDApKSxcbiAgICAgICAgICAgIG9yaWdpbiA9IHBsYXllckhlYWRQb3NpdGlvbixcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gdGhpcy5jYW1lcmEucG9zaXRpb24sXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIGNvbnN0IGdldENoaWxkcmVuRmxhdCA9IG9iamVjdHMgPT4gW10uY29uY2F0KC4uLm9iamVjdHMubWFwKFxuICAgICAgICAgICAgb2JqID0+IG9iai5jaGlsZHJlblxuICAgICAgICAgICAgICAgID8gW29iaiwgLi4uZ2V0Q2hpbGRyZW5GbGF0KG9iai5jaGlsZHJlbildXG4gICAgICAgICAgICAgICAgOiBbb2JqXVxuICAgICAgICApKTtcblxuICAgICAgICBjb25zdCBlbnZpcm9ubWVudCA9IFtjaGlsZHJlbi5maW5kKGMgPT4gYy5uYW1lID09PSAnTEVWRUxfRU5WSVJPTk1FTlQnKV07XG4gICAgICAgIGNvbnN0IGZsYXRDaGlsZHJlbk1lc2hlcyA9IGdldENoaWxkcmVuRmxhdChlbnZpcm9ubWVudCkuZmlsdGVyKG9iaiA9PiBvYmoudHlwZSA9PT0gJ01lc2gnKTtcblxuICAgICAgICB0aGlzLnJheWNhc3Rlci5zZXQob3JpZ2luLCBkaXJlY3Rpb24uc3ViVmVjdG9ycyhkZXN0aW5hdGlvbiwgb3JpZ2luKS5ub3JtYWxpemUoKSk7XG4gICAgICAgIHRoaXMucmF5Y2FzdGVyLmZhciA9IGRlbHRhWSAqIDEuNTtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0cyA9IHRoaXMucmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHMoZmxhdENoaWxkcmVuTWVzaGVzKTtcblxuICAgICAgICBsZXQgZGlzdGFuY2UgPSBNYXRoLm1pbihkZWx0YVksIC4uLmludGVyc2VjdHMubWFwKGkgPT4gaS5kaXN0YW5jZSAtIHRoaXMuZGlzdGFuY2UgKiAwLjUpKTtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSArPSAoZGlzdGFuY2UgLSB0aGlzLmRpc3RhbmNlKSAvIDI7XG5cbiAgICAgICAgY29uc3QgcGxheWVyRm9yd2FyZCA9IHBsYXllci5nZXRGb3J3YXJkKCkubXVsdGlwbHlTY2FsYXIodGhpcy5zY2VuZS5pbnB1dC5sb29rLmJhY2sgPyAxIDogLTEpO1xuXG4gICAgICAgIHBsYXllckZvcndhcmQueSA9IHRoaXMucm90YXRlWTtcbiAgICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uY29weShwbGF5ZXJIZWFkUG9zaXRpb24uY2xvbmUoKS5hZGQocGxheWVyRm9yd2FyZCkpO1xuXG4gICAgICAgIHRoaXMuY2FtZXJhLmxvb2tBdChwbGF5ZXJIZWFkUG9zaXRpb24pO1xuXG4gICAgICAgIGNvbnN0IGNhbWVyYUZvcndhcmQgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAtMSk7XG4gICAgICAgIGNhbWVyYUZvcndhcmQuYXBwbHlRdWF0ZXJuaW9uKHRoaXMuY2FtZXJhLnF1YXRlcm5pb24pO1xuXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnN1YihjYW1lcmFGb3J3YXJkLm11bHRpcGx5U2NhbGFyKHRoaXMuZGlzdGFuY2UpKTtcbiAgICB9XG5cbiAgICB0b1NjcmVlblBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoSGFsZiA9IDAuNSAqIHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0SGFsZiA9IDAuNSAqIHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIGNvbnN0IGNvcGllZFByb2plY3RWZWN0b3IgPSBwb3NpdGlvbi5jbG9uZSgpLnByb2plY3QodGhpcy5jYW1lcmEpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBNYXRoLnJvdW5kKChjb3BpZWRQcm9qZWN0VmVjdG9yLnggKyAxKSAqIHdpZHRoSGFsZiksXG4gICAgICAgICAgICB5OiBNYXRoLnJvdW5kKCgtY29waWVkUHJvamVjdFZlY3Rvci55ICsgMSkgKiBoZWlnaHRIYWxmKSxcbiAgICAgICAgICAgIHo6IGNvcGllZFByb2plY3RWZWN0b3IuelxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xsaWRlcnMgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5jb2xsaWRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0SWQgPSAwO1xuICAgIH1cblxuICAgIGNoZWNrV2F5KHBvc2l0aW9uLCBnYW1lT2JqZWN0KSB7XG4gICAgICAgIGZvcihsZXQgY29sbGlkZXIgb2YgdGhpcy5jb2xsaWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChjb2xsaWRlci5mbihwb3NpdGlvbiwgZ2FtZU9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXNldENvbGxpZGVycygpIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlcnMgPSBbXTtcbiAgICB9XG5cbiAgICByZW1vdmVDb2xsaWRlcihpZCkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmNvbGxpZGVycy5maW5kSW5kZXgoYyA9PiBjLmlkID09PSBpZCk7XG5cbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxpZGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZENvbGxpZGVyRnVuY3Rpb24oZm4pIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlcnMucHVzaCh7XG4gICAgICAgICAgICBpZDogdGhpcy5uZXh0SWQrKyxcbiAgICAgICAgICAgIGZuLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNjZW5lLnBhdGhGaW5kZXIucmVidWlsZEFyZWFzKCk7XG4gICAgfVxufSIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuaW1wb3J0IHsgUGxheWVyLCBBSSB9IGZyb20gJy4vR2FtZU9iamVjdHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25uZWN0aW9uIGV4dGVuZHMgQXV0b0JpbmRNZXRob2RzIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaXBcblx0ICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBwb3J0XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTZWN1cmVcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNjZW5lLCBpcCA9ICdsb2NhbGhvc3QnLCBwb3J0ID0gJzEzMzcnLCBpc1NlY3VyZSA9IHRydWUpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcblx0XHR0aGlzLm1ldGEgPSB7fTtcblx0XHR0aGlzLm5ldHdvcmtQbGF5ZXJzID0ge307XG5cdFx0dGhpcy5uZXR3b3JrQUlzID0ge307XG5cblx0XHR0aGlzLmxhc3RSZXF1ZXN0ID0gRGF0ZS5ub3coKTtcblx0XHR0aGlzLnBpbmcgPSAwO1xuXG5cdFx0Y29uc3QgV2ViU29ja2V0ID0gd2luZG93LldlYlNvY2tldCB8fCB3aW5kb3cuTW96V2ViU29ja2V0O1xuXG5cdFx0dGhpcy5jb25uZWN0aW9uID0gbmV3IFdlYlNvY2tldChgJHtpc1NlY3VyZSA/ICd3c3MnIDogJ3dzJ306Ly8ke2lwfToke3BvcnR9YCk7XG5cdFx0dGhpcy5jb25uZWN0aW9uLm9ub3BlbiA9ICgpID0+IGNvbnNvbGUubG9nKCdvcGVuIGNvbm5lY3Rpb24nKTtcblx0XHR0aGlzLmNvbm5lY3Rpb24ub25lcnJvciA9IChlcnJvcikgPT4gY29uc29sZS5sb2coJ2Vycm9yIGNvbm5lY3Rpb24nLCBlcnJvcik7XG5cdFx0dGhpcy5jb25uZWN0aW9uLm9ubWVzc2FnZSA9IHRoaXMub25NZXNzYWdlO1xuXG5cdFx0dGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHRcdFx0dGhpcy5zZW5kR2FtZU9iamVjdHMoKTtcblx0XHRcdHRoaXMubGFzdFJlcXVlc3QgPSBEYXRlLm5vdygpO1xuXHRcdH0sIDEwMCk7XG5cdH1cblxuXHR1cGRhdGUoKSB7fVxuXG5cdG9uTWVzc2FnZSh7IGRhdGEgfSkge1xuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhXG5cdFx0ICogQHBhcmFtIHthbnl9IHJlc3BvbnNlXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VUeXBlXG5cdFx0ICovXG5cdFx0Y29uc3QgeyBtZXRhLCBkYXRhOiByZXNwb25zZSwgbWVzc2FnZVR5cGUgfSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cblx0XHRpZiAobWV0YS5yb2xlICYmIHRoaXMubWV0YS5yb2xlICE9PSBtZXRhLnJvbGUpIHtcblx0XHRcdHRoaXMuc2NlbmUudWkuc2V0Q29ubmVjdGlvblJvbGUobWV0YS5yb2xlKTtcblxuXHRcdFx0aWYgKHRoaXMubWV0YS5yb2xlICYmIG1ldGEucm9sZSA9PT0gJ2hvc3QnKSB7XG5cdFx0XHRcdHRoaXMuaG9zdFVuaXRzRnJvbU5ldHdvcmsoKTtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMubWV0YS5kZWJ1Zykge1xuXHRcdFx0XHR0aGlzLmNsZWFyTG9jYWxHYW1lT2JqZWN0cygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMubWV0YSA9IG1ldGE7XG5cblx0XHR0cnkge1xuXHRcdFx0c3dpdGNoIChtZXNzYWdlVHlwZSkge1xuXHRcdFx0XHRjYXNlICdoYW5kc2hha2UnOiB7XG5cdFx0XHRcdFx0dGhpcy5wcm9jZXNzSGFuZHNoYWtlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAncmVzdGFydFNlcnZlcic6IHtcblx0XHRcdFx0XHR3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAnc2V0VXNlclBsYXllcic6IHtcblx0XHRcdFx0XHRjb25zdCBwbGF5ZXIgPSB0aGlzLnNjZW5lLmdldFBsYXllcigpO1xuXG5cdFx0XHRcdFx0aWYgKHBsYXllcikge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRQbGF5ZXJQYXJhbXMocGxheWVyLCByZXNwb25zZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuc2NlbmUudW5pdHMuc2V0RGVmYXVsdFBsYXllclBhcmFtcyhyZXNwb25zZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ3VwZGF0ZUdhbWVPYmplY3RzJzoge1xuXHRcdFx0XHRcdHRoaXMucGluZyA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RSZXF1ZXN0O1xuXHRcdFx0XHRcdHRoaXMudXBkYXRlR2FtZU9iamVjdHMocmVzcG9uc2UpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6IHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZURpc2Nvbm5lY3RlZFBsYXllcihyZXNwb25zZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBlcnJvcicsIGUpO1xuXHRcdH1cblx0fVxuXG5cdHRha2VIb3N0KCkge1xuXHRcdHRoaXMuc2VuZCgndGFrZUhvc3QnKTtcblx0fVxuXG5cdHJlc3RhcnRTZXJ2ZXIoKSB7XG5cdFx0dGhpcy5zZW5kKCdyZXN0YXJ0U2VydmVyJyk7XG5cdH1cblxuXHQvLyBUaGVyZSBpcyByYWNlIGNvbmRpdGlvbiBiZXR3ZWVuXG5cdC8vIGNsZWFyTG9jYWxHYW1lT2JqZWN0cyBhbmQgTG9jYXRpb24uY3JlYXRlSW50ZXJhY3RpdmVHYW1lT2JqZWN0c1xuXHRjbGVhckxvY2FsR2FtZU9iamVjdHMoKSB7XG5cdFx0Y29uc3QgZ2FtZU9iamVjdHNTZXJ2aWNlID0gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2U7XG5cdFx0Y29uc3QgcGxheWVyID0gdGhpcy5zY2VuZS5nZXRQbGF5ZXIoKTtcblxuXHRcdC8vIENsZWFyIGxvY2FsIGdhbWVPYmplY3RzIHRvIHJlcGxhY2UgdGhlbSBieSBuZXR3b3JrIHVuaXRzIChleGNlcHQgcGxheWVyKVxuXHRcdGdhbWVPYmplY3RzU2VydmljZS5nZXRVbml0cygpLmZvckVhY2goKHVuaXQpID0+IHtcblx0XHRcdGlmICghdW5pdC5wYXJhbXMuZnJvbU5ldHdvcmsgJiYgdW5pdCAhPT0gcGxheWVyKSB7XG5cdFx0XHRcdGdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdCh1bml0KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHNlbmQobWVzc2FnZVR5cGUsIGRhdGEpIHtcblx0XHRjb25zdCB7IHVzZXJOYW1lLCBwYXNzd29yZCB9ID0gdGhpcy5zY2VuZS51c2VyO1xuXG5cdFx0Y29uc3QgbWV0YSA9IHtcblx0XHRcdHRva2VuOiB0aGlzLmdldEhhc2godXNlck5hbWUgKyBwYXNzd29yZCksXG5cdFx0fTtcblxuXHRcdHRoaXMuY29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KHsgbWVzc2FnZVR5cGUsIG1ldGEsIGRhdGEgfSkpXG5cdH1cblxuXHRwcm9jZXNzSGFuZHNoYWtlKCkge1xuXHRcdHRoaXMuc2VuZCgnbG9hZEN1cnJlbnRVc2VyJyk7XG5cdH1cblxuXHR1cGRhdGVHYW1lT2JqZWN0cyhnYW1lT2JqZWN0cykge1xuXHRcdGdhbWVPYmplY3RzLmZvckVhY2goKGdhbWVPYmplY3QpID0+IHtcblx0XHRcdHN3aXRjaCAoZ2FtZU9iamVjdC50eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ3BsYXllcic6IHtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZU5ldHdvcmtQbGF5ZXIoZ2FtZU9iamVjdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAnYWknOiB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGVOZXR3b3JrQUkoZ2FtZU9iamVjdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHJlbW92ZURpc2Nvbm5lY3RlZFBsYXllcih7IGNvbm5lY3Rpb25JZCB9KSB7XG5cdFx0Y29uc3QgZ2FtZU9iamVjdHNTZXJ2aWNlID0gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2U7XG5cdFx0Y29uc3QgZGlzY29ubmVjdGVkUGxheWVyID0gZ2FtZU9iamVjdHNTZXJ2aWNlLmdldFVuaXRzKCkuZmluZCh1bml0ID0+XG5cdFx0XHR1bml0IGluc3RhbmNlb2YgUGxheWVyXG5cdFx0XHQmJiB1bml0LnBhcmFtcy5jb25uZWN0aW9uSWQgPT09IGNvbm5lY3Rpb25JZFxuXHRcdCk7XG5cblx0XHRjb25zb2xlLmxvZygnUGxheWVyIGRpc2Nvbm5lY3RlZCcsIGNvbm5lY3Rpb25JZCk7XG5cblx0XHRpZiAoZGlzY29ubmVjdGVkUGxheWVyKSB7XG5cdFx0XHRkaXNjb25uZWN0ZWRQbGF5ZXIuZGllKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGdldEhhc2goc3RyKSB7XG5cdFx0ZnVuY3Rpb24gaGFzaDMyKHN0cikge1xuXHRcdFx0bGV0IGk7XG5cdFx0XHRsZXQgbDtcblx0XHRcdGxldCBodmFsID0gMHg4MTFjOWRjNTtcblxuXHRcdFx0Zm9yIChpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aHZhbCBePSBzdHIuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0aHZhbCArPSAoaHZhbCA8PCAxKSArIChodmFsIDw8IDQpICsgKGh2YWwgPDwgNykgKyAoaHZhbCA8PCA4KSArIChodmFsIDw8IDI0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIChcIjAwMDAwMDBcIiArIChodmFsID4+PiAwKS50b1N0cmluZygxNikpLnN1YnN0cigtOCk7XG5cdFx0fVxuXG5cdFx0bGV0IGgxID0gaGFzaDMyKHN0cik7XG5cdFx0cmV0dXJuIGgxICsgaGFzaDMyKGgxICsgc3RyKTtcblx0fVxuXG5cdGhvc3RVbml0c0Zyb21OZXR3b3JrKCkge1xuXHRcdHRoaXMuc2NlbmUudW5pdHNcblx0XHRcdC5nZXRBbGl2ZVVuaXRzKClcblx0XHRcdC5mb3JFYWNoKCh1bml0KSA9PiB7XG5cdFx0XHRcdGlmICh1bml0LnBhcmFtcy5mcm9tTmV0d29yaykge1xuXHRcdFx0XHRcdHVuaXQucGFyYW1zLmZyb21OZXR3b3JrID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9XG5cblx0dXBkYXRlTmV0d29ya1BsYXllcihwbGF5ZXJEYXRhKSB7XG5cdFx0Y29uc3QgeyBsb2NhdGlvbk5hbWUsIHBvc2l0aW9uLCByb3RhdGlvbiwgYW5pbWF0aW9uU3RhdGUsIHBhcmFtcyB9ID0gcGxheWVyRGF0YTtcblx0XHRjb25zdCB7IHBhcmFtczogeyB1bml0TmV0d29ya0lkIH0gfSA9IHBsYXllckRhdGE7XG5cblx0XHRpZiAodW5pdE5ldHdvcmtJZCA9PT0gdGhpcy5tZXRhLnVuaXROZXR3b3JrSWQgJiYgIXRoaXMubWV0YS5kZWJ1Zykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChsb2NhdGlvbk5hbWUgIT09IHRoaXMuc2NlbmUubG9jYXRpb24uZ2V0TG9jYXRpb25OYW1lKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSBQbGF5ZXIgfCBzdHJpbmdcblx0XHQgKi9cblx0XHRsZXQgbmV0d29ya1BsYXllciA9IHRoaXMubmV0d29ya1BsYXllcnNbdW5pdE5ldHdvcmtJZF07XG5cblx0XHRpZiAoIW5ldHdvcmtQbGF5ZXIpIHtcblx0XHRcdHRoaXMubmV0d29ya1BsYXllcnNbdW5pdE5ldHdvcmtJZF0gPSAnbG9hZGluZyc7XG5cblx0XHRcdHRoaXMuc2NlbmUudW5pdHMuY3JlYXRlTmV0d29ya1BsYXllcihcblx0XHRcdFx0cGxheWVyRGF0YSxcblx0XHRcdFx0KG5ldHdvcmtQbGF5ZXIpID0+IHtcblx0XHRcdFx0XHR0aGlzLm5ldHdvcmtQbGF5ZXJzW3VuaXROZXR3b3JrSWRdID0gbmV0d29ya1BsYXllcjtcblx0XHRcdFx0fSxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChuZXR3b3JrUGxheWVyICE9PSAnbG9hZGluZycpIHtcblx0XHRcdHRoaXMuc2V0UGxheWVyUGFyYW1zKG5ldHdvcmtQbGF5ZXIsIHsgcG9zaXRpb24sIHJvdGF0aW9uLCBhbmltYXRpb25TdGF0ZSwgcGFyYW1zIH0pO1xuXHRcdH1cblx0fVxuXG5cdHNldFBsYXllclBhcmFtcyhwbGF5ZXIsIHsgcG9zaXRpb24sIHJvdGF0aW9uLCBhbmltYXRpb25TdGF0ZSwgcGFyYW1zIH0pIHtcblx0XHRwbGF5ZXIucG9zaXRpb24uc2V0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuXHRcdHBsYXllci5yb3RhdGlvbi5zZXQocm90YXRpb24ueCwgcm90YXRpb24ueSwgcm90YXRpb24ueik7XG5cdFx0cGxheWVyLmFuaW1hdGlvblN0YXRlID0gYW5pbWF0aW9uU3RhdGU7XG5cblx0XHRpZiAocGFyYW1zKSB7XG5cdFx0XHRjb25zdCB7IGlucHV0LCBhY2NlbGVyYXRpb24gfSA9IHBhcmFtcztcblx0XHRcdGNvbnN0IHBsYXllclBhcmFtcyA9IHBsYXllci5wYXJhbXM7XG5cblx0XHRcdHBsYXllclBhcmFtcy5pbnB1dC52ZXJ0aWNhbCA9IGlucHV0LnZlcnRpY2FsO1xuXHRcdFx0cGxheWVyUGFyYW1zLmlucHV0Lmhvcml6b250YWwgPSBpbnB1dC5ob3Jpem9udGFsO1xuXHRcdFx0cGxheWVyUGFyYW1zLmlucHV0LmF0dGFjazEgPSBpbnB1dC5hdHRhY2sxO1xuXHRcdFx0cGxheWVyUGFyYW1zLmlucHV0LmF0dGFjazIgPSBpbnB1dC5hdHRhY2syO1xuXHRcdFx0cGxheWVyUGFyYW1zLmhwID0gcGFyYW1zLmhwO1xuXHRcdFx0cGxheWVyUGFyYW1zLmhwTWF4ID0gcGFyYW1zLmhwTWF4O1xuXHRcdFx0cGxheWVyUGFyYW1zLmZyYWN0aW9uID0gcGFyYW1zLmZyYWN0aW9uO1xuXHRcdFx0cGxheWVyUGFyYW1zLmRhbWFnZSA9IHBhcmFtcy5kYW1hZ2U7XG5cdFx0XHRwbGF5ZXJQYXJhbXMuc3BlZWQgPSBwYXJhbXMuc3BlZWQ7XG5cdFx0XHRwbGF5ZXJQYXJhbXMubW9uZXkgPSBwYXJhbXMubW9uZXk7XG5cdFx0XHRwbGF5ZXJQYXJhbXMubGV2ZWwgPSBwYXJhbXMubGV2ZWw7XG5cdFx0XHRwbGF5ZXJQYXJhbXMudW5zcGVudFRhbGVudHMgPSBwYXJhbXMudW5zcGVudFRhbGVudHM7XG5cdFx0XHRwbGF5ZXJQYXJhbXMuZXhwZXJpZW5jZSA9IHBhcmFtcy5leHBlcmllbmNlO1xuXHRcdFx0cGxheWVyUGFyYW1zLmFjY2VsZXJhdGlvbi5zZXQoYWNjZWxlcmF0aW9uLngsIGFjY2VsZXJhdGlvbi55LCBhY2NlbGVyYXRpb24ueik7XG5cdFx0fVxuXHR9XG5cblx0dXBkYXRlTmV0d29ya0FJKHVuaXREYXRhKSB7XG5cdFx0Y29uc3QgeyBsb2NhdGlvbk5hbWUsIHBvc2l0aW9uLCByb3RhdGlvbiwgaXNSdW5uaW5nLCBpc0F0dGFjaywgYW5pbWF0aW9uU3RhdGUsIHNjYWxlLCBwYXJhbXMgfSA9IHVuaXREYXRhO1xuXHRcdGNvbnN0IHsgdW5pdE5ldHdvcmtJZCB9ID0gcGFyYW1zO1xuXG5cdFx0aWYgKGxvY2F0aW9uTmFtZSAhPT0gdGhpcy5zY2VuZS5sb2NhdGlvbi5nZXRMb2NhdGlvbk5hbWUoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIEFJIHwgc3RyaW5nXG5cdFx0ICovXG5cdFx0bGV0IG5ldHdvcmtBSSA9IHRoaXMubmV0d29ya0FJc1t1bml0TmV0d29ya0lkXTtcblxuXHRcdGlmICghbmV0d29ya0FJKSB7XG5cdFx0XHR0aGlzLm5ldHdvcmtBSXNbdW5pdE5ldHdvcmtJZF0gPSAnbG9hZGluZyc7XG5cblx0XHRcdHRoaXMuc2NlbmUudW5pdHMuY3JlYXRlTmV0d29ya0FJKHVuaXREYXRhLCAobmV0d29ya0FJKSA9PiB7XG5cdFx0XHRcdHRoaXMubmV0d29ya0FJc1t1bml0TmV0d29ya0lkXSA9IG5ldHdvcmtBSTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAobmV0d29ya0FJICE9PSAnbG9hZGluZycpIHtcblx0XHRcdG5ldHdvcmtBSS5wb3NpdGlvbi5zZXQocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XG5cdFx0XHRuZXR3b3JrQUkucm90YXRpb24uc2V0KHJvdGF0aW9uLngsIHJvdGF0aW9uLnksIHJvdGF0aW9uLnopO1xuXHRcdFx0bmV0d29ya0FJLm9iamVjdC5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSwgc2NhbGUueik7XG5cdFx0XHRuZXR3b3JrQUkuaXNSdW5uaW5nID0gaXNSdW5uaW5nO1xuXHRcdFx0bmV0d29ya0FJLmlzQXR0YWNrID0gaXNBdHRhY2s7XG5cdFx0XHRuZXR3b3JrQUkuYW5pbWF0aW9uU3RhdGUgPSBhbmltYXRpb25TdGF0ZTtcblxuXHRcdFx0aWYgKHBhcmFtcykge1xuXHRcdFx0XHRjb25zdCB7IGFjY2VsZXJhdGlvbiB9ID0gcGFyYW1zO1xuXHRcdFx0XHRjb25zdCBuZXR3b3JrQUlQYXJhbXMgPSBuZXR3b3JrQUkucGFyYW1zO1xuXG5cdFx0XHRcdG5ldHdvcmtBSVBhcmFtcy5ocCA9IHBhcmFtcy5ocDtcblx0XHRcdFx0bmV0d29ya0FJUGFyYW1zLmhwTWF4ID0gcGFyYW1zLmhwTWF4O1xuXHRcdFx0XHRuZXR3b3JrQUlQYXJhbXMuZnJhY3Rpb24gPSBwYXJhbXMuZnJhY3Rpb247XG5cdFx0XHRcdG5ldHdvcmtBSVBhcmFtcy5kYW1hZ2UgPSBwYXJhbXMuZGFtYWdlO1xuXHRcdFx0XHRuZXR3b3JrQUlQYXJhbXMubGV2ZWwgPSBwYXJhbXMubGV2ZWw7XG5cdFx0XHRcdG5ldHdvcmtBSVBhcmFtcy5hY2NlbGVyYXRpb24uc2V0KGFjY2VsZXJhdGlvbi54LCBhY2NlbGVyYXRpb24ueSwgYWNjZWxlcmF0aW9uLnopO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHNlbmRHYW1lT2JqZWN0cygpIHtcblx0XHRjb25zdCBjb25uZWN0aW9uSWQgPSB0aGlzLm1ldGEuaWQ7XG5cblx0XHRpZiAodGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGUgIT09IDEgfHwgIWNvbm5lY3Rpb25JZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IHBsYXllciA9IHRoaXMuc2NlbmUuZ2V0UGxheWVyKCk7XG5cdFx0Y29uc3QgdW5pdHMgPSAoXG5cdFx0XHR0aGlzLm1ldGEucm9sZSA9PT0gJ2hvc3QnXG5cdFx0XHRcdD8gW1xuXHRcdFx0XHRcdHBsYXllcixcblx0XHRcdFx0XHQuLi50aGlzLnNjZW5lLnVuaXRzXG5cdFx0XHRcdFx0XHQuZ2V0QWxpdmVVbml0cygpXG5cdFx0XHRcdFx0XHQuZmlsdGVyKHVuaXQgPT4gIXVuaXQucGFyYW1zLmZyb21OZXR3b3JrKVxuXHRcdFx0XHRdXG5cdFx0XHRcdDogW3BsYXllcl1cblx0XHQpO1xuXG5cdFx0Y29uc3QgZGF0YSA9IFtdO1xuXG5cdFx0dW5pdHMuZm9yRWFjaCgodW5pdCkgPT4ge1xuXHRcdFx0Y29uc3QgdW5pdERhdGEgPSBDb25uZWN0aW9uLnVuaXRUb05ldHdvcmsoXG5cdFx0XHRcdHVuaXQsXG5cdFx0XHRcdGNvbm5lY3Rpb25JZCxcblx0XHRcdFx0dGhpcy5zY2VuZS5sb2NhdGlvbi5nZXRMb2NhdGlvbk5hbWUoKSxcblx0XHRcdCk7XG5cblx0XHRcdGlmICh1bml0RGF0YSkge1xuXHRcdFx0XHRkYXRhLnB1c2godW5pdERhdGEpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMubWV0YS5yb2xlID09PSAnaG9zdCcpIHtcblx0XHRcdHRoaXMuc2VuZCgndXBkYXRlR2FtZU9iamVjdHMnLCBkYXRhKTtcblx0XHR9IGVsc2UgaWYgKGRhdGFbMF0pIHtcblx0XHRcdHRoaXMuc2VuZCgndXBkYXRlUGxheWVyJywgZGF0YVswXSk7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIHVuaXRUb05ldHdvcmsodW5pdCwgY29ubmVjdGlvbklkLCBsb2NhdGlvbk5hbWUpIHtcblx0XHRpZiAodW5pdCkge1xuXHRcdFx0Y29uc3QgdW5pdFJvdGF0aW9uID0gdW5pdC5vYmplY3Qucm90YXRpb24udG9WZWN0b3IzKCk7XG5cblx0XHRcdGlmICghdW5pdC5wYXJhbXMudW5pdE5ldHdvcmtJZCkge1xuXHRcdFx0XHRjb25zdCBnZXRSYW5kb21TdHJpbmcgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMik7XG5cdFx0XHRcdHVuaXQucGFyYW1zLnVuaXROZXR3b3JrSWQgPSBnZXRSYW5kb21TdHJpbmcoKSArIGdldFJhbmRvbVN0cmluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB1bml0TmV0d29ya0lkID0gdW5pdC5wYXJhbXMudW5pdE5ldHdvcmtJZDtcblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0aXNSdW5uaW5nLFxuXHRcdFx0XHRpc0F0dGFjayxcblx0XHRcdH0gPSB1bml0O1xuXHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRocCxcblx0XHRcdFx0aHBNYXgsXG5cdFx0XHRcdGFjY2VsZXJhdGlvbixcblx0XHRcdFx0ZGFtYWdlLFxuXHRcdFx0XHRsZXZlbCxcblx0XHRcdFx0ZXhwZXJpZW5jZSxcblx0XHRcdFx0ZnJhY3Rpb24sXG5cdFx0XHRcdG5hbWUsXG5cdFx0XHRcdHNwZWVkLFxuXHRcdFx0XHR1bnNwZW50VGFsZW50cyxcblx0XHRcdFx0bW9uZXksXG5cdFx0XHR9ID0gdW5pdC5wYXJhbXM7XG5cblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0dmVydGljYWwsXG5cdFx0XHRcdGhvcml6b250YWwsXG5cdFx0XHRcdGF0dGFjazEsXG5cdFx0XHRcdGF0dGFjazIsXG5cdFx0XHR9ID0gdW5pdC5wYXJhbXMuaW5wdXQgfHwge307XG5cblx0XHRcdGNvbnN0IHZlY3RvclRvT2JqZWN0ID0gKHZlY3RvciwgZXBzID0gMTAwMCkgPT4gKHtcblx0XHRcdFx0eDogTWF0aC5yb3VuZCh2ZWN0b3IueCAqIGVwcykgLyBlcHMsXG5cdFx0XHRcdHk6IE1hdGgucm91bmQodmVjdG9yLnkgKiBlcHMpIC8gZXBzLFxuXHRcdFx0XHR6OiBNYXRoLnJvdW5kKHZlY3Rvci56ICogZXBzKSAvIGVwcyxcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gKHtcblx0XHRcdFx0dHlwZTogdW5pdCBpbnN0YW5jZW9mIFBsYXllciA/ICdwbGF5ZXInIDogJ2FpJyxcblx0XHRcdFx0bG9jYXRpb25OYW1lLFxuXHRcdFx0XHRhbmltYXRpb25TdGF0ZTogdW5pdC5hbmltYXRpb25TdGF0ZSxcblx0XHRcdFx0aXNSdW5uaW5nLFxuXHRcdFx0XHRpc0F0dGFjayxcblx0XHRcdFx0cG9zaXRpb246IHZlY3RvclRvT2JqZWN0KHVuaXQucG9zaXRpb24pLFxuXHRcdFx0XHRyb3RhdGlvbjogdmVjdG9yVG9PYmplY3QodW5pdFJvdGF0aW9uKSxcblx0XHRcdFx0c2NhbGU6IHZlY3RvclRvT2JqZWN0KHVuaXQub2JqZWN0LnNjYWxlKSxcblx0XHRcdFx0cGFyYW1zOiB7XG5cdFx0XHRcdFx0Y29ubmVjdGlvbklkLFxuXHRcdFx0XHRcdHVuaXROZXR3b3JrSWQsXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRocCxcblx0XHRcdFx0XHRocE1heCxcblx0XHRcdFx0XHRmcmFjdGlvbixcblx0XHRcdFx0XHRkYW1hZ2UsXG5cdFx0XHRcdFx0bGV2ZWwsXG5cdFx0XHRcdFx0ZXhwZXJpZW5jZSxcblx0XHRcdFx0XHRzcGVlZCxcblx0XHRcdFx0XHRtb25leSxcblx0XHRcdFx0XHR1bnNwZW50VGFsZW50cyxcblx0XHRcdFx0XHRhY2NlbGVyYXRpb246IHZlY3RvclRvT2JqZWN0KGFjY2VsZXJhdGlvbiksXG5cdFx0XHRcdFx0aW5wdXQ6IHtcblx0XHRcdFx0XHRcdHZlcnRpY2FsLCBob3Jpem9udGFsLFxuXHRcdFx0XHRcdFx0YXR0YWNrMSwgYXR0YWNrMixcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59IiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5pbXBvcnQgQUkgZnJvbSAnLi9HYW1lT2JqZWN0cy9BSSc7XG5pbXBvcnQgUGxheWVyIGZyb20gJy4vR2FtZU9iamVjdHMvUGxheWVyJztcbmltcG9ydCBGaXJlIGZyb20gJy4vR2FtZU9iamVjdHMvRmlyZSc7XG5pbXBvcnQgVW5pdCBmcm9tICcuL0dhbWVPYmplY3RzL1VuaXQnO1xuaW1wb3J0IEFuaW1hdGVkR2FtZU9iamVjdCBmcm9tICcuL0dhbWVPYmplY3RzL0FuaW1hdGVkR2FtZU9iamVjdCc7XG5cbmV4cG9ydCB7XG4gICAgQUksXG4gICAgUGxheWVyLFxuICAgIEZpcmUsXG4gICAgVW5pdCxcbiAgICBBbmltYXRlZEdhbWVPYmplY3QsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lT2JqZWN0c1NlcnZpY2UgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2NlbmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0cyA9IFtdO1xuICAgICAgICB0aGlzLm5leHRHYW1lT2JqZWN0SWQgPSAwO1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICB0aGlzLmdhbWVPYmplY3RzLmZvckVhY2goZ2FtZU9iamVjdCA9PiBnYW1lT2JqZWN0LnVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VuaXR9IGF0dGFja2luZ1VuaXRcbiAgICAgKi9cbiAgICBhdHRhY2soYXR0YWNraW5nVW5pdCkge1xuICAgICAgICBpZiAoYXR0YWNraW5nVW5pdC5pc0RlYWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnYW1lVGltZSA9IHRoaXMuc2NlbmUuaW50ZXJ2YWxzLmdldFRpbWVQYXNzZWQoKTtcblxuICAgICAgICAgICAgaWYgKGF0dGFja2luZ1VuaXQuaXNBdHRhY2tJbnRlcnJ1cHRlZChnYW1lVGltZSkpIHtcbiAgICAgICAgICAgICAgICBhdHRhY2tpbmdVbml0LnJlbGVhc2VBdHRhY2soZ2FtZVRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYXR0YWNrZWRVbml0cyA9IHRoaXMuZ2V0VW5pdHMoKS5maWx0ZXIoZ2FtZU9iamVjdCA9PiAoXG4gICAgICAgICAgICAgICAgZ2FtZU9iamVjdCAhPT0gYXR0YWNraW5nVW5pdFxuICAgICAgICAgICAgICAgICYmIGdhbWVPYmplY3QuaXNBbGl2ZSgpXG4gICAgICAgICAgICAgICAgJiYgZ2FtZU9iamVjdC5pc0VuZW15KGF0dGFja2luZ1VuaXQpXG4gICAgICAgICAgICAgICAgJiYgZ2FtZU9iamVjdC5wb3NpdGlvbi5kaXN0YW5jZVRvKGF0dGFja2luZ1VuaXQucG9zaXRpb24pIDwgMlxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIGF0dGFja2VkVW5pdHMuZm9yRWFjaCgoY29sbGlzaW9uR2FtZU9iamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkdhbWVPYmplY3QuZGFtYWdlVGFrZW4oe1xuICAgICAgICAgICAgICAgICAgICBkYW1hZ2U6IGF0dGFja2luZ1VuaXQucGFyYW1zLmRhbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgdW5pdDogYXR0YWNraW5nVW5pdCxcbiAgICAgICAgICAgICAgICB9LCBnYW1lVGltZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBpZiAoYXR0YWNrZWRVbml0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnNjZW5lLmF1ZGlvLnBsYXlTb3VuZChhdHRhY2tpbmdVbml0LnBvc2l0aW9uLCAnQXR0YWNrIFNvZnQnKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfSwgYXR0YWNraW5nVW5pdC5nZXRBdHRhY2tUaW1lb3V0KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VW5pdH0gZmlyaW5nR2FtZU9iamVjdFxuICAgICAqL1xuICAgIGZpcmUoZmlyaW5nR2FtZU9iamVjdCkge1xuICAgICAgICBpZiAoZmlyaW5nR2FtZU9iamVjdC5pc0RlYWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3JlYXRlTGlnaHRDdWJlID0gbGVmdCA9PiB0aGlzLnNjZW5lLm1vZGVscy5jcmVhdGVDdWJlKHtcbiAgICAgICAgICAgIHg6IDAuMDIsXG4gICAgICAgICAgICB5OiAwLjAyLFxuICAgICAgICAgICAgejogMC4zLFxuICAgICAgICAgICAgZW1pc3NpdmU6ICcjZmYwMDAwJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygwLjA1IC0gTnVtYmVyKGxlZnQpICogMC4xLCAwLCAwKSxcbiAgICAgICAgICAgIG5vU2NlbmU6IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG9iamVjdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gICAgICAgIG9iamVjdC5wb3NpdGlvbi5jb3B5KGZpcmluZ0dhbWVPYmplY3QuZ2V0RmlyZUluaXRpYWxQb3NpdGlvbigpKTtcbiAgICAgICAgb2JqZWN0LnF1YXRlcm5pb24uY29weShmaXJpbmdHYW1lT2JqZWN0LmdldEZpcmVJbml0aWFsUm90YXRpb24oKSk7XG5cbiAgICAgICAgb2JqZWN0LmFkZChjcmVhdGVMaWdodEN1YmUodHJ1ZSkpO1xuICAgICAgICBvYmplY3QuYWRkKGNyZWF0ZUxpZ2h0Q3ViZShmYWxzZSkpO1xuXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKG9iamVjdCk7XG5cbiAgICAgICAgY29uc3QgZmlyZUdhbWVPYmplY3QgPSB0aGlzLmhvb2tHYW1lT2JqZWN0KG5ldyBGaXJlKHtcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIHRocm90dGxpbmc6IG5ldyBUSFJFRS5WZWN0b3IzKDEsIDEsIDEpLFxuICAgICAgICAgICAgc3BlZWQ6IGZpcmluZ0dhbWVPYmplY3QucGFyYW1zLmZpcmVTaGVsbFNwZWVkLFxuICAgICAgICAgICAgZGFtYWdlOiBmaXJpbmdHYW1lT2JqZWN0LnBhcmFtcy5maXJlRGFtYWdlLFxuICAgICAgICAgICAgcGFyZW50OiBmaXJpbmdHYW1lT2JqZWN0LFxuICAgICAgICAgICAgY2hlY2tXYXk6IHRoaXMuc2NlbmUuY29sbGlkZXJzLmNoZWNrV2F5LFxuICAgICAgICAgICAgZ2V0Q29sbGlzaW9uczogKCkgPT4gdGhpcy5nYW1lT2JqZWN0cy5maWx0ZXIoZ2FtZU9iamVjdCA9PiAoXG4gICAgICAgICAgICAgICAgZ2FtZU9iamVjdCBpbnN0YW5jZW9mIFVuaXRcbiAgICAgICAgICAgICAgICAmJiBnYW1lT2JqZWN0LmlzQWxpdmUoKVxuICAgICAgICAgICAgICAgICYmIGZpcmVHYW1lT2JqZWN0LnBhcmFtcy5wYXJlbnQgIT09IGdhbWVPYmplY3RcbiAgICAgICAgICAgICAgICAmJiBmaXJlR2FtZU9iamVjdC5wb3NpdGlvbi5kaXN0YW5jZVRvKGdhbWVPYmplY3QucG9zaXRpb24pIDwgM1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBkZXN0cm95OiAoKSA9PiB0aGlzLmRlc3Ryb3lHYW1lT2JqZWN0KGZpcmVHYW1lT2JqZWN0KSxcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRoaXMuc2NlbmUuaW50ZXJ2YWxzLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5kZXN0cm95R2FtZU9iamVjdChmaXJlR2FtZU9iamVjdCksIDIwMDApO1xuXG4gICAgICAgIC8vIHRoaXMuc2NlbmUuYXVkaW8ucGxheVNvdW5kKGZpcmluZ0dhbWVPYmplY3QucG9zaXRpb24sICdMYXNlcnMnKTtcbiAgICB9XG4gICAgXG4gICAgY3JlYXRlSXRlbSh7XG4gICAgICAgIHNjYWxlID0gMS41LFxuICAgICAgICBtb2RlbCA9ICdpdGVtLWhlYWwnLFxuICAgICAgICBwb3NpdGlvbiA9IHt9LFxuICAgICAgICBjYW5QaWNrdXAsXG4gICAgICAgIG9uUGlja3VwLFxuICAgIH0pIHtcbiAgICAgICAgdGhpcy5zY2VuZS5tb2RlbHMubG9hZEdMVEYoe1xuICAgICAgICAgICAgYmFzZVVybDogJy4vYXNzZXRzL21vZGVscy9pdGVtcy8nICsgbW9kZWwsXG4gICAgICAgICAgICBub1NjZW5lOiB0cnVlLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGxvYWRlZE9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25WZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMyhwb3NpdGlvbi54IHx8IDAsIHBvc2l0aW9uLnkgfHwgMCwgcG9zaXRpb24ueiB8fCAwKTtcbiAgICAgICAgICAgICAgICBsb2FkZWRPYmplY3Quc2NlbmUuc2NhbGUuc2V0KHNjYWxlLCBzY2FsZSwgc2NhbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbG9hZGVkT2JqZWN0LnNjZW5lLnRyYXZlcnNlKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNNZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC5hbHBoYVRlc3QgPSAwLjU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxvYWRlZE9iamVjdC5zY2VuZS5wb3NpdGlvbi5zZXQocG9zaXRpb25WZWN0b3IueCwgcG9zaXRpb25WZWN0b3IueSwgcG9zaXRpb25WZWN0b3Iueik7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5zY2VuZS5hZGQobG9hZGVkT2JqZWN0LnNjZW5lKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGdhbWVJdGVtID0gbmV3IEFuaW1hdGVkR2FtZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogbG9hZGVkT2JqZWN0LnNjZW5lLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBsb2FkZWRPYmplY3QuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlLmhvb2tHYW1lT2JqZWN0KGdhbWVJdGVtKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrUGlja3VwID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmludGVydmFscy5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldFByaW9yaXR5ID0gdW5pdCA9PiAxIC8gTWF0aC5jZWlsKHBvc2l0aW9uVmVjdG9yLmRpc3RhbmNlVG8odW5pdC5wb3NpdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lYXJVbml0cyA9IHRoaXMuc2NlbmUudW5pdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEFsaXZlVW5pdHMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh1bml0KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIWNhblBpY2t1cCB8fCBjYW5QaWNrdXAodW5pdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBwb3NpdGlvblZlY3Rvci5kaXN0YW5jZVRvKHVuaXQucG9zaXRpb24pIDwgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgodW5pdEEsIHVuaXRCKSA9PiBnZXRQcmlvcml0eSh1bml0QikgLSBnZXRQcmlvcml0eSh1bml0QSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lYXJVbml0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uUGlja3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblBpY2t1cChuZWFyVW5pdHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhbWVJdGVtLmFuaW1hdGlvblN0YXRlLmlzRGllID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlLmRlc3Ryb3lHYW1lT2JqZWN0KGdhbWVJdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDUwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1BpY2t1cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDAwLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjaGVja1BpY2t1cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0dhbWVPYmplY3R9IGdhbWVPYmplY3RcbiAgICAgKi9cbiAgICBob29rR2FtZU9iamVjdChnYW1lT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdHMucHVzaChnYW1lT2JqZWN0KTtcbiAgICAgICAgZ2FtZU9iamVjdC5fX2dhbWVfb2JqZWN0X2lkID0gdGhpcy5uZXh0R2FtZU9iamVjdElkKys7XG5cbiAgICAgICAgcmV0dXJuIGdhbWVPYmplY3Q7XG4gICAgfVxuXG4gICAgcmVtb3ZlQWxsKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5nYW1lT2JqZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUdhbWVPYmplY3QodGhpcy5nYW1lT2JqZWN0c1swXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVBbGxFeGNlcHRQbGF5ZXIoKSB7XG4gICAgICAgIGNvbnN0IGdldE5leHROb25QbGF5ZXJJbmRleCA9ICgpID0+IHRoaXMuZ2FtZU9iamVjdHMuZmluZEluZGV4KGdvID0+IGdvICE9PSB0aGlzLnNjZW5lLmdldFBsYXllcigpKTtcbiAgICAgICAgbGV0IHJlbW92ZUlkeCA9IGdldE5leHROb25QbGF5ZXJJbmRleCgpO1xuXG4gICAgICAgIHdoaWxlIChyZW1vdmVJZHggPiAtMSkge1xuICAgICAgICAgICAgY29uc3QgZ2FtZU9iamVjdCA9IHRoaXMuZ2FtZU9iamVjdHNbcmVtb3ZlSWR4XTtcbiAgICAgICAgICAgIHRoaXMuZ2FtZU9iamVjdHMuc3BsaWNlKHJlbW92ZUlkeCwgMSk7XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlR2FtZU9iamVjdEZyb21TY2VuZShnYW1lT2JqZWN0KTtcblxuICAgICAgICAgICAgcmVtb3ZlSWR4ID0gZ2V0TmV4dE5vblBsYXllckluZGV4KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0dhbWVPYmplY3R9IGdhbWVPYmplY3RcbiAgICAgKi9cbiAgICBkZXN0cm95R2FtZU9iamVjdChnYW1lT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nYW1lT2JqZWN0cy5pbmRleE9mKGdhbWVPYmplY3QpO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmdhbWVPYmplY3RzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbW92ZUdhbWVPYmplY3RGcm9tU2NlbmUoZ2FtZU9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtHYW1lT2JqZWN0fSBnYW1lT2JqZWN0XG4gICAgICovXG4gICAgcmVtb3ZlR2FtZU9iamVjdEZyb21TY2VuZShnYW1lT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IChnYW1lT2JqZWN0Lm9iamVjdCAmJiBnYW1lT2JqZWN0Lm9iamVjdC5wYXJlbnQpIHx8IHRoaXMuc2NlbmU7XG5cbiAgICAgICAgaWYgKHBhcmVudC5yZW1vdmUpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmUoZ2FtZU9iamVjdC5vYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IGZpbmQgb2JqZWN0IHBhcmVudCB0byByZW1vdmUgdGhlIG9iamVjdCcsIGdhbWVPYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VW5pdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdhbWVPYmplY3RzLmZpbHRlcihnbyA9PiBnbyBpbnN0YW5jZW9mIFVuaXQpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IEZpcmluZ1VuaXQgZnJvbSAnLi9GaXJpbmdVbml0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUkgZXh0ZW5kcyBGaXJpbmdVbml0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBzcGVlZDogMC41LFxuICAgICAgICAgICAgZGFtYWdlOiAxMCxcbiAgICAgICAgICAgIG1hczogMSxcbiAgICAgICAgICAgIGhwOiAxMDAsXG4gICAgICAgICAgICBuYW1lOiAnVW5uYW1lZCBVbml0JyxcbiAgICAgICAgICAgIGZyYWN0aW9uOiAnbmV1dHJhbCcsXG4gICAgICAgICAgICBmaXJlVGltZW91dDogMS41LFxuICAgICAgICAgICAgYXR0YWNrVGltZW91dDogMS41LFxuICAgICAgICAgICAganVtcFRpbWVvdXQ6IDEuNSxcbiAgICAgICAgICAgIHN0YXJ0UnVuVGltZW91dDogMSxcbiAgICAgICAgICAgIG5leHRQb2ludFVwZGF0ZVRpbWVvdXQ6IDAuMSxcbiAgICAgICAgICAgIHVwZGF0ZVRhcmdldFRpbWVvdXQ6IDMsXG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgaHAsIGRhbWFnZSwgc3BlZWQgfSA9IHRoaXMucGFyYW1zO1xuXG4gICAgICAgIHRoaXMucGFyYW1zLmJvdW50eSA9IGhwIC8gNCArIGRhbWFnZSArIHNwZWVkICogMzA7XG4gICAgICAgIHRoaXMubGFzdFJ1biA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRhcmdldFVwZGF0ZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdE5leHRQb2ludFVwZGF0ZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEp1bXBUaW1lc3RhbXAgPSAwO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQXR0YWNrID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICBzdXBlci51cGRhdGUodGltZSwgZGVsdGFUaW1lKTtcblxuICAgICAgICBpZiAodGhpcy5pc0RlYWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmZpbmRUYXJnZXQgJiYgdGhpcy5pc1VwZGF0ZVRhcmdldFJlbGVhc2VkKHRpbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy50YXJnZXQgPSB0aGlzLnBhcmFtcy5maW5kVGFyZ2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IG9iamVjdCwgdGFyZ2V0LCBhY2NlbGVyYXRpb24sIHNwZWVkLCBnZXROZXh0UG9pbnQgfSA9IHRoaXMucGFyYW1zO1xuXG4gICAgICAgIGlmICghdGhpcy5wYXJhbXMuZnJvbU5ldHdvcmspIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0TmV4dFBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTmV4dFBvaW50VXBkYXRlUmVsZWFzZWQodGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE5leHRQb2ludFVwZGF0ZSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRQb2ludCA9IGdldE5leHRQb2ludCh0aGlzLnBvc2l0aW9uLCB0YXJnZXQucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0UG9pbnQgPSB0YXJnZXQucG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpc1RhcmdldE5lYXIgPSB0YXJnZXQgJiYgb2JqZWN0LnBvc2l0aW9uLmRpc3RhbmNlVG8odGFyZ2V0LnBvc2l0aW9uKSA8IDEuNzU7XG5cbiAgICAgICAgICAgIHRoaXMuaXNBdHRhY2sgPSAoXG4gICAgICAgICAgICAgICBpc1RhcmdldE5lYXJcbiAgICAgICAgICAgICAgICYmIHRoaXMuaXNFbmVteSh0YXJnZXQpXG4gICAgICAgICAgICAgICAmJiB0YXJnZXQuaXNBbGl2ZSgpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0F0dGFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlVG9Qb3NpdGlvbih0YXJnZXQucG9zaXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHRQb2ludCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlVG9Qb3NpdGlvbih0aGlzLm5leHRQb2ludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGlzTmV4dFBvaW50TmVhciA9ICF0aGlzLm5leHRQb2ludDtcblxuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSAoXG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgICAgJiYgIWlzVGFyZ2V0TmVhclxuICAgICAgICAgICAgICAgICYmICFpc05leHRQb2ludE5lYXJcbiAgICAgICAgICAgICAgICAmJiAodGhpcy5pc1J1bm5pbmcgfHwgdGhpcy5pc1J1blJlbGVhc2VkKHRpbWUpKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuaXNBdHRhY2tSZWxlYXNlZCh0aW1lKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuaXNIaXRSZWxlYXNlZCh0aW1lKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNrKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ0ZvcndhcmQgPSB0aGlzLmlzUnVubmluZyAmJiB0aGlzLmlzQWNjZWxlcmF0aW9uKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVja1dheSA9IChqdW1wSGVpZ2h0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXJhbXM6IHsgYWNjZWxlcmF0aW9uOiB7IHg6IGR4LCB5OiBkeSwgejogZHogfSB9IH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrV2F5KGR4LCBkeSArIGp1bXBIZWlnaHQsIGR6KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMubGFzdFJ1biA9IHRpbWU7XG4gICAgICAgICAgICBhY2NlbGVyYXRpb24uYWRkKHRoaXMuZ2V0Rm9yd2FyZCgpLm11bHRpcGx5U2NhbGFyKChzcGVlZCAqIDAuMSkgKiAoZGVsdGFUaW1lICogMC4wNikpKTtcblxuICAgICAgICAgICAgY29uc3QgaXNKdW1wTmVlZGVkID0gKFxuICAgICAgICAgICAgICAgIHRoaXMuaXNHcm91bmRlZFxuICAgICAgICAgICAgICAgICYmIChhY2NlbGVyYXRpb24ueCB8fCBhY2NlbGVyYXRpb24ueilcbiAgICAgICAgICAgICAgICAmJiB0aW1lIC0gdGhpcy5sYXN0SnVtcFRpbWVzdGFtcCA+IHRoaXMucGFyYW1zLmp1bXBUaW1lb3V0ICogMTAwMFxuICAgICAgICAgICAgICAgICYmICFjaGVja1dheSgwLjEpXG4gICAgICAgICAgICAgICAgJiYgY2hlY2tXYXkoMS41KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKGlzSnVtcE5lZWRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEp1bXBUaW1lc3RhbXAgPSB0aW1lO1xuICAgICAgICAgICAgICAgIGFjY2VsZXJhdGlvbi55ICs9IDAuMjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByb3RhdGVUb1Bvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgb2JqZWN0IH0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgICBjb25zdCByb3RhdGlvblRvVGFyZ2V0UmFkaWFucyA9IE1hdGguYXRhbjIoXG4gICAgICAgICAgICBwb3NpdGlvbi54IC0gb2JqZWN0LnBvc2l0aW9uLngsXG4gICAgICAgICAgICBwb3NpdGlvbi56IC0gb2JqZWN0LnBvc2l0aW9uLnpcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB0aGlzLmFuaW1hdGlvblN0YXRlLmlzUm90YXRlTGVmdCA9IHJvdGF0aW9uVG9UYXJnZXRSYWRpYW5zIC0gb2JqZWN0LnJvdGF0aW9uLnkgPiAwLjE7XG4gICAgICAgIC8vIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNSb3RhdGVSaWdodCA9IHJvdGF0aW9uVG9UYXJnZXRSYWRpYW5zIC0gb2JqZWN0LnJvdGF0aW9uLnkgPCAtMC4xO1xuXG4gICAgICAgIGNvbnN0IHRhcmdldFF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAgICAgICB0YXJnZXRRdWF0ZXJuaW9uLnNldEZyb21FdWxlcihvYmplY3Qucm90YXRpb24uY2xvbmUoKS5zZXQoMCwgcm90YXRpb25Ub1RhcmdldFJhZGlhbnMsIDApKTtcbiAgICAgICAgb2JqZWN0LnF1YXRlcm5pb24uc2xlcnAodGFyZ2V0UXVhdGVybmlvbiwgMC4xKTtcbiAgICB9XG5cbiAgICBpc0FjY2VsZXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMucGFyYW1zLmFjY2VsZXJhdGlvbi54KVxuICAgICAgICAgICAgKyBNYXRoLmFicyh0aGlzLnBhcmFtcy5hY2NlbGVyYXRpb24ueSlcbiAgICAgICAgICAgICsgTWF0aC5hYnModGhpcy5wYXJhbXMuYWNjZWxlcmF0aW9uLnopXG4gICAgICAgICkgPiAwLjAxO1xuICAgIH1cblxuICAgIGlzUnVuUmVsZWFzZWQodGltZSkge1xuICAgICAgICByZXR1cm4gdGltZSAtIHRoaXMubGFzdFJ1biA+IHRoaXMucGFyYW1zLnN0YXJ0UnVuVGltZW91dCAqIDEwMDA7XG4gICAgfVxuXG4gICAgaXNOZXh0UG9pbnRVcGRhdGVSZWxlYXNlZCh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aW1lIC0gdGhpcy5sYXN0TmV4dFBvaW50VXBkYXRlID4gdGhpcy5wYXJhbXMubmV4dFBvaW50VXBkYXRlVGltZW91dCAqIDEwMDA7XG4gICAgfVxuXG4gICAgaXNVcGRhdGVUYXJnZXRSZWxlYXNlZCh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aW1lIC0gdGhpcy5sYXN0VGFyZ2V0VXBkYXRlID4gdGhpcy5wYXJhbXMudXBkYXRlVGFyZ2V0VGltZW91dCAqIDEwMDA7XG4gICAgfVxuXG4gICAgZGFtYWdlVGFrZW4oeyBkYW1hZ2UsIHVuaXQ6IGF0dGFja2VyIH0gPSB7fSwgdGltZSkge1xuICAgICAgICBzdXBlci5kYW1hZ2VUYWtlbih7IGRhbWFnZSwgdW5pdDogYXR0YWNrZXIgfSwgdGltZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnBhcmFtcy50YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLnRhcmdldCA9IGF0dGFja2VyO1xuICAgICAgICAgICAgdGhpcy5sYXN0VGFyZ2V0VXBkYXRlID0gdGltZTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgR2FtZU9iamVjdCBmcm9tICcuL0dhbWVPYmplY3QnO1xuXG5jb25zdCBhbmltYXRpb25OYW1lcyA9IHtcbiAgICBzdGFuZDogJ1N0YW5kJyxcbiAgICBydW46ICdSdW4nLFxuICAgIGp1bXA6ICdKdW1wJyxcbiAgICBhdHRhY2s6ICdBdHRhY2snLFxuICAgIHJvdGF0ZUxlZnQ6ICdSb3RhdGUgTGVmdCcsXG4gICAgcm90YXRlUmlnaHQ6ICdSb3RhdGUgUmlnaHQnLFxuICAgIHJ1bkxlZnQ6ICdSdW4gTGVmdCcsXG4gICAgcnVuUmlnaHQ6ICdSdW4gUmlnaHQnLFxuICAgIHdhbGtCYWNrOiAnV2FsayBCYWNrJyxcbiAgICBkaWU6ICdEaWUnLFxuICAgIHNwYXduOiAnU3Bhd24nLFxuICAgIGhpdDogJ0hpdCcsXG5cbiAgICAvLyBDb21wbGV4IGFuaW1pbWF0aW9uc1xuICAgIHRvcFJ1bjogJ1RvcCBSdW4nLFxuICAgIGJvdHRvbVJ1bjogJ0JvdHRvbSBSdW4nLFxuICAgIHRvcFdhbGtCYWNrOiAnVG9wIFdhbGsgQmFjaycsXG4gICAgYm90dG9tV2Fsa0JhY2s6ICdCb3R0b20gV2FsayBCYWNrJyxcbiAgICB0b3BBdHRhY2s6ICdUb3AgQXR0YWNrJyxcbiAgICBib3R0b21BdHRhY2s6ICdCb3R0b20gQXR0YWNrJyxcbiAgICB0b3BTdGFuZDogJ1RvcCBTdGFuZCcsXG4gICAgYm90dG9tU3RhbmQ6ICdCb3R0b20gU3RhbmQnLFxuICAgIHRvcFJ1blJpZ2h0OiAnVG9wIFJ1biBSaWdodCcsXG4gICAgdG9wUnVuTGVmdDogJ1RvcCBSdW4gTGVmdCcsXG4gICAgdG9wSnVtcDogJ1RvcCBKdW1wJyxcbiAgICB0b3BIaXQ6ICdUb3AgSGl0JyxcbiAgICBib3R0b21SdW5SaWdodDogJ0JvdHRvbSBSdW4gUmlnaHQnLFxuICAgIGJvdHRvbVJ1bkxlZnQ6ICdCb3R0b20gUnVuIExlZnQnLFxuICAgIGJvdHRvbUp1bXA6ICdCb3R0b20gSnVtcCcsXG4gICAgYm90dG9tSGl0OiAnQm90dG9tIEhpdCcsXG4gICAgdG9wRGllOiAnVG9wIERpZScsXG4gICAgYm90dG9tRGllOiAnQm90dG9tIERpZScsXG4gICAgdG9wU3Bhd246ICdUb3AgU3Bhd24nLFxuICAgIGJvdHRvbVNwYXduOiAnQm90dG9tIFNwYXduJyxcbn07XG5cbmNvbnN0IHRvcEFuaW1hdGlvbnMgPSBbXG4gICAgJ3RvcFJ1bicsXG4gICAgJ3RvcFdhbGtCYWNrJyxcbiAgICAndG9wQXR0YWNrJyxcbiAgICAndG9wU3RhbmQnLFxuICAgICd0b3BSdW5SaWdodCcsXG4gICAgJ3RvcFJ1bkxlZnQnLFxuICAgICd0b3BKdW1wJyxcbiAgICAndG9wSGl0JyxcbiAgICAndG9wRGllJyxcbl07XG5cbmNvbnN0IGJvdHRvbUFuaW1hdGlvbnMgPSBbXG4gICAgJ2JvdHRvbVJ1bicsXG4gICAgJ2JvdHRvbVdhbGtCYWNrJyxcbiAgICAnYm90dG9tQXR0YWNrJyxcbiAgICAnYm90dG9tU3RhbmQnLFxuICAgICdib3R0b21SdW5SaWdodCcsXG4gICAgJ2JvdHRvbVJ1bkxlZnQnLFxuICAgICdib3R0b21KdW1wJyxcbiAgICAnYm90dG9tSGl0JyxcbiAgICAnYm90dG9tRGllJyxcbl07XG5cbmNvbnN0IHRvcEJvbmVzID0gW1xuICAgICdSaWdodF9Gb3JlYXJtJyxcbiAgICAnUmlnaHRfQXJtJyxcbiAgICAnUmlnaHRfSGFuZCcsXG4gICAgJ1JpZ2h0X0hhbmRfZW5kJyxcbiAgICAnUmlnaHRfU2hvdWxkZXInLFxuICAgICdMZWZ0X1Nob3VsZGVyJyxcbiAgICAnTGVmdF9Gb3JlYXJtJyxcbiAgICAnTGVmdF9Bcm0nLFxuICAgICdMZWZ0X0hhbmQnLFxuICAgICdMZWZ0X0hhbmRfZW5kJyxcbiAgICAnQ2hlc3QnLFxuICAgICdOZWNrJyxcbiAgICAnSGVhZCcsXG4gICAgJ0hlYWRfZW5kJ1xuXTtcblxuY29uc3QgYm90dG9tQm9uZXMgPSBbXG4gICAgJ01haW5fQm9uZScsXG4gICAgJ1JpZ2h0X0xlZycsXG4gICAgJ1JpZ2h0X01pZGRsZV9Gb290JyxcbiAgICAnUmlnaHRfRm9vdCcsXG4gICAgJ1JpZ2h0X0Zvb3RfZW5kJyxcbiAgICAnTGVmdF9MZWcnLFxuICAgICdMZWZ0X01pZGRsZV9Gb290JyxcbiAgICAnTGVmdF9Gb290JyxcbiAgICAnTGVmdF9Gb290X2VuZCcsXG4gICAgJ0xlZ3NfUm90YXRpb24nLFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0ZWRHYW1lT2JqZWN0IGV4dGVuZHMgR2FtZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZXM6IHsgLi4uYW5pbWF0aW9uTmFtZXMgfSxcbiAgICAgICAgICAgIHRvcEJvbmVzOiBbLi4udG9wQm9uZXNdLFxuICAgICAgICAgICAgYm90dG9tQm9uZXM6IFsuLi5ib3R0b21Cb25lc10sXG4gICAgICAgICAgICB0b3BBbmltYXRpb25zOiBbLi4udG9wQW5pbWF0aW9uc10sXG4gICAgICAgICAgICBib3R0b21BbmltYXRpb25zOiBbLi4uYm90dG9tQW5pbWF0aW9uc10sXG4gICAgICAgICAgICBzcGF3blRpbWVvdXQ6IDEsXG4gICAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgICAgIGlzTW92aW5nRm9yd2FyZDogZmFsc2UsXG4gICAgICAgICAgICBpc01vdmluZ1JpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzTW92aW5nTGVmdDogZmFsc2UsXG4gICAgICAgICAgICBpc01vdmluZ0JhY2t3YXJkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUm90YXRlTGVmdDogZmFsc2UsXG4gICAgICAgICAgICBpc1JvdGF0ZVJpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzQXR0YWNrOiBmYWxzZSxcbiAgICAgICAgICAgIGlzSnVtcDogZmFsc2UsXG4gICAgICAgICAgICBpc0RpZTogZmFsc2UsXG4gICAgICAgICAgICBpc0hpdDogZmFsc2UsXG4gICAgICAgICAgICBpc1NwYXduOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucGxheWluZ0FuaW1hdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5sZWdzUm90YXRpb25ZID0gMDtcbiAgICAgICAgdGhpcy5zcGF3blRpbWUgPSAwO1xuXG4gICAgICAgIHRoaXMubWl4ZXIgPSBuZXcgVEhSRUUuQW5pbWF0aW9uTWl4ZXIodGhpcy5wYXJhbXMub2JqZWN0KTtcblxuICAgICAgICB0aGlzLmluaXRBbmltYXRpb25zKHRoaXMucGFyYW1zLmFuaW1hdGlvbk5hbWVzKTtcbiAgICB9XG5cbiAgICB1cGRhdGUodGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF0aGlzLnNwYXduVGltZSkge1xuICAgICAgICAgICAgdGhpcy5zcGF3blRpbWUgPSB0aW1lO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNTcGF3biAmJiB0aGlzLmlzU3Bhd25GaW5pc2hlZCh0aW1lKSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc1NwYXduID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5taXhlcikge1xuICAgICAgICAgICAgdGhpcy5taXhlci51cGRhdGUoZGVsdGFUaW1lIC8gMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wYXJhbXMuY29tcGxleEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29tcGxleEFuaW1hdGlvbnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuZ2V0Q3VycmVudEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgYW5pbWF0aW9uICYmIHRoaXMucGxheUFuaW1hdGlvbihhbmltYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGxheUFuaW1hdGlvbihhbmltYXRpb24sIHsgZm9yY2UgfSA9IHt9KSB7XG4gICAgICAgIGlmICghYW5pbWF0aW9uIHx8ICFhbmltYXRpb24uX2NsaXApIHJldHVybjtcblxuICAgICAgICBjb25zdCBhbmltYXRpb25OYW1lID0gYW5pbWF0aW9uLl9jbGlwLm5hbWU7XG4gICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9IHRoaXMucGxheWluZ0FuaW1hdGlvbk5hbWUgIT09IGFuaW1hdGlvbk5hbWUgfHwgZm9yY2U7XG5cbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5wbGF5aW5nQW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbk5hbWU7XG4gICAgICAgICAgICBhbmltYXRpb24ucmVzZXQoKTtcbiAgICAgICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBsYXlpbmdBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMucGxheWluZ0FuaW1hdGlvbjtcblxuICAgICAgICAgICAgICAgIGZyb20uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgZnJvbS5jcm9zc0ZhZGVUbyhhbmltYXRpb24sIDAuMyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGxheWluZ0FuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluaXRBbmltYXRpb25zKGFuaW1hdGlvbk5hbWVzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRvcEFuaW1hdGlvbnMsXG4gICAgICAgICAgICBib3R0b21BbmltYXRpb25zLFxuICAgICAgICAgICAgdG9wQm9uZXMsXG4gICAgICAgICAgICBib3R0b21Cb25lcyxcbiAgICAgICAgICAgIGNvbXBsZXhBbmltYXRpb25zLFxuICAgICAgICB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gT2JqZWN0LmtleXMoYW5pbWF0aW9uTmFtZXMpLnJlZHVjZShcbiAgICAgICAgICAgIChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBleGNsdWRlZEJvbmVzID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxleEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcEFuaW1hdGlvbnMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZWRCb25lcyA9IGJvdHRvbUJvbmVzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJvdHRvbUFuaW1hdGlvbnMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZWRCb25lcyA9IHRvcEJvbmVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxBbmltYXRpb24gPSB0aGlzLmZpbmRNb2RlbEFuaW1hdGlvbihhbmltYXRpb25OYW1lc1trZXldLCB7IGV4Y2x1ZGVkQm9uZXMgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGluaXRlZEFuaW1hdGlvbiA9IHRoaXMuY3JlYXRlQ2xpcEFjdGlvbihtb2RlbEFuaW1hdGlvbik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQsIFtrZXldOiBpbml0ZWRBbmltYXRpb24gfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7fVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBqdW1wLFxuICAgICAgICAgICAgICAgIGF0dGFjayxcbiAgICAgICAgICAgICAgICB0b3BBdHRhY2ssXG4gICAgICAgICAgICAgICAgZGllLFxuICAgICAgICAgICAgICAgIHNwYXduLFxuICAgICAgICAgICAgICAgIHRvcERpZSxcbiAgICAgICAgICAgICAgICBib3R0b21EaWUsXG4gICAgICAgICAgICAgICAgdG9wSnVtcCxcbiAgICAgICAgICAgICAgICBib3R0b21KdW1wLFxuICAgICAgICAgICAgICAgIGJvdHRvbUF0dGFja1xuICAgICAgICAgICAgfSA9IHt9XG4gICAgICAgIH0gPSB0aGlzO1xuXG4gICAgICAgIFtqdW1wLCBkaWUsIHNwYXduLCB0b3BEaWUsIGJvdHRvbURpZSwgdG9wSnVtcCwgYm90dG9tSnVtcF0uZm9yRWFjaCgoY2xhbXBBbmltYXRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChjbGFtcEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGNsYW1wQW5pbWF0aW9uLnNldExvb3AoVEhSRUUuTG9vcE9uY2UsIDApO1xuICAgICAgICAgICAgICAgIGNsYW1wQW5pbWF0aW9uLmNsYW1wV2hlbkZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgW2F0dGFjaywgdG9wQXR0YWNrLCBib3R0b21BdHRhY2tdLmZvckVhY2goKGF0dGFja0FuaW1hdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKGF0dGFja0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGF0dGFja0FuaW1hdGlvbi5zZXREdXJhdGlvbih0aGlzLnBhcmFtcy5hdHRhY2tUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xpcEFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbiAmJiB0aGlzLm1peGVyLmNsaXBBY3Rpb24oYWN0aW9uKS5zdG9wKCk7XG4gICAgfVxuXG4gICAgZmluZE1vZGVsQW5pbWF0aW9uKG5hbWUsIHsgZXhjbHVkZWRCb25lcyA9IFtdIH0gPSB7fSkge1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbnMgPSBbXSB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgICAgbGV0IGFuaW1hdGlvbiA9IGFuaW1hdGlvbnMuZmluZChhbmltYXRpb24gPT4gYW5pbWF0aW9uLm5hbWUgPT09IG5hbWUpO1xuXG4gICAgICAgIGlmIChhbmltYXRpb24gJiYgZXhjbHVkZWRCb25lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsZWFyQW5pbWF0aW9uQm9uZXMoYW5pbWF0aW9uLCBleGNsdWRlZEJvbmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgfVxuXG4gICAgaXNNb3ZpbmcoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLmlzTW92aW5nTGVmdFxuICAgICAgICAgICAgfHwgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ1JpZ2h0XG4gICAgICAgICAgICB8fCB0aGlzLmFuaW1hdGlvblN0YXRlLmlzTW92aW5nRm9yd2FyZFxuICAgICAgICAgICAgfHwgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ0JhY2t3YXJkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaXNTcGF3bkZpbmlzaGVkKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRpbWUgLSB0aGlzLnNwYXduVGltZSA+IHRoaXMucGFyYW1zLnNwYXduVGltZW91dCAqIDEwMDA7XG4gICAgfVxuXG4gICAgY2xlYXJBbmltYXRpb25Cb25lcyhhbmltYXRpb24sIGJvbmVzKSB7XG4gICAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGdldEJvbmVOYW1lID0gaXRlbSA9PiBpdGVtLm5hbWUuc3BsaXQoJy4nKVswXSxcbiAgICAgICAgICAgICAgICBpc05vdEV4Y2x1ZGVkID0gaXRlbSA9PiAhYm9uZXMuaW5jbHVkZXMoZ2V0Qm9uZU5hbWUoaXRlbSkpO1xuXG4gICAgICAgICAgICBhbmltYXRpb24udHJhY2tzID0gYW5pbWF0aW9uLnRyYWNrcy5maWx0ZXIoaXNOb3RFeGNsdWRlZCk7XG5cbiAgICAgICAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDb21wbGV4QW5pbWF0aW9ucygpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgIHRvcEF0dGFjaywgYm90dG9tQXR0YWNrLFxuICAgICAgICAgICAgICAgIHRvcFdhbGtCYWNrLCBib3R0b21XYWxrQmFjayxcbiAgICAgICAgICAgICAgICB0b3BSdW4sIGJvdHRvbVJ1bixcbiAgICAgICAgICAgICAgICB0b3BSdW5SaWdodCxcbiAgICAgICAgICAgICAgICB0b3BSdW5MZWZ0LFxuICAgICAgICAgICAgICAgIHRvcFN0YW5kLCBib3R0b21TdGFuZCxcbiAgICAgICAgICAgICAgICB0b3BKdW1wLCBib3R0b21KdW1wLFxuICAgICAgICAgICAgICAgIHRvcEhpdCwgYm90dG9tSGl0LFxuICAgICAgICAgICAgICAgIHRvcERpZSwgYm90dG9tRGllLFxuICAgICAgICAgICAgICAgIHRvcFNwYXduLCBib3R0b21TcGF3bixcbiAgICAgICAgICAgIH0gPSB7fVxuICAgICAgICB9ID0gdGhpcztcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpc0F0dGFjayxcbiAgICAgICAgICAgIGlzTW92aW5nUmlnaHQsXG4gICAgICAgICAgICBpc01vdmluZ0xlZnQsXG4gICAgICAgICAgICBpc01vdmluZ0JhY2t3YXJkLFxuICAgICAgICAgICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgICAgICAgaXNKdW1wLFxuICAgICAgICAgICAgaXNEaWUsXG4gICAgICAgICAgICBpc0hpdCxcbiAgICAgICAgICAgIGlzU3Bhd24sXG4gICAgICAgIH0gPSB0aGlzLmFuaW1hdGlvblN0YXRlO1xuXG4gICAgICAgIGNvbnN0IHBsYXlpbmdBbmltYXRpb25zID0ge1xuICAgICAgICAgICAgdG9wOiAoXG4gICAgICAgICAgICAgICAgKGlzRGllICYmIHRvcERpZSlcbiAgICAgICAgICAgICAgICB8fCAoaXNIaXQgJiYgdG9wSGl0KVxuICAgICAgICAgICAgICAgIHx8IChpc0F0dGFjayAmJiB0b3BBdHRhY2spXG4gICAgICAgICAgICAgICAgfHwgKGlzSnVtcCAmJiB0b3BKdW1wKVxuICAgICAgICAgICAgICAgIHx8IChpc01vdmluZ0JhY2t3YXJkICYmIGlzTW92aW5nUmlnaHQgJiYgdG9wUnVuTGVmdClcbiAgICAgICAgICAgICAgICB8fCAoaXNNb3ZpbmdCYWNrd2FyZCAmJiBpc01vdmluZ0xlZnQgJiYgdG9wUnVuUmlnaHQpXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nQmFja3dhcmQgJiYgdG9wV2Fsa0JhY2spXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nUmlnaHQgJiYgdG9wUnVuUmlnaHQpXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nTGVmdCAmJiB0b3BSdW5MZWZ0KVxuICAgICAgICAgICAgICAgIHx8IChpc01vdmluZ0ZvcndhcmQgJiYgdG9wUnVuKVxuICAgICAgICAgICAgICAgIHx8IChpc1NwYXduICYmIHRvcFNwYXduKVxuICAgICAgICAgICAgICAgIHx8ICh0b3BTdGFuZClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBib3R0b206IChcbiAgICAgICAgICAgICAgICAoaXNEaWUgJiYgYm90dG9tRGllKVxuICAgICAgICAgICAgICAgIHx8IChpc0p1bXAgJiYgYm90dG9tSnVtcClcbiAgICAgICAgICAgICAgICB8fCAoaXNNb3ZpbmdCYWNrd2FyZCAmJiBpc01vdmluZ1JpZ2h0ICYmIGJvdHRvbVdhbGtCYWNrKVxuICAgICAgICAgICAgICAgIHx8IChpc01vdmluZ0JhY2t3YXJkICYmIGlzTW92aW5nTGVmdCAmJiBib3R0b21XYWxrQmFjaylcbiAgICAgICAgICAgICAgICB8fCAoaXNNb3ZpbmdCYWNrd2FyZCAmJiBib3R0b21XYWxrQmFjaylcbiAgICAgICAgICAgICAgICB8fCAoaXNNb3ZpbmdSaWdodCAmJiBib3R0b21SdW4pXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nTGVmdCAmJiBib3R0b21SdW4pXG4gICAgICAgICAgICAgICAgfHwgKGlzTW92aW5nRm9yd2FyZCAmJiBib3R0b21SdW4pXG4gICAgICAgICAgICAgICAgfHwgKGlzQXR0YWNrICYmIGJvdHRvbUF0dGFjaylcbiAgICAgICAgICAgICAgICB8fCAoaXNIaXQgJiYgYm90dG9tSGl0KVxuICAgICAgICAgICAgICAgIHx8IChpc1NwYXduICYmIGJvdHRvbVNwYXduKVxuICAgICAgICAgICAgICAgIHx8IChib3R0b21TdGFuZClcbiAgICAgICAgICAgICksXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbGVnc1JvdGF0aW9uQm9uZSA9IHRoaXMuZ2V0Q2hpbGRCeU5hbWUoJ0xlZ3NfUm90YXRpb24nKTtcbiAgICAgICAgaWYgKGxlZ3NSb3RhdGlvbkJvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcm90YXRpb24gfSA9IGxlZ3NSb3RhdGlvbkJvbmU7XG4gICAgICAgICAgICBsZXQgeSA9IC0wLjM7XG5cbiAgICAgICAgICAgIGlmIChpc01vdmluZ0xlZnQpIHtcbiAgICAgICAgICAgICAgICB5ID0gaXNNb3ZpbmdGb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgID8gMC41XG4gICAgICAgICAgICAgICAgICAgIDogaXNNb3ZpbmdCYWNrd2FyZCA/IC0wLjcgOiAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01vdmluZ1JpZ2h0KSB7XG4gICAgICAgICAgICAgICAgeSA9IGlzTW92aW5nRm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICA/IC0xLjJcbiAgICAgICAgICAgICAgICAgICAgOiBpc01vdmluZ0JhY2t3YXJkID8gMC40IDogLTEuNztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sZWdzUm90YXRpb25ZID0gdGhpcy5sZWdzUm90YXRpb25ZIC0gKHRoaXMubGVnc1JvdGF0aW9uWSAtIHkpIC8gMTA7XG4gICAgICAgICAgICByb3RhdGlvbi5zZXQocm90YXRpb24ueCwgdGhpcy5sZWdzUm90YXRpb25ZLCByb3RhdGlvbi56KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmxlbmRBbmltYXRpb25zKHBsYXlpbmdBbmltYXRpb25zKTtcbiAgICB9XG5cbiAgICBibGVuZEFuaW1hdGlvbnMoeyB0b3AsIGJvdHRvbSB9KSB7XG4gICAgICAgIGlmICghKHRvcCAmJiBib3R0b20gJiYgdG9wLl9jbGlwICYmIGJvdHRvbS5fY2xpcCkpIHJldHVybjtcblxuICAgICAgICBjb25zdCBnZXRBbmltYXRpb25OYW1lID0gYSA9PiBhLl9jbGlwLm5hbWUsXG4gICAgICAgICAgICBwbGF5QW5pbWF0aW9uID0gKGZyb21BbmltYXRpb24sIGFuaW1hdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbk5hbWUgPSBnZXRBbmltYXRpb25OYW1lKGFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbUFuaW1hdGlvbk5hbWUgPSBmcm9tQW5pbWF0aW9uICYmIGdldEFuaW1hdGlvbk5hbWUoZnJvbUFuaW1hdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoZnJvbUFuaW1hdGlvbk5hbWUgIT09IGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21BbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21BbmltYXRpb24uY3Jvc3NGYWRlVG8oYW5pbWF0aW9uLCAwLjMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBwbGF5QW5pbWF0aW9uKHRoaXMucGxheWluZ0FuaW1hdGlvbnMudG9wLCB0b3ApO1xuICAgICAgICBwbGF5QW5pbWF0aW9uKHRoaXMucGxheWluZ0FuaW1hdGlvbnMuYm90dG9tLCBib3R0b20pO1xuXG4gICAgICAgIHRoaXMucGxheWluZ0FuaW1hdGlvbnMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLnBsYXlpbmdBbmltYXRpb25zLmJvdHRvbSA9IGJvdHRvbTtcbiAgICB9XG5cbiAgICBnZXRDdXJyZW50QW5pbWF0aW9uKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgc3RhbmQsXG4gICAgICAgICAgICAgICAgYXR0YWNrLFxuICAgICAgICAgICAgICAgIHdhbGtCYWNrLFxuICAgICAgICAgICAgICAgIHJ1bkxlZnQsXG4gICAgICAgICAgICAgICAgcnVuUmlnaHQsXG4gICAgICAgICAgICAgICAgcnVuLFxuICAgICAgICAgICAgICAgIGp1bXAsXG4gICAgICAgICAgICAgICAgaGl0LFxuICAgICAgICAgICAgICAgIHJvdGF0ZUxlZnQsXG4gICAgICAgICAgICAgICAgcm90YXRlUmlnaHQsXG4gICAgICAgICAgICAgICAgZGllLFxuICAgICAgICAgICAgICAgIHNwYXduLFxuICAgICAgICAgICAgfSA9IHt9XG4gICAgICAgIH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlzQXR0YWNrLFxuICAgICAgICAgICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgICAgICAgaXNKdW1wLFxuICAgICAgICAgICAgaXNNb3ZpbmdMZWZ0LFxuICAgICAgICAgICAgaXNNb3ZpbmdSaWdodCxcbiAgICAgICAgICAgIGlzTW92aW5nQmFja3dhcmQsXG4gICAgICAgICAgICBpc1JvdGF0ZUxlZnQsXG4gICAgICAgICAgICBpc1JvdGF0ZVJpZ2h0LFxuICAgICAgICAgICAgaXNEaWUsXG4gICAgICAgICAgICBpc0hpdCxcbiAgICAgICAgICAgIGlzU3Bhd24sXG4gICAgICAgIH0gPSB0aGlzLmFuaW1hdGlvblN0YXRlO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoaXNEaWUgJiYgZGllKVxuICAgICAgICAgICAgfHwgKGlzSGl0ICYmIGhpdClcbiAgICAgICAgICAgIHx8IChpc0F0dGFjayAmJiBhdHRhY2spXG4gICAgICAgICAgICB8fCAoaXNKdW1wICYmIGp1bXApXG4gICAgICAgICAgICB8fCAoaXNNb3ZpbmdCYWNrd2FyZCAmJiB3YWxrQmFjaylcbiAgICAgICAgICAgIHx8IChpc01vdmluZ0xlZnQgJiYgcnVuTGVmdClcbiAgICAgICAgICAgIHx8IChpc01vdmluZ1JpZ2h0ICYmIHJ1blJpZ2h0KVxuICAgICAgICAgICAgfHwgKGlzTW92aW5nRm9yd2FyZCAmJiBydW4pXG4gICAgICAgICAgICB8fCAoaXNSb3RhdGVMZWZ0ICYmIHJvdGF0ZUxlZnQpXG4gICAgICAgICAgICB8fCAoaXNSb3RhdGVSaWdodCAmJiByb3RhdGVSaWdodClcbiAgICAgICAgICAgIHx8IChpc1NwYXduICYmIHNwYXduKVxuICAgICAgICAgICAgfHwgc3RhbmRcbiAgICAgICAgKTtcbiAgICB9XG59IiwiaW1wb3J0IFVuaXQgZnJvbSAnLi9Vbml0JztcbmltcG9ydCBNb3ZpbmdHYW1lT2JqZWN0IGZyb20gJy4vTW92aW5nR2FtZU9iamVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpcmUgZXh0ZW5kcyBNb3ZpbmdHYW1lT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbXMpO1xuXG4gICAgICAgIHRoaXMucGFyYW1zLmFjY2VsZXJhdGlvbi5hZGQoXG4gICAgICAgICAgICB0aGlzLmdldEZvcndhcmQoKS5tdWx0aXBseVNjYWxhcih0aGlzLnBhcmFtcy5zcGVlZCAqIDAuMSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB1cGRhdGUodGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpO1xuXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5nZXRDb2xsaXNpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xsaXNpb25zID0gdGhpcy5wYXJhbXMuZ2V0Q29sbGlzaW9ucyh0aGlzKTtcblxuICAgICAgICAgICAgY29sbGlzaW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGNvbGxpc2lvbkdhbWVPYmplY3QpID0+IChcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uR2FtZU9iamVjdCBpbnN0YW5jZW9mIFVuaXRcbiAgICAgICAgICAgICAgICAgICAgJiYgY29sbGlzaW9uR2FtZU9iamVjdC5pc0VuZW15KHRoaXMucGFyYW1zLnBhcmVudClcbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGNvbGxpc2lvbkdhbWVPYmplY3QgPT4gKFxuICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25HYW1lT2JqZWN0LmRhbWFnZVRha2VuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhbWFnZTogdGhpcy5wYXJhbXMuZGFtYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pdDogdGhpcy5wYXJhbXMucGFyZW50LFxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lKVxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICBpZiAoY29sbGlzaW9ucy5sZW5ndGggJiYgdGhpcy5wYXJhbXMuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IFVuaXQgZnJvbSAnLi9Vbml0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlyaW5nVW5pdCBleHRlbmRzIFVuaXQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGZpcmVEYW1hZ2U6IDEwLFxuICAgICAgICAgICAgZmlyZVRpbWVvdXQ6IDEuNSxcbiAgICAgICAgICAgIGZpcmVTaGVsbFNwZWVkOiAzLFxuICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2hvdWxkRmlyZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhdGVzdEZpcmUgPSAwO1xuICAgIH1cblxuICAgIGdldEZpcmVJbml0aWFsUG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLmNsb25lKCkuYWRkKFxuICAgICAgICAgICAgdGhpcy5nZXRVcCgpXG4gICAgICAgICAgICAgICAgLm11bHRpcGx5U2NhbGFyKDEuNSlcbiAgICAgICAgICAgICAgICAuYWRkKHRoaXMuZ2V0Rm9yd2FyZCgpLm11bHRpcGx5U2NhbGFyKDAuMykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICBzdXBlci51cGRhdGUodGltZSwgZGVsdGFUaW1lKTtcblxuICAgICAgICBpZiAodGhpcy5pc0RlYWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0ZpcmUgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5zaG91bGRGaXJlICYmIHRoaXMucGFyYW1zLmZpcmUgJiYgdGhpcy5pc0ZpcmVSZWxlYXNlZCh0aW1lKSAmJiB0aGlzLmlzQXR0YWNrUmVsZWFzZWQodGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGaXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkRmlyZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RGaXJlID0gdGltZTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLmZpcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkRmlyZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNGaXJlUmVsZWFzZWQodGltZSkge1xuICAgICAgICByZXR1cm4gdGltZSAtIHRoaXMubGF0ZXN0RmlyZSA+PSB0aGlzLnBhcmFtcy5maXJlVGltZW91dCAqIDEwMDA7XG4gICAgfVxuXG4gICAgZmlyZSgpIHtcbiAgICAgICAgdGhpcy5zaG91bGRGaXJlID0gdHJ1ZTtcbiAgICB9XG59IiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuLi9BdXRvQmluZE1ldGhvZHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lT2JqZWN0IGV4dGVuZHMgQXV0b0JpbmRNZXRob2RzIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHsgLi4ucGFyYW1zIH07XG4gICAgICAgIHRoaXMub2JqZWN0ID0gcGFyYW1zLm9iamVjdDtcblxuICAgICAgICBpZiAocGFyYW1zLm9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBhcmFtcy5vYmplY3QucG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gcGFyYW1zLm9iamVjdC5yb3RhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSBhcmdzXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayguLi5hcmdzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENoaWxkQnlOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0LmdldE9iamVjdEJ5TmFtZShuYW1lLCB0cnVlKTtcbiAgICB9XG5cbiAgICBnZXRDaGlsZERpcmVjdGlvbihhcmcsIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gdGhpcy5nZXRDaGlsZEJ5TmFtZShhcmcpXG4gICAgICAgICAgICA6IGFyZztcblxuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbih0aGlzLmdldENoaWxkUm90YXRpb24oY2hpbGQpKTtcbiAgICB9XG5cbiAgICBnZXRDaGlsZFBvc2l0aW9uKGFyZykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHRoaXMuZ2V0Q2hpbGRCeU5hbWUoYXJnKVxuICAgICAgICAgICAgOiBhcmc7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGNoaWxkLm1hdHJpeFdvcmxkKTtcbiAgICB9XG5cbiAgICBnZXRDaGlsZFJvdGF0aW9uKGFyZykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHRoaXMuZ2V0Q2hpbGRCeU5hbWUoYXJnKVxuICAgICAgICAgICAgOiBhcmc7XG5cbiAgICAgICAgbGV0IHRhcmdldCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gICAgICAgIGNoaWxkLmdldFdvcmxkUXVhdGVybmlvbih0YXJnZXQpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxufSIsImltcG9ydCBBbmltYXRlZEdhbWVPYmplY3QgZnJvbSAnLi9BbmltYXRlZEdhbWVPYmplY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3ZpbmdHYW1lT2JqZWN0IGV4dGVuZHMgQW5pbWF0ZWRHYW1lT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBzcGVlZDogMC4xLFxuICAgICAgICAgICAgdGhyb3R0bGluZzogbmV3IFRIUkVFLlZlY3RvcjMoMC41LCAwLjk1LCAwLjUpLFxuICAgICAgICAgICAgYWNjZWxlcmF0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgICAgICAgbWFzOiAwLFxuICAgICAgICAgICAgY2hlY2tXYXk6ICgpID0+IHRydWUsXG4gICAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICBzdXBlci51cGRhdGUodGltZSwgZGVsdGFUaW1lKTtcbiAgICAgICAgY29uc3QgeyBwYXJhbXM6IHsgYWNjZWxlcmF0aW9uLCB0aHJvdHRsaW5nIH0gfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLm1hcykge1xuICAgICAgICAgICAgYWNjZWxlcmF0aW9uLnkgLT0gMC4wMTtcblxuICAgICAgICAgICAgdGhpcy5pc0dyb3VuZGVkID0gIXRoaXMuY2hlY2tXYXkoMCwgLTAuMiwgMCk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLmlzSnVtcCA9ICF0aGlzLmlzR3JvdW5kZWQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGlzWCA9IEJvb2xlYW4oYWNjZWxlcmF0aW9uLngpICYmIHRoaXMuY2hlY2tXYXkoYWNjZWxlcmF0aW9uLngsIDAsIDApO1xuICAgICAgICBjb25zdCBpc1kgPSBCb29sZWFuKGFjY2VsZXJhdGlvbi55KSAmJiB0aGlzLmNoZWNrV2F5KDAsIGFjY2VsZXJhdGlvbi55LCAwKTtcbiAgICAgICAgY29uc3QgaXNaID0gQm9vbGVhbihhY2NlbGVyYXRpb24ueikgJiYgdGhpcy5jaGVja1dheSgwLCAwLCBhY2NlbGVyYXRpb24ueik7XG5cbiAgICAgICAgaWYgKCFpc1ggfHwgIWlzWSB8fCAhaXNaKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyYW1zLm1hcykge1xuICAgICAgICAgICAgICAgIC8vIFN0b3Agb2JqZWN0IHNtb290aGx5IGJlY2F1c2Ugb2YgQ29sbGlkZXIgaGl0XG4gICAgICAgICAgICAgICAgYWNjZWxlcmF0aW9uLm11bHRpcGx5U2NhbGFyKDAuNzUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzWCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2xpbWJpbmcgPSAoYWNjZWxlcmF0aW9uLnggJiYgYWNjZWxlcmF0aW9uLnkgPD0gMCAmJiB0aGlzLmNoZWNrV2F5KGFjY2VsZXJhdGlvbi54LCAwLjA0LCAwKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNDbGltYmluZykge1xuICAgICAgICAgICAgICAgICAgICBhY2NlbGVyYXRpb24ueSA9IDAuMDQgLyB0aHJvdHRsaW5nLnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZWxlcmF0aW9uLnggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc1kpIHsgYWNjZWxlcmF0aW9uLnkgPSAwOyB9XG5cbiAgICAgICAgICAgIGlmICghaXNaKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDbGltYmluZyA9IChhY2NlbGVyYXRpb24ueiAmJiBhY2NlbGVyYXRpb24ueSA8PSAwICYmIHRoaXMuY2hlY2tXYXkoMCwgMC4wNCwgYWNjZWxlcmF0aW9uLnopKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0NsaW1iaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VsZXJhdGlvbi55ID0gMC4wNCAvIHRocm90dGxpbmcueTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2NlbGVyYXRpb24ueiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWNjZWxlcmF0aW9uLnggKj0gdGhyb3R0bGluZy54O1xuICAgICAgICBhY2NlbGVyYXRpb24ueSAqPSB0aHJvdHRsaW5nLnk7XG4gICAgICAgIGFjY2VsZXJhdGlvbi56ICo9IHRocm90dGxpbmcuejtcblxuICAgICAgICBjb25zdCBpc01vdmluZyA9IChcbiAgICAgICAgICAgIE1hdGguYWJzKGFjY2VsZXJhdGlvbi54KSA+IDAuMDAxXG4gICAgICAgICAgICB8fCBNYXRoLmFicyhhY2NlbGVyYXRpb24ueSkgPiAwLjAwMVxuICAgICAgICAgICAgfHwgTWF0aC5hYnMoYWNjZWxlcmF0aW9uLnopID4gMC4wMDFcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNNb3ZpbmcpIHtcbiAgICAgICAgICAgIC8vIGFjY2VsZXJhdGlvbi5tdWx0aXBseVNjYWxhcihkZWx0YVRpbWUgKiA2MClcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkKGFjY2VsZXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja1dheSh4ID0gMCwgeSA9IDAsIHogPSAwKSB7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb24sIHBhcmFtczogeyBjaGVja1dheSB9IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhwb3NpdGlvbi54ICsgeCwgcG9zaXRpb24ueSArIHkgKyAwLjEsIHBvc2l0aW9uLnogKyB6KTtcblxuICAgICAgICByZXR1cm4gY2hlY2tXYXkobmV4dFBvc2l0aW9uLCB0aGlzKTtcbiAgICB9XG5cbiAgICBnZXRMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREaXJlY3Rpb24obmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMCkpO1xuICAgIH1cblxuICAgIGdldFVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREaXJlY3Rpb24obmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCkpO1xuICAgIH1cblxuICAgIGdldEZvcndhcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERpcmVjdGlvbihuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUSFJFRS5WZWN0b3IzfSBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICBnZXREaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgICAgIGRpcmVjdGlvbi5hcHBseVF1YXRlcm5pb24odGhpcy5vYmplY3QucXVhdGVybmlvbik7XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfVxuXG4gICAgZ2V0U2NhbGFyQWNjZWxlcmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuYWNjZWxlcmF0aW9uLnRvQXJyYXkoKVxuICAgICAgICAgICAgLm1hcChNYXRoLmFicylcbiAgICAgICAgICAgIC5yZWR1Y2UoKHIsIHYpID0+IHIgKyB2LCAwKVxuICAgIH1cbn0iLCJpbXBvcnQgRmlyaW5nVW5pdCBmcm9tICcuL0ZpcmluZ1VuaXQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF5ZXIgZXh0ZW5kcyBGaXJpbmdVbml0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBzcGVlZDogMC41NCxcbiAgICAgICAgICAgIGZpcmVUaW1lb3V0OiAxLFxuICAgICAgICAgICAgZmlyZURhbWFnZTogMjUsXG4gICAgICAgICAgICBkYW1hZ2U6IDUwLFxuICAgICAgICAgICAgaHA6IDEwMCxcbiAgICAgICAgICAgIGV4cGVyaWVuY2U6IDAsXG4gICAgICAgICAgICB1bnNwZW50VGFsZW50czogMCxcbiAgICAgICAgICAgIG1vbmV5OiA1MDAsXG4gICAgICAgICAgICBpc0ZpcmU6IGZhbHNlLFxuICAgICAgICAgICAgbWFzOiAxLFxuICAgICAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgICAgICBqdW1wVGltZW91dDogMC45LFxuICAgICAgICAgICAgZnJhY3Rpb246ICdmcmllbmRseScsXG4gICAgICAgICAgICBzZW5zaXRpdml0eTogMSxcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sYXN0SnVtcFRpbWVzdGFtcCA9IDA7XG4gICAgICAgIHRoaXMucm90YXRpb25BY2NlbGVyYXRpb24gPSAwO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdQbGF5ZXInLCB0aGlzKTtcblxuICAgICAgICBwYXJhbXMub25MZXZlbFVwICYmIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignb25MZXZlbFVwJywgcGFyYW1zLm9uTGV2ZWxVcCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHRpbWUsIGRlbHRhVGltZSkge1xuICAgICAgICBzdXBlci51cGRhdGUodGltZSwgZGVsdGFUaW1lKTtcblxuICAgICAgICBpZiAodGhpcy5pc0RlYWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBpbnB1dCwgb2JqZWN0LCBhY2NlbGVyYXRpb24sIGZyb21OZXR3b3JrIH0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgICBhY2NlbGVyYXRpb24uYWRkKHRoaXMuZ2V0TW92aW5nQWNjZWxlcmF0aW9uKHRpbWUsIGRlbHRhVGltZSkpO1xuXG4gICAgICAgIGlmIChpbnB1dC5hdHRhY2sxKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0LmF0dGFjazIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ0xlZnQgPSBpbnB1dC5ob3Jpem9udGFsID09PSAtMTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ1JpZ2h0ID0gaW5wdXQuaG9yaXpvbnRhbCA9PT0gMTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ0ZvcndhcmQgPSBpbnB1dC52ZXJ0aWNhbCA9PT0gMTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc01vdmluZ0JhY2t3YXJkID0gaW5wdXQudmVydGljYWwgPT09IC0xO1xuXG4gICAgICAgIGlmICghZnJvbU5ldHdvcmspIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5pc1RoaXJkUGVyc29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Lmxvb2suaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3Jpem9udGFsTG9vayA9IGlucHV0Lmxvb2suaG9yaXpvbnRhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc1JvdGF0ZUxlZnQgPSBob3Jpem9udGFsTG9vayA8IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNSb3RhdGVSaWdodCA9IGhvcml6b250YWxMb29rID4gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbkFjY2VsZXJhdGlvbiArPSAoLWhvcml6b250YWxMb29rIC8gNTAwMCkgKiBpbnB1dC5sb29rLnNlbnNpdGl2aXR5O1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5yZXNldEhvcml6b250YWxMb29rKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgQ0FMQ19ST1RBVEVfVEhSRVNIT0xEID0gMC4wMDAwMDAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMucm90YXRpb25BY2NlbGVyYXRpb24pID4gQ0FMQ19ST1RBVEVfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5yb3RhdGVPbldvcmxkQXhpcyhuZXcgVEhSRUUuVmVjdG9yMygwLCAxLCAwKSwgdGhpcy5yb3RhdGlvbkFjY2VsZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb25BY2NlbGVyYXRpb24gKj0gMC43O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFYID0gd2luZG93LmlubmVyV2lkdGggLyAyIC0gaW5wdXQuY3Vyc29yLng7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFZID0gaW5wdXQuY3Vyc29yLnkgLSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdGF0aW9uWSA9IE1hdGguYXRhbjIoZGVsdGFZLCBkZWx0YVgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc1JvdGF0ZUxlZnQgPSByb3RhdGlvblkgPiBvYmplY3Qucm90YXRpb24ueTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLmlzUm90YXRlUmlnaHQgPSByb3RhdGlvblkgPCBvYmplY3Qucm90YXRpb24ueTtcblxuICAgICAgICAgICAgICAgIG9iamVjdC5yb3RhdGlvbi5zZXQoMCwgcm90YXRpb25ZLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFVuc3BlbnRUYWxlbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMudW5zcGVudFRhbGVudHM7XG4gICAgfVxuXG4gICAgZGVjcmVhc2VVbnNwZW50VGFsZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLnVuc3BlbnRUYWxlbnRzLS07XG4gICAgfVxuXG4gICAgZ2V0RmlyZUluaXRpYWxQb3NpdGlvbigpIHtcbiAgICAgICAgY29uc3QgaGVhZCA9IHRoaXMuZ2V0Q2hpbGRCeU5hbWUoJ0hlYWQnKTtcbiAgICAgICAgY29uc3QgaGVhZEZvcndhcmQgPSB0aGlzLmdldENoaWxkRGlyZWN0aW9uKGhlYWQsIG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpKTtcbiAgICAgICAgY29uc3QgaGVhZFVwID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCk7XG4gICAgICAgIGhlYWRVcC5hcHBseVF1YXRlcm5pb24oaGVhZC5xdWF0ZXJuaW9uKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZFBvc2l0aW9uKGhlYWQpXG4gICAgICAgICAgICAuYWRkKGhlYWRVcC5tdWx0aXBseVNjYWxhcigwLjE1KSlcbiAgICAgICAgICAgIC5hZGQoaGVhZEZvcndhcmQubXVsdGlwbHlTY2FsYXIoMC4yNSkpO1xuICAgIH1cblxuICAgIGdldEZpcmVJbml0aWFsUm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENoaWxkUm90YXRpb24oJ0hlYWQnKTtcbiAgICB9XG5cbiAgICBhZGRFeHBlcmllbmNlKGV4cGVyaWVuY2UpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMuZXhwZXJpZW5jZSArPSBleHBlcmllbmNlO1xuXG4gICAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5nZXRMZXZlbCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5sZXZlbCAhPT0gbGV2ZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsc1VwID0gbGV2ZWwgLSB0aGlzLnBhcmFtcy5sZXZlbDtcblxuICAgICAgICAgICAgdGhpcy5wYXJhbXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLnVuc3BlbnRUYWxlbnRzICs9IDMgKiBsZXZlbHNVcDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLmhwID0gdGhpcy5wYXJhbXMuaHBNYXg7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ29uTGV2ZWxVcCcsIGxldmVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEV4cGVyaWVuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5leHBlcmllbmNlO1xuICAgIH1cblxuICAgIGdldExldmVsRXhwZXJpZW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHRoaXMuZ2V0TGV2ZWwoKSwgMikgKiAxMDA7XG4gICAgfVxuXG4gICAgZ2V0TGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGguc3FydCh0aGlzLnBhcmFtcy5leHBlcmllbmNlIC8gMTAwKSkgKyAxO1xuICAgIH1cblxuICAgIGdldE1vdmluZ0FjY2VsZXJhdGlvbih0aW1lLCBkZWx0YVRpbWUpIHtcbiAgICAgICAgY29uc3QgeyBpbnB1dDogeyBob3Jpem9udGFsLCB2ZXJ0aWNhbCwganVtcCB9IH0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgICBjb25zdCBzcGVlZCA9IHZlcnRpY2FsICYmIGhvcml6b250YWxcbiAgICAgICAgICAgID8gdGhpcy5wYXJhbXMuc3BlZWQgKiAwLjEgKiAwLjcgKiAoZGVsdGFUaW1lICogMC4wNilcbiAgICAgICAgICAgIDogdGhpcy5wYXJhbXMuc3BlZWQgKiAwLjEgKiAoZGVsdGFUaW1lICogMC4wNik7XG5cbiAgICAgICAgY29uc3QgYWRkRm9yd2FyZCA9IHZlcnRpY2FsID09PSAxXG4gICAgICAgICAgICA/IHNwZWVkXG4gICAgICAgICAgICA6ICh2ZXJ0aWNhbCA9PT0gLTEgPyAtc3BlZWQgKiAwLjYgOiAwKTtcblxuICAgICAgICBjb25zdCBhZGRTaWRlID0gdmVydGljYWwgPT09IC0xXG4gICAgICAgICAgICA/ICgtaG9yaXpvbnRhbCAqIHNwZWVkICogMC42KVxuICAgICAgICAgICAgOiAoLWhvcml6b250YWwgKiBzcGVlZCApO1xuXG4gICAgICAgIGNvbnN0IGlzSnVtcCA9IChcbiAgICAgICAgICAgIHRpbWUgLSB0aGlzLmxhc3RKdW1wVGltZXN0YW1wID4gdGhpcy5wYXJhbXMuanVtcFRpbWVvdXQgKiAxMDAwXG4gICAgICAgICAgICAmJiBqdW1wXG4gICAgICAgICAgICAmJiB0aGlzLmlzR3JvdW5kZWRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNKdW1wKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RKdW1wVGltZXN0YW1wID0gdGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldERpcmVjdGlvbihuZXcgVEhSRUUuVmVjdG9yMyhhZGRTaWRlLCBOdW1iZXIoaXNKdW1wKSAqIDAuMjUsIGFkZEZvcndhcmQpKTtcbiAgICB9XG59IiwiaW1wb3J0IE1vdmluZ0dhbWVPYmplY3QgZnJvbSAnLi9Nb3ZpbmdHYW1lT2JqZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5pdCBleHRlbmRzIE1vdmluZ0dhbWVPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGhwOiAxMDAsXG4gICAgICAgICAgICBocE1heDogcGFyYW1zLmhwIHx8IDEwMCxcbiAgICAgICAgICAgIGRhbWFnZTogMTAsXG4gICAgICAgICAgICBhdHRhY2tUaW1lb3V0OiAwLjksXG4gICAgICAgICAgICBoaXRUaW1lOiAwLjMsXG4gICAgICAgICAgICBhdHRhY2tEYW1hZ2VUaW1lb3V0OiAwLjMsXG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2hvdWxkQXR0YWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGF0ZXN0QXR0YWNrVGltZXN0YW1wID0gMDtcbiAgICAgICAgdGhpcy5sYXRlc3RIaXRUaW1lc3RhbXAgPSAwO1xuXG4gICAgICAgIFsnb25EYW1hZ2VUYWtlbicsICdvbkRhbWFnZURlYWwnLCAnb25LaWxsJywgJ29uRGllJ10uZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1tldmVudE5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcGFyYW1zW2V2ZW50TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGUodGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZSh0aW1lLCBkZWx0YVRpbWUpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRGVhZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoaXRSZWxlYXNlZCA9IHRoaXMuaXNIaXRSZWxlYXNlZCh0aW1lKTtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLmlzSGl0ID0gIWhpdFJlbGVhc2VkO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNrUmVsZWFzZWQodGltZSkgJiYgaGl0UmVsZWFzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuaXNBdHRhY2sgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkQXR0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc0F0dGFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RBdHRhY2tUaW1lc3RhbXAgPSB0aW1lO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLmF0dGFjayAmJiB0aGlzLnBhcmFtcy5hdHRhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQXR0YWNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGcmFjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmZyYWN0aW9uO1xuICAgIH1cblxuICAgIGdldENvbGxpZGVyKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IGRpZmZZID0gcG9zaXRpb24ueSAtIHRoaXMucG9zaXRpb24ueTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgIE1hdGgucG93KHBvc2l0aW9uLnggLSB0aGlzLnBvc2l0aW9uLngsIDIpXG4gICAgICAgICAgICAgICAgKyBNYXRoLnBvdyhwb3NpdGlvbi56IC0gdGhpcy5wb3NpdGlvbi56LCAyKVxuICAgICAgICAgICAgKSA8IDFcbiAgICAgICAgICAgICYmIGRpZmZZID49IDBcbiAgICAgICAgICAgICYmIGRpZmZZIDwgMS43XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmVsZWFzZUF0dGFjayh0aW1lKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0QXR0YWNrVGltZXN0YW1wID0gdGltZSAtIHRoaXMucGFyYW1zLmF0dGFja1RpbWVvdXQgKiAxMDAwO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLmlzQXR0YWNrID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaXNBdHRhY2tSZWxlYXNlZCh0aW1lKSB7XG4gICAgICAgIHJldHVybiAodGltZSAtIHRoaXMubGF0ZXN0QXR0YWNrVGltZXN0YW1wID49IHRoaXMucGFyYW1zLmF0dGFja1RpbWVvdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBpc0F0dGFja0ludGVycnVwdGVkKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aW1lIC0gdGhpcy5sYXRlc3RIaXRUaW1lc3RhbXAgPD0gdGhpcy5wYXJhbXMuYXR0YWNrRGFtYWdlVGltZW91dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGlzSGl0UmVsZWFzZWQodGltZSkge1xuICAgICAgICByZXR1cm4gKHRpbWUgLSB0aGlzLmxhdGVzdEhpdFRpbWVzdGFtcCA+PSB0aGlzLnBhcmFtcy5oaXRUaW1lICogMTAwMCk7XG4gICAgfVxuXG4gICAgYXR0YWNrKCkge1xuICAgICAgICB0aGlzLnNob3VsZEF0dGFjayA9IHRydWU7XG4gICAgfVxuXG4gICAgaXNEZWFkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuaHAgPD0gMDtcbiAgICB9XG5cbiAgICBpc0FsaXZlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNEZWFkKCk7XG4gICAgfVxuICAgIFxuICAgIGlzRW5lbXkodW5pdCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdW5pdC5wYXJhbXMuZnJhY3Rpb24gIT09IHRoaXMucGFyYW1zLmZyYWN0aW9uXG4gICAgICAgICAgICAmJiB1bml0LnBhcmFtcy5mcmFjdGlvbiAhPT0gJ25ldXRyYWwnXG4gICAgICAgICAgICAmJiB0aGlzLnBhcmFtcy5mcmFjdGlvbiAhPT0gJ25ldXRyYWwnXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0TGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5sZXZlbDtcbiAgICB9XG5cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMubmFtZTtcbiAgICB9XG5cbiAgICBnZXRBdHRhY2tUaW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuYXR0YWNrRGFtYWdlVGltZW91dCAqIDEwMDA7XG4gICAgfVxuXG4gICAgZGFtYWdlVGFrZW4oeyBkYW1hZ2UsIHVuaXQ6IGF0dGFja2VyIH0gPSB7fSwgdGltZSkge1xuICAgICAgICBpZiAoZGFtYWdlICYmIGF0dGFja2VyKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5ocCAtPSBkYW1hZ2U7XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnb25EYW1hZ2VUYWtlbicsIGF0dGFja2VyKTtcblxuICAgICAgICAgICAgaWYgKGF0dGFja2VyKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNrZXIuZGlzcGF0Y2hFdmVudCgnb25EYW1hZ2VEZWFsJywgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGludGVycnVwdEJ5Q2hhbmNlID0gTWF0aC5yYW5kb20oKSA8IDAuMzM7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnJ1cHRCeUxldmVsID0gYXR0YWNrZXIuZ2V0TGV2ZWwoKSAtIHRoaXMuZ2V0TGV2ZWwoKSA+IDI7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUludGVycnVwdGVkID0gaW50ZXJydXB0QnlMZXZlbCB8fCBpbnRlcnJ1cHRCeUNoYW5jZTtcblxuICAgICAgICAgICAgaWYgKHNob3VsZEJlSW50ZXJydXB0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdEhpdFRpbWVzdGFtcCA9IHRpbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGVhZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWUoYXR0YWNrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGllKGtpbGxpbmdVbml0KSB7XG4gICAgICAgIHRoaXMucGFyYW1zLmhwID0gMDtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdvbkRpZScsIGtpbGxpbmdVbml0KTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS5pc0RpZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGtpbGxpbmdVbml0KSB7XG4gICAgICAgICAgICBraWxsaW5nVW5pdC5kaXNwYXRjaEV2ZW50KCdvbktpbGwnLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFNwZWVkKHNwZWVkKSB7XG4gICAgICAgIHRoaXMucGFyYW1zLnNwZWVkICs9IHNwZWVkO1xuICAgIH1cblxuICAgIGFkZERhbWFnZShkYW1hZ2UpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMuZGFtYWdlICs9IGRhbWFnZTtcbiAgICB9XG5cbiAgICBhZGRIUChocCkge1xuICAgICAgICBpZiAodGhpcy5pc0FsaXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLmhwID0gTWF0aC5taW4odGhpcy5wYXJhbXMuaHAgKyBocCwgdGhpcy5wYXJhbXMuaHBNYXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TW9uZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5tb25leTtcbiAgICB9XG5cbiAgICBhZGRNb25leShtb25leSkge1xuICAgICAgICB0aGlzLnBhcmFtcy5tb25leSArPSBtb25leTtcbiAgICB9XG5cbiAgICBhZGRNYXhIUChocCkge1xuICAgICAgICBpZiAodGhpcy5pc0FsaXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zLmhwTWF4ICs9IGhwO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMuaHAgKz0gaHA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRIUCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmhwO1xuICAgIH1cblxuICAgIGdldE1heEhQKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuaHBNYXg7XG4gICAgfVxuXG4gICAgZ2V0U3BlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5zcGVlZDtcbiAgICB9XG5cbiAgICBnZXREYW1hZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5kYW1hZ2U7XG4gICAgfVxufSIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuXG5jb25zdCBLRVlTID0ge1xuICAgIE1PVVNFX0xFRlQ6IDEsXG4gICAgTU9VU0VfUklHSFQ6IDMsXG4gICAgU1BBQ0U6IDMyLFxuICAgIEVOVEVSOiAxMyxcbiAgICBFU0M6IDI3LFxuICAgIEM6IDY3LFxuICAgIFc6IDg3LFxuICAgIEE6IDY1LFxuICAgIFM6IDgzLFxuICAgIEQ6IDY4LFxuICAgIFg6IDg4LFxuICAgIFo6IDkwLFxuICAgIFE6IDgxLFxuICAgIEU6IDY5LFxuICAgIFI6IDgyLFxuICAgIEY6IDcwLFxuICAgIFY6IDg2LFxuICAgIDE6IDQ5LFxuICAgIDI6IDUwLFxuICAgIEFSUk9XX0xFRlQ6IDM3LFxuICAgIEFSUk9XX1JJR0hUOiAzOSxcbiAgICBBUlJPV19VUDogMzgsXG4gICAgQVJST1dfRE9XTjogNDAsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dCBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnZlcnRpY2FsID0gMDtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gMDtcbiAgICAgICAgdGhpcy5hdHRhY2sxID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXR0YWNrMiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvb2sgPSB7XG4gICAgICAgICAgICB2ZXJ0aWNhbDogMCxcbiAgICAgICAgICAgIGhvcml6b250YWw6IDAsXG4gICAgICAgICAgICBiYWNrOiBmYWxzZSxcbiAgICAgICAgICAgIHNlbnNpdGl2aXR5OiAxLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc2V0SG9yaXpvbnRhbExvb2sgPSAoKSA9PiB0aGlzLmxvb2suaG9yaXpvbnRhbCA9IDA7XG4gICAgICAgIHRoaXMuaXNUaGlyZFBlcnNvbiA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5jdXJzb3IgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm1vdXNlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5sb29rLmhvcml6b250YWwgPSAwO1xuICAgICAgICB0aGlzLmxvb2sudmVydGljYWwgPSAwO1xuICAgIH1cblxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IEtFWVMuTU9VU0VfTEVGVCkgeyB0aGlzLmF0dGFjazEgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gS0VZUy5NT1VTRV9SSUdIVCkgeyB0aGlzLmF0dGFjazIgPSB0cnVlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IEtFWVMuTU9VU0VfTEVGVCkgeyB0aGlzLmF0dGFjazEgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IEtFWVMuTU9VU0VfUklHSFQpIHsgdGhpcy5hdHRhY2syID0gZmFsc2U7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHRpbWVvdXQ7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvb2suaG9yaXpvbnRhbCArPSBlLm1vdmVtZW50WCB8fCAwO1xuICAgICAgICAgICAgdGhpcy5sb29rLnZlcnRpY2FsICs9IGUubW92ZW1lbnRZIHx8IDA7XG5cbiAgICAgICAgICAgIHRoaXMubW91c2UueCA9IGUueDtcbiAgICAgICAgICAgIHRoaXMubW91c2UueSA9IGUueTtcblxuICAgICAgICAgICAgY29uc3QgY3Vyc29yWCA9IHRoaXMuY3Vyc29yLnggKyAoZS5tb3ZlbWVudFggfHwgMCk7XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JZID0gdGhpcy5jdXJzb3IueSArIChlLm1vdmVtZW50WSB8fCAwKTtcblxuICAgICAgICAgICAgaWYgKGN1cnNvclggPiAwICYmIGN1cnNvclggPCB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnggPSBjdXJzb3JYO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3Vyc29yWSA+IDAgJiYgY3Vyc29yWSA8IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnkgPSBjdXJzb3JZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnb25tb3VzZW1vdmVlbmQnKSk7XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdvbm1vdXNlbW92ZWVuZCcsIChlKSA9PiB7XG4gICAgICAgICAgICAvLyBIb3Jpem9udGFsIGxvb2sgaXMgY2xlYW5pbmcgYnkgUGxheWVyLnVwZGF0ZSBhZnRlciByb3RhdGlvbiBpcyBhcHBsaWVkXG4gICAgICAgICAgICAvLyB0aGlzLmxvb2suaG9yaXpvbnRhbCA9IDA7XG4gICAgICAgICAgICB0aGlzLmxvb2sudmVydGljYWwgPSAwO1xuICAgICAgICB9KTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5FTlRFUjogdGhpcy5wYXJhbXMub25BY3Rpb24gJiYgdGhpcy5wYXJhbXMub25BY3Rpb24oKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkVTQzogdGhpcy5wYXJhbXMub25FeGl0ICYmIHRoaXMucGFyYW1zLm9uRXhpdCgpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuQzogdGhpcy5wYXJhbXMub25Td2l0Y2hDYW1lcmEgJiYgdGhpcy5wYXJhbXMub25Td2l0Y2hDYW1lcmEoKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLlc6IGNhc2UgS0VZUy5BUlJPV19VUDogdGhpcy52ZXJ0aWNhbCA9IDE7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5TOiBjYXNlIEtFWVMuQVJST1dfRE9XTjogdGhpcy52ZXJ0aWNhbCA9IC0xOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuQTogY2FzZSBLRVlTLkFSUk9XX0xFRlQ6IHRoaXMuaG9yaXpvbnRhbCA9IC0xOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuRDogY2FzZSBLRVlTLkFSUk9XX1JJR0hUOiB0aGlzLmhvcml6b250YWwgPSAxOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuWDogdGhpcy5sb29rLmJhY2sgPSB0cnVlOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuRjogdGhpcy5sb29rLmNpbmVtYXRpYyA9IHRydWU7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5TUEFDRTogdGhpcy5qdW1wID0gMTsgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGUpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5XOlxuICAgICAgICAgICAgICAgIGNhc2UgS0VZUy5BUlJPV19VUDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmVydGljYWwgPT09IDEpIHsgdGhpcy52ZXJ0aWNhbCA9IDA7IH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLlM6XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkFSUk9XX0RPV046XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2FsID09PSAtMSkgeyB0aGlzLnZlcnRpY2FsID0gMDsgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuQTpcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuQVJST1dfTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCA9PT0gLTEpIHsgdGhpcy5ob3Jpem9udGFsID0gMDsgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuRDpcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuQVJST1dfUklHSFQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhvcml6b250YWwgPT09IDEpIHsgdGhpcy5ob3Jpem9udGFsID0gMDsgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEtFWVMuWDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb29rLmJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLkY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9vay5jaW5lbWF0aWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLRVlTLlNQQUNFOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmp1bXAgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgZSA9PiB0aGlzLnBhcmFtcy5vblpvb20gJiYgdGhpcy5wYXJhbXMub25ab29tKGUuZGVsdGFZIC8gMTAwKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVydmFscyBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgY29uc3RydWN0b3Ioc2NlbmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLnRpbWVQYXNzZWQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RGcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzID0gW107XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgdXBkYXRlKG5vdykge1xuICAgICAgICB0aGlzLnRpbWVQYXNzZWQgKz0gbm93IC0gdGhpcy5sYXN0RnJhbWU7XG5cbiAgICAgICAgdGhpcy5pbnRlcnZhbHNcbiAgICAgICAgICAgIC5maWx0ZXIoaSA9PiB0aGlzLnRpbWVQYXNzZWQgLSBpLmNhbGxlZEF0ID4gaS5pbnRlcnZhbClcbiAgICAgICAgICAgIC5mb3JFYWNoKChpbnRlcnZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGludGVydmFsLmNhbGxlZEF0ID0gdGhpcy50aW1lUGFzc2VkO1xuICAgICAgICAgICAgICAgIGludGVydmFsLmZuKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJ2YWwubG9vcHMgJiYgLS1pbnRlcnZhbC5sb29wcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubGFzdEZyYW1lID0gbm93O1xuICAgIH1cblxuICAgIGdldFRpbWVQYXNzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVQYXNzZWQ7XG4gICAgfVxuXG4gICAgZ2V0RGVsdGFUaW1lKG5vdykge1xuICAgICAgICByZXR1cm4gbm93IC0gdGhpcy5sYXN0RnJhbWU7XG4gICAgfVxuXG4gICAgc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsLCBpbW1lZGlhdGVseSwgbG9vcHMpIHtcbiAgICAgICAgaWYgKGZuICYmIGludGVydmFsKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsZWRBdCA9IGltbWVkaWF0ZWx5ID8gdGhpcy50aW1lUGFzc2VkIC0gaW50ZXJ2YWwgOiB0aGlzLnRpbWVQYXNzZWQ7XG5cbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIGZuLFxuICAgICAgICAgICAgICAgIGludGVydmFsLFxuICAgICAgICAgICAgICAgIGNhbGxlZEF0LFxuICAgICAgICAgICAgICAgIGxvb3BzLFxuICAgICAgICAgICAgICAgIGlkOiArK3RoaXMuaW50ZXJ2YWxJbmRleCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0VGltZW91dChmbiwgdGltZW91dCkge1xuICAgICAgICBpZiAoZm4gJiYgdGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgbG9vcHM6IDEsXG4gICAgICAgICAgICAgICAgY2FsbGVkQXQ6IHRoaXMudGltZVBhc3NlZCxcbiAgICAgICAgICAgICAgICBpZDogKyt0aGlzLmludGVydmFsSW5kZXgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFySW50ZXJ2YWwoaWQpIHtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxJZHggPSB0aGlzLmludGVydmFscy5maW5kSW5kZXgoaSA9PiBpLmlkID09PSBpZCk7XG5cbiAgICAgICAgaWYgKGludGVydmFsSWR4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzLnNwbGljZShpbnRlcnZhbElkeCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuLi9BdXRvQmluZE1ldGhvZHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBYnN0cmFjdExvY2F0aW9uIGV4dGVuZHMgQXV0b0JpbmRNZXRob2RzIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lLCBpZCA9ICd1bmtub3duLWxldmVsJykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7fVxuXG4gICAgc3RhcnRMb2NhdGlvbigpIHt9XG4gICAgcmVzdGFydExvY2F0aW9uKCkge31cbiAgICBzdG9wTG9jYXRpb24oKSB7fVxuICAgIG9uQWN0aW9uKCkge31cblxuICAgIGdldExvY2F0aW9uTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuXG4gICAgY3JlYXRlQW1iaWVudExpZ2h0KCkge1xuICAgICAgICBjb25zdCBhbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4ODg4ODg4KTtcbiAgICAgICAgYW1iaWVudExpZ2h0LmNhc3RTaGFkb3cgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGFtYmllbnRMaWdodDtcbiAgICB9XG5cbiAgICBjcmVhdGVTaGFkb3dMaWdodCgpIHtcbiAgICAgICAgY29uc3QgbGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweGZmZmZmZiwgMTAsIDE1MCk7XG4gICAgICAgIGxpZ2h0LmludGVuc2l0eSA9IDE7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5iaWFzID0gLTAuMDAwMDE7XG4gICAgICAgIGNvbnN0IHNoYWRvd1NpemUgPSAyNTtcbiAgICAgICAgbGlnaHQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5jYW1lcmEubGVmdCA9IC1zaGFkb3dTaXplO1xuICAgICAgICBsaWdodC5zaGFkb3cuY2FtZXJhLnJpZ2h0ID0gc2hhZG93U2l6ZTtcbiAgICAgICAgbGlnaHQuc2hhZG93LmNhbWVyYS50b3AgPSBzaGFkb3dTaXplO1xuICAgICAgICBsaWdodC5zaGFkb3cuY2FtZXJhLmJvdHRvbSA9IC1zaGFkb3dTaXplO1xuICAgICAgICBsaWdodC5zaGFkb3cubWFwU2l6ZS53aWR0aCA9IDUxMjtcbiAgICAgICAgbGlnaHQuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gNTEyO1xuICAgICAgICBsaWdodC5zaGFkb3cuY2FtZXJhLm5lYXIgPSAxMDtcbiAgICAgICAgbGlnaHQuc2hhZG93LmNhbWVyYS5mYXIgPSAxNTA7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5jYW1lcmEudmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGxpZ2h0O1xuICAgIH1cblxuXG4gICAgY3JlYXRlU2t5Ym94KCkge1xuICAgICAgICBjb25zdCBtYXRlcmlhbEFycmF5ID0gWyd4cG9zJywgJ3huZWcnLCAneXBvcycsICd5bmVnJywgJ3pwb3MnLCAnem5lZyddLm1hcChmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgLi9hc3NldHMvdGV4dHVyZXMvc2t5LW5lYnVsYS9uZWJ1bGEtJHtkaXJlY3Rpb259LnBuZ2A7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgICAgICAgICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCh1cmwpLFxuICAgICAgICAgICAgICAgIHNpZGU6IFRIUkVFLkJhY2tTaWRlLFxuICAgICAgICAgICAgICAgIGZvZzogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBza3lHZW9tZXRyeSA9IG5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoNzUwMDAsIDc1MDAwLCA3NTAwMCk7XG4gICAgICAgIGNvbnN0IHNreU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwobWF0ZXJpYWxBcnJheSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NZXNoKHNreUdlb21ldHJ5LCBza3lNYXRlcmlhbCk7XG4gICAgfVxufSIsImNvbnN0IGJ1aWxkQXJlYSA9IChhcmVhSWQsIG1hcCkgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gQXJlYVNpemVzW2FyZWFJZF07XG5cbiAgICBjb25zdCB3YXlwb2ludFhUb1dvcmxkWCA9IHBvc2l0aW9uID0+IHBvc2l0aW9uIC0gd2lkdGggLyAyO1xuICAgIGNvbnN0IHdheXBvaW50WVRvV29ybGRaID0gcG9zaXRpb24gPT4gcG9zaXRpb24gLSBoZWlnaHQgLyAyO1xuXG4gICAgY29uc3Qgd29ybGRYVG9XYXlwb2ludFggPSAocG9zaXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgZ3JhcGhYID0gTWF0aC5yb3VuZChwb3NpdGlvbiArIHdpZHRoIC8gMik7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChncmFwaFgsIDQpLCB3aWR0aCAtIDUpO1xuICAgIH07XG5cbiAgICBjb25zdCB3b3JsZFpUb1dheXBvaW50WSA9IChwb3NpdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBncmFwaFkgPSBNYXRoLnJvdW5kKHBvc2l0aW9uICsgaGVpZ2h0IC8gMik7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChncmFwaFksIDQpLCBoZWlnaHQgLSA1KTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXJlYSA9IHtcbiAgICAgICAgaWQ6IGFyZWFJZCxcbiAgICAgICAgd2F5cG9pbnRYVG9Xb3JsZFgsXG4gICAgICAgIHdheXBvaW50WVRvV29ybGRaLFxuICAgICAgICB3b3JsZFhUb1dheXBvaW50WCxcbiAgICAgICAgd29ybGRaVG9XYXlwb2ludFksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgfTtcblxuICAgIHJldHVybiBtYXAoYXJlYSk7XG59O1xuXG5jb25zdCBBcmVhU2l6ZXMgPSB7XG4gICAgRkxPT1JfMDoge1xuICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICBoZWlnaHQ6IDE1MCxcbiAgICB9LFxuICAgIEZMT09SXzE6IHtcbiAgICAgICAgd2lkdGg6IDI3MCxcbiAgICAgICAgaGVpZ2h0OiAyNzAsXG4gICAgfSxcbiAgICBGTE9PUl8yOiB7XG4gICAgICAgIHdpZHRoOiAyNzAsXG4gICAgICAgIGhlaWdodDogMjcwLFxuICAgIH1cbn07XG5cbmNvbnN0IEFyZWFzID0ge1xuICAgIEZMT09SXzA6IGJ1aWxkQXJlYSgnRkxPT1JfMCcsIGFyZWEgPT4gKHtcbiAgICAgICAgLi4uYXJlYSxcbiAgICAgICAgaW5jbHVkZXNQb3NpdGlvbjogcG9zaXRpb24gPT4gcG9zaXRpb24ueSA8IDEwMCxcbiAgICAgICAgZ2V0V29ybGRXYXlwb2ludEJ5WFk6ICh4LCB5KSA9PiAoeyB4OiBhcmVhLndheXBvaW50WFRvV29ybGRYKHgpLCB5OiAwLjIsIHo6IGFyZWEud2F5cG9pbnRZVG9Xb3JsZFooeSkgfSksXG4gICAgICAgIGdldFdheXBvaW50UG9ydGFsczogKCkgPT4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IHsgeDogYXJlYS53b3JsZFhUb1dheXBvaW50WCgtNDkpLCB5OiBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKDApIH0sXG4gICAgICAgICAgICAgICAgdG86IHsgeDogYXJlYS53b3JsZFhUb1dheXBvaW50WCgtNDkpLCB5OiBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKDApLCBhcmVhSWQ6ICdGTE9PUl8xJyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IHsgeDogYXJlYS53b3JsZFhUb1dheXBvaW50WCgtNDkpLCB5OiBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKDApIH0sXG4gICAgICAgICAgICAgICAgdG86IHsgeDogYXJlYS53b3JsZFhUb1dheXBvaW50WCgtNDkpLCB5OiBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKDApLCBhcmVhSWQ6ICdGTE9PUl8yJyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgfSkpLFxuXG4gICAgRkxPT1JfMTogYnVpbGRBcmVhKCdGTE9PUl8xJywgYXJlYSA9PiAoe1xuICAgICAgICAuLi5hcmVhLFxuICAgICAgICBpbmNsdWRlc1Bvc2l0aW9uOiBwb3NpdGlvbiA9PiBwb3NpdGlvbi55IDwgMjAwLFxuICAgICAgICBnZXRXb3JsZFdheXBvaW50QnlYWTogKHgsIHkpID0+ICh7IHg6IGFyZWEud2F5cG9pbnRYVG9Xb3JsZFgoeCksIHk6IDEwMC4yLCB6OiBhcmVhLndheXBvaW50WVRvV29ybGRaKHkpIH0pLFxuICAgICAgICBnZXRXYXlwb2ludFBvcnRhbHM6ICgpID0+IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcm9tOiB7IHg6IGFyZWEud29ybGRYVG9XYXlwb2ludFgoLTQ4KSwgeTogYXJlYS53b3JsZFpUb1dheXBvaW50WSgwKSB9LFxuICAgICAgICAgICAgICAgIHRvOiB7IHg6IGFyZWEud29ybGRYVG9XYXlwb2ludFgoLTQ4KSwgeTogYXJlYS53b3JsZFpUb1dheXBvaW50WSgwKSwgYXJlYUlkOiAnRkxPT1JfMCcgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcm9tOiB7IHg6IGFyZWEud29ybGRYVG9XYXlwb2ludFgoLTQ4KSwgeTogYXJlYS53b3JsZFpUb1dheXBvaW50WSgwKSB9LFxuICAgICAgICAgICAgICAgIHRvOiB7IHg6IGFyZWEud29ybGRYVG9XYXlwb2ludFgoLTQ4KSwgeTogYXJlYS53b3JsZFpUb1dheXBvaW50WSgwKSwgYXJlYUlkOiAnRkxPT1JfMicgfVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgIH0pKSxcblxuICAgIEZMT09SXzI6IGJ1aWxkQXJlYSgnRkxPT1JfMicsIGFyZWEgPT4gKHtcbiAgICAgICAgLi4uYXJlYSxcbiAgICAgICAgaW5jbHVkZXNQb3NpdGlvbjogcG9zaXRpb24gPT4gcG9zaXRpb24ueSA+PSAyMDAsXG4gICAgICAgIGdldFdvcmxkV2F5cG9pbnRCeVhZOiAoeCwgeSkgPT4gKHsgeDogYXJlYS53YXlwb2ludFhUb1dvcmxkWCh4KSwgeTogMjAwLjIsIHo6IGFyZWEud2F5cG9pbnRZVG9Xb3JsZFooeSkgfSksXG4gICAgICAgIGdldFdheXBvaW50UG9ydGFsczogKCkgPT4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IHsgeDogYXJlYS53b3JsZFhUb1dheXBvaW50WCgtNDgpLCB5OiBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKDApIH0sXG4gICAgICAgICAgICAgICAgdG86IHsgeDogYXJlYS53b3JsZFhUb1dheXBvaW50WCgtNDgpLCB5OiBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKDApLCBhcmVhSWQ6ICdGTE9PUl8wJyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb206IHsgeDogYXJlYS53b3JsZFhUb1dheXBvaW50WCgtNDgpLCB5OiBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKDApIH0sXG4gICAgICAgICAgICAgICAgdG86IHsgeDogYXJlYS53b3JsZFhUb1dheXBvaW50WCgtNDgpLCB5OiBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKDApLCBhcmVhSWQ6ICdGTE9PUl8xJyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgfSkpLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQXJlYXM7IiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuLi8uLi9BdXRvQmluZE1ldGhvZHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGV2YXRvciBleHRlbmRzIEF1dG9CaW5kTWV0aG9kcyB7XG4gICAgY29uc3RydWN0b3Ioc2NlbmUsIHBhcmFtcykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50Rmxvb3IgPSAxO1xuICAgICAgICB0aGlzLnRhcmdldCA9IDA7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gLTE7XG4gICAgICAgIHRoaXMuc3BlZWQgPSAwLjM7XG4gICAgICAgIHRoaXMuc3RhbmRUaW1lID0gMTA7XG5cbiAgICAgICAgdGhpcy5vYmplY3QgPSB0aGlzLnNjZW5lLm1vZGVscy5jcmVhdGVDdWJlKHBhcmFtcyk7XG4gICAgICAgIHRoaXMuc3RhbmRBdCA9IHRoaXMuc2NlbmUuaW50ZXJ2YWxzLmdldFRpbWVQYXNzZWQoKTtcbiAgICB9XG5cbiAgICBpc1JlbGVhc2VkKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5zY2VuZS5pbnRlcnZhbHMuZ2V0VGltZVBhc3NlZCgpIC0gdGhpcy5zdGFuZEF0ID4gdGhpcy5zdGFuZFRpbWUgKiAxMDAwXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaXNDYXJyeWluZyh7IHgsIHksIHogfSkge1xuICAgICAgICBjb25zdCB7IG9iamVjdDogeyBwb3NpdGlvbiwgc2NhbGUgfSB9ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgTWF0aC5hYnMoeCAtIHBvc2l0aW9uLngpIDwgc2NhbGUueCAvIDJcbiAgICAgICAgICAgICYmIE1hdGguYWJzKHogLSBwb3NpdGlvbi56KSA8IHNjYWxlLnogLyAyXG4gICAgICAgICAgICAmJiAoeSAtIHBvc2l0aW9uLnkgPCBzY2FsZS55IC8gMilcbiAgICAgICAgICAgIC8vICYmICh5ICsgMS43KSAtIHBvc2l0aW9uLnkgPiAtc2NhbGUueSAvIDJcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgZ2V0Rmxvb3IoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA+IDBcbiAgICAgICAgICAgICAgICA/IChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMub2JqZWN0LnBvc2l0aW9uLnkgPj0gMjAwICYmIDIpXG4gICAgICAgICAgICAgICAgICAgIHx8ICh0aGlzLm9iamVjdC5wb3NpdGlvbi55ID49IDEwMCAmJiAxKVxuICAgICAgICAgICAgICAgICAgICB8fCAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogKFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5vYmplY3QucG9zaXRpb24ueSA+IDEwMCAmJiAyKVxuICAgICAgICAgICAgICAgICAgICB8fCAodGhpcy5vYmplY3QucG9zaXRpb24ueSA+IDAgJiYgMSlcbiAgICAgICAgICAgICAgICAgICAgfHwgMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVsZWFzZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgZmxvb3IgPSB0aGlzLmdldEZsb29yKCk7XG5cbiAgICAgICAgICAgIGlmIChmbG9vciAhPT0gdGhpcy5jdXJyZW50Rmxvb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YW5kQXQgPSB0aGlzLnNjZW5lLmludGVydmFscy5nZXRUaW1lUGFzc2VkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Rmxvb3IgPSBmbG9vcjtcblxuICAgICAgICAgICAgICAgIGlmIChmbG9vciA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxvb3IgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gZmxvb3IgKyB0aGlzLmRpcmVjdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2V0Q2FycnlpbmdQb3NpdGlvbiA9IHVuaXQgPT4gKHsgLi4udW5pdC5wb3NpdGlvbiwgeTogdW5pdC5wb3NpdGlvbi55IC0gKHRoaXMuZGlyZWN0aW9uID4gMCA/IDIgOiAwLjEpIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhcnJ5aW5nVW5pdHMgPSB0aGlzLnNjZW5lLmdhbWVPYmplY3RzU2VydmljZS5nZXRVbml0cygpLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgdW5pdCA9PiAodGhpcy5pc0NhcnJ5aW5nKGdldENhcnJ5aW5nUG9zaXRpb24odW5pdCkpKSxcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc0FjY2VsZXJhdGlvbiA9IHRoaXMuc3BlZWQgKiB0aGlzLmRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBjYXJyeWluZ1VuaXRzLmZvckVhY2goKHVuaXQpID0+IHsgdW5pdC5wb3NpdGlvbi55ICs9IHRoaXNBY2NlbGVyYXRpb247IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0LnBvc2l0aW9uLnkgKz0gdGhpc0FjY2VsZXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59IiwiXG5jb25zdCBjcmVhdGVFbnZpcm9ubWVudCA9IGZ1bmN0aW9uICh7XG4gICAgbG9hZCxcbiAgICB0cmVlcyxcbiAgICBob3VzZXMsXG4gICAgYWRkQ29sbGlkZXJGdW5jdGlvbixcbiAgICBvbkxvYWQsXG59KSB7XG4gICAgY29uc3QgcGl2b3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgICBwaXZvdC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgcGl2b3QubmFtZSA9ICdMRVZFTF9FTlZJUk9OTUVOVCc7XG5cbiAgICBsZXQgaXNFbnZpcm9ubWVudExvYWRlZCA9IGZhbHNlO1xuICAgIGxldCBpc1RyZWVMb2FkZWQgPSBmYWxzZTtcbiAgICBsZXQgaXNIb3VzZUxvYWRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgY2hlY2tJc0FsbExvYWRlZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGlzRW52aXJvbm1lbnRMb2FkZWRcbiAgICAgICAgICAgICYmIGlzVHJlZUxvYWRlZFxuICAgICAgICAgICAgJiYgaXNIb3VzZUxvYWRlZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBsb2FkKHtcbiAgICAgICAgYmFzZVVybDogJy4vYXNzZXRzL21vZGVscy9lbnZpcm9ubWVudC9lbnZpcm9tZW50JyxcbiAgICAgICAgbm9TY2VuZTogdHJ1ZSxcbiAgICAgICAgY2FzdFNoYWRvdzogZmFsc2UsXG4gICAgICAgIGNhbGxiYWNrOiBvYmplY3QgPT4ge1xuICAgICAgICAgICAgcGl2b3QuYWRkKG9iamVjdC5zY2VuZSk7XG4gICAgICAgICAgICBvYmplY3Quc2NlbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgb2JqZWN0LnNjZW5lLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICAgICAgaXNFbnZpcm9ubWVudExvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBjaGVja0lzQWxsTG9hZGVkKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGxvYWQoe1xuICAgICAgICBiYXNlVXJsOiAnLi9hc3NldHMvbW9kZWxzL2Vudmlyb25tZW50L3RyZWUnLFxuICAgICAgICBub1NjZW5lOiB0cnVlLFxuICAgICAgICByZWNlaXZlU2hhZG93OiBmYWxzZSxcbiAgICAgICAgY2FsbGJhY2s6IChsb2FkZWRNb2RlbCkgPT4ge1xuICAgICAgICAgICAgaXNUcmVlTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNoZWNrSXNBbGxMb2FkZWQoKTtcblxuICAgICAgICAgICAgdHJlZXMuZm9yRWFjaCgocG9zaXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IGxvYWRlZE1vZGVsLnNjZW5lLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgbW9kZWwubmFtZSA9ICdUcmVlJztcbiAgICAgICAgICAgICAgICBtb2RlbC5wb3NpdGlvbi5zZXQocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XG4gICAgICAgICAgICAgICAgbW9kZWwubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG1vZGVsLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyB4LCB6IH0gPSBtb2RlbC5wb3NpdGlvbjtcblxuICAgICAgICAgICAgICAgIGFkZENvbGxpZGVyRnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIChwb3NpdGlvbikgPT4gTWF0aC5hYnMocG9zaXRpb24ueCAtIHgpIDwgMiAmJiBNYXRoLmFicyhwb3NpdGlvbi56IC0geikgPCAyXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHBpdm90LmFkZChtb2RlbCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBsb2FkKHtcbiAgICAgICAgYmFzZVVybDogJy4vYXNzZXRzL21vZGVscy9lbnZpcm9ubWVudC9ob3VzZTEnLFxuICAgICAgICByZWNlaXZlU2hhZG93OiBmYWxzZSxcbiAgICAgICAgbm9TY2VuZTogdHJ1ZSxcbiAgICAgICAgY2FsbGJhY2s6IChsb2FkZWRNb2RlbCkgPT4ge1xuICAgICAgICAgICAgaXNIb3VzZUxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBjaGVja0lzQWxsTG9hZGVkKCk7XG5cbiAgICAgICAgICAgIGhvdXNlcy5mb3JFYWNoKChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gbG9hZGVkTW9kZWwuc2NlbmUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5uYW1lID0gJ0hvdXNlMSc7XG4gICAgICAgICAgICAgICAgbW9kZWwucG9zaXRpb24uc2V0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuICAgICAgICAgICAgICAgIG1vZGVsLnJvdGF0aW9uLnNldChwb3NpdGlvbi5yeCB8fCAwLCBwb3NpdGlvbi5yeSB8fCAwLCBwb3NpdGlvbi5yeiB8fCAwKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbW9kZWwudXBkYXRlTWF0cml4KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHgsIHogfSA9IG1vZGVsLnBvc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgYWRkQ29sbGlkZXJGdW5jdGlvbih1bml0UG9zaXRpb24gPT4gKFxuICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyh1bml0UG9zaXRpb24ueCAtIHgpIDwgKHBvc2l0aW9uLnJ5IDwgLTMuMTMgPyA0IDogMylcbiAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5hYnModW5pdFBvc2l0aW9uLnogLSB6KSA8IChwb3NpdGlvbi5yeSA8IC0zLjEzID8gMyA6IDQpXG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgICAgICBwaXZvdC5hZGQobW9kZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwaXZvdDtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUVudmlyb25tZW50IH07XG4iLCJpbXBvcnQgQWJzdHJhY3RMb2NhdGlvbiBmcm9tICcuLi9BYnN0cmFjdExvY2F0aW9uJztcbmltcG9ydCB7IFBsYXllciwgRmlyZSB9IGZyb20gJy4uLy4uL0dhbWVPYmplY3RzJztcbmltcG9ydCBFbGV2YXRvciBmcm9tICcuL0VsZXZhdG9yJztcbmltcG9ydCB7IGNyZWF0ZUVudmlyb25tZW50IH0gZnJvbSAnLi9FbnZpcm9ubWVudCc7XG5pbXBvcnQgQXJlYXMgZnJvbSAnLi9BcmVhcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvY2F0aW9uIGV4dGVuZHMgQWJzdHJhY3RMb2NhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzY2VuZSkge1xuICAgICAgICBzdXBlcihzY2VuZSk7XG4gICAgICAgIHRoaXMuaWQgPSAnZHJlYW0tdG93bic7XG5cbiAgICAgICAgdGhpcy5zaGFkb3dMaWdodFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMjUsIDUwLCAyNSk7XG5cbiAgICAgICAgdGhpcy5zY2VuZS51aS5zZXRMb2FkaW5nKHRydWUpO1xuICAgICAgICB0aGlzLnNjZW5lLnVpLnNldFBhdXNlKHRydWUpO1xuXG4gICAgICAgIHRoaXMuZW52aXJvbm1lbnQgPSBjcmVhdGVFbnZpcm9ubWVudCh7XG4gICAgICAgICAgICBsb2FkOiB0aGlzLnNjZW5lLm1vZGVscy5sb2FkR0xURixcbiAgICAgICAgICAgIGFkZENvbGxpZGVyRnVuY3Rpb246IHRoaXMuc2NlbmUuY29sbGlkZXJzLmFkZENvbGxpZGVyRnVuY3Rpb24sXG4gICAgICAgICAgICB0cmVlczogW1xuICAgICAgICAgICAgICAgIHsgeDogMCwgeTogMCwgejogMTUgfSxcbiAgICAgICAgICAgICAgICB7IHg6IDAsIHk6IDAsIHo6IC0xNSB9LFxuICAgICAgICAgICAgICAgIHsgeDogMTUsIHk6IDAsIHo6IDAgfSxcbiAgICAgICAgICAgICAgICB7IHg6IC0xNSwgeTogMCwgejogMCB9LFxuICAgIFxuICAgIFxuICAgICAgICAgICAgICAgIHsgeDogMTUsIHk6IDAsIHo6IDE1IH0sXG4gICAgICAgICAgICAgICAgeyB4OiAxNSwgeTogMCwgejogLTE1IH0sXG4gICAgICAgICAgICAgICAgeyB4OiAzMCwgeTogMCwgejogMjAgfSxcbiAgICAgICAgICAgICAgICB7IHg6IDMwLCB5OiAwLCB6OiAtMjAgfSxcbiAgICBcbiAgICAgICAgICAgICAgICB7IHg6IDQ1LCB5OiAwLCB6OiAtMzUgfSxcbiAgICAgICAgICAgICAgICB7IHg6IDQ1LCB5OiAwLCB6OiAzNSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGhvdXNlczogW1xuICAgICAgICAgICAgICAgIHsgeDogMCwgeTogMCwgejogNDAsIHJ5OiAtTWF0aC5QSSB9LFxuICAgICAgICAgICAgICAgIHsgeDogLTEwLCB5OiAwLCB6OiAzMCwgcnk6IE1hdGguUEkgLyAyIH0sXG4gICAgICAgICAgICAgICAgeyB4OiAxMCwgeTogMCwgejogMzAsIHJ5OiAtTWF0aC5QSSAvIDIgfSxcbiAgICAgICAgICAgICAgICAvLyB7IHg6IDc1LCB5OiAxMDAsIHo6IDc1IH0sXG4gICAgICAgICAgICAgICAgLy8geyB4OiA3NSwgeTogMjAwLCB6OiA3NSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9uTG9hZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUudWkuc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS51aS5zZXRQYXVzZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5ub3RpZnkoJ0RyZWFtIFRvd24nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hbWJpZW50TGlnaHQgPSB0aGlzLmNyZWF0ZUFtYmllbnRMaWdodCgpO1xuICAgICAgICB0aGlzLnNoYWRvd0xpZ2h0ID0gdGhpcy5jcmVhdGVTaGFkb3dMaWdodCgpO1xuXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMuZW52aXJvbm1lbnQpO1xuICAgICAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLmFtYmllbnRMaWdodCk7XG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMuc2hhZG93TGlnaHQpO1xuXG4gICAgICAgIHRoaXMuZWxldmF0b3IgPSBuZXcgRWxldmF0b3Ioc2NlbmUsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IC00OCwgeTogMTAwLCB6OiAwIH0sXG4gICAgICAgICAgICB4OiA0LFxuICAgICAgICAgICAgeTogMSxcbiAgICAgICAgICAgIHo6IDQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNvbG9yID0gMHgwMDAwMDA7XG4gICAgICAgIGNvbnN0IG5lYXIgPSAxMDtcbiAgICAgICAgY29uc3QgZmFyID0gMTAwO1xuICAgICAgICB0aGlzLnNjZW5lLnNjZW5lLmZvZyA9IG5ldyBUSFJFRS5Gb2coY29sb3IsIG5lYXIsIGZhcik7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVMb2NhdGlvbkNvbGxpZGVycygpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKCk7XG5cbiAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5zY2VuZS5nZXRQbGF5ZXIoKTtcblxuICAgICAgICBpZiAocGxheWVyKSB7XG4gICAgICAgICAgICB0aGlzLmVsZXZhdG9yLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLnNoYWRvd0xpZ2h0LnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgLmNvcHkocGxheWVyLnBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIC5hZGQodGhpcy5zaGFkb3dMaWdodFBvc2l0aW9uKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2hhZG93TGlnaHQudGFyZ2V0ICE9PSBwbGF5ZXIub2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dMaWdodC50YXJnZXQgPSBwbGF5ZXIub2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV2aXZlSGVybygpIHtcbiAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5zY2VuZS5nZXRQbGF5ZXIoKTtcbiAgICAgICAgcGxheWVyLnBhcmFtcy5ocCA9IDEwO1xuICAgICAgICBwbGF5ZXIucG9zaXRpb24uc2V0KDAsIDAuMywgMzApO1xuICAgICAgICBwbGF5ZXIuYW5pbWF0aW9uU3RhdGUuaXNEaWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY2VuZS5wYXJ0aWNsZXMuY3JlYXRlRWZmZWN0KHtcbiAgICAgICAgICAgIGVmZmVjdDogJ2xldmVsLXVwL2xldmVsLXVwJyxcbiAgICAgICAgICAgIHNjYWxlOiAxLjUsXG4gICAgICAgICAgICBhdHRhY2hUbzogcGxheWVyLm9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWZ0ZXJDbGVhcigpIHtcbiAgICAgICAgdGhpcy5zY2VuZS51bml0cy5jcmVhdGVQbGF5ZXIoe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uQ3JlYXRlOiAocGxheWVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5jYW1lcmEucGxheWVyID0gcGxheWVyO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUudWkudXBkYXRlUGxheWVyUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgcGxheWVyLnBvc2l0aW9uLnNldCgwLCAwLjMsIDMwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRpZTogKCkgPT4gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUudWkuc2V0UGF1c2UodHJ1ZSk7XG4gICAgICAgICAgICB9LCAyNTAwKSxcbiAgICAgICAgICAgIG9uS2lsbDogKG9iamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMuc2NlbmUuZ2V0UGxheWVyKCk7XG4gICAgICAgICAgICAgICAgcGxheWVyLmFkZEV4cGVyaWVuY2Uob2JqZWN0LnBhcmFtcy5ib3VudHkpO1xuICAgICAgICAgICAgICAgIHBsYXllci5hZGRNb25leShvYmplY3QucGFyYW1zLmJvdW50eSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EYW1hZ2VUYWtlbjogKCkgPT4gdGhpcy5zY2VuZS51aS51cGRhdGVQbGF5ZXJQYXJhbXMoKSxcbiAgICAgICAgICAgIG9uTG9jYXRpb25VcDogKCkgPT4gdGhpcy5zY2VuZS51aS51cGRhdGVQbGF5ZXJQYXJhbXMoKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVJbnRlcmFjdGl2ZUdhbWVPYmplY3RzKCk7XG4gICAgfVxuXG4gICAgc3RhcnRMb2NhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXN0YXJ0TG9jYXRpb24oKSB7XG4gICAgICAgIHRoaXMuc2NlbmUuY2xlYXJTY2VuZSgpO1xuICAgIH1cblxuICAgIHN0b3BMb2NhdGlvbigpIHtcbiAgICAgICAgdGhpcy5zY2VuZS5yZW1vdmUodGhpcy5lbnZpcm9ubWVudCk7XG4gICAgICAgIC8vIHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMuc2t5Ym94KTtcbiAgICAgICAgdGhpcy5zY2VuZS5yZW1vdmUodGhpcy5hbWJpZW50TGlnaHQpO1xuICAgICAgICB0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLnNoYWRvd0xpZ2h0KTtcbiAgICAgICAgdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2UucmVtb3ZlQWxsRXhjZXB0UGxheWVyKCk7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNyZWF0ZUludGVyYWN0aXZlR2FtZU9iamVjdHMoKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUhlYWxJdGVtID0gKCkgPT4gKFxuICAgICAgICAgICAgdGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUhlYWxQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKC02LjUsIDAuMSwgMzIuOCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmdhbWVPYmplY3RzU2VydmljZS5jcmVhdGVJdGVtKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6ICdpdGVtLWhlYWwnLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaXRlbUhlYWxQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY2FuUGlja3VwOiAodW5pdCkgPT4gKHVuaXQuZ2V0TWF4SFAoKSAtIHVuaXQuZ2V0SFAoKSA+IDApLFxuICAgICAgICAgICAgICAgICAgICBvblBpY2t1cDogKHVuaXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXQuYWRkSFAoMjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlSGVhbEl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDEwMDAwKVxuICAgICAgICApO1xuICAgIFxuICAgICAgICBjcmVhdGVIZWFsSXRlbSgpO1xuXG4gICAgICAgIGNvbnN0IGdldEFJUGFyYW1zID0gKHsgbGV2ZWwsIC4uLnBhcmFtcyB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgICAgICBzY2FsZTogMC43ICsgbGV2ZWwgLyAxMCxcbiAgICAgICAgICAgICAgICBvbkRpZTogKCkgPT4gdGhpcy5zY2VuZS51bml0cy5jcmVhdGVBSShnZXRBSVBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsICsgMSArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGxldmVsKSxcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGdldEdvYXRzUGFyYW1zID0gKGxldmVsLCBwb3NpdGlvbikgPT4gZ2V0QUlQYXJhbXMoe1xuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGZyYWN0aW9uOiAnZ29hdHMnLFxuICAgICAgICAgICAgbmFtZTogbGV2ZWwgPD0gMTBcbiAgICAgICAgICAgICAgID8gJ0dvYXQgV2FycmlvcidcbiAgICAgICAgICAgICAgIDogKGxldmVsIDw9IDIwID8gJ0dvYXQgRWxpdGUnIDogJ0dvYXQgRGVzdHJveWVyJyksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGdldEZyaWVuZGx5UGFyYW1zID0gKGxldmVsLCBwb3NpdGlvbiwgcm90YXRpb24pID0+IGdldEFJUGFyYW1zKHtcbiAgICAgICAgICAgIGxldmVsLCBwb3NpdGlvbiwgcm90YXRpb24sIGZyYWN0aW9uOiAnZnJpZW5kbHknLCBuYW1lOiAnRnJpZW5kbHkgQ2l0aXplbicsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudW5pdHMgPSBbXG4gICAgICAgICAgICBnZXRHb2F0c1BhcmFtcygzLCB7IHg6IC0xNywgeTogMC4yLCB6OiAtNSB9KSxcbiAgICAgICAgICAgIGdldEdvYXRzUGFyYW1zKDMsIHsgeDogMTcgLCB5OiAwLjIsIHo6IC01IH0pLFxuICAgICAgICAgICAgZ2V0R29hdHNQYXJhbXMoMiwgeyB4OiAtMTUsIHk6IDAuMiwgejogLTMwIH0pLFxuICAgICAgICAgICAgZ2V0R29hdHNQYXJhbXMoMiwgeyB4OiAxNSwgeTogMC4yLCB6OiAtMzAgfSksXG5cbiAgICAgICAgICAgIGdldEdvYXRzUGFyYW1zKDUsIHsgeDogLTMwLCB5OiAwLjIsIHo6IC05IH0pLFxuICAgICAgICAgICAgZ2V0R29hdHNQYXJhbXMoNSwgeyB4OiAzMCAsIHk6IDAuMiwgejogLTkgfSksXG4gICAgICAgICAgICBnZXRHb2F0c1BhcmFtcyg0LCB7IHg6IC00NSwgeTogMC4yLCB6OiAtMzAgfSksXG4gICAgICAgICAgICBnZXRHb2F0c1BhcmFtcyg0LCB7IHg6IDQ1LCB5OiAwLjIsIHo6IC0zMCB9KSxcblxuICAgICAgICAgICAgZ2V0R29hdHNQYXJhbXMoMSwgeyB4OiA0NSwgeTogMC4yLCB6OiA0NSB9KSxcbiAgICAgICAgICAgIGdldEdvYXRzUGFyYW1zKDEsIHsgeDogNDUsIHk6IDAuMiwgejogLTQ1IH0pLFxuXG4gICAgICAgICAgICBnZXRHb2F0c1BhcmFtcygyNSwgeyB4OiAwLCB5OiAwLjIsIHo6IDAgfSksXG5cbiAgICAgICAgICAgIGdldEZyaWVuZGx5UGFyYW1zKDUsIHsgeDogLTAuOCwgeTogMC4yLCB6OiA0MCAtIDQuMDMgfSwgeyB5OiBNYXRoLlBJIH0pLFxuICAgICAgICAgICAgZ2V0RnJpZW5kbHlQYXJhbXMoNSwgeyB4OiAtMTAgKyAzLjUsIHk6IDAuMiwgejogMjkuMiB9LCB7IHk6IE1hdGguUEkgLyAyIH0pLFxuICAgICAgICAgICAgZ2V0RnJpZW5kbHlQYXJhbXMoNSwgeyB4OiAxMCAtIDMuNSwgeTogMC4yLCB6OiAzMC44IH0sIHsgeTogLU1hdGguUEkgLyAyIH0pLFxuICAgICAgICBdLmZvckVhY2godGhpcy5zY2VuZS51bml0cy5jcmVhdGVBSSk7XG4gICAgfVxuXG4gICAgY3JlYXRlTG9jYXRpb25Db2xsaWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGlzQmV0d2VlbiA9ICh2LCBtaW4sIG1heCkgPT4gdiA+IG1pbiAmJiB2IDwgbWF4O1xuXG4gICAgICAgIHRoaXMuc2NlbmUuY29sbGlkZXJzLmFkZENvbGxpZGVyRnVuY3Rpb24oKHBvc2l0aW9uLCBnYW1lT2JqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHksIHogfSA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgYWJzWCA9IE1hdGguYWJzKHgpO1xuICAgICAgICAgICAgY29uc3QgYWJzWiA9IE1hdGguYWJzKHopO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHkgPCAwLjEgJiYgYWJzWCA8IDUwICYmIGFic1ogPCA1MCkgLy8gZmxvb3IgMFxuICAgICAgICAgICAgICAgIHx8ICgoKHkgPCAoYWJzWCAtIDUwKSAvIDEuNSkgJiYgYWJzWCA+IDUwKSB8fCAoKHkgPCAoYWJzWiAtIDUwKSAvIDEuNSkgJiYgYWJzWiA+IDUwKSkgLy8gb3V0IG9mIGZsb29yIDBcbiAgICAgICAgICAgICAgICB8fCAoeSA8IDkwICYmIGFic1ggPiA5NiAmJiBhYnNaID4gOTYpIC8vIG91dCBvZiBmbG9vciAwXG4gICAgICAgICAgICAgICAgfHwgKGlzQmV0d2Vlbih5LCA5MCwgMTAwKSAmJiAoYWJzWCA+IDUwIHx8IGFic1ogPiA1MCkpIC8vIGZsb29yIDFcbiAgICAgICAgICAgICAgICB8fCAoaXNCZXR3ZWVuKHksIDkwLCAxOTApICYmIChhYnNYID4gMTM1IHx8IGFic1ogPiAxMzUpKSAvLyBvdXQgb2YgZmxvb3IgMVxuICAgICAgICAgICAgICAgIHx8IChpc0JldHdlZW4oeSwgMTkwLCAyMDApICYmIChhYnNYID4gNTAgfHwgYWJzWiA+IDUwKSkgLy8gZmxvb3IgMlxuICAgICAgICAgICAgICAgIHx8ICh5ID4gMTkwICYmIChhYnNYID4gMTMzIHx8IGFic1ogPiAxMzMpKSAvLyBvdXQgb2YgZmxvb3IgMlxuICAgICAgICAgICAgICAgIHx8IHRoaXMuZWxldmF0b3IuaXNDYXJyeWluZyhwb3NpdGlvbilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiB3ZSBuZWVkIHVuaXRzIGNvbGxpZGVyc1xuICAgICAgICAgICAgLy8gY29uc3QgdW5pdHMgPSB0aGlzLnNjZW5lLnVuaXRzLmdldEFsaXZlVW5pdHMoKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBmb3IobGV0IHVuaXQgb2YgdW5pdHMpIHtcbiAgICAgICAgICAgIC8vICAgICBpZiAoXG4gICAgICAgICAgICAvLyAgICAgICAgIHVuaXQgIT09IGdhbWVPYmplY3RcbiAgICAgICAgICAgIC8vICAgICAgICAgJiYgKFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIShnYW1lT2JqZWN0IGluc3RhbmNlb2YgRmlyZSlcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHx8IGdhbWVPYmplY3QucGFyYW1zLnBhcmVudCAhPT0gdW5pdFxuICAgICAgICAgICAgLy8gICAgICAgICApXG4gICAgICAgICAgICAvLyAgICAgICAgICYmIHVuaXQuZ2V0Q29sbGlkZXIocG9zaXRpb24pXG4gICAgICAgICAgICAvLyAgICAgKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRBcmVhcygpIHtcbiAgICAgICAgY29uc3QgYXJlYXMgPSBPYmplY3QudmFsdWVzKEFyZWFzKTtcblxuICAgICAgICBjb25zdCBnZW5lcmF0ZVdheXBvaW50cyA9ICh3aWR0aCwgaGVpZ2h0LCBtYXApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkod2lkdGgpLmZpbGwobnVsbCkubWFwKFxuICAgICAgICAgICAgICAgIChudWxsMSwgeCkgPT4gbmV3IEFycmF5KGhlaWdodCkuZmlsbChudWxsKS5tYXAoXG4gICAgICAgICAgICAgICAgICAgIChudWxsMiwgeSkgPT4gbWFwKHgsIHkpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBhcmVhcy5tYXAoKGFyZWEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgLi4uYXJlYSB9O1xuXG4gICAgICAgICAgICByZXN1bHQuZ2V0V2F5cG9pbnRzID0gKCkgPT4gZ2VuZXJhdGVXYXlwb2ludHMoXG4gICAgICAgICAgICAgICAgYXJlYS53aWR0aCxcbiAgICAgICAgICAgICAgICBhcmVhLmhlaWdodCxcbiAgICAgICAgICAgICAgICAoeCwgeSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbGV2YXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoYXJlYS53YXlwb2ludFhUb1dvcmxkWCh4KSAtIHRoaXMuZWxldmF0b3IucGFyYW1zLnBvc2l0aW9uLngpIDw9IDVcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGguYWJzKGFyZWEud2F5cG9pbnRZVG9Xb3JsZFooeSkgLSB0aGlzLmVsZXZhdG9yLnBhcmFtcy5wb3NpdGlvbi56KSA8PSAxXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmVhLmlkICE9PSAnRkxPT1JfMCcgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENlbnRlciBob2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhhcmVhLndheXBvaW50WFRvV29ybGRYKHgpKSA8IDUxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGguYWJzKGFyZWEud2F5cG9pbnRZVG9Xb3JsZFooeSkpIDwgNTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhhcmVhLndheXBvaW50WFRvV29ybGRYKHgpKSA8PSA1MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLmFicyhhcmVhLndheXBvaW50WVRvV29ybGRaKHkpKSA8PSA1MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLmFicyhhcmVhLndheXBvaW50WFRvV29ybGRYKHgpKSA+PSA1MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLmFicyhhcmVhLndheXBvaW50WVRvV29ybGRaKHkpKSA+PSA1MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZWEuaWQgPT09ICdGTE9PUl8wJ1xuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsb29yIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGFyZWEud2F5cG9pbnRYVG9Xb3JsZFgoeCkpID49IDQ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgTWF0aC5hYnMoYXJlYS53YXlwb2ludFlUb1dvcmxkWih5KSkgPj0gNDlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5jaGVja1dheUZvcldheXBvaW50KGFyZWEuZ2V0V29ybGRXYXlwb2ludEJ5WFkoeCwgeSkpKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjaGVja1dheUZvcldheXBvaW50KHsgeCwgeSwgeiB9KSB7XG4gICAgICAgIGNvbnN0IGNoZWNrV2F5ID0gdGhpcy5zY2VuZS5jb2xsaWRlcnMuY2hlY2tXYXk7XG4gICAgICAgIGNvbnN0IGNoZWNrTmVhciA9IChyYW5nZSwgZGlhZ29uYWwpID0+IChcbiAgICAgICAgICAgIGNoZWNrV2F5KG5ldyBUSFJFRS5WZWN0b3IzKHggKyByYW5nZSwgeSwgeikpXG4gICAgICAgICAgICAmJiAoY2hlY2tXYXkobmV3IFRIUkVFLlZlY3RvcjMoeCAtIHJhbmdlLCB5LCB6KSkpXG4gICAgICAgICAgICAmJiAoY2hlY2tXYXkobmV3IFRIUkVFLlZlY3RvcjMoeCwgeSwgeiArIHJhbmdlKSkpXG4gICAgICAgICAgICAmJiAoY2hlY2tXYXkobmV3IFRIUkVFLlZlY3RvcjMoeCwgeSwgeiAtIHJhbmdlKSkpXG4gICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgICAgIWRpYWdvbmFsIHx8IChcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tXYXkobmV3IFRIUkVFLlZlY3RvcjMoeCArIHJhbmdlLCB5LCB6ICsgcmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAmJiBjaGVja1dheShuZXcgVEhSRUUuVmVjdG9yMyh4IC0gcmFuZ2UsIHksIHogLSByYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgICYmIGNoZWNrV2F5KG5ldyBUSFJFRS5WZWN0b3IzKHggLSByYW5nZSwgeSwgeiArIHJhbmdlKSlcbiAgICAgICAgICAgICAgICAgICAgJiYgY2hlY2tXYXkobmV3IFRIUkVFLlZlY3RvcjMoeCArIHJhbmdlLCB5LCB6IC0gcmFuZ2UpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY2hlY2tXYXkobmV3IFRIUkVFLlZlY3RvcjMoeCwgeSwgeikpXG4gICAgICAgICAgICAmJiBjaGVja05lYXIoMSwgdHJ1ZSlcbiAgICAgICAgICAgICYmIGNoZWNrTmVhcigyKVxuICAgICAgICApO1xuICAgIH1cbn1cbiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL0xvY2F0aW9uJzsiLCJpbXBvcnQgQXV0b0JpbmRNZXRob2RzIGZyb20gJy4vQXV0b0JpbmRNZXRob2RzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWxzIGV4dGVuZHMgQXV0b0JpbmRNZXRob2RzIHtcbiAgICBjb25zdHJ1Y3RvcihzY2VuZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMucmVwZWF0WFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMucmVwZWF0WVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW1pc3NpdmVcbiAgICAgKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHBhcmFtcy5wb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtUSFJFRS5NZXNofVxuICAgICAqL1xuICAgIGNyZWF0ZUN1YmUocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgICAgICBjb25zdCBtYXRlcmlhbFBhcmFtcyA9IHt9O1xuXG4gICAgICAgIGlmIChwYXJhbXMuaW1hZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQocGFyYW1zLmltYWdlKTtcbiAgICAgICAgICAgIHRleHR1cmUud3JhcFMgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcbiAgICAgICAgICAgIHRleHR1cmUud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcbiAgICAgICAgICAgIHRleHR1cmUucmVwZWF0LnNldChwYXJhbXMucmVwZWF0WCB8fCAxLCBwYXJhbXMucmVwZWF0WSB8fCAxKTtcbiAgICAgICAgICAgIG1hdGVyaWFsUGFyYW1zLm1hcCA9IHRleHR1cmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLmVtaXNzaXZlKSB7XG4gICAgICAgICAgICBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvcihwYXJhbXMuZW1pc3NpdmUpO1xuICAgICAgICAgICAgbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG4gICAgICAgICAgICBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdWJlID0gbmV3IFRIUkVFLk1lc2goXG4gICAgICAgICAgICBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KDEsIDEsIDEpLFxuICAgICAgICAgICAgbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwobWF0ZXJpYWxQYXJhbXMpXG4gICAgICAgICk7XG5cbiAgICAgICAgY3ViZS5zY2FsZS5zZXQocGFyYW1zLnggfHwgMSwgcGFyYW1zLnkgfHwgMSwgcGFyYW1zLnogfHwgMSk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5wb3NpdGlvbikge1xuICAgICAgICAgICAgY3ViZS5wb3NpdGlvbi5zZXQoXG4gICAgICAgICAgICAgICAgcGFyYW1zLnBvc2l0aW9uLnggfHwgMCxcbiAgICAgICAgICAgICAgICBwYXJhbXMucG9zaXRpb24ueSB8fCAwLFxuICAgICAgICAgICAgICAgIHBhcmFtcy5wb3NpdGlvbi56IHx8IDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLnJvdGF0aW9uKSB7XG4gICAgICAgICAgICBjdWJlLnJvdGF0aW9uLnNldChcbiAgICAgICAgICAgICAgICBwYXJhbXMucm90YXRpb24ueCB8fCAwLFxuICAgICAgICAgICAgICAgIHBhcmFtcy5yb3RhdGlvbi55IHx8IDAsXG4gICAgICAgICAgICAgICAgcGFyYW1zLnJvdGF0aW9uLnogfHwgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyYW1zLm5vU2NlbmUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuYWRkKGN1YmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1YmU7XG4gICAgfVxuXG4gICAgbG9hZEdMVEYoe1xuICAgICAgICBiYXNlVXJsLFxuICAgICAgICBpc0dMVEYgPSBmYWxzZSxcbiAgICAgICAgbm9TY2VuZSA9IGZhbHNlLFxuICAgICAgICBjYWxsYmFjayA9ICgpID0+IG51bGwsXG4gICAgICAgIGNhc3RTaGFkb3cgPSB0cnVlLFxuICAgICAgICByZWNlaXZlU2hhZG93ID0gdHJ1ZSxcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBHTFRGTG9hZGVyKCk7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke2Jhc2VVcmx9LmdsYiR7aXNHTFRGID8gJy5nbHRmJyA6ICcnfWA7XG4gICAgICAgIFxuICAgICAgICBsb2FkZXIubG9hZCh1cmwsIChsb2FkZWRNb2RlbCkgPT4ge1xuICAgICAgICAgICAgbG9hZGVkTW9kZWwuc2NlbmUudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IHJlY2VpdmVTaGFkb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKGxvYWRlZE1vZGVsKTtcblxuICAgICAgICAgICAgaWYgKCFub1NjZW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5hZGQobG9hZGVkTW9kZWwuc2NlbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59IiwiaW1wb3J0IFNjZW5lIGZyb20gJy4vU2NlbmUnO1xuaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5pbXBvcnQgQW5pbWF0ZWRHYW1lT2JqZWN0IGZyb20gJy4vR2FtZU9iamVjdHMvQW5pbWF0ZWRHYW1lT2JqZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydGljbGVzIGV4dGVuZHMgQXV0b0JpbmRNZXRob2RzIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBbXTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMucGFydGljbGVzLmZvckVhY2gocCA9PiBwLnVwZGF0ZSgpKTtcbiAgICB9XG5cbiAgICBjcmVhdGVTbm93KCkge1xuICAgICAgICBjb25zdCBhcmVhID0gbmV3IFRIUkVFLlZlY3RvcjMoMTAwLCAyNSwgMTAwKTtcblxuICAgICAgICB0aGlzLmNyZWF0ZVBhcnRpY2xlcyh7XG4gICAgICAgICAgICBwYXJ0aWNsZUNvdW50OiAxMDAwMCxcbiAgICAgICAgICAgIGNvbG9yOiAweDg4ODg4OCxcbiAgICAgICAgICAgIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygtYXJlYS54IC8gMiwgMCwgLWFyZWEueiAvIDIpLFxuICAgICAgICAgICAgZ2V0UGFydGljbGVQb3NpdGlvbjogKGksIHBvc2l0aW9uID0gdGhpcy5nZXRSYW5kb21Qb3NpdGlvbihhcmVhKSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbi55IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHRoaXMuZ2V0UmFuZG9tUG9zaXRpb24oYXJlYSk7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnggPSBuZXdQb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi55ID0gYXJlYS55O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi56ID0gbmV3UG9zaXRpb24uejtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBjcmVhdGVFZmZlY3Qoe1xuICAgICAgICBzY2FsZSA9IDEuNSxcbiAgICAgICAgZWZmZWN0ID0gJ2xldmVsLXVwLWFsdC9sZXZlbC11cCcsXG4gICAgICAgIHBvc2l0aW9uID0ge30sXG4gICAgICAgIGF0dGFjaFRvLFxuICAgICAgICBsaWZlVGltZSA9IDIwODAsXG4gICAgfSkge1xuICAgICAgICB0aGlzLnNjZW5lLm1vZGVscy5sb2FkR0xURih7XG4gICAgICAgICAgICBiYXNlVXJsOiAnLi9hc3NldHMvbW9kZWxzL2VmZmVjdHMvJyArIGVmZmVjdCxcbiAgICAgICAgICAgIG5vU2NlbmU6IHRydWUsXG4gICAgICAgICAgICBjYXN0U2hhZG93OiBmYWxzZSxcbiAgICAgICAgICAgIHJlY2VpdmVTaGFkb3c6IGZhbHNlLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGxvYWRlZE9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgbG9hZGVkT2JqZWN0LnNjZW5lLnNjYWxlLnNldChzY2FsZSwgc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxvYWRlZE9iamVjdC5zY2VuZS50cmF2ZXJzZSgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzTWVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwuYWxwaGFUZXN0ID0gMC41O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsb2FkZWRPYmplY3Quc2NlbmUucG9zaXRpb24uc2V0KHBvc2l0aW9uLnggfHwgMCwgcG9zaXRpb24ueSB8fCAwLCBwb3NpdGlvbi56IHx8IDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaFRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaFRvLmFkZChsb2FkZWRPYmplY3Quc2NlbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGVmZmVjdCA9IG5ldyBBbmltYXRlZEdhbWVPYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGxvYWRlZE9iamVjdC5zY2VuZSxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uczogbG9hZGVkT2JqZWN0LmFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmdhbWVPYmplY3RzU2VydmljZS5ob29rR2FtZU9iamVjdChlZmZlY3QpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2UuZGVzdHJveUdhbWVPYmplY3QoZWZmZWN0KSxcbiAgICAgICAgICAgICAgICAgICAgbGlmZVRpbWUsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIFxuICAgIFxuXG4gICAgbG9hZEVmZmVjdCh7XG4gICAgICAgIHBhcnRpY2xlTmFtZSA9ICdibG9vZCcsXG4gICAgICAgIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgICAgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygxLCAxLCAxKVxuICAgIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBnYW1lT2JqZWN0c1NlcnZpY2UgPSB0aGlzLnNjZW5lLmdhbWVPYmplY3RzU2VydmljZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZS5tb2RlbHMubG9hZEdMVEYoe1xuICAgICAgICAgICAgYmFzZVVybDogYC4vYXNzZXRzL21vZGVscy9lZmZlY3RzLyR7cGFydGljbGVOYW1lfWAsXG4gICAgICAgICAgICBjYXN0U2hhZG93OiBmYWxzZSxcbiAgICAgICAgICAgIHJlY2VpdmVTaGFkb3c6IGZhbHNlLFxuICAgICAgICAgICAgY2FsbGJhY2s6IChnbHRmKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2x0Zi5zY2VuZS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBnbHRmLnNjZW5lLnNjYWxlLmNvcHkoc2NhbGUpO1xuICAgICAgICAgICAgICAgIGdsdGYuc2NlbmUucm90YXRpb24uc2V0KDAsIE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJLCAwKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpY2xlU3lzdGVtID0gZ2FtZU9iamVjdHNTZXJ2aWNlLmhvb2tHYW1lT2JqZWN0KG5ldyBBbmltYXRlZEdhbWVPYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGdsdGYuc2NlbmUsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IGdsdGYuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmludGVydmFscy5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnNjZW5lLmdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdChwYXJ0aWNsZVN5c3RlbSksXG4gICAgICAgICAgICAgICAgICAgIDYyNVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldFJhbmRvbVBvc2l0aW9uKGFyZWEpIHtcbiAgICAgICAgY29uc3QgcmFuZG9tID0gKGZyb20sIHRvKSA9PiBNYXRoLnJhbmRvbSgpICogKHRvIC0gZnJvbSkgKyBmcm9tO1xuXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICAgIHJhbmRvbSgwLCBhcmVhLngpLFxuICAgICAgICAgICAgcmFuZG9tKDAsIGFyZWEueSksXG4gICAgICAgICAgICByYW5kb20oMCwgYXJlYS56KSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBjcmVhdGVQYXJ0aWNsZXMoe1xuICAgICAgICBwYXJ0aWNsZUNvdW50ID0gMTAwMCxcbiAgICAgICAgbm9TY2VuZSA9IGZhbHNlLFxuICAgICAgICBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDUsIDApLFxuICAgICAgICBzaXplID0gMC4wMSxcbiAgICAgICAgY29sb3IgPSAweEZGRkZGRixcbiAgICAgICAgYmxlbmRpbmcgPSBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLFxuICAgICAgICBkZXB0aFRlc3QgPSB0cnVlLFxuICAgICAgICB0cmFuc3BhcmVudCA9IHRydWUsXG4gICAgICAgIGFyZWEgPSBuZXcgVEhSRUUuVmVjdG9yMygxMCwgNSwgMTApLFxuICAgICAgICBnZXRQYXJ0aWNsZVZlbG9jaXR5ID0gKCkgPT4gbmV3IFRIUkVFLlZlY3RvcjMoLTAuMDEsIC0wLjAxLCAwKSxcbiAgICAgICAgZ2V0UGFydGljbGVQb3NpdGlvbiA9IChpLCBwb3NpdGlvbiA9IHRoaXMuZ2V0UmFuZG9tUG9zaXRpb24oYXJlYSkpID0+IHBvc2l0aW9uLFxuICAgIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXJ0aWNsZXMgPSBuZXcgVEhSRUUuR2VvbWV0cnk7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCh7IGNvbG9yLCBzaXplLCBibGVuZGluZywgZGVwdGhUZXN0LCB0cmFuc3BhcmVudCB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRpY2xlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFydGljbGUgPSBnZXRQYXJ0aWNsZVBvc2l0aW9uKGkpO1xuICAgICAgICAgICAgcGFydGljbGVzLnZlbG9jaXR5ID0gZ2V0UGFydGljbGVWZWxvY2l0eShpLCBwYXJ0aWNsZSk7XG4gICAgICAgICAgICBwYXJ0aWNsZXMudmVydGljZXMucHVzaChwYXJ0aWNsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJ0aWNsZVN5c3RlbSA9IG5ldyBUSFJFRS5Qb2ludENsb3VkKHBhcnRpY2xlcywgbWF0ZXJpYWwpO1xuICAgICAgICBwYXJ0aWNsZVN5c3RlbS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLnBhcnRpY2xlcy5wdXNoKHtcbiAgICAgICAgICAgIG9iamVjdDogcGFydGljbGVTeXN0ZW0sXG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBwYXJ0aWNsZUNvdW50O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGljbGUgPSBwYXJ0aWNsZXMudmVydGljZXNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnZlbG9jaXR5ID0gZ2V0UGFydGljbGVWZWxvY2l0eShpbmRleCwgcGFydGljbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnggKz0gcGFydGljbGUudmVsb2NpdHkueDtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUueSArPSBwYXJ0aWNsZS52ZWxvY2l0eS55O1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS56ICs9IHBhcnRpY2xlLnZlbG9jaXR5Lno7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGljbGVQb3NpdGlvbiA9IGdldFBhcnRpY2xlUG9zaXRpb24oaW5kZXgsIHBhcnRpY2xlKTtcblxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS54ID0gcGFydGljbGVQb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS55ID0gcGFydGljbGVQb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS56ID0gcGFydGljbGVQb3NpdGlvbi56O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnRpY2xlcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFub1NjZW5lKSB7XG4gICAgICAgICAgICB0aGlzLnNjZW5lLmFkZChwYXJ0aWNsZVN5c3RlbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydGljbGVTeXN0ZW07XG4gICAgfVxufSIsImltcG9ydCBBdXRvQmluZE1ldGhvZHMgZnJvbSAnLi9BdXRvQmluZE1ldGhvZHMnO1xuaW1wb3J0IEFTdGFyIGZyb20gJy4vVXRpbHMvQVN0YXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xsaWRlcnMgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5hcmVhcyA9IFtdO1xuICAgIH1cblxuICAgIGdldE5leHRQb2ludChmcm9tLCB0bykge1xuICAgICAgICBjb25zdCBhcmVhID0gdGhpcy5nZXRBcmVhQnlQb3NpdGlvbihmcm9tKSxcbiAgICAgICAgICAgIGZyb21YID0gYXJlYS53b3JsZFhUb1dheXBvaW50WChmcm9tLngpLFxuICAgICAgICAgICAgZnJvbVkgPSBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKGZyb20ueiksXG4gICAgICAgICAgICBhcmVhVG8gPSB0aGlzLmdldEFyZWFCeVBvc2l0aW9uKHRvKTtcblxuICAgICAgICBsZXQgdG9YO1xuICAgICAgICBsZXQgdG9ZO1xuICAgICAgICBsZXQgcG9ydGFsO1xuXG4gICAgICAgIGlmIChhcmVhLmlkID09PSBhcmVhVG8uaWQpIHtcbiAgICAgICAgICAgIHRvWCA9IGFyZWEud29ybGRYVG9XYXlwb2ludFgodG8ueCk7XG4gICAgICAgICAgICB0b1kgPSBhcmVhLndvcmxkWlRvV2F5cG9pbnRZKHRvLnopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9ydGFsID0gYXJlYS5nZXRXYXlwb2ludFBvcnRhbHMoKS5maW5kKHBvcnRhbCA9PiBwb3J0YWwudG8uYXJlYUlkID09PSBhcmVhVG8uaWQpO1xuXG4gICAgICAgICAgICBpZiAocG9ydGFsKSB7XG4gICAgICAgICAgICAgICAgdG9YID0gcG9ydGFsLmZyb20ueDtcbiAgICAgICAgICAgICAgICB0b1kgPSBwb3J0YWwuZnJvbS55O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmdldEZyZWVHcmFwaFBvaW50KGFyZWEuZ3JhcGgsIGZyb21YLCBmcm9tWSk7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLmdldEZyZWVHcmFwaFBvaW50KGFyZWEuZ3JhcGgsIHRvWCwgdG9ZKTtcblxuICAgICAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gQVN0YXIuYXN0YXIuc2VhcmNoKFxuICAgICAgICAgICAgICAgIGFyZWEuZ3JhcGgsXG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgICAgIHsgaGV1cmlzdGljOiBBU3Rhci5hc3Rhci5oZXVyaXN0aWNzLmRpYWdvbmFsIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IG5leHRHcmFwaFBvaW50ID0gcmVzdWx0WzJdIHx8IHJlc3VsdFsxXTtcblxuICAgICAgICAgICAgaWYgKG5leHRHcmFwaFBvaW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFdvcmxkUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICAgICAgICAgICAgYXJlYS53YXlwb2ludFhUb1dvcmxkWChuZXh0R3JhcGhQb2ludC54KSxcbiAgICAgICAgICAgICAgICAgICAgdG8ueSxcbiAgICAgICAgICAgICAgICAgICAgYXJlYS53YXlwb2ludFlUb1dvcmxkWihuZXh0R3JhcGhQb2ludC55KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFdvcmxkUG9pbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIGdldEZyZWVHcmFwaFBvaW50KGdyYXBoLCB4LCB5KSB7XG4gICAgICAgIGNvbnN0IGdyaWQgPSBncmFwaC5ncmlkO1xuXG4gICAgICAgIGNvbnN0IGdldFdlaWdodCA9ICh4LCB5KSA9PiBncmlkW3hdICYmIGdyaWRbeF1beV0gJiYgZ3JpZFt4XVt5XS53ZWlnaHQ7XG5cbiAgICAgICAgY29uc3QgZ2V0TmVhckZyZWVQb2ludCA9IHJhbmdlID0+IChcbiAgICAgICAgICAgIChnZXRXZWlnaHQoeCArIHJhbmdlLCB5KSAmJiBncmlkW3ggKyByYW5nZV1beV0pXG4gICAgICAgICAgICB8fCAoZ2V0V2VpZ2h0KHggLSByYW5nZSwgeSkgJiYgZ3JpZFt4IC0gcmFuZ2VdW3ldKVxuICAgICAgICAgICAgfHwgKGdldFdlaWdodCh4LCB5ICsgcmFuZ2UpICYmIGdyaWRbeF1beSArIHJhbmdlXSlcbiAgICAgICAgICAgIHx8IChnZXRXZWlnaHQoeCwgeSAtIHJhbmdlKSAmJiBncmlkW3hdW3kgLSByYW5nZV0pXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChnZXRXZWlnaHQoZ3JpZFt4XVt5XSkgJiYgZ3JpZFt4XVt5XSlcbiAgICAgICAgICAgIHx8IGdldE5lYXJGcmVlUG9pbnQoMSlcbiAgICAgICAgICAgIHx8IGdldE5lYXJGcmVlUG9pbnQoMilcbiAgICAgICAgICAgIHx8IGdldE5lYXJGcmVlUG9pbnQoMylcbiAgICAgICAgICAgIHx8IGdldE5lYXJGcmVlUG9pbnQoNClcbiAgICAgICAgICAgIHx8IG51bGxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZWJ1aWxkQXJlYXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjZW5lLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFyZWFzID0gdGhpcy5zY2VuZS5sb2NhdGlvbi5nZXRBcmVhcygpLm1hcChhcmVhID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uYXJlYSxcbiAgICAgICAgICAgICAgICBncmFwaDogbmV3IEFTdGFyLkdyYXBoKGFyZWEuZ2V0V2F5cG9pbnRzKCksIHsgZGlhZ29uYWw6IHRydWUgfSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRBcmVhQnlQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmVhcy5maW5kKGFyZWEgPT4gYXJlYS5pbmNsdWRlc1Bvc2l0aW9uKHBvc2l0aW9uKSk7XG4gICAgfVxufSIsImltcG9ydCB7IFBsYXllciB9IGZyb20gJy4vR2FtZU9iamVjdHMnO1xuLy8gaW1wb3J0IEF1ZGlvIGZyb20gJy4vQXVkaW8nO1xuaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4vQ2FtZXJhJztcbmltcG9ydCBDb25uZWN0aW9uIGZyb20gJy4vQ29ubmVjdGlvbic7XG5pbXBvcnQgR2FtZU9iamVjdHNTZXJ2aWNlIGZyb20gJy4vR2FtZU9iamVjdHMnO1xuaW1wb3J0IElucHV0IGZyb20gJy4vSW5wdXQnO1xuaW1wb3J0IEludGVydmFscyBmcm9tICcuL0ludGVydmFscyc7XG5pbXBvcnQgTG9jYXRpb24gZnJvbSAnLi9Mb2NhdGlvbnMvRHJlYW1Ub3duJztcbmltcG9ydCBDb2xsaWRlcnMgZnJvbSAnLi9Db2xsaWRlcnMnO1xuaW1wb3J0IE1vZGVscyBmcm9tICcuL01vZGVscyc7XG5pbXBvcnQgUGFydGljbGVzIGZyb20gJy4vUGFydGljbGVzJztcbmltcG9ydCBQYXRoRmluZGVyIGZyb20gJy4vUGF0aEZpbmRlcic7XG5pbXBvcnQgVW5pdHMgZnJvbSAnLi9Vbml0cyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmUgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogIHNldFJlc3RhcnRCdXR0b25WaXNpYmxlOiBmdW5jdGlvbixcbiAgICAgKiAgc2V0UGF1c2U6IGZ1bmN0aW9uLFxuICAgICAqICByZXN0YXJ0R2FtZTogZnVuY3Rpb24sXG4gICAgICogIGlzUGF1c2U6IGZ1bmN0aW9uLFxuICAgICAqICBpc1RoaXJkUGVyc29uOiBmdW5jdGlvbixcbiAgICAgKiAgdXBkYXRlOiBmdW5jdGlvbixcbiAgICAgKiAgdXBkYXRlUGxheWVyUGFyYW1zOiBmdW5jdGlvbixcbiAgICAgKiAgY2xlYXJIcEJhcnM6IGZ1bmN0aW9uLFxuICAgICAqICBzd2l0Y2hDYW1lcmE6IGZ1bmN0aW9uLFxuICAgICAqICBzZXRGcHM6IGZ1bmN0aW9uLFxuICAgICAqICBub3RpZnk6IGZ1bmN0aW9uLFxuICAgICAqIH19IHVpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIHVpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2xvY2sgPSBuZXcgVEhSRUUuQ2xvY2soKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbHMgPSBuZXcgSW50ZXJ2YWxzKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMudWkgPSB1aTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSBuZXcgTW9kZWxzKHRoaXMpO1xuICAgICAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgICAgIHRoaXMucGF0aEZpbmRlciA9IG5ldyBQYXRoRmluZGVyKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbGxpZGVycyA9IG5ldyBDb2xsaWRlcnModGhpcyk7XG4gICAgICAgIHRoaXMudW5pdHMgPSBuZXcgVW5pdHModGhpcyk7XG4gICAgICAgIHRoaXMuY2FtZXJhID0gbmV3IENhbWVyYSh0aGlzKTtcbiAgICAgICAgLy8gdGhpcy5hdWRpbyA9IG5ldyBBdWRpbyh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBJbnB1dCh7XG4gICAgICAgICAgICBvbkFjdGlvbjogKCkgPT4gdGhpcy5sZXZlbC5vbkFjdGlvbigpLFxuICAgICAgICAgICAgb25FeGl0OiAoKSA9PiB0aGlzLnVpLnNldFBhdXNlKCF0aGlzLnVpLmlzUGF1c2UoKSksXG4gICAgICAgICAgICBvblpvb206IHpvb20gPT4gdGhpcy5jYW1lcmEuYWRkWSh6b29tKSxcbiAgICAgICAgICAgIG9uU3dpdGNoQ2FtZXJhOiAoKSA9PiB0aGlzLnVpLnN3aXRjaENhbWVyYSgpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0c1NlcnZpY2UgPSBuZXcgR2FtZU9iamVjdHNTZXJ2aWNlKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcnRpY2xlcyA9IG5ldyBQYXJ0aWNsZXModGhpcyk7XG5cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbkhvc3RuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09PSAnbG9jYWxob3N0JyA/ICdsb2NhbGhvc3QnIDogJ2dvaHRtbC5ydSc7XG4gICAgICAgIGNvbnN0IGlzU1NMID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICE9PSAnbG9jYWxob3N0JztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24odGhpcywgY29ubmVjdGlvbkhvc3RuYW1lLCAxMzM3LCBpc1NTTCk7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBuZXcgTG9jYXRpb24odGhpcyk7XG5cbiAgICAgICAgdGhpcy5pbnRlcnZhbHMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51aS5zZXRGcHModGhpcy5yZW5kZXJlci5mcHMsIHRoaXMucmVuZGVyZXIudGFyZ2V0RnBzKTtcbiAgICAgICAgICAgIHRoaXMudWkuc2V0UGluZyh0aGlzLmNvbm5lY3Rpb24ucGluZyk7XG4gICAgICAgICAgICB0aGlzLnVpLnVwZGF0ZVBsYXllclBhcmFtcygpXG4gICAgICAgIH0sIDEwMDApO1xuXG4gICAgICAgIHRoaXMuaW5wdXQuaXNUaGlyZFBlcnNvbiA9IHVpLmlzVGhpcmRQZXJzb24oKTtcbiAgICAgICAgdGhpcy5wYXRoRmluZGVyLnJlYnVpbGRBcmVhcygpO1xuXG4gICAgICAgIHRoaXMuY2xlYXJTY2VuZSgpO1xuICAgICAgICB0aGlzLmFuaW1hdGUoKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnU2NlbmUnLCB0aGlzKTtcbiAgICB9XG5cbiAgICBjbGVhclNjZW5lKCkge1xuICAgICAgICB0aGlzLmdhbWVPYmplY3RzU2VydmljZS5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbi5hZnRlckNsZWFyKCk7XG4gICAgfVxuXG4gICAgYW5pbWF0ZSgpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgZGVsdGFUaW1lID0gdGhpcy5pbnRlcnZhbHMuZ2V0RGVsdGFUaW1lKG5vdyk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxzLnVwZGF0ZShub3cpO1xuICAgICAgICBjb25zdCBnYW1lVGltZSA9IHRoaXMuaW50ZXJ2YWxzLmdldFRpbWVQYXNzZWQoKTtcblxuICAgICAgICB0aGlzLmdhbWVPYmplY3RzU2VydmljZS51cGRhdGUoZ2FtZVRpbWUsIGRlbHRhVGltZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnVpLmlzUGF1c2UoKSkge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlKGdhbWVUaW1lLCBkZWx0YVRpbWUpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC51cGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudWkudXBkYXRlKCk7XG4gICAgICAgIHRoaXMubG9jYXRpb24udXBkYXRlKCk7XG4gICAgICAgIHRoaXMucGFydGljbGVzLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24udXBkYXRlKGdhbWVUaW1lLCBkZWx0YVRpbWUpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLmNhbWVyYSwgZGVsdGFUaW1lKTtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGUpO1xuICAgIH1cblxuICAgIHNldExvZ2dlZFVzZXIodXNlck5hbWUsIHBhc3N3b3JkKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHsgdXNlck5hbWUsIHBhc3N3b3JkIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BsYXllcn1cbiAgICAgKi9cbiAgICBnZXRQbGF5ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaXRzLmdldFBsYXllcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VEhSRUUuT2JqZWN0M0R9IG9iamVjdFxuICAgICAqL1xuICAgIGFkZChvYmplY3QpIHtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RIUkVFLk9iamVjdDNEfSBvYmplY3RcbiAgICAgKi9cbiAgICByZW1vdmUob2JqZWN0KSB7XG4gICAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKG9iamVjdCk7XG4gICAgfVxuXG4gICAgbm90aWZ5KHRleHQpIHtcbiAgICAgICAgdGhpcy51aS5ub3RpZnkodGV4dCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEF1dG9CaW5kTWV0aG9kcyBmcm9tICcuL0F1dG9CaW5kTWV0aG9kcyc7XG5pbXBvcnQgeyBQbGF5ZXIsIEFJLCBBbmltYXRlZEdhbWVPYmplY3QgfSBmcm9tICcuL0dhbWVPYmplY3RzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5pdHMgZXh0ZW5kcyBBdXRvQmluZE1ldGhvZHMge1xuXHRjb25zdHJ1Y3RvcihzY2VuZSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xuXHRcdHRoaXMucGxheWVyID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0Z2V0VW5pdHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlLmdldFVuaXRzKCk7XG5cdH1cblxuXHRnZXRBbGl2ZVVuaXRzKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFVuaXRzKCkuZmlsdGVyKGdhbWVPYmplY3QgPT4gZ2FtZU9iamVjdC5pc0FsaXZlKCkpO1xuXHR9XG5cblx0Z2V0UGxheWVyKCkge1xuXHRcdHJldHVybiB0aGlzLnBsYXllcjtcblx0fVxuXG5cdHNldERlZmF1bHRQbGF5ZXJQYXJhbXMoZGVmYXVsdFBhcmFtcykge1xuXHRcdHRoaXMuZGVmYXVsdFBhcmFtcyA9IGRlZmF1bHRQYXJhbXM7XG5cdH1cblxuXHRjcmVhdGVQbGF5ZXIoe1xuXHRcdG9uQ3JlYXRlID0gKCkgPT4gbnVsbCxcblx0XHRvbktpbGwgPSAoKSA9PiBudWxsLFxuXHRcdG9uRGFtYWdlRGVhbCA9ICgpID0+IG51bGwsXG5cdFx0b25EYW1hZ2VUYWtlbiA9ICgpID0+IG51bGwsXG5cdFx0b25EaWUgPSAoKSA9PiBudWxsLFxuXHRcdG9uTGV2ZWxVcCA9ICgpID0+IG51bGwsXG5cdH0gPSB7fSkge1xuXHRcdGNvbnN0IGdhbWVPYmplY3RzU2VydmljZSA9IHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2NlbmUubW9kZWxzLmxvYWRHTFRGKHtcblx0XHRcdGJhc2VVcmw6ICcuL2Fzc2V0cy9tb2RlbHMvdW5pdHMvcGxheWVyJyxcblx0XHRcdGNhbGxiYWNrOiAobG9hZGVkTW9kZWwpID0+IHtcblx0XHRcdFx0Y29uc3QgZGVmYXVsdFBhcmFtcyA9IHRoaXMuZGVmYXVsdFBhcmFtcztcblx0XHRcdFx0bG9hZGVkTW9kZWwuc2NlbmUucG9zaXRpb24uc2V0KDAsIDAuMSwgMCk7XG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEB0eXBlIHtQbGF5ZXJ9XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRjb25zdCBwbGF5ZXIgPSBnYW1lT2JqZWN0c1NlcnZpY2UuaG9va0dhbWVPYmplY3QobmV3IFBsYXllcih7XG5cdFx0XHRcdFx0YW5pbWF0aW9uczogbG9hZGVkTW9kZWwuYW5pbWF0aW9ucyxcblx0XHRcdFx0XHRvYmplY3Q6IGxvYWRlZE1vZGVsLnNjZW5lLFxuXHRcdFx0XHRcdGlucHV0OiB0aGlzLnNjZW5lLmlucHV0LFxuXHRcdFx0XHRcdGNvbXBsZXhBbmltYXRpb25zOiB0cnVlLFxuXHRcdFx0XHRcdGNoZWNrV2F5OiB0aGlzLnNjZW5lLmNvbGxpZGVycy5jaGVja1dheSxcblx0XHRcdFx0XHRuYW1lOiB0aGlzLnNjZW5lLnVzZXIgPyB0aGlzLnNjZW5lLnVzZXIudXNlck5hbWUgOiAnICcsXG5cdFx0XHRcdFx0b25EYW1hZ2VEZWFsOiBkYW1hZ2VkVW5pdCA9PiBvbkRhbWFnZURlYWwoZGFtYWdlZFVuaXQpLFxuXHRcdFx0XHRcdG9uRGFtYWdlVGFrZW46IChhdHRhY2tlcikgPT4ge1xuXHRcdFx0XHRcdFx0b25EYW1hZ2VUYWtlbihhdHRhY2tlcik7XG5cdFx0XHRcdFx0XHR0aGlzLnNjZW5lLnBhcnRpY2xlcy5sb2FkRWZmZWN0KHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb246IHBsYXllci5wb3NpdGlvbi5jbG9uZSgpLmFkZChuZXcgVEhSRUUuVmVjdG9yMygwLCAwLjc1LCAwKSlcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0b25LaWxsOiAob2JqZWN0KSA9PiBvbktpbGwob2JqZWN0KSxcblx0XHRcdFx0XHRvbkRpZTogKGtpbGxlcikgPT4gb25EaWUoa2lsbGVyKSxcblx0XHRcdFx0XHRvbkxldmVsVXA6ICgpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMuc2NlbmUucGFydGljbGVzLmNyZWF0ZUVmZmVjdCh7XG5cdFx0XHRcdFx0XHRcdGVmZmVjdDogJ2xldmVsLXVwLWFsdC9sZXZlbC11cCcsXG5cdFx0XHRcdFx0XHRcdHNjYWxlOiAxLjUsXG5cdFx0XHRcdFx0XHRcdGF0dGFjaFRvOiB0aGlzLnBsYXllci5vYmplY3QsXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdG9uTGV2ZWxVcCgpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0YXR0YWNrOiAoKSA9PiBnYW1lT2JqZWN0c1NlcnZpY2UuYXR0YWNrKHBsYXllciksXG5cdFx0XHRcdFx0ZmlyZTogKCkgPT4gZ2FtZU9iamVjdHNTZXJ2aWNlLmZpcmUocGxheWVyKSxcblx0XHRcdFx0XHRkZXN0cm95OiAoKSA9PiBnYW1lT2JqZWN0c1NlcnZpY2UuZGVzdHJveUdhbWVPYmplY3QocGxheWVyKSxcblx0XHRcdFx0fSkpO1xuXG5cdFx0XHRcdHRoaXMucGxheWVyID0gcGxheWVyO1xuXHRcdFx0XHRvbkNyZWF0ZShwbGF5ZXIpO1xuXG5cdFx0XHRcdGlmIChkZWZhdWx0UGFyYW1zICYmIGRlZmF1bHRQYXJhbXMucGFyYW1zKSB7XG5cdFx0XHRcdFx0Y29uc3QgeyBwb3NpdGlvbiwgcm90YXRpb24sIHBhcmFtcyB9ID0gZGVmYXVsdFBhcmFtcztcblx0XHRcdFx0XHRjb25zdCBwbGF5ZXJQYXJhbXMgPSBwbGF5ZXIucGFyYW1zO1xuXG5cdFx0XHRcdFx0cGxheWVyLnBvc2l0aW9uLnNldChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcblx0XHRcdFx0XHRwbGF5ZXIucm90YXRpb24uc2V0KHJvdGF0aW9uLngsIHJvdGF0aW9uLnksIHJvdGF0aW9uLnopO1xuXHRcdFx0XHRcdHBsYXllclBhcmFtcy5ocCA9IHBhcmFtcy5ocDtcblx0XHRcdFx0XHRwbGF5ZXJQYXJhbXMuaHBNYXggPSBwYXJhbXMuaHBNYXg7XG5cdFx0XHRcdFx0cGxheWVyUGFyYW1zLmZyYWN0aW9uID0gcGFyYW1zLmZyYWN0aW9uO1xuXHRcdFx0XHRcdHBsYXllclBhcmFtcy5sZXZlbCA9IHBhcmFtcy5sZXZlbDtcblx0XHRcdFx0XHRwbGF5ZXJQYXJhbXMuZGFtYWdlID0gcGFyYW1zLmRhbWFnZTtcblx0XHRcdFx0XHRwbGF5ZXJQYXJhbXMuc3BlZWQgPSBwYXJhbXMuc3BlZWQ7XG5cdFx0XHRcdFx0cGxheWVyUGFyYW1zLmV4cGVyaWVuY2UgPSBwYXJhbXMuZXhwZXJpZW5jZTtcblx0XHRcdFx0XHRwbGF5ZXJQYXJhbXMubW9uZXkgPSBwYXJhbXMubW9uZXk7XG5cdFx0XHRcdFx0cGxheWVyUGFyYW1zLnVuc3BlbnRUYWxlbnRzID0gcGFyYW1zLnVuc3BlbnRUYWxlbnRzO1xuXG5cdFx0XHRcdFx0aWYgKCFwbGF5ZXJQYXJhbXMuaHApIHtcblx0XHRcdFx0XHRcdHBsYXllci5hbmltYXRpb25TdGF0ZS5pc0RpZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRjcmVhdGVBSSh7IGZyYWN0aW9uLCBsZXZlbCwgcG9zaXRpb246IHsgeCwgeSwgeiB9LCByb3RhdGlvbiA9IHt9LCBzY2FsZSwgb25EaWUsIG5hbWUgfSkge1xuXHRcdGNvbnN0IGdhbWVPYmplY3RzU2VydmljZSA9IHRoaXMuc2NlbmUuZ2FtZU9iamVjdHNTZXJ2aWNlO1xuXHRcdGNvbnN0IGdldFByaW9yaXR5ID0gKHVuaXQsIHRhcmdldCkgPT4gKFxuXHRcdFx0KHRhcmdldCBpbnN0YW5jZW9mIFBsYXllciA/IDAuNzUgOiAwKVxuXHRcdFx0KyAxIC8gTWF0aC5jZWlsKHRhcmdldC5wb3NpdGlvbi5kaXN0YW5jZVRvKHVuaXQucG9zaXRpb24pKVxuXHRcdCk7XG5cblx0XHR0aGlzLnNjZW5lLm1vZGVscy5sb2FkR0xURih7XG5cdFx0XHRiYXNlVXJsOiBmcmFjdGlvbiA9PT0gJ2dvYXRzJ1xuXHRcdFx0XHQ/ICcuL2Fzc2V0cy9tb2RlbHMvdW5pdHMvZ29hdC13YXJyaW9yJ1xuXHRcdFx0XHQ6ICcuL2Fzc2V0cy9tb2RlbHMvdW5pdHMvZW5lbXknLFxuXHRcdFx0Y2FsbGJhY2s6IChnbHRmKSA9PiB7XG5cdFx0XHRcdGNvbnN0IG5ldHdvcmtDb25uZWN0aW9uID0gdGhpcy5zY2VuZS5jb25uZWN0aW9uO1xuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhbmV0d29ya0Nvbm5lY3Rpb25cblx0XHRcdFx0XHR8fCAhbmV0d29ya0Nvbm5lY3Rpb24ubWV0YVxuXHRcdFx0XHRcdHx8ICFuZXR3b3JrQ29ubmVjdGlvbi5tZXRhLnJvbGVcblx0XHRcdFx0XHR8fCBuZXR3b3JrQ29ubmVjdGlvbi5tZXRhLnJvbGUgPT09ICdob3N0J1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvKiogQHR5cGUge0FJfSAqL1xuXHRcdFx0XHRcdGNvbnN0IGFpID0gZ2FtZU9iamVjdHNTZXJ2aWNlLmhvb2tHYW1lT2JqZWN0KG5ldyBBSSh7XG5cdFx0XHRcdFx0XHRhbmltYXRpb25zOiBnbHRmLmFuaW1hdGlvbnMsXG5cdFx0XHRcdFx0XHRvYmplY3Q6IGdsdGYuc2NlbmUsXG5cdFx0XHRcdFx0XHRzcGVlZDogMC4zNSArIGxldmVsICogMC4wMjUsXG5cdFx0XHRcdFx0XHRkYW1hZ2U6IDUgKyBsZXZlbCAqIDEuNSxcblx0XHRcdFx0XHRcdGhwOiA3MCArIGxldmVsICogMzAsXG5cdFx0XHRcdFx0XHRmcmFjdGlvbixcblx0XHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0XHRsZXZlbCxcblx0XHRcdFx0XHRcdGNoZWNrV2F5OiB0aGlzLnNjZW5lLmNvbGxpZGVycy5jaGVja1dheSxcblx0XHRcdFx0XHRcdGdldE5leHRQb2ludDogdGhpcy5zY2VuZS5wYXRoRmluZGVyLmdldE5leHRQb2ludCxcblx0XHRcdFx0XHRcdGF0dGFjazogKCkgPT4gZ2FtZU9iamVjdHNTZXJ2aWNlLmF0dGFjayhhaSksXG5cdFx0XHRcdFx0XHRvbkRhbWFnZVRha2VuOiAoKSA9PiB0aGlzLnNjZW5lLnBhcnRpY2xlcy5sb2FkRWZmZWN0KHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb246IGFpLnBvc2l0aW9uLmNsb25lKCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAuNzUsIDApKVxuXHRcdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0XHRvbkRpZTogKCkgPT4gdGhpcy5zY2VuZS5pbnRlcnZhbHMuc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmIChhaS5pc0RlYWQoKSkge1xuXHRcdFx0XHRcdFx0XHRcdGdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdChhaSk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAob25EaWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9uRGllKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCAxMDAwMCksXG5cdFx0XHRcdFx0XHRmaW5kVGFyZ2V0OiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5lYXJFbmVteVVuaXRzID0gdGhpcy5nZXRBbGl2ZVVuaXRzKClcblx0XHRcdFx0XHRcdFx0XHQuZmlsdGVyKHVuaXQgPT4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0dW5pdCAhPT0gYWlcblx0XHRcdFx0XHRcdFx0XHRcdCYmIHVuaXQuZ2V0RnJhY3Rpb24oKSAhPT0gZnJhY3Rpb25cblx0XHRcdFx0XHRcdFx0XHRcdCYmIHVuaXQucG9zaXRpb24uZGlzdGFuY2VUbyhhaS5wb3NpdGlvbikgPCAxNVxuXHRcdFx0XHRcdFx0XHRcdCkpXG5cdFx0XHRcdFx0XHRcdFx0LnNvcnQoKHVuaXRBLCB1bml0QikgPT4gZ2V0UHJpb3JpdHkoYWksIHVuaXRCKSAtIGdldFByaW9yaXR5KGFpLCB1bml0QSkpO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZWFyRW5lbXlVbml0cy5sZW5ndGggPyBuZWFyRW5lbXlVbml0c1swXSA6IG51bGw7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0XHRcdGFpLnBvc2l0aW9uLnNldCh4IHx8IDAsIHkgfHwgMCwgeiB8fCAwKTtcblx0XHRcdFx0XHRhaS5yb3RhdGlvbi5zZXQocm90YXRpb24ueCB8fCAwLCByb3RhdGlvbi55IHx8IDAsIHJvdGF0aW9uLnogfHwgMCk7XG5cblx0XHRcdFx0XHRpZiAoc2NhbGUpIHtcblx0XHRcdFx0XHRcdGFpLm9iamVjdC5zY2FsZS5zZXQoc2NhbGUsIHNjYWxlLCBzY2FsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdH0pO1xuXHR9XG5cblx0Y3JlYXRlTmV0d29ya0FJKFxuXHRcdHtcblx0XHRcdHBhcmFtczoge1xuXHRcdFx0XHRmcmFjdGlvbixcblx0XHRcdFx0dW5pdE5ldHdvcmtJZCxcblx0XHRcdFx0bGV2ZWwsXG5cdFx0XHRcdG5hbWUsXG5cdFx0XHRcdGhwLFxuXHRcdFx0XHRocE1heCxcblx0XHRcdFx0ZGFtYWdlLFxuXHRcdFx0XHRmcm9tTmV0d29yayA9IHRydWVcblx0XHRcdH0sXG5cdFx0XHRwb3NpdGlvbixcblx0XHRcdG9uRGllXG5cdFx0fSxcblx0XHRjYWxsYmFjayA9ICgpID0+IHtcblx0XHR9LFxuXHQpIHtcblx0XHRjb25zdCBnYW1lT2JqZWN0c1NlcnZpY2UgPSB0aGlzLnNjZW5lLmdhbWVPYmplY3RzU2VydmljZTtcblx0XHRjb25zdCBnZXRQcmlvcml0eSA9ICh1bml0LCB0YXJnZXQpID0+IChcblx0XHRcdCh0YXJnZXQgaW5zdGFuY2VvZiBQbGF5ZXIgPyAwLjc1IDogMClcblx0XHRcdCsgMSAvIE1hdGguY2VpbCh0YXJnZXQucG9zaXRpb24uZGlzdGFuY2VUbyh1bml0LnBvc2l0aW9uKSlcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2NlbmUubW9kZWxzLmxvYWRHTFRGKHtcblx0XHRcdGJhc2VVcmw6IGZyYWN0aW9uID09PSAnZ29hdHMnXG5cdFx0XHRcdD8gJy4vYXNzZXRzL21vZGVscy91bml0cy9nb2F0LXdhcnJpb3InXG5cdFx0XHRcdDogJy4vYXNzZXRzL21vZGVscy91bml0cy9lbmVteScsXG5cdFx0XHRjYWxsYmFjazogKGxvYWRlZE9iamVjdCkgPT4ge1xuXHRcdFx0XHRjb25zdCBhaSA9IGdhbWVPYmplY3RzU2VydmljZS5ob29rR2FtZU9iamVjdChuZXcgQUkoe1xuXHRcdFx0XHRcdG9iamVjdDogbG9hZGVkT2JqZWN0LnNjZW5lLFxuXHRcdFx0XHRcdGFuaW1hdGlvbnM6IGxvYWRlZE9iamVjdC5hbmltYXRpb25zLFxuXHRcdFx0XHRcdHVuaXROZXR3b3JrSWQsXG5cdFx0XHRcdFx0ZnJhY3Rpb24sXG5cdFx0XHRcdFx0bGV2ZWwsXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRocCxcblx0XHRcdFx0XHRocE1heCxcblx0XHRcdFx0XHRkYW1hZ2UsXG5cdFx0XHRcdFx0ZnJvbU5ldHdvcmssXG5cdFx0XHRcdFx0Y2hlY2tXYXk6IHRoaXMuc2NlbmUuY29sbGlkZXJzLmNoZWNrV2F5LFxuXHRcdFx0XHRcdGdldE5leHRQb2ludDogdGhpcy5zY2VuZS5wYXRoRmluZGVyLmdldE5leHRQb2ludCxcblx0XHRcdFx0XHRhdHRhY2s6ICgpID0+IGdhbWVPYmplY3RzU2VydmljZS5hdHRhY2soYWkpLFxuXHRcdFx0XHRcdG9uRGFtYWdlVGFrZW46ICgpID0+IHRoaXMuc2NlbmUucGFydGljbGVzLmxvYWRFZmZlY3Qoe1xuXHRcdFx0XHRcdFx0cG9zaXRpb246IGFpLnBvc2l0aW9uLmNsb25lKCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAuNzUsIDApKVxuXHRcdFx0XHRcdH0pLFxuXG5cdFx0XHRcdFx0b25EaWU6ICgpID0+IHRoaXMuc2NlbmUuaW50ZXJ2YWxzLnNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGFpLmlzRGVhZCgpKSB7XG5cdFx0XHRcdFx0XHRcdGdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdChhaSk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFhaS5wYXJhbXMuZnJvbU5ldHdvcmspIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmNyZWF0ZU5ldHdvcmtBSSh7XG5cdFx0XHRcdFx0XHRcdFx0XHRmcmFjdGlvbixcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXROZXR3b3JrSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdFx0XHRcdFx0aHAsXG5cdFx0XHRcdFx0XHRcdFx0XHRocE1heCxcblx0XHRcdFx0XHRcdFx0XHRcdGRhbWFnZSxcblx0XHRcdFx0XHRcdFx0XHRcdGZyb21OZXR3b3JrOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRcdGxldmVsOiBsZXZlbCArIDEgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBsZXZlbCksXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCAxMDAwMCksXG5cdFx0XHRcdFx0ZmluZFRhcmdldDogKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKCFhaS5wYXJhbXMuZnJvbU5ldHdvcmspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbmVhckVuZW15VW5pdHMgPSB0aGlzLmdldEFsaXZlVW5pdHMoKVxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIodW5pdCA9PiAoXG5cdFx0XHRcdFx0XHRcdFx0XHR1bml0ICE9PSBhaVxuXHRcdFx0XHRcdFx0XHRcdFx0JiYgdW5pdC5nZXRGcmFjdGlvbigpICE9PSBmcmFjdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0JiYgdW5pdC5wb3NpdGlvbi5kaXN0YW5jZVRvKGFpLnBvc2l0aW9uKSA8IDE1XG5cdFx0XHRcdFx0XHRcdFx0KSlcblx0XHRcdFx0XHRcdFx0XHQuc29ydCgodW5pdEEsIHVuaXRCKSA9PiBnZXRQcmlvcml0eShhaSwgdW5pdEIpIC0gZ2V0UHJpb3JpdHkoYWksIHVuaXRBKSk7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5lYXJFbmVteVVuaXRzLmxlbmd0aCA/IG5lYXJFbmVteVVuaXRzWzBdIDogbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KSk7XG5cblxuXHRcdFx0XHRjYWxsYmFjayhhaSk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXHR9XG5cblx0Y3JlYXRlTmV0d29ya1BsYXllcih7XG5cdFx0cGFyYW1zOiB7IGNvbm5lY3Rpb25JZCwgdW5pdE5ldHdvcmtJZCwgbmFtZSB9LFxuXHRcdG9uRGFtYWdlRGVhbCxcblx0XHRvbktpbGwsXG5cdFx0b25EaWUsXG5cdFx0b25MZXZlbFVwLFxuXHRcdG9uRGFtYWdlVGFrZW4sXG5cdH0sIGNhbGxiYWNrKSB7XG5cdFx0Y29uc3QgZ2FtZU9iamVjdHNTZXJ2aWNlID0gdGhpcy5zY2VuZS5nYW1lT2JqZWN0c1NlcnZpY2U7XG5cblx0XHRyZXR1cm4gdGhpcy5zY2VuZS5tb2RlbHMubG9hZEdMVEYoe1xuXHRcdFx0YmFzZVVybDogJy4vYXNzZXRzL21vZGVscy91bml0cy9uZXR3b3JrLXBsYXllcicsXG5cdFx0XHRjYWxsYmFjazogKGxvYWRlZE9iamVjdCkgPT4ge1xuXHRcdFx0XHQvKiogQHR5cGUge1BsYXllcn0gKi9cblx0XHRcdFx0Y29uc3QgcGxheWVyID0gZ2FtZU9iamVjdHNTZXJ2aWNlLmhvb2tHYW1lT2JqZWN0KG5ldyBQbGF5ZXIoe1xuXHRcdFx0XHRcdG9iamVjdDogbG9hZGVkT2JqZWN0LnNjZW5lLFxuXHRcdFx0XHRcdGFuaW1hdGlvbnM6IGxvYWRlZE9iamVjdC5hbmltYXRpb25zLFxuXHRcdFx0XHRcdHVuaXROZXR3b3JrSWQsXG5cdFx0XHRcdFx0Y29ubmVjdGlvbklkLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZnJvbU5ldHdvcms6IHRydWUsXG5cdFx0XHRcdFx0Y29tcGxleEFuaW1hdGlvbnM6IHRydWUsXG5cdFx0XHRcdFx0Y2hlY2tXYXk6IHRoaXMuc2NlbmUuY29sbGlkZXJzLmNoZWNrV2F5LFxuXHRcdFx0XHRcdGlucHV0OiB7XG5cdFx0XHRcdFx0XHR2ZXJ0aWNhbDogMCxcblx0XHRcdFx0XHRcdGhvcml6b250YWw6IDAsXG5cdFx0XHRcdFx0XHRqdW1wOiBmYWxzZSxcblx0XHRcdFx0XHRcdGN1cnNvcjoge1xuXHRcdFx0XHRcdFx0XHR4OiAwLFxuXHRcdFx0XHRcdFx0XHR5OiAwLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGxvb2s6IHtcblx0XHRcdFx0XHRcdFx0dmVydGljYWw6IDAsXG5cdFx0XHRcdFx0XHRcdGhvcml6b250YWw6IDAsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0b25EaWU6IChraWxsZXIpID0+IHRoaXMuc2NlbmUuaW50ZXJ2YWxzLnNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHBsYXllci5pc0RlYWQoKSkge1xuXHRcdFx0XHRcdFx0XHRnYW1lT2JqZWN0c1NlcnZpY2UuZGVzdHJveUdhbWVPYmplY3QocGxheWVyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9uRGllICYmIG9uRGllKGtpbGxlcilcblx0XHRcdFx0XHR9LCAxMDAwMCksXG5cdFx0XHRcdFx0b25EYW1hZ2VEZWFsOiBkYW1hZ2VkVW5pdCA9PiBvbkRhbWFnZURlYWwgJiYgb25EYW1hZ2VEZWFsKGRhbWFnZWRVbml0KSxcblx0XHRcdFx0XHRvbkRhbWFnZVRha2VuOiAoYXR0YWNrZXIpID0+IHtcblx0XHRcdFx0XHRcdG9uRGFtYWdlVGFrZW4gJiYgb25EYW1hZ2VUYWtlbihhdHRhY2tlcik7XG5cdFx0XHRcdFx0XHR0aGlzLnNjZW5lLnBhcnRpY2xlcy5sb2FkRWZmZWN0KHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb246IHBsYXllci5wb3NpdGlvbi5jbG9uZSgpLmFkZChuZXcgVEhSRUUuVmVjdG9yMygwLCAwLjc1LCAwKSlcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0b25LaWxsOiAob2JqZWN0KSA9PiBvbktpbGwgJiYgb25LaWxsKG9iamVjdCksXG5cdFx0XHRcdFx0b25MZXZlbFVwOiAoKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnNjZW5lLnBhcnRpY2xlcy5jcmVhdGVFZmZlY3Qoe1xuXHRcdFx0XHRcdFx0XHRlZmZlY3Q6ICdsZXZlbC11cC1hbHQvbGV2ZWwtdXAnLFxuXHRcdFx0XHRcdFx0XHRzY2FsZTogMS41LFxuXHRcdFx0XHRcdFx0XHRhdHRhY2hUbzogdGhpcy5wbGF5ZXIub2JqZWN0LFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRvbkxldmVsVXAgJiYgb25MZXZlbFVwKCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRhdHRhY2s6ICgpID0+IGdhbWVPYmplY3RzU2VydmljZS5hdHRhY2socGxheWVyKSxcblx0XHRcdFx0XHRmaXJlOiAoKSA9PiBnYW1lT2JqZWN0c1NlcnZpY2UuZmlyZShwbGF5ZXIpLFxuXHRcdFx0XHRcdGRlc3Ryb3k6ICgpID0+IGdhbWVPYmplY3RzU2VydmljZS5kZXN0cm95R2FtZU9iamVjdChwbGF5ZXIpLFxuXHRcdFx0XHR9KSk7XG5cblx0XHRcdFx0Y2FsbGJhY2socGxheWVyKTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cdH1cbn0iLCIvLyBqYXZhc2NyaXB0LWFzdGFyIDAuNC4xXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9iZ3JpbnMvamF2YXNjcmlwdC1hc3RhclxuLy8gRnJlZWx5IGRpc3RyaWJ1dGFibGUgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuLy8gSW1wbGVtZW50cyB0aGUgYXN0YXIgc2VhcmNoIGFsZ29yaXRobSBpbiBqYXZhc2NyaXB0IHVzaW5nIGEgQmluYXJ5IEhlYXAuXG4vLyBJbmNsdWRlcyBCaW5hcnkgSGVhcCAod2l0aCBtb2RpZmljYXRpb25zKSBmcm9tIE1hcmlqbiBIYXZlcmJla2UuXG4vLyBodHRwOi8vZWxvcXVlbnRqYXZhc2NyaXB0Lm5ldC9hcHBlbmRpeDIuaHRtbFxuKGZ1bmN0aW9uKGRlZmluaXRpb24pIHtcbiAgICAvKiBnbG9iYWwgbW9kdWxlLCBkZWZpbmUgKi9cbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgICAgICB3aW5kb3cuYXN0YXIgPSBleHBvcnRzLmFzdGFyO1xuICAgICAgICB3aW5kb3cuR3JhcGggPSBleHBvcnRzLkdyYXBoO1xuICAgIH1cbn0pKGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gcGF0aFRvKG5vZGUpIHtcbiAgICAgICAgdmFyIGN1cnIgPSBub2RlO1xuICAgICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgICB3aGlsZSAoY3Vyci5wYXJlbnQpIHtcbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChjdXJyKTtcbiAgICAgICAgICAgIGN1cnIgPSBjdXJyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRIZWFwKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUhlYXAoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGFzdGFyID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhbiBBKiBTZWFyY2ggb24gYSBncmFwaCBnaXZlbiBhIHN0YXJ0IGFuZCBlbmQgbm9kZS5cbiAgICAgICAgICogQHBhcmFtIHtHcmFwaH0gZ3JhcGhcbiAgICAgICAgICogQHBhcmFtIHtHcmlkTm9kZX0gc3RhcnRcbiAgICAgICAgICogQHBhcmFtIHtHcmlkTm9kZX0gZW5kXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICogQHBhcmFtIHtib29sfSBbb3B0aW9ucy5jbG9zZXN0XSBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAgICAgICBwYXRoIHRvIHRoZSBjbG9zZXN0IG5vZGUgaWYgdGhlIHRhcmdldCBpcyB1bnJlYWNoYWJsZS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuaGV1cmlzdGljXSBIZXVyaXN0aWMgZnVuY3Rpb24gKHNlZVxuICAgICAgICAgKiAgICAgICAgICBhc3Rhci5oZXVyaXN0aWNzKS5cbiAgICAgICAgICovXG4gICAgICAgIHNlYXJjaDogZnVuY3Rpb24oZ3JhcGgsIHN0YXJ0LCBlbmQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGdyYXBoLmNsZWFuRGlydHkoKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGhldXJpc3RpYyA9IG9wdGlvbnMuaGV1cmlzdGljIHx8IGFzdGFyLmhldXJpc3RpY3MubWFuaGF0dGFuO1xuICAgICAgICAgICAgdmFyIGNsb3Nlc3QgPSBvcHRpb25zLmNsb3Nlc3QgfHwgZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBvcGVuSGVhcCA9IGdldEhlYXAoKTtcbiAgICAgICAgICAgIHZhciBjbG9zZXN0Tm9kZSA9IHN0YXJ0OyAvLyBzZXQgdGhlIHN0YXJ0IG5vZGUgdG8gYmUgdGhlIGNsb3Nlc3QgaWYgcmVxdWlyZWRcblxuICAgICAgICAgICAgc3RhcnQuaCA9IGhldXJpc3RpYyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIGdyYXBoLm1hcmtEaXJ0eShzdGFydCk7XG5cbiAgICAgICAgICAgIG9wZW5IZWFwLnB1c2goc3RhcnQpO1xuXG4gICAgICAgICAgICB3aGlsZSAob3BlbkhlYXAuc2l6ZSgpID4gMCkge1xuXG4gICAgICAgICAgICAgICAgLy8gR3JhYiB0aGUgbG93ZXN0IGYoeCkgdG8gcHJvY2VzcyBuZXh0LiAgSGVhcCBrZWVwcyB0aGlzIHNvcnRlZCBmb3IgdXMuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gb3BlbkhlYXAucG9wKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBFbmQgY2FzZSAtLSByZXN1bHQgaGFzIGJlZW4gZm91bmQsIHJldHVybiB0aGUgdHJhY2VkIHBhdGguXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhUbyhjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsIGNhc2UgLS0gbW92ZSBjdXJyZW50Tm9kZSBmcm9tIG9wZW4gdG8gY2xvc2VkLCBwcm9jZXNzIGVhY2ggb2YgaXRzIG5laWdoYm9ycy5cbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5jbG9zZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluZCBhbGwgbmVpZ2hib3JzIGZvciB0aGUgY3VycmVudCBub2RlLlxuICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaC5uZWlnaGJvcnMoY3VycmVudE5vZGUpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZWlnaGJvci5jbG9zZWQgfHwgbmVpZ2hib3IuaXNXYWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIHZhbGlkIG5vZGUgdG8gcHJvY2Vzcywgc2tpcCB0byBuZXh0IG5laWdoYm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZyBzY29yZSBpcyB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgZnJvbSBzdGFydCB0byBjdXJyZW50IG5vZGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHBhdGggd2UgaGF2ZSBhcnJpdmVkIGF0IHRoaXMgbmVpZ2hib3IgaXMgdGhlIHNob3J0ZXN0IG9uZSB3ZSBoYXZlIHNlZW4geWV0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgZ1Njb3JlID0gY3VycmVudE5vZGUuZyArIG5laWdoYm9yLmdldENvc3QoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmVlblZpc2l0ZWQgPSBuZWlnaGJvci52aXNpdGVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVlblZpc2l0ZWQgfHwgZ1Njb3JlIDwgbmVpZ2hib3IuZykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBhbiBvcHRpbWFsIChzbyBmYXIpIHBhdGggdG8gdGhpcyBub2RlLiAgVGFrZSBzY29yZSBmb3Igbm9kZSB0byBzZWUgaG93IGdvb2QgaXQgaXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvci52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IuaCA9IG5laWdoYm9yLmggfHwgaGV1cmlzdGljKG5laWdoYm9yLCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IuZyA9IGdTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLmYgPSBuZWlnaGJvci5nICsgbmVpZ2hib3IuaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoLm1hcmtEaXJ0eShuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZWlnaGJvdXIgaXMgY2xvc2VyIHRoYW4gdGhlIGN1cnJlbnQgY2xvc2VzdE5vZGUgb3IgaWYgaXQncyBlcXVhbGx5IGNsb3NlIGJ1dCBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGNoZWFwZXIgcGF0aCB0aGFuIHRoZSBjdXJyZW50IGNsb3Nlc3Qgbm9kZSB0aGVuIGl0IGJlY29tZXMgdGhlIGNsb3Nlc3Qgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWlnaGJvci5oIDwgY2xvc2VzdE5vZGUuaCB8fCAobmVpZ2hib3IuaCA9PT0gY2xvc2VzdE5vZGUuaCAmJiBuZWlnaGJvci5nIDwgY2xvc2VzdE5vZGUuZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdE5vZGUgPSBuZWlnaGJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmVlblZpc2l0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoaW5nIHRvIGhlYXAgd2lsbCBwdXQgaXQgaW4gcHJvcGVyIHBsYWNlIGJhc2VkIG9uIHRoZSAnZicgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkhlYXAucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgc2VlbiB0aGUgbm9kZSwgYnV0IHNpbmNlIGl0IGhhcyBiZWVuIHJlc2NvcmVkIHdlIG5lZWQgdG8gcmVvcmRlciBpdCBpbiB0aGUgaGVhcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5IZWFwLnJlc2NvcmVFbGVtZW50KG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNsb3Nlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFRvKGNsb3Nlc3ROb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm8gcmVzdWx0IHdhcyBmb3VuZCAtIGVtcHR5IGFycmF5IHNpZ25pZmllcyBmYWlsdXJlIHRvIGZpbmQgcGF0aC5cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2VlIGxpc3Qgb2YgaGV1cmlzdGljczogaHR0cDovL3RoZW9yeS5zdGFuZm9yZC5lZHUvfmFtaXRwL0dhbWVQcm9ncmFtbWluZy9IZXVyaXN0aWNzLmh0bWxcbiAgICAgICAgaGV1cmlzdGljczoge1xuICAgICAgICAgICAgbWFuaGF0dGFuOiBmdW5jdGlvbihwb3MwLCBwb3MxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQxID0gTWF0aC5hYnMocG9zMS54IC0gcG9zMC54KTtcbiAgICAgICAgICAgICAgICB2YXIgZDIgPSBNYXRoLmFicyhwb3MxLnkgLSBwb3MwLnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkMSArIGQyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpYWdvbmFsOiBmdW5jdGlvbihwb3MwLCBwb3MxKSB7XG4gICAgICAgICAgICAgICAgdmFyIEQgPSAxO1xuICAgICAgICAgICAgICAgIHZhciBEMiA9IE1hdGguc3FydCgyKTtcbiAgICAgICAgICAgICAgICB2YXIgZDEgPSBNYXRoLmFicyhwb3MxLnggLSBwb3MwLngpO1xuICAgICAgICAgICAgICAgIHZhciBkMiA9IE1hdGguYWJzKHBvczEueSAtIHBvczAueSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChEICogKGQxICsgZDIpKSArICgoRDIgLSAoMiAqIEQpKSAqIE1hdGgubWluKGQxLCBkMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGVhbk5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuZiA9IDA7XG4gICAgICAgICAgICBub2RlLmcgPSAwO1xuICAgICAgICAgICAgbm9kZS5oID0gMDtcbiAgICAgICAgICAgIG5vZGUudmlzaXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZS5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGdyYXBoIG1lbW9yeSBzdHJ1Y3R1cmVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBncmlkSW4gMkQgYXJyYXkgb2YgaW5wdXQgd2VpZ2h0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtvcHRpb25zLmRpYWdvbmFsXSBTcGVjaWZpZXMgd2hldGhlciBkaWFnb25hbCBtb3ZlcyBhcmUgYWxsb3dlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdyYXBoKGdyaWRJbiwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmRpYWdvbmFsID0gISFvcHRpb25zLmRpYWdvbmFsO1xuICAgICAgICB0aGlzLmdyaWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBncmlkSW4ubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZFt4XSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMCwgcm93ID0gZ3JpZEluW3hdOyB5IDwgcm93Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgR3JpZE5vZGUoeCwgeSwgcm93W3ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRbeF1beV0gPSBub2RlO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBHcmFwaC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpcnR5Tm9kZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhc3Rhci5jbGVhbk5vZGUodGhpcy5ub2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgR3JhcGgucHJvdG90eXBlLmNsZWFuRGlydHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpcnR5Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFzdGFyLmNsZWFuTm9kZSh0aGlzLmRpcnR5Tm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHlOb2RlcyA9IFtdO1xuICAgIH07XG5cbiAgICBHcmFwaC5wcm90b3R5cGUubWFya0RpcnR5ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB0aGlzLmRpcnR5Tm9kZXMucHVzaChub2RlKTtcbiAgICB9O1xuXG4gICAgR3JhcGgucHJvdG90eXBlLm5laWdoYm9ycyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICB2YXIgeCA9IG5vZGUueDtcbiAgICAgICAgdmFyIHkgPSBub2RlLnk7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5ncmlkO1xuXG4gICAgICAgIC8vIFdlc3RcbiAgICAgICAgaWYgKGdyaWRbeCAtIDFdICYmIGdyaWRbeCAtIDFdW3ldKSB7XG4gICAgICAgICAgICByZXQucHVzaChncmlkW3ggLSAxXVt5XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFYXN0XG4gICAgICAgIGlmIChncmlkW3ggKyAxXSAmJiBncmlkW3ggKyAxXVt5XSkge1xuICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4ICsgMV1beV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU291dGhcbiAgICAgICAgaWYgKGdyaWRbeF0gJiYgZ3JpZFt4XVt5IC0gMV0pIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGdyaWRbeF1beSAtIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vcnRoXG4gICAgICAgIGlmIChncmlkW3hdICYmIGdyaWRbeF1beSArIDFdKSB7XG4gICAgICAgICAgICByZXQucHVzaChncmlkW3hdW3kgKyAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kaWFnb25hbCkge1xuICAgICAgICAgICAgLy8gU291dGh3ZXN0XG4gICAgICAgICAgICBpZiAoZ3JpZFt4IC0gMV0gJiYgZ3JpZFt4IC0gMV1beSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4IC0gMV1beSAtIDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU291dGhlYXN0XG4gICAgICAgICAgICBpZiAoZ3JpZFt4ICsgMV0gJiYgZ3JpZFt4ICsgMV1beSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4ICsgMV1beSAtIDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm9ydGh3ZXN0XG4gICAgICAgICAgICBpZiAoZ3JpZFt4IC0gMV0gJiYgZ3JpZFt4IC0gMV1beSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4IC0gMV1beSArIDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm9ydGhlYXN0XG4gICAgICAgICAgICBpZiAoZ3JpZFt4ICsgMV0gJiYgZ3JpZFt4ICsgMV1beSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goZ3JpZFt4ICsgMV1beSArIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIEdyYXBoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JhcGhTdHJpbmcgPSBbXTtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ncmlkO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG5vZGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICB2YXIgcm93RGVidWcgPSBbXTtcbiAgICAgICAgICAgIHZhciByb3cgPSBub2Rlc1t4XTtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcm93Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgcm93RGVidWcucHVzaChyb3dbeV0ud2VpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYXBoU3RyaW5nLnB1c2gocm93RGVidWcuam9pbihcIiBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFwaFN0cmluZy5qb2luKFwiXFxuXCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBHcmlkTm9kZSh4LCB5LCB3ZWlnaHQpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XG4gICAgfVxuXG4gICAgR3JpZE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIltcIiArIHRoaXMueCArIFwiIFwiICsgdGhpcy55ICsgXCJdXCI7XG4gICAgfTtcblxuICAgIEdyaWROb2RlLnByb3RvdHlwZS5nZXRDb3N0ID0gZnVuY3Rpb24oZnJvbU5laWdoYm9yKSB7XG4gICAgICAgIC8vIFRha2UgZGlhZ29uYWwgd2VpZ2h0IGludG8gY29uc2lkZXJhdGlvbi5cbiAgICAgICAgaWYgKGZyb21OZWlnaGJvciAmJiBmcm9tTmVpZ2hib3IueCAhPSB0aGlzLnggJiYgZnJvbU5laWdoYm9yLnkgIT0gdGhpcy55KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWlnaHQgKiAxLjQxNDIxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndlaWdodDtcbiAgICB9O1xuXG4gICAgR3JpZE5vZGUucHJvdG90eXBlLmlzV2FsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWlnaHQgPT09IDA7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEJpbmFyeUhlYXAoc2NvcmVGdW5jdGlvbikge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5zY29yZUZ1bmN0aW9uID0gc2NvcmVGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBCaW5hcnlIZWFwLnByb3RvdHlwZSA9IHtcbiAgICAgICAgcHVzaDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBBbGxvdyBpdCB0byBzaW5rIGRvd24uXG4gICAgICAgICAgICB0aGlzLnNpbmtEb3duKHRoaXMuY29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBmaXJzdCBlbGVtZW50IHNvIHdlIGNhbiByZXR1cm4gaXQgbGF0ZXIuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb250ZW50WzBdO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuY29udGVudC5wb3AoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgZWxlbWVudHMgbGVmdCwgcHV0IHRoZSBlbmQgZWxlbWVudCBhdCB0aGVcbiAgICAgICAgICAgIC8vIHN0YXJ0LCBhbmQgbGV0IGl0IGJ1YmJsZSB1cC5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFswXSA9IGVuZDtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1YmJsZVVwKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuY29udGVudC5pbmRleE9mKG5vZGUpO1xuXG4gICAgICAgICAgICAvLyBXaGVuIGl0IGlzIGZvdW5kLCB0aGUgcHJvY2VzcyBzZWVuIGluICdwb3AnIGlzIHJlcGVhdGVkXG4gICAgICAgICAgICAvLyB0byBmaWxsIHVwIHRoZSBob2xlLlxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuY29udGVudC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGkgIT09IHRoaXMuY29udGVudC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W2ldID0gZW5kO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NvcmVGdW5jdGlvbihlbmQpIDwgdGhpcy5zY29yZUZ1bmN0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2lua0Rvd24oaSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWJibGVVcChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2NvcmVFbGVtZW50OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLnNpbmtEb3duKHRoaXMuY29udGVudC5pbmRleE9mKG5vZGUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lua0Rvd246IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBlbGVtZW50IHRoYXQgaGFzIHRvIGJlIHN1bmsuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXTtcblxuICAgICAgICAgICAgLy8gV2hlbiBhdCAwLCBhbiBlbGVtZW50IGNhbiBub3Qgc2luayBhbnkgZnVydGhlci5cbiAgICAgICAgICAgIHdoaWxlIChuID4gMCkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBpbmRleCwgYW5kIGZldGNoIGl0LlxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROID0gKChuICsgMSkgPj4gMSkgLSAxO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmNvbnRlbnRbcGFyZW50Tl07XG4gICAgICAgICAgICAgICAgLy8gU3dhcCB0aGUgZWxlbWVudHMgaWYgdGhlIHBhcmVudCBpcyBncmVhdGVyLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCkgPCB0aGlzLnNjb3JlRnVuY3Rpb24ocGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbcGFyZW50Tl0gPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbbl0gPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSAnbicgdG8gY29udGludWUgYXQgdGhlIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgbiA9IHBhcmVudE47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgcGFyZW50IHRoYXQgaXMgbGVzcywgbm8gbmVlZCB0byBzaW5rIGFueSBmdXJ0aGVyLlxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJ1YmJsZVVwOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAvLyBMb29rIHVwIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgaXRzIHNjb3JlLlxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXTtcbiAgICAgICAgICAgIHZhciBlbGVtU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCk7XG5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaW5kaWNlcyBvZiB0aGUgY2hpbGQgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkMk4gPSAobiArIDEpIDw8IDE7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkMU4gPSBjaGlsZDJOIC0gMTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICAgICAgICAgIHZhciBzd2FwID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQxU2NvcmU7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGNoaWxkIGV4aXN0cyAoaXMgaW5zaWRlIHRoZSBhcnJheSkuLi5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQxTiA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGl0IHVwIGFuZCBjb21wdXRlIGl0cyBzY29yZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkMSA9IHRoaXMuY29udGVudFtjaGlsZDFOXTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQxU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQxKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2NvcmUgaXMgbGVzcyB0aGFuIG91ciBlbGVtZW50J3MsIHdlIG5lZWQgdG8gc3dhcC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkMVNjb3JlIDwgZWxlbVNjb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FwID0gY2hpbGQxTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvIHRoZSBzYW1lIGNoZWNrcyBmb3IgdGhlIG90aGVyIGNoaWxkLlxuICAgICAgICAgICAgICAgIGlmIChjaGlsZDJOIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZDIgPSB0aGlzLmNvbnRlbnRbY2hpbGQyTl07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZDJTY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihjaGlsZDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQyU2NvcmUgPCAoc3dhcCA9PT0gbnVsbCA/IGVsZW1TY29yZSA6IGNoaWxkMVNjb3JlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dhcCA9IGNoaWxkMk47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBuZWVkcyB0byBiZSBtb3ZlZCwgc3dhcCBpdCwgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgICAgIGlmIChzd2FwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFtuXSA9IHRoaXMuY29udGVudFtzd2FwXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3N3YXBdID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbiA9IHN3YXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgYXJlIGRvbmUuXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhc3RhcjogYXN0YXIsXG4gICAgICAgIEdyYXBoOiBHcmFwaFxuICAgIH07XG59KTsiLCJpbXBvcnQgU2VydmVyIGZyb20gJy4vc3RhbmRhbG9uZS1zZXJ2ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgU2VydmVyKCk7XG4iLCJleHBvcnQgdmFyIFJFVklTSU9OID0gJzExMSc7XG5leHBvcnQgdmFyIE1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyLCBST1RBVEU6IDAsIERPTExZOiAxLCBQQU46IDIgfTtcbmV4cG9ydCB2YXIgVE9VQ0ggPSB7IFJPVEFURTogMCwgUEFOOiAxLCBET0xMWV9QQU46IDIsIERPTExZX1JPVEFURTogMyB9O1xuZXhwb3J0IHZhciBDdWxsRmFjZU5vbmUgPSAwO1xuZXhwb3J0IHZhciBDdWxsRmFjZUJhY2sgPSAxO1xuZXhwb3J0IHZhciBDdWxsRmFjZUZyb250ID0gMjtcbmV4cG9ydCB2YXIgQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xuZXhwb3J0IHZhciBGcm9udEZhY2VEaXJlY3Rpb25DVyA9IDA7XG5leHBvcnQgdmFyIEZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XG5leHBvcnQgdmFyIEJhc2ljU2hhZG93TWFwID0gMDtcbmV4cG9ydCB2YXIgUENGU2hhZG93TWFwID0gMTtcbmV4cG9ydCB2YXIgUENGU29mdFNoYWRvd01hcCA9IDI7XG5leHBvcnQgdmFyIFZTTVNoYWRvd01hcCA9IDM7XG5leHBvcnQgdmFyIEZyb250U2lkZSA9IDA7XG5leHBvcnQgdmFyIEJhY2tTaWRlID0gMTtcbmV4cG9ydCB2YXIgRG91YmxlU2lkZSA9IDI7XG5leHBvcnQgdmFyIEZsYXRTaGFkaW5nID0gMTtcbmV4cG9ydCB2YXIgU21vb3RoU2hhZGluZyA9IDI7XG5leHBvcnQgdmFyIE5vQ29sb3JzID0gMDtcbmV4cG9ydCB2YXIgRmFjZUNvbG9ycyA9IDE7XG5leHBvcnQgdmFyIFZlcnRleENvbG9ycyA9IDI7XG5leHBvcnQgdmFyIE5vQmxlbmRpbmcgPSAwO1xuZXhwb3J0IHZhciBOb3JtYWxCbGVuZGluZyA9IDE7XG5leHBvcnQgdmFyIEFkZGl0aXZlQmxlbmRpbmcgPSAyO1xuZXhwb3J0IHZhciBTdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcbmV4cG9ydCB2YXIgTXVsdGlwbHlCbGVuZGluZyA9IDQ7XG5leHBvcnQgdmFyIEN1c3RvbUJsZW5kaW5nID0gNTtcbmV4cG9ydCB2YXIgQWRkRXF1YXRpb24gPSAxMDA7XG5leHBvcnQgdmFyIFN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XG5leHBvcnQgdmFyIFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xuZXhwb3J0IHZhciBNaW5FcXVhdGlvbiA9IDEwMztcbmV4cG9ydCB2YXIgTWF4RXF1YXRpb24gPSAxMDQ7XG5leHBvcnQgdmFyIFplcm9GYWN0b3IgPSAyMDA7XG5leHBvcnQgdmFyIE9uZUZhY3RvciA9IDIwMTtcbmV4cG9ydCB2YXIgU3JjQ29sb3JGYWN0b3IgPSAyMDI7XG5leHBvcnQgdmFyIE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSAyMDM7XG5leHBvcnQgdmFyIFNyY0FscGhhRmFjdG9yID0gMjA0O1xuZXhwb3J0IHZhciBPbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xuZXhwb3J0IHZhciBEc3RBbHBoYUZhY3RvciA9IDIwNjtcbmV4cG9ydCB2YXIgT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcbmV4cG9ydCB2YXIgRHN0Q29sb3JGYWN0b3IgPSAyMDg7XG5leHBvcnQgdmFyIE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XG5leHBvcnQgdmFyIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XG5leHBvcnQgdmFyIE5ldmVyRGVwdGggPSAwO1xuZXhwb3J0IHZhciBBbHdheXNEZXB0aCA9IDE7XG5leHBvcnQgdmFyIExlc3NEZXB0aCA9IDI7XG5leHBvcnQgdmFyIExlc3NFcXVhbERlcHRoID0gMztcbmV4cG9ydCB2YXIgRXF1YWxEZXB0aCA9IDQ7XG5leHBvcnQgdmFyIEdyZWF0ZXJFcXVhbERlcHRoID0gNTtcbmV4cG9ydCB2YXIgR3JlYXRlckRlcHRoID0gNjtcbmV4cG9ydCB2YXIgTm90RXF1YWxEZXB0aCA9IDc7XG5leHBvcnQgdmFyIE11bHRpcGx5T3BlcmF0aW9uID0gMDtcbmV4cG9ydCB2YXIgTWl4T3BlcmF0aW9uID0gMTtcbmV4cG9ydCB2YXIgQWRkT3BlcmF0aW9uID0gMjtcbmV4cG9ydCB2YXIgTm9Ub25lTWFwcGluZyA9IDA7XG5leHBvcnQgdmFyIExpbmVhclRvbmVNYXBwaW5nID0gMTtcbmV4cG9ydCB2YXIgUmVpbmhhcmRUb25lTWFwcGluZyA9IDI7XG5leHBvcnQgdmFyIFVuY2hhcnRlZDJUb25lTWFwcGluZyA9IDM7XG5leHBvcnQgdmFyIENpbmVvblRvbmVNYXBwaW5nID0gNDtcbmV4cG9ydCB2YXIgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nID0gNTtcblxuZXhwb3J0IHZhciBVVk1hcHBpbmcgPSAzMDA7XG5leHBvcnQgdmFyIEN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IDMwMTtcbmV4cG9ydCB2YXIgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xuZXhwb3J0IHZhciBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcbmV4cG9ydCB2YXIgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDQ7XG5leHBvcnQgdmFyIFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nID0gMzA1O1xuZXhwb3J0IHZhciBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA9IDMwNjtcbmV4cG9ydCB2YXIgQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDc7XG5leHBvcnQgdmFyIFJlcGVhdFdyYXBwaW5nID0gMTAwMDtcbmV4cG9ydCB2YXIgQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IDEwMDE7XG5leHBvcnQgdmFyIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSAxMDAyO1xuZXhwb3J0IHZhciBOZWFyZXN0RmlsdGVyID0gMTAwMztcbmV4cG9ydCB2YXIgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuZXhwb3J0IHZhciBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5leHBvcnQgdmFyIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuZXhwb3J0IHZhciBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcbmV4cG9ydCB2YXIgTGluZWFyRmlsdGVyID0gMTAwNjtcbmV4cG9ydCB2YXIgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5leHBvcnQgdmFyIExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xuZXhwb3J0IHZhciBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuZXhwb3J0IHZhciBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuZXhwb3J0IHZhciBVbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcbmV4cG9ydCB2YXIgQnl0ZVR5cGUgPSAxMDEwO1xuZXhwb3J0IHZhciBTaG9ydFR5cGUgPSAxMDExO1xuZXhwb3J0IHZhciBVbnNpZ25lZFNob3J0VHlwZSA9IDEwMTI7XG5leHBvcnQgdmFyIEludFR5cGUgPSAxMDEzO1xuZXhwb3J0IHZhciBVbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuZXhwb3J0IHZhciBGbG9hdFR5cGUgPSAxMDE1O1xuZXhwb3J0IHZhciBIYWxmRmxvYXRUeXBlID0gMTAxNjtcbmV4cG9ydCB2YXIgVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNztcbmV4cG9ydCB2YXIgVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxODtcbmV4cG9ydCB2YXIgVW5zaWduZWRTaG9ydDU2NVR5cGUgPSAxMDE5O1xuZXhwb3J0IHZhciBVbnNpZ25lZEludDI0OFR5cGUgPSAxMDIwO1xuZXhwb3J0IHZhciBBbHBoYUZvcm1hdCA9IDEwMjE7XG5leHBvcnQgdmFyIFJHQkZvcm1hdCA9IDEwMjI7XG5leHBvcnQgdmFyIFJHQkFGb3JtYXQgPSAxMDIzO1xuZXhwb3J0IHZhciBMdW1pbmFuY2VGb3JtYXQgPSAxMDI0O1xuZXhwb3J0IHZhciBMdW1pbmFuY2VBbHBoYUZvcm1hdCA9IDEwMjU7XG5leHBvcnQgdmFyIFJHQkVGb3JtYXQgPSBSR0JBRm9ybWF0O1xuZXhwb3J0IHZhciBEZXB0aEZvcm1hdCA9IDEwMjY7XG5leHBvcnQgdmFyIERlcHRoU3RlbmNpbEZvcm1hdCA9IDEwMjc7XG5leHBvcnQgdmFyIFJlZEZvcm1hdCA9IDEwMjg7XG5leHBvcnQgdmFyIFJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMzM3NzY7XG5leHBvcnQgdmFyIFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IDMzNzc3O1xuZXhwb3J0IHZhciBSR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAzMzc3ODtcbmV4cG9ydCB2YXIgUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMzM3Nzk7XG5leHBvcnQgdmFyIFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMzU4NDA7XG5leHBvcnQgdmFyIFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDE7XG5leHBvcnQgdmFyIFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQyO1xuZXhwb3J0IHZhciBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAzNTg0MztcbmV4cG9ydCB2YXIgUkdCX0VUQzFfRm9ybWF0ID0gMzYxOTY7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ180eDRfRm9ybWF0ID0gMzc4MDg7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ181eDRfRm9ybWF0ID0gMzc4MDk7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ181eDVfRm9ybWF0ID0gMzc4MTA7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ182eDVfRm9ybWF0ID0gMzc4MTE7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ182eDZfRm9ybWF0ID0gMzc4MTI7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ184eDVfRm9ybWF0ID0gMzc4MTM7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ184eDZfRm9ybWF0ID0gMzc4MTQ7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ184eDhfRm9ybWF0ID0gMzc4MTU7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ18xMHg1X0Zvcm1hdCA9IDM3ODE2O1xuZXhwb3J0IHZhciBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgPSAzNzgxNztcbmV4cG9ydCB2YXIgUkdCQV9BU1RDXzEweDhfRm9ybWF0ID0gMzc4MTg7XG5leHBvcnQgdmFyIFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQgPSAzNzgxOTtcbmV4cG9ydCB2YXIgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCA9IDM3ODIwO1xuZXhwb3J0IHZhciBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0ID0gMzc4MjE7XG5leHBvcnQgdmFyIExvb3BPbmNlID0gMjIwMDtcbmV4cG9ydCB2YXIgTG9vcFJlcGVhdCA9IDIyMDE7XG5leHBvcnQgdmFyIExvb3BQaW5nUG9uZyA9IDIyMDI7XG5leHBvcnQgdmFyIEludGVycG9sYXRlRGlzY3JldGUgPSAyMzAwO1xuZXhwb3J0IHZhciBJbnRlcnBvbGF0ZUxpbmVhciA9IDIzMDE7XG5leHBvcnQgdmFyIEludGVycG9sYXRlU21vb3RoID0gMjMwMjtcbmV4cG9ydCB2YXIgWmVyb0N1cnZhdHVyZUVuZGluZyA9IDI0MDA7XG5leHBvcnQgdmFyIFplcm9TbG9wZUVuZGluZyA9IDI0MDE7XG5leHBvcnQgdmFyIFdyYXBBcm91bmRFbmRpbmcgPSAyNDAyO1xuZXhwb3J0IHZhciBUcmlhbmdsZXNEcmF3TW9kZSA9IDA7XG5leHBvcnQgdmFyIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IDE7XG5leHBvcnQgdmFyIFRyaWFuZ2xlRmFuRHJhd01vZGUgPSAyO1xuZXhwb3J0IHZhciBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XG5leHBvcnQgdmFyIHNSR0JFbmNvZGluZyA9IDMwMDE7XG5leHBvcnQgdmFyIEdhbW1hRW5jb2RpbmcgPSAzMDA3O1xuZXhwb3J0IHZhciBSR0JFRW5jb2RpbmcgPSAzMDAyO1xuZXhwb3J0IHZhciBMb2dMdXZFbmNvZGluZyA9IDMwMDM7XG5leHBvcnQgdmFyIFJHQk03RW5jb2RpbmcgPSAzMDA0O1xuZXhwb3J0IHZhciBSR0JNMTZFbmNvZGluZyA9IDMwMDU7XG5leHBvcnQgdmFyIFJHQkRFbmNvZGluZyA9IDMwMDY7XG5leHBvcnQgdmFyIEJhc2ljRGVwdGhQYWNraW5nID0gMzIwMDtcbmV4cG9ydCB2YXIgUkdCQURlcHRoUGFja2luZyA9IDMyMDE7XG5leHBvcnQgdmFyIFRhbmdlbnRTcGFjZU5vcm1hbE1hcCA9IDA7XG5leHBvcnQgdmFyIE9iamVjdFNwYWNlTm9ybWFsTWFwID0gMTtcblxuZXhwb3J0IHZhciBaZXJvU3RlbmNpbE9wID0gMDtcbmV4cG9ydCB2YXIgS2VlcFN0ZW5jaWxPcCA9IDc2ODA7XG5leHBvcnQgdmFyIFJlcGxhY2VTdGVuY2lsT3AgPSA3NjgxO1xuZXhwb3J0IHZhciBJbmNyZW1lbnRTdGVuY2lsT3AgPSA3NjgyO1xuZXhwb3J0IHZhciBEZWNyZW1lbnRTdGVuY2lsT3AgPSA3NjgzO1xuZXhwb3J0IHZhciBJbmNyZW1lbnRXcmFwU3RlbmNpbE9wID0gMzQwNTU7XG5leHBvcnQgdmFyIERlY3JlbWVudFdyYXBTdGVuY2lsT3AgPSAzNDA1NjtcbmV4cG9ydCB2YXIgSW52ZXJ0U3RlbmNpbE9wID0gNTM4NjtcblxuZXhwb3J0IHZhciBOZXZlclN0ZW5jaWxGdW5jID0gNTEyO1xuZXhwb3J0IHZhciBMZXNzU3RlbmNpbEZ1bmMgPSA1MTM7XG5leHBvcnQgdmFyIEVxdWFsU3RlbmNpbEZ1bmMgPSA1MTQ7XG5leHBvcnQgdmFyIExlc3NFcXVhbFN0ZW5jaWxGdW5jID0gNTE1O1xuZXhwb3J0IHZhciBHcmVhdGVyU3RlbmNpbEZ1bmMgPSA1MTY7XG5leHBvcnQgdmFyIE5vdEVxdWFsU3RlbmNpbEZ1bmMgPSA1MTc7XG5leHBvcnQgdmFyIEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jID0gNTE4O1xuZXhwb3J0IHZhciBBbHdheXNTdGVuY2lsRnVuYyA9IDUxOTtcblxuZXhwb3J0IHZhciBTdGF0aWNEcmF3VXNhZ2UgPSAzNTA0NDtcbmV4cG9ydCB2YXIgRHluYW1pY0RyYXdVc2FnZSA9IDM1MDQ4O1xuZXhwb3J0IHZhciBTdHJlYW1EcmF3VXNhZ2UgPSAzNTA0MDtcbmV4cG9ydCB2YXIgU3RhdGljUmVhZFVzYWdlID0gMzUwNDU7XG5leHBvcnQgdmFyIER5bmFtaWNSZWFkVXNhZ2UgPSAzNTA0OTtcbmV4cG9ydCB2YXIgU3RyZWFtUmVhZFVzYWdlID0gMzUwNDE7XG5leHBvcnQgdmFyIFN0YXRpY0NvcHlVc2FnZSA9IDM1MDQ2O1xuZXhwb3J0IHZhciBEeW5hbWljQ29weVVzYWdlID0gMzUwNTA7XG5leHBvcnQgdmFyIFN0cmVhbUNvcHlVc2FnZSA9IDM1MDQyO1xuIiwiLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50ZGlzcGF0Y2hlci5qcy9cbiAqL1xuXG5mdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7fVxuXG5PYmplY3QuYXNzaWduKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLCB7XG5cblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cblx0XHR9XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGhhc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuXHRcdHJldHVybiBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMTtcblxuXHR9LFxuXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZiggbGlzdGVuZXIgKTtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRcdGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHRkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0dmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcblxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xuXG5cdFx0XHR2YXIgYXJyYXkgPSBsaXN0ZW5lckFycmF5LnNsaWNlKCAwICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59ICk7XG5cblxuZXhwb3J0IHsgRXZlbnREaXNwYXRjaGVyIH07XG4iLCIvKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuZnVuY3Rpb24gTGF5ZXJzKCkge1xuXG5cdHRoaXMubWFzayA9IDEgfCAwO1xuXG59XG5cbk9iamVjdC5hc3NpZ24oIExheWVycy5wcm90b3R5cGUsIHtcblxuXHRzZXQ6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayA9IDEgPDwgY2hhbm5lbCB8IDA7XG5cblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayB8PSAxIDw8IGNoYW5uZWwgfCAwO1xuXG5cdH0sXG5cblx0ZW5hYmxlQWxsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLm1hc2sgPSAweGZmZmZmZmZmIHwgMDtcblxuXHR9LFxuXG5cdHRvZ2dsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xuXG5cdFx0dGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbCB8IDA7XG5cblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XG5cblx0XHR0aGlzLm1hc2sgJj0gfiAoIDEgPDwgY2hhbm5lbCB8IDAgKTtcblxuXHR9LFxuXG5cdGRpc2FibGVBbGw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMubWFzayA9IDA7XG5cblx0fSxcblxuXHR0ZXN0OiBmdW5jdGlvbiAoIGxheWVycyApIHtcblxuXHRcdHJldHVybiAoIHRoaXMubWFzayAmIGxheWVycy5tYXNrICkgIT09IDA7XG5cblx0fVxuXG59ICk7XG5cblxuZXhwb3J0IHsgTGF5ZXJzIH07XG4iLCJpbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vbWF0aC9RdWF0ZXJuaW9uLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlci5qcyc7XG5pbXBvcnQgeyBFdWxlciB9IGZyb20gJy4uL21hdGgvRXVsZXIuanMnO1xuaW1wb3J0IHsgTGF5ZXJzIH0gZnJvbSAnLi9MYXllcnMuanMnO1xuaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4uL21hdGgvTWF0cml4My5qcyc7XG5pbXBvcnQgeyBfTWF0aCB9IGZyb20gJy4uL21hdGgvTWF0aC5qcyc7XG5pbXBvcnQgeyBUcmlhbmdsZXNEcmF3TW9kZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5cbnZhciBfb2JqZWN0M0RJZCA9IDA7XG5cbnZhciBfdjEgPSBuZXcgVmVjdG9yMygpO1xudmFyIF9xMSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG52YXIgX20xID0gbmV3IE1hdHJpeDQoKTtcbnZhciBfdGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcblxudmFyIF9wb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG52YXIgX3NjYWxlID0gbmV3IFZlY3RvcjMoKTtcbnZhciBfcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbnZhciBfeEF4aXMgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xudmFyIF95QXhpcyA9IG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XG52YXIgX3pBeGlzID0gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcblxudmFyIF9hZGRlZEV2ZW50ID0geyB0eXBlOiAnYWRkZWQnIH07XG52YXIgX3JlbW92ZWRFdmVudCA9IHsgdHlwZTogJ3JlbW92ZWQnIH07XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGVsZXBoYW50YXR3b3JrIC8gd3d3LmVsZXBoYW50YXR3b3JrLmNoXG4gKi9cblxuZnVuY3Rpb24gT2JqZWN0M0QoKSB7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfb2JqZWN0M0RJZCArKyB9ICk7XG5cblx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cdHRoaXMudHlwZSA9ICdPYmplY3QzRCc7XG5cblx0dGhpcy5wYXJlbnQgPSBudWxsO1xuXHR0aGlzLmNoaWxkcmVuID0gW107XG5cblx0dGhpcy51cCA9IE9iamVjdDNELkRlZmF1bHRVcC5jbG9uZSgpO1xuXG5cdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciByb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XG5cblx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcblxuXHRcdHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCByb3RhdGlvbiwgZmFsc2UgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xuXG5cdFx0cm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcblxuXHR9XG5cblx0cm90YXRpb24uX29uQ2hhbmdlKCBvblJvdGF0aW9uQ2hhbmdlICk7XG5cdHF1YXRlcm5pb24uX29uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0dmFsdWU6IHBvc2l0aW9uXG5cdFx0fSxcblx0XHRyb3RhdGlvbjoge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiByb3RhdGlvblxuXHRcdH0sXG5cdFx0cXVhdGVybmlvbjoge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBxdWF0ZXJuaW9uXG5cdFx0fSxcblx0XHRzY2FsZToge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBzY2FsZVxuXHRcdH0sXG5cdFx0bW9kZWxWaWV3TWF0cml4OiB7XG5cdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDQoKVxuXHRcdH0sXG5cdFx0bm9ybWFsTWF0cml4OiB7XG5cdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxuXHRcdH1cblx0fSApO1xuXG5cdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0dGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGU7XG5cdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG5cdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblxuXHR0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xuXHR0aGlzLnJlbmRlck9yZGVyID0gMDtcblxuXHR0aGlzLnVzZXJEYXRhID0ge307XG5cbn1cblxuT2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcbk9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcblxuT2JqZWN0M0QucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IE9iamVjdDNELFxuXG5cdGlzT2JqZWN0M0Q6IHRydWUsXG5cblx0b25CZWZvcmVSZW5kZXI6IGZ1bmN0aW9uICgpIHt9LFxuXHRvbkFmdGVyUmVuZGVyOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLm1hdHJpeC5wcmVtdWx0aXBseSggbWF0cml4ICk7XG5cblx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdH0sXG5cblx0YXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XG5cblx0fSxcblxuXHRyb3RhdGVPbkF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdF9xMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBfcTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cm90YXRlT25Xb3JsZEF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdC8vIG1ldGhvZCBhc3N1bWVzIG5vIHJvdGF0ZWQgcGFyZW50XG5cblx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggX3ExICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF94QXhpcywgYW5nbGUgKTtcblxuXHR9LFxuXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF95QXhpcywgYW5nbGUgKTtcblxuXHR9LFxuXG5cdHJvdGF0ZVo6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF96QXhpcywgYW5nbGUgKTtcblxuXHR9LFxuXG5cdHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBkaXN0YW5jZSApIHtcblxuXHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0X3YxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5hZGQoIF92MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0cmFuc2xhdGVYOiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfeEF4aXMsIGRpc3RhbmNlICk7XG5cblx0fSxcblxuXHR0cmFuc2xhdGVZOiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfeUF4aXMsIGRpc3RhbmNlICk7XG5cblx0fSxcblxuXHR0cmFuc2xhdGVaOiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfekF4aXMsIGRpc3RhbmNlICk7XG5cblx0fSxcblxuXHRsb2NhbFRvV29ybGQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHR9LFxuXG5cdHdvcmxkVG9Mb2NhbDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggX20xLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKSApO1xuXG5cdH0sXG5cblx0bG9va0F0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHQvLyBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgaGF2aW5nIG5vbi11bmlmb3JtbHktc2NhbGVkIHBhcmVudChzKVxuXG5cdFx0aWYgKCB4LmlzVmVjdG9yMyApIHtcblxuXHRcdFx0X3RhcmdldC5jb3B5KCB4ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfdGFyZ2V0LnNldCggeCwgeSwgeiApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdF9wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdGlmICggdGhpcy5pc0NhbWVyYSB8fCB0aGlzLmlzTGlnaHQgKSB7XG5cblx0XHRcdF9tMS5sb29rQXQoIF9wb3NpdGlvbiwgX3RhcmdldCwgdGhpcy51cCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X20xLmxvb2tBdCggX3RhcmdldCwgX3Bvc2l0aW9uLCB0aGlzLnVwICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcblxuXHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRfbTEuZXh0cmFjdFJvdGF0aW9uKCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRcdF9xMS5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSApO1xuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBfcTEuaW52ZXJzZSgpICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0ID09PSB0aGlzICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLlwiLCBvYmplY3QgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAoIG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCApICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0b2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIF9hZGRlZEV2ZW50ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC5cIiwgb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBvYmplY3QgKTtcblxuXHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcblxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IG51bGw7XG5cdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIF9yZW1vdmVkRXZlbnQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXR0YWNoOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdC8vIGFkZHMgb2JqZWN0IGFzIGEgY2hpbGQgb2YgdGhpcywgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIG9iamVjdCdzIHdvcmxkIHRyYW5zZm9ybVxuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdF9tMS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdG9iamVjdC5wYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRcdF9tMS5tdWx0aXBseSggb2JqZWN0LnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0fVxuXG5cdFx0b2JqZWN0LmFwcGx5TWF0cml4KCBfbTEgKTtcblxuXHRcdG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIGZhbHNlICk7XG5cblx0XHR0aGlzLmFkZCggb2JqZWN0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldE9iamVjdEJ5SWQ6IGZ1bmN0aW9uICggaWQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xuXG5cdH0sXG5cblx0Z2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcblxuXHR9LFxuXG5cdGdldE9iamVjdEJ5UHJvcGVydHk6IGZ1bmN0aW9uICggbmFtZSwgdmFsdWUgKSB7XG5cblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xuXHRcdFx0dmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cblx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG9iamVjdDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHR9LFxuXG5cdGdldFdvcmxkUG9zaXRpb246IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRXb3JsZFBvc2l0aW9uKCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH0sXG5cblx0Z2V0V29ybGRRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHRhcmdldCApIHtcblxuXHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZ2V0V29ybGRRdWF0ZXJuaW9uKCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcblx0XHRcdHRhcmdldCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggX3Bvc2l0aW9uLCB0YXJnZXQsIF9zY2FsZSApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9LFxuXG5cdGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRXb3JsZFNjYWxlKCkgdGFyZ2V0IGlzIG5vdyByZXF1aXJlZCcgKTtcblx0XHRcdHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggX3Bvc2l0aW9uLCBfcXVhdGVybmlvbiwgdGFyZ2V0ICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH0sXG5cblx0Z2V0V29ybGREaXJlY3Rpb246IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRXb3JsZERpcmVjdGlvbigpIHRhcmdldCBpcyBub3cgcmVxdWlyZWQnICk7XG5cdFx0XHR0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0dmFyIGUgPSB0aGlzLm1hdHJpeFdvcmxkLmVsZW1lbnRzO1xuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoIGVbIDggXSwgZVsgOSBdLCBlWyAxMCBdICkubm9ybWFsaXplKCk7XG5cblx0fSxcblxuXHRyYXljYXN0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHR0cmF2ZXJzZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZSggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHRyYXZlcnNlVmlzaWJsZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHR0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRjYWxsYmFjayggcGFyZW50ICk7XG5cblx0XHRcdHBhcmVudC50cmF2ZXJzZUFuY2VzdG9ycyggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHVwZGF0ZU1hdHJpeDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH0sXG5cblx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSB8fCBmb3JjZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0Zm9yY2UgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIGNoaWxkcmVuXG5cblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHVwZGF0ZVdvcmxkTWF0cml4OiBmdW5jdGlvbiAoIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuICkge1xuXG5cdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0aWYgKCB1cGRhdGVQYXJlbnRzID09PSB0cnVlICYmIHBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0cGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxuXG5cdFx0aWYgKCB1cGRhdGVDaGlsZHJlbiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjaGlsZHJlblsgaSBdLnVwZGF0ZVdvcmxkTWF0cml4KCBmYWxzZSwgdHJ1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdC8vIG1ldGEgaXMgYSBzdHJpbmcgd2hlbiBjYWxsZWQgZnJvbSBKU09OLnN0cmluZ2lmeVxuXHRcdHZhciBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcblxuXHRcdHZhciBvdXRwdXQgPSB7fTtcblxuXHRcdC8vIG1ldGEgaXMgYSBoYXNoIHVzZWQgdG8gY29sbGVjdCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMuXG5cdFx0Ly8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3Rcblx0XHQvLyBiZWluZyBzZXJpYWxpemVkLlxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHQvLyBpbml0aWFsaXplIG1ldGEgb2JqXG5cdFx0XHRtZXRhID0ge1xuXHRcdFx0XHRnZW9tZXRyaWVzOiB7fSxcblx0XHRcdFx0bWF0ZXJpYWxzOiB7fSxcblx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRpbWFnZXM6IHt9LFxuXHRcdFx0XHRzaGFwZXM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRvdXRwdXQubWV0YWRhdGEgPSB7XG5cdFx0XHRcdHZlcnNpb246IDQuNSxcblx0XHRcdFx0dHlwZTogJ09iamVjdCcsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHQvLyBzdGFuZGFyZCBPYmplY3QzRCBzZXJpYWxpemF0aW9uXG5cblx0XHR2YXIgb2JqZWN0ID0ge307XG5cblx0XHRvYmplY3QudXVpZCA9IHRoaXMudXVpZDtcblx0XHRvYmplY3QudHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIG9iamVjdC5uYW1lID0gdGhpcy5uYW1lO1xuXHRcdGlmICggdGhpcy5jYXN0U2hhZG93ID09PSB0cnVlICkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5yZWNlaXZlU2hhZG93ID09PSB0cnVlICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIG9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cdFx0aWYgKCB0aGlzLmZydXN0dW1DdWxsZWQgPT09IGZhbHNlICkgb2JqZWN0LmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcblx0XHRpZiAoIHRoaXMucmVuZGVyT3JkZXIgIT09IDAgKSBvYmplY3QucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXHRcdGlmICggSlNPTi5zdHJpbmdpZnkoIHRoaXMudXNlckRhdGEgKSAhPT0gJ3t9JyApIG9iamVjdC51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG5cblx0XHRvYmplY3QubGF5ZXJzID0gdGhpcy5sYXllcnMubWFzaztcblx0XHRvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IGZhbHNlICkgb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdC8vIG9iamVjdCBzcGVjaWZpYyBwcm9wZXJ0aWVzXG5cblx0XHRpZiAoIHRoaXMuaXNNZXNoICYmIHRoaXMuZHJhd01vZGUgIT09IFRyaWFuZ2xlc0RyYXdNb2RlICkgb2JqZWN0LmRyYXdNb2RlID0gdGhpcy5kcmF3TW9kZTtcblxuXHRcdGlmICggdGhpcy5pc0luc3RhbmNlZE1lc2ggKSB7XG5cblx0XHRcdG9iamVjdC50eXBlID0gJ0luc3RhbmNlZE1lc2gnO1xuXHRcdFx0b2JqZWN0LmNvdW50ID0gdGhpcy5jb3VudDtcblx0XHRcdG9iamVjdC5pbnN0YW5jZU1hdHJpeCA9IHRoaXMuaW5zdGFuY2VNYXRyaXgudG9KU09OKCk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplKCBsaWJyYXJ5LCBlbGVtZW50ICkge1xuXG5cdFx0XHRpZiAoIGxpYnJhcnlbIGVsZW1lbnQudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bGlicmFyeVsgZWxlbWVudC51dWlkIF0gPSBlbGVtZW50LnRvSlNPTiggbWV0YSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtZW50LnV1aWQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuaXNNZXNoIHx8IHRoaXMuaXNMaW5lIHx8IHRoaXMuaXNQb2ludHMgKSB7XG5cblx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHNlcmlhbGl6ZSggbWV0YS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5ICk7XG5cblx0XHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5nZW9tZXRyeS5wYXJhbWV0ZXJzO1xuXG5cdFx0XHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCAmJiBwYXJhbWV0ZXJzLnNoYXBlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBzaGFwZXMgPSBwYXJhbWV0ZXJzLnNoYXBlcztcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBzaGFwZSA9IHNoYXBlc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHRoaXMubWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHR2YXIgdXVpZHMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLm1hdGVyaWFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR1dWlkcy5wdXNoKCBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsWyBpIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSB1dWlkcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdC5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xuXHRcdFx0dmFyIG1hdGVyaWFscyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubWF0ZXJpYWxzICk7XG5cdFx0XHR2YXIgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XG5cdFx0XHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblx0XHRcdHZhciBzaGFwZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnNoYXBlcyApO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJpZXMubGVuZ3RoID4gMCApIG91dHB1dC5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcblx0XHRcdGlmICggbWF0ZXJpYWxzLmxlbmd0aCA+IDAgKSBvdXRwdXQubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xuXHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgb3V0cHV0LnRleHR1cmVzID0gdGV4dHVyZXM7XG5cdFx0XHRpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgb3V0cHV0LmltYWdlcyA9IGltYWdlcztcblx0XHRcdGlmICggc2hhcGVzLmxlbmd0aCA+IDAgKSBvdXRwdXQuc2hhcGVzID0gc2hhcGVzO1xuXG5cdFx0fVxuXG5cdFx0b3V0cHV0Lm9iamVjdCA9IG9iamVjdDtcblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0XHQvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxuXHRcdC8vIHJlbW92ZSBtZXRhZGF0YSBvbiBlYWNoIGl0ZW1cblx0XHQvLyBhbmQgcmV0dXJuIGFzIGFycmF5XG5cdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XG5cblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gY2FjaGUgKSB7XG5cblx0XHRcdFx0dmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XG5cdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuXHRcdFx0XHR2YWx1ZXMucHVzaCggZGF0YSApO1xuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICggcmVjdXJzaXZlICkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHVuZGVmaW5lZCApIHJlY3Vyc2l2ZSA9IHRydWU7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdHRoaXMudXAuY29weSggc291cmNlLnVwICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBzb3VyY2UucXVhdGVybmlvbiApO1xuXHRcdHRoaXMuc2NhbGUuY29weSggc291cmNlLnNjYWxlICk7XG5cblx0XHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBzb3VyY2UubWF0cml4V29ybGQgKTtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xuXG5cdFx0dGhpcy5sYXllcnMubWFzayA9IHNvdXJjZS5sYXllcnMubWFzaztcblx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcblxuXHRcdHRoaXMuY2FzdFNoYWRvdyA9IHNvdXJjZS5jYXN0U2hhZG93O1xuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xuXG5cdFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gc291cmNlLmZydXN0dW1DdWxsZWQ7XG5cdFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcblxuXHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcblxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlblsgaSBdO1xuXHRcdFx0XHR0aGlzLmFkZCggY2hpbGQuY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn0gKTtcblxuXG5leHBvcnQgeyBPYmplY3QzRCB9O1xuIiwiaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vUXVhdGVybmlvbi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuL01hdHJpeDQuanMnO1xuaW1wb3J0IHsgX01hdGggfSBmcm9tICcuL01hdGguanMnO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG52YXIgX21hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG52YXIgX3F1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG5mdW5jdGlvbiBFdWxlciggeCwgeSwgeiwgb3JkZXIgKSB7XG5cblx0dGhpcy5feCA9IHggfHwgMDtcblx0dGhpcy5feSA9IHkgfHwgMDtcblx0dGhpcy5feiA9IHogfHwgMDtcblx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCBFdWxlci5EZWZhdWx0T3JkZXI7XG5cbn1cblxuRXVsZXIuUm90YXRpb25PcmRlcnMgPSBbICdYWVonLCAnWVpYJywgJ1pYWScsICdYWlknLCAnWVhaJywgJ1pZWCcgXTtcblxuRXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBFdWxlci5wcm90b3R5cGUsIHtcblxuXHR4OiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX3g7XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHR9XG5cblx0fSxcblxuXHR5OiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX3k7XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHR9XG5cblx0fSxcblxuXHR6OiB7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX3o7XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRvcmRlcjoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl9vcmRlcjtcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuX29yZGVyID0gdmFsdWU7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHR9XG5cblx0fVxuXG59ICk7XG5cbk9iamVjdC5hc3NpZ24oIEV1bGVyLnByb3RvdHlwZSwge1xuXG5cdGlzRXVsZXI6IHRydWUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cblx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XG5cdFx0dGhpcy5feSA9IGV1bGVyLl95O1xuXHRcdHRoaXMuX3ogPSBldWxlci5fejtcblx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgY2xhbXAgPSBfTWF0aC5jbGFtcDtcblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdHZhciBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xuXHRcdHZhciBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xuXHRcdHZhciBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cblx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMTEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0dGhpcy5feiA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggLSBjbGFtcCggbTIzLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMjMgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTIyICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblx0XHRcdFx0dGhpcy5feiA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTMyICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIxICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMTIgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feSA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6ICcgKyBvcmRlciApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuXHRcdF9tYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX21hdHJpeCwgb3JkZXIsIHVwZGF0ZSApO1xuXG5cdH0sXG5cblx0c2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uICggdiwgb3JkZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyIHx8IHRoaXMuX29yZGVyICk7XG5cblx0fSxcblxuXHRyZW9yZGVyOiBmdW5jdGlvbiAoIG5ld09yZGVyICkge1xuXG5cdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuXG5cdFx0X3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggX3F1YXRlcm5pb24sIG5ld09yZGVyICk7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cblx0XHRyZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cblx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIDIgXTtcblx0XHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX29yZGVyO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0dG9WZWN0b3IzOiBmdW5jdGlvbiAoIG9wdGlvbmFsUmVzdWx0ICkge1xuXG5cdFx0aWYgKCBvcHRpb25hbFJlc3VsdCApIHtcblxuXHRcdFx0cmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IzKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRfb25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdF9vbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxuXG59ICk7XG5cblxuZXhwb3J0IHsgRXVsZXIgfTtcbiIsIi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxudmFyIF9sdXQgPSBbXTtcblxuZm9yICggdmFyIGkgPSAwOyBpIDwgMjU2OyBpICsrICkge1xuXG5cdF9sdXRbIGkgXSA9ICggaSA8IDE2ID8gJzAnIDogJycgKSArICggaSApLnRvU3RyaW5nKCAxNiApO1xuXG59XG5cbnZhciBfTWF0aCA9IHtcblxuXHRERUcyUkFEOiBNYXRoLlBJIC8gMTgwLFxuXHRSQUQyREVHOiAxODAgLyBNYXRoLlBJLFxuXG5cdGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XG5cblx0XHR2YXIgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdFx0dmFyIGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRcdHZhciBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0XHR2YXIgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdFx0dmFyIHV1aWQgPSBfbHV0WyBkMCAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDggJiAweGZmIF0gKyBfbHV0WyBkMCA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDI0ICYgMHhmZiBdICsgJy0nICtcblx0XHRcdF9sdXRbIGQxICYgMHhmZiBdICsgX2x1dFsgZDEgPj4gOCAmIDB4ZmYgXSArICctJyArIF9sdXRbIGQxID4+IDE2ICYgMHgwZiB8IDB4NDAgXSArIF9sdXRbIGQxID4+IDI0ICYgMHhmZiBdICsgJy0nICtcblx0XHRcdF9sdXRbIGQyICYgMHgzZiB8IDB4ODAgXSArIF9sdXRbIGQyID4+IDggJiAweGZmIF0gKyAnLScgKyBfbHV0WyBkMiA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQyID4+IDI0ICYgMHhmZiBdICtcblx0XHRcdF9sdXRbIGQzICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gOCAmIDB4ZmYgXSArIF9sdXRbIGQzID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gMjQgJiAweGZmIF07XG5cblx0XHQvLyAudG9VcHBlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG5cdFx0cmV0dXJuIHV1aWQudG9VcHBlckNhc2UoKTtcblxuXHR9LFxuXG5cdGNsYW1wOiBmdW5jdGlvbiAoIHZhbHVlLCBtaW4sIG1heCApIHtcblxuXHRcdHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCB2YWx1ZSApICk7XG5cblx0fSxcblxuXHQvLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cblx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuXG5cdGV1Y2xpZGVhbk1vZHVsbzogZnVuY3Rpb24gKCBuLCBtICkge1xuXG5cdFx0cmV0dXJuICggKCBuICUgbSApICsgbSApICUgbTtcblxuXHR9LFxuXG5cdC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cblxuXHRtYXBMaW5lYXI6IGZ1bmN0aW9uICggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XG5cblx0XHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxuXHR9LFxuXG5cdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9pbnRlcnBvbGF0aW9uXG5cblx0bGVycDogZnVuY3Rpb24gKCB4LCB5LCB0ICkge1xuXG5cdFx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcblxuXHR9LFxuXG5cdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxuXG5cdHNtb290aHN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRcdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XG5cblx0fSxcblxuXHRzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRcdHJldHVybiB4ICogeCAqIHggKiAoIHggKiAoIHggKiA2IC0gMTUgKSArIDEwICk7XG5cblx0fSxcblxuXHQvLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cblx0cmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cblx0XHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xuXG5cdH0sXG5cblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuXHRyYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG5cdFx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxuXHR9LFxuXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcblxuXHRyYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uICggcmFuZ2UgKSB7XG5cblx0XHRyZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcblxuXHR9LFxuXG5cdGRlZ1RvUmFkOiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XG5cblx0XHRyZXR1cm4gZGVncmVlcyAqIF9NYXRoLkRFRzJSQUQ7XG5cblx0fSxcblxuXHRyYWRUb0RlZzogZnVuY3Rpb24gKCByYWRpYW5zICkge1xuXG5cdFx0cmV0dXJuIHJhZGlhbnMgKiBfTWF0aC5SQUQyREVHO1xuXG5cdH0sXG5cblx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cblx0fSxcblxuXHRjZWlsUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5jZWlsKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcblxuXHR9LFxuXG5cdGZsb29yUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5mbG9vciggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cblx0fVxuXG59O1xuXG5cbmV4cG9ydCB7IF9NYXRoIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxudmFyIF92ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG5mdW5jdGlvbiBNYXRyaXgzKCkge1xuXG5cdHRoaXMuZWxlbWVudHMgPSBbXG5cblx0XHQxLCAwLCAwLFxuXHRcdDAsIDEsIDAsXG5cdFx0MCwgMCwgMVxuXG5cdF07XG5cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcblxuXHR9XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggTWF0cml4My5wcm90b3R5cGUsIHtcblxuXHRpc01hdHJpeDM6IHRydWUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDEgXSA9IG4yMTsgdGVbIDIgXSA9IG4zMTtcblx0XHR0ZVsgMyBdID0gbjEyOyB0ZVsgNCBdID0gbjIyOyB0ZVsgNSBdID0gbjMyO1xuXHRcdHRlWyA2IF0gPSBuMTM7IHRlWyA3IF0gPSBuMjM7IHRlWyA4IF0gPSBuMzM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCxcblx0XHRcdDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdO1xuXHRcdHRlWyAzIF0gPSBtZVsgMyBdOyB0ZVsgNCBdID0gbWVbIDQgXTsgdGVbIDUgXSA9IG1lWyA1IF07XG5cdFx0dGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdOyB0ZVsgOCBdID0gbWVbIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0bWVbIDAgXSwgbWVbIDQgXSwgbWVbIDggXSxcblx0XHRcdG1lWyAxIF0sIG1lWyA1IF0sIG1lWyA5IF0sXG5cdFx0XHRtZVsgMiBdLCBtZVsgNiBdLCBtZVsgMTAgXVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXBwbHlUb0J1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRfdmVjdG9yLnggPSBhdHRyaWJ1dGUuZ2V0WCggaSApO1xuXHRcdFx0X3ZlY3Rvci55ID0gYXR0cmlidXRlLmdldFkoIGkgKTtcblx0XHRcdF92ZWN0b3IueiA9IGF0dHJpYnV0ZS5nZXRaKCBpICk7XG5cblx0XHRcdF92ZWN0b3IuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cblx0XHRcdGF0dHJpYnV0ZS5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJ1dGU7XG5cblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH0sXG5cblx0cHJlbXVsdGlwbHk6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuXHR9LFxuXG5cdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHZhciBhZSA9IGEuZWxlbWVudHM7XG5cdFx0dmFyIGJlID0gYi5lbGVtZW50cztcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyAzIF0sIGExMyA9IGFlWyA2IF07XG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA0IF0sIGEyMyA9IGFlWyA3IF07XG5cdFx0dmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA1IF0sIGEzMyA9IGFlWyA4IF07XG5cblx0XHR2YXIgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDMgXSwgYjEzID0gYmVbIDYgXTtcblx0XHR2YXIgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDQgXSwgYjIzID0gYmVbIDcgXTtcblx0XHR2YXIgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDUgXSwgYjMzID0gYmVbIDggXTtcblxuXHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzE7XG5cdFx0dGVbIDMgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcblx0XHR0ZVsgNiBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzO1xuXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTtcblx0XHR0ZVsgNCBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xuXHRcdHRlWyA3IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzM7XG5cblx0XHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxO1xuXHRcdHRlWyA1IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XG5cdFx0dGVbIDggXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdICo9IHM7IHRlWyAzIF0gKj0gczsgdGVbIDYgXSAqPSBzO1xuXHRcdHRlWyAxIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgNyBdICo9IHM7XG5cdFx0dGVbIDIgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA4IF0gKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgYSA9IHRlWyAwIF0sIGIgPSB0ZVsgMSBdLCBjID0gdGVbIDIgXSxcblx0XHRcdGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXG5cdFx0XHRnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xuXG5cdFx0cmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcblxuXHR9LFxuXG5cdGdldEludmVyc2U6IGZ1bmN0aW9uICggbWF0cml4LCB0aHJvd09uRGVnZW5lcmF0ZSApIHtcblxuXHRcdGlmICggbWF0cml4ICYmIG1hdHJpeC5pc01hdHJpeDQgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuTWF0cml4MzogLmdldEludmVyc2UoKSBubyBsb25nZXIgdGFrZXMgYSBNYXRyaXg0IGFyZ3VtZW50LlwiICk7XG5cblx0XHR9XG5cblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHMsXG5cdFx0XHR0ZSA9IHRoaXMuZWxlbWVudHMsXG5cblx0XHRcdG4xMSA9IG1lWyAwIF0sIG4yMSA9IG1lWyAxIF0sIG4zMSA9IG1lWyAyIF0sXG5cdFx0XHRuMTIgPSBtZVsgMyBdLCBuMjIgPSBtZVsgNCBdLCBuMzIgPSBtZVsgNSBdLFxuXHRcdFx0bjEzID0gbWVbIDYgXSwgbjIzID0gbWVbIDcgXSwgbjMzID0gbWVbIDggXSxcblxuXHRcdFx0dDExID0gbjMzICogbjIyIC0gbjMyICogbjIzLFxuXHRcdFx0dDEyID0gbjMyICogbjEzIC0gbjMzICogbjEyLFxuXHRcdFx0dDEzID0gbjIzICogbjEyIC0gbjIyICogbjEzLFxuXG5cdFx0XHRkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTM7XG5cblx0XHRpZiAoIGRldCA9PT0gMCApIHtcblxuXHRcdFx0dmFyIG1zZyA9IFwiVEhSRUUuTWF0cml4MzogLmdldEludmVyc2UoKSBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cblx0XHRcdGlmICggdGhyb3dPbkRlZ2VuZXJhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIG1zZyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmlkZW50aXR5KCk7XG5cblx0XHR9XG5cblx0XHR2YXIgZGV0SW52ID0gMSAvIGRldDtcblxuXHRcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XG5cdFx0dGVbIDEgXSA9ICggbjMxICogbjIzIC0gbjMzICogbjIxICkgKiBkZXRJbnY7XG5cdFx0dGVbIDIgXSA9ICggbjMyICogbjIxIC0gbjMxICogbjIyICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgMyBdID0gdDEyICogZGV0SW52O1xuXHRcdHRlWyA0IF0gPSAoIG4zMyAqIG4xMSAtIG4zMSAqIG4xMyApICogZGV0SW52O1xuXHRcdHRlWyA1IF0gPSAoIG4zMSAqIG4xMiAtIG4zMiAqIG4xMSApICogZGV0SW52O1xuXG5cdFx0dGVbIDYgXSA9IHQxMyAqIGRldEludjtcblx0XHR0ZVsgNyBdID0gKCBuMjEgKiBuMTMgLSBuMjMgKiBuMTEgKSAqIGRldEludjtcblx0XHR0ZVsgOCBdID0gKCBuMjIgKiBuMTEgLSBuMjEgKiBuMTIgKSAqIGRldEludjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdG1wLCBtID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG5cdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcblx0XHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4NCApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuZ2V0SW52ZXJzZSggdGhpcyApLnRyYW5zcG9zZSgpO1xuXG5cdH0sXG5cblx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XG5cblx0XHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRyWyAwIF0gPSBtWyAwIF07XG5cdFx0clsgMSBdID0gbVsgMyBdO1xuXHRcdHJbIDIgXSA9IG1bIDYgXTtcblx0XHRyWyAzIF0gPSBtWyAxIF07XG5cdFx0clsgNCBdID0gbVsgNCBdO1xuXHRcdHJbIDUgXSA9IG1bIDcgXTtcblx0XHRyWyA2IF0gPSBtWyAyIF07XG5cdFx0clsgNyBdID0gbVsgNSBdO1xuXHRcdHJbIDggXSA9IG1bIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0VXZUcmFuc2Zvcm06IGZ1bmN0aW9uICggdHgsIHR5LCBzeCwgc3ksIHJvdGF0aW9uLCBjeCwgY3kgKSB7XG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCByb3RhdGlvbiApO1xuXHRcdHZhciBzID0gTWF0aC5zaW4oIHJvdGF0aW9uICk7XG5cblx0XHR0aGlzLnNldChcblx0XHRcdHN4ICogYywgc3ggKiBzLCAtIHN4ICogKCBjICogY3ggKyBzICogY3kgKSArIGN4ICsgdHgsXG5cdFx0XHQtIHN5ICogcywgc3kgKiBjLCAtIHN5ICogKCAtIHMgKiBjeCArIGMgKiBjeSApICsgY3kgKyB0eSxcblx0XHRcdDAsIDAsIDFcblx0XHQpO1xuXG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uICggc3gsIHN5ICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gc3g7IHRlWyAzIF0gKj0gc3g7IHRlWyA2IF0gKj0gc3g7XG5cdFx0dGVbIDEgXSAqPSBzeTsgdGVbIDQgXSAqPSBzeTsgdGVbIDcgXSAqPSBzeTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKTtcblx0XHR2YXIgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciBhMTEgPSB0ZVsgMCBdLCBhMTIgPSB0ZVsgMyBdLCBhMTMgPSB0ZVsgNiBdO1xuXHRcdHZhciBhMjEgPSB0ZVsgMSBdLCBhMjIgPSB0ZVsgNCBdLCBhMjMgPSB0ZVsgNyBdO1xuXG5cdFx0dGVbIDAgXSA9IGMgKiBhMTEgKyBzICogYTIxO1xuXHRcdHRlWyAzIF0gPSBjICogYTEyICsgcyAqIGEyMjtcblx0XHR0ZVsgNiBdID0gYyAqIGExMyArIHMgKiBhMjM7XG5cblx0XHR0ZVsgMSBdID0gLSBzICogYTExICsgYyAqIGEyMTtcblx0XHR0ZVsgNCBdID0gLSBzICogYTEyICsgYyAqIGEyMjtcblx0XHR0ZVsgNyBdID0gLSBzICogYTEzICsgYyAqIGEyMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIHR4LCB0eSApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdICs9IHR4ICogdGVbIDIgXTsgdGVbIDMgXSArPSB0eCAqIHRlWyA1IF07IHRlWyA2IF0gKz0gdHggKiB0ZVsgOCBdO1xuXHRcdHRlWyAxIF0gKz0gdHkgKiB0ZVsgMiBdOyB0ZVsgNCBdICs9IHR5ICogdGVbIDUgXTsgdGVbIDcgXSArPSB0eSAqIHRlWyA4IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSA9IHRlWyA4IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG59ICk7XG5cblxuZXhwb3J0IHsgTWF0cml4MyB9O1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XG5cbnZhciBfdjEgPSBuZXcgVmVjdG9yMygpO1xudmFyIF9tMSA9IG5ldyBNYXRyaXg0KCk7XG52YXIgX3plcm8gPSBuZXcgVmVjdG9yMyggMCwgMCwgMCApO1xudmFyIF9vbmUgPSBuZXcgVmVjdG9yMyggMSwgMSwgMSApO1xudmFyIF94ID0gbmV3IFZlY3RvcjMoKTtcbnZhciBfeSA9IG5ldyBWZWN0b3IzKCk7XG52YXIgX3ogPSBuZXcgVmVjdG9yMygpO1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cbiAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuZnVuY3Rpb24gTWF0cml4NCgpIHtcblxuXHR0aGlzLmVsZW1lbnRzID0gW1xuXG5cdFx0MSwgMCwgMCwgMCxcblx0XHQwLCAxLCAwLCAwLFxuXHRcdDAsIDAsIDEsIDAsXG5cdFx0MCwgMCwgMCwgMVxuXG5cdF07XG5cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcblxuXHR9XG5cbn1cblxuT2JqZWN0LmFzc2lnbiggTWF0cml4NC5wcm90b3R5cGUsIHtcblxuXHRpc01hdHJpeDQ6IHRydWUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgNCBdID0gbjEyOyB0ZVsgOCBdID0gbjEzOyB0ZVsgMTIgXSA9IG4xNDtcblx0XHR0ZVsgMSBdID0gbjIxOyB0ZVsgNSBdID0gbjIyOyB0ZVsgOSBdID0gbjIzOyB0ZVsgMTMgXSA9IG4yNDtcblx0XHR0ZVsgMiBdID0gbjMxOyB0ZVsgNiBdID0gbjMyOyB0ZVsgMTAgXSA9IG4zMzsgdGVbIDE0IF0gPSBuMzQ7XG5cdFx0dGVbIDMgXSA9IG40MTsgdGVbIDcgXSA9IG40MjsgdGVbIDExIF0gPSBuNDM7IHRlWyAxNSBdID0gbjQ0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07IHRlWyAzIF0gPSBtZVsgMyBdO1xuXHRcdHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTsgdGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdO1xuXHRcdHRlWyA4IF0gPSBtZVsgOCBdOyB0ZVsgOSBdID0gbWVbIDkgXTsgdGVbIDEwIF0gPSBtZVsgMTAgXTsgdGVbIDExIF0gPSBtZVsgMTEgXTtcblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdOyB0ZVsgMTMgXSA9IG1lWyAxMyBdOyB0ZVsgMTQgXSA9IG1lWyAxNCBdOyB0ZVsgMTUgXSA9IG1lWyAxNSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHMsIG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07XG5cdFx0dGVbIDEzIF0gPSBtZVsgMTMgXTtcblx0XHR0ZVsgMTQgXSA9IG1lWyAxNCBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRleHRyYWN0QmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHhBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDAgKTtcblx0XHR5QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAxICk7XG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlQmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcblx0XHRcdHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXG5cdFx0XHR4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGV4dHJhY3RSb3RhdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gdGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCByZWZsZWN0aW9uIG1hdHJpY2VzXG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR2YXIgc2NhbGVYID0gMSAvIF92MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XG5cdFx0dmFyIHNjYWxlWSA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdHZhciBzY2FsZVogPSAxIC8gX3YxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcblxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xuXHRcdHRlWyAxIF0gPSBtZVsgMSBdICogc2NhbGVYO1xuXHRcdHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xuXHRcdHRlWyAzIF0gPSAwO1xuXG5cdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XG5cdFx0dGVbIDUgXSA9IG1lWyA1IF0gKiBzY2FsZVk7XG5cdFx0dGVbIDYgXSA9IG1lWyA2IF0gKiBzY2FsZVk7XG5cdFx0dGVbIDcgXSA9IDA7XG5cblx0XHR0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcblx0XHR0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcblx0XHR0ZVsgMTAgXSA9IG1lWyAxMCBdICogc2NhbGVaO1xuXHRcdHRlWyAxMSBdID0gMDtcblxuXHRcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDE0IF0gPSAwO1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0aWYgKCAhICggZXVsZXIgJiYgZXVsZXIuaXNFdWxlciApICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLm1ha2VSb3RhdGlvbkZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cblx0XHR9XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XG5cdFx0dmFyIGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKTtcblx0XHR2YXIgYyA9IE1hdGguY29zKCB5ICksIGQgPSBNYXRoLnNpbiggeSApO1xuXHRcdHZhciBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XG5cblx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGMgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcblx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBjO1xuXG5cdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYmUgKyBhZiAqIGQ7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGNlICsgZGYgKiBiO1xuXHRcdFx0dGVbIDQgXSA9IGRlICogYiAtIGNmO1xuXHRcdFx0dGVbIDggXSA9IGEgKiBkO1xuXG5cdFx0XHR0ZVsgMSBdID0gYSAqIGY7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gLSBiO1xuXG5cdFx0XHR0ZVsgMiBdID0gY2YgKiBiIC0gZGU7XG5cdFx0XHR0ZVsgNiBdID0gZGYgKyBjZSAqIGI7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xuXHRcdFx0dGVbIDQgXSA9IC0gYSAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XG5cblx0XHRcdHRlWyAxIF0gPSBjZiArIGRlICogYjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcblxuXHRcdFx0dGVbIDIgXSA9IC0gYSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XG5cblx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XG5cdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XG5cblx0XHRcdHRlWyAxIF0gPSBjICogZjtcblx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcblx0XHRcdHRlWyA5IF0gPSBhZiAqIGQgLSBiZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZDtcblx0XHRcdHRlWyA2IF0gPSBiICogYztcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gYmQgLSBhYyAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gYmMgKiBmICsgYWQ7XG5cblx0XHRcdHRlWyAxIF0gPSBmO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGU7XG5cblx0XHRcdHRlWyAyIF0gPSAtIGQgKiBlO1xuXHRcdFx0dGVbIDYgXSA9IGFkICogZiArIGJjO1xuXHRcdFx0dGVbIDEwIF0gPSBhYyAtIGJkICogZjtcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcblxuXHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGY7XG5cdFx0XHR0ZVsgOCBdID0gZCAqIGU7XG5cblx0XHRcdHRlWyAxIF0gPSBhYyAqIGYgKyBiZDtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcblxuXHRcdFx0dGVbIDIgXSA9IGJjICogZiAtIGFkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBlO1xuXHRcdFx0dGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcblxuXHRcdH1cblxuXHRcdC8vIGJvdHRvbSByb3dcblx0XHR0ZVsgMyBdID0gMDtcblx0XHR0ZVsgNyBdID0gMDtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHQvLyBsYXN0IGNvbHVtblxuXHRcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDE0IF0gPSAwO1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbXBvc2UoIF96ZXJvLCBxLCBfb25lICk7XG5cblx0fSxcblxuXHRsb29rQXQ6IGZ1bmN0aW9uICggZXllLCB0YXJnZXQsIHVwICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdF96LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICk7XG5cblx0XHRpZiAoIF96Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxuXG5cdFx0XHRfei56ID0gMTtcblxuXHRcdH1cblxuXHRcdF96Lm5vcm1hbGl6ZSgpO1xuXHRcdF94LmNyb3NzVmVjdG9ycyggdXAsIF96ICk7XG5cblx0XHRpZiAoIF94Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIHVwIGFuZCB6IGFyZSBwYXJhbGxlbFxuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB1cC56ICkgPT09IDEgKSB7XG5cblx0XHRcdFx0X3oueCArPSAwLjAwMDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3oueiArPSAwLjAwMDE7XG5cblx0XHRcdH1cblxuXHRcdFx0X3oubm9ybWFsaXplKCk7XG5cdFx0XHRfeC5jcm9zc1ZlY3RvcnMoIHVwLCBfeiApO1xuXG5cdFx0fVxuXG5cdFx0X3gubm9ybWFsaXplKCk7XG5cdFx0X3kuY3Jvc3NWZWN0b3JzKCBfeiwgX3ggKTtcblxuXHRcdHRlWyAwIF0gPSBfeC54OyB0ZVsgNCBdID0gX3kueDsgdGVbIDggXSA9IF96Lng7XG5cdFx0dGVbIDEgXSA9IF94Lnk7IHRlWyA1IF0gPSBfeS55OyB0ZVsgOSBdID0gX3oueTtcblx0XHR0ZVsgMiBdID0gX3guejsgdGVbIDYgXSA9IF95Lno7IHRlWyAxMCBdID0gX3ouejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcblxuXHRcdGlmICggbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCBuICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XG5cblx0fSxcblxuXHRwcmVtdWx0aXBseTogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgdGhpcyApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlNYXRyaWNlczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dmFyIGFlID0gYS5lbGVtZW50cztcblx0XHR2YXIgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xuXHRcdHZhciBhMzEgPSBhZVsgMiBdLCBhMzIgPSBhZVsgNiBdLCBhMzMgPSBhZVsgMTAgXSwgYTM0ID0gYWVbIDE0IF07XG5cdFx0dmFyIGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcblxuXHRcdHZhciBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcblx0XHR2YXIgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDUgXSwgYjIzID0gYmVbIDkgXSwgYjI0ID0gYmVbIDEzIF07XG5cdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcblx0XHR2YXIgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xuXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcblx0XHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuXHRcdHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XG5cblx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG5cdFx0dGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0Mztcblx0XHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XG5cdFx0dGVbIDYgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0Mjtcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0Mztcblx0XHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XG5cdFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0Mjtcblx0XHR0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0Mztcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xuXHRcdHRlWyAxIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOSBdICo9IHM7IHRlWyAxMyBdICo9IHM7XG5cdFx0dGVbIDIgXSAqPSBzOyB0ZVsgNiBdICo9IHM7IHRlWyAxMCBdICo9IHM7IHRlWyAxNCBdICo9IHM7XG5cdFx0dGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3YxLnggPSBhdHRyaWJ1dGUuZ2V0WCggaSApO1xuXHRcdFx0X3YxLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaSApO1xuXHRcdFx0X3YxLnogPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xuXG5cdFx0XHRfdjEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cblx0XHRcdGF0dHJpYnV0ZS5zZXRYWVooIGksIF92MS54LCBfdjEueSwgX3YxLnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJ1dGU7XG5cblx0fSxcblxuXHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciBuMTEgPSB0ZVsgMCBdLCBuMTIgPSB0ZVsgNCBdLCBuMTMgPSB0ZVsgOCBdLCBuMTQgPSB0ZVsgMTIgXTtcblx0XHR2YXIgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XG5cdFx0dmFyIG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcblx0XHR2YXIgbjQxID0gdGVbIDMgXSwgbjQyID0gdGVbIDcgXSwgbjQzID0gdGVbIDExIF0sIG40NCA9IHRlWyAxNSBdO1xuXG5cdFx0Ly9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcblx0XHQvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcblxuXHRcdHJldHVybiAoXG5cdFx0XHRuNDEgKiAoXG5cdFx0XHRcdCsgbjE0ICogbjIzICogbjMyXG5cdFx0XHRcdCAtIG4xMyAqIG4yNCAqIG4zMlxuXHRcdFx0XHQgLSBuMTQgKiBuMjIgKiBuMzNcblx0XHRcdFx0ICsgbjEyICogbjI0ICogbjMzXG5cdFx0XHRcdCArIG4xMyAqIG4yMiAqIG4zNFxuXHRcdFx0XHQgLSBuMTIgKiBuMjMgKiBuMzRcblx0XHRcdCkgK1xuXHRcdFx0bjQyICogKFxuXHRcdFx0XHQrIG4xMSAqIG4yMyAqIG4zNFxuXHRcdFx0XHQgLSBuMTEgKiBuMjQgKiBuMzNcblx0XHRcdFx0ICsgbjE0ICogbjIxICogbjMzXG5cdFx0XHRcdCAtIG4xMyAqIG4yMSAqIG4zNFxuXHRcdFx0XHQgKyBuMTMgKiBuMjQgKiBuMzFcblx0XHRcdFx0IC0gbjE0ICogbjIzICogbjMxXG5cdFx0XHQpICtcblx0XHRcdG40MyAqIChcblx0XHRcdFx0KyBuMTEgKiBuMjQgKiBuMzJcblx0XHRcdFx0IC0gbjExICogbjIyICogbjM0XG5cdFx0XHRcdCAtIG4xNCAqIG4yMSAqIG4zMlxuXHRcdFx0XHQgKyBuMTIgKiBuMjEgKiBuMzRcblx0XHRcdFx0ICsgbjE0ICogbjIyICogbjMxXG5cdFx0XHRcdCAtIG4xMiAqIG4yNCAqIG4zMVxuXHRcdFx0KSArXG5cdFx0XHRuNDQgKiAoXG5cdFx0XHRcdC0gbjEzICogbjIyICogbjMxXG5cdFx0XHRcdCAtIG4xMSAqIG4yMyAqIG4zMlxuXHRcdFx0XHQgKyBuMTEgKiBuMjIgKiBuMzNcblx0XHRcdFx0ICsgbjEzICogbjIxICogbjMyXG5cdFx0XHRcdCAtIG4xMiAqIG4yMSAqIG4zM1xuXHRcdFx0XHQgKyBuMTIgKiBuMjMgKiBuMzFcblx0XHRcdClcblxuXHRcdCk7XG5cblx0fSxcblxuXHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIHRtcDtcblxuXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xuXG5cdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHgueDtcblx0XHRcdHRlWyAxMyBdID0geC55O1xuXHRcdFx0dGVbIDE0IF0gPSB4Lno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHg7XG5cdFx0XHR0ZVsgMTMgXSA9IHk7XG5cdFx0XHR0ZVsgMTQgXSA9IHo7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkRlZ2VuZXJhdGUgKSB7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLFxuXHRcdFx0bWUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRuMTEgPSBtZVsgMCBdLCBuMjEgPSBtZVsgMSBdLCBuMzEgPSBtZVsgMiBdLCBuNDEgPSBtZVsgMyBdLFxuXHRcdFx0bjEyID0gbWVbIDQgXSwgbjIyID0gbWVbIDUgXSwgbjMyID0gbWVbIDYgXSwgbjQyID0gbWVbIDcgXSxcblx0XHRcdG4xMyA9IG1lWyA4IF0sIG4yMyA9IG1lWyA5IF0sIG4zMyA9IG1lWyAxMCBdLCBuNDMgPSBtZVsgMTEgXSxcblx0XHRcdG4xNCA9IG1lWyAxMiBdLCBuMjQgPSBtZVsgMTMgXSwgbjM0ID0gbWVbIDE0IF0sIG40NCA9IG1lWyAxNSBdLFxuXG5cdFx0XHR0MTEgPSBuMjMgKiBuMzQgKiBuNDIgLSBuMjQgKiBuMzMgKiBuNDIgKyBuMjQgKiBuMzIgKiBuNDMgLSBuMjIgKiBuMzQgKiBuNDMgLSBuMjMgKiBuMzIgKiBuNDQgKyBuMjIgKiBuMzMgKiBuNDQsXG5cdFx0XHR0MTIgPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQsXG5cdFx0XHR0MTMgPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQsXG5cdFx0XHR0MTQgPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XG5cblx0XHR2YXIgZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzICsgbjQxICogdDE0O1xuXG5cdFx0aWYgKCBkZXQgPT09IDAgKSB7XG5cblx0XHRcdHZhciBtc2cgPSBcIlRIUkVFLk1hdHJpeDQ6IC5nZXRJbnZlcnNlKCkgY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xuXG5cdFx0XHRpZiAoIHRocm93T25EZWdlbmVyYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCBtc2cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGRldEludiA9IDEgLyBkZXQ7XG5cblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuXHRcdHRlWyAxIF0gPSAoIG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAyIF0gPSAoIG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAzIF0gPSAoIG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDQgXSA9IHQxMiAqIGRldEludjtcblx0XHR0ZVsgNSBdID0gKCBuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgNiBdID0gKCBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgNyBdID0gKCBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyA4IF0gPSB0MTMgKiBkZXRJbnY7XG5cdFx0dGVbIDkgXSA9ICggbjE0ICogbjIzICogbjQxIC0gbjEzICogbjI0ICogbjQxIC0gbjE0ICogbjIxICogbjQzICsgbjExICogbjI0ICogbjQzICsgbjEzICogbjIxICogbjQ0IC0gbjExICogbjIzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDEwIF0gPSAoIG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAxMSBdID0gKCBuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyAxMiBdID0gdDE0ICogZGV0SW52O1xuXHRcdHRlWyAxMyBdID0gKCBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQgKSAqIGRldEludjtcblx0XHR0ZVsgMTQgXSA9ICggbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDE1IF0gPSAoIG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMyApICogZGV0SW52O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR2YXIgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcblxuXHRcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XG5cdFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcblx0XHR0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcblx0XHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Z2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgc2NhbGVYU3EgPSB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICsgdGVbIDIgXSAqIHRlWyAyIF07XG5cdFx0dmFyIHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xuXHRcdHZhciBzY2FsZVpTcSA9IHRlWyA4IF0gKiB0ZVsgOCBdICsgdGVbIDkgXSAqIHRlWyA5IF0gKyB0ZVsgMTAgXSAqIHRlWyAxMCBdO1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggTWF0aC5tYXgoIHNjYWxlWFNxLCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApO1xuXG5cdH0sXG5cblx0bWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgeCxcblx0XHRcdDAsIDEsIDAsIHksXG5cdFx0XHQwLCAwLCAxLCB6LFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uWDogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgYywgLSBzLCAwLFxuXHRcdFx0MCwgcywgYywgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VSb3RhdGlvblk6IGZ1bmN0aW9uICggdGhldGEgKSB7XG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0IGMsIDAsIHMsIDAsXG5cdFx0XHQgMCwgMSwgMCwgMCxcblx0XHRcdC0gcywgMCwgYywgMCxcblx0XHRcdCAwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUm90YXRpb25aOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdGMsIC0gcywgMCwgMCxcblx0XHRcdHMsIGMsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcblx0XHR2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXHRcdHZhciB0ID0gMSAtIGM7XG5cdFx0dmFyIHggPSBheGlzLngsIHkgPSBheGlzLnksIHogPSBheGlzLno7XG5cdFx0dmFyIHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxuXHRcdFx0dHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxuXHRcdFx0dHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdCByZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VTY2FsZTogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdHgsIDAsIDAsIDAsXG5cdFx0XHQwLCB5LCAwLCAwLFxuXHRcdFx0MCwgMCwgeiwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VTaGVhcjogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIHksIHosIDAsXG5cdFx0XHR4LCAxLCB6LCAwLFxuXHRcdFx0eCwgeSwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvbXBvc2U6IGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciB4ID0gcXVhdGVybmlvbi5feCwgeSA9IHF1YXRlcm5pb24uX3ksIHogPSBxdWF0ZXJuaW9uLl96LCB3ID0gcXVhdGVybmlvbi5fdztcblx0XHR2YXIgeDIgPSB4ICsgeCxcdHkyID0geSArIHksIHoyID0geiArIHo7XG5cdFx0dmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XG5cdFx0dmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XG5cdFx0dmFyIHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XG5cblx0XHR2YXIgc3ggPSBzY2FsZS54LCBzeSA9IHNjYWxlLnksIHN6ID0gc2NhbGUuejtcblxuXHRcdHRlWyAwIF0gPSAoIDEgLSAoIHl5ICsgenogKSApICogc3g7XG5cdFx0dGVbIDEgXSA9ICggeHkgKyB3eiApICogc3g7XG5cdFx0dGVbIDIgXSA9ICggeHogLSB3eSApICogc3g7XG5cdFx0dGVbIDMgXSA9IDA7XG5cblx0XHR0ZVsgNCBdID0gKCB4eSAtIHd6ICkgKiBzeTtcblx0XHR0ZVsgNSBdID0gKCAxIC0gKCB4eCArIHp6ICkgKSAqIHN5O1xuXHRcdHRlWyA2IF0gPSAoIHl6ICsgd3ggKSAqIHN5O1xuXHRcdHRlWyA3IF0gPSAwO1xuXG5cdFx0dGVbIDggXSA9ICggeHogKyB3eSApICogc3o7XG5cdFx0dGVbIDkgXSA9ICggeXogLSB3eCApICogc3o7XG5cdFx0dGVbIDEwIF0gPSAoIDEgLSAoIHh4ICsgeXkgKSApICogc3o7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0dGVbIDEyIF0gPSBwb3NpdGlvbi54O1xuXHRcdHRlWyAxMyBdID0gcG9zaXRpb24ueTtcblx0XHR0ZVsgMTQgXSA9IHBvc2l0aW9uLno7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkZWNvbXBvc2U6IGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciBzeCA9IF92MS5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKS5sZW5ndGgoKTtcblx0XHR2YXIgc3kgPSBfdjEuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0dmFyIHN6ID0gX3YxLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKS5sZW5ndGgoKTtcblxuXHRcdC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG5cdFx0dmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcblx0XHRpZiAoIGRldCA8IDAgKSBzeCA9IC0gc3g7XG5cblx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XG5cdFx0cG9zaXRpb24ueSA9IHRlWyAxMyBdO1xuXHRcdHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcblxuXHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cdFx0X20xLmNvcHkoIHRoaXMgKTtcblxuXHRcdHZhciBpbnZTWCA9IDEgLyBzeDtcblx0XHR2YXIgaW52U1kgPSAxIC8gc3k7XG5cdFx0dmFyIGludlNaID0gMSAvIHN6O1xuXG5cdFx0X20xLmVsZW1lbnRzWyAwIF0gKj0gaW52U1g7XG5cdFx0X20xLmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG5cdFx0X20xLmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XG5cblx0XHRfbTEuZWxlbWVudHNbIDQgXSAqPSBpbnZTWTtcblx0XHRfbTEuZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcblx0XHRfbTEuZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcblxuXHRcdF9tMS5lbGVtZW50c1sgOCBdICo9IGludlNaO1xuXHRcdF9tMS5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuXHRcdF9tMS5lbGVtZW50c1sgMTAgXSAqPSBpbnZTWjtcblxuXHRcdHF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcblxuXHRcdHNjYWxlLnggPSBzeDtcblx0XHRzY2FsZS55ID0gc3k7XG5cdFx0c2NhbGUueiA9IHN6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUGVyc3BlY3RpdmU6IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRpZiAoIGZhciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubWFrZVBlcnNwZWN0aXZlKCkgaGFzIGJlZW4gcmVkZWZpbmVkIGFuZCBoYXMgYSBuZXcgc2lnbmF0dXJlLiBQbGVhc2UgY2hlY2sgdGhlIGRvY3MuJyApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR2YXIgeCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHR2YXIgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcblxuXHRcdHZhciBhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0dmFyIGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcblx0XHR2YXIgYyA9IC0gKCBmYXIgKyBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcblx0XHR2YXIgZCA9IC0gMiAqIGZhciAqIG5lYXIgLyAoIGZhciAtIG5lYXIgKTtcblxuXHRcdHRlWyAwIF0gPSB4O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gYTtcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gYztcdHRlWyAxNCBdID0gZDtcblx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAtIDE7XHR0ZVsgMTUgXSA9IDA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VPcnRob2dyYXBoaWM6IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHR2YXIgaCA9IDEuMCAvICggdG9wIC0gYm90dG9tICk7XG5cdFx0dmFyIHAgPSAxLjAgLyAoIGZhciAtIG5lYXIgKTtcblxuXHRcdHZhciB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XG5cdFx0dmFyIHkgPSAoIHRvcCArIGJvdHRvbSApICogaDtcblx0XHR2YXIgeiA9ICggZmFyICsgbmVhciApICogcDtcblxuXHRcdHRlWyAwIF0gPSAyICogdztcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IDA7XHR0ZVsgMTIgXSA9IC0geDtcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSAyICogaDtcdHRlWyA5IF0gPSAwO1x0dGVbIDEzIF0gPSAtIHk7XG5cdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gLSAyICogcDtcdHRlWyAxNCBdID0gLSB6O1xuXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IDA7XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgOSBdID0gdGVbIDkgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxufSApO1xuXG5cbmV4cG9ydCB7IE1hdHJpeDQgfTtcbiIsIi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG5pbXBvcnQgeyBfTWF0aCB9IGZyb20gJy4vTWF0aC5qcyc7XG5cbmZ1bmN0aW9uIFF1YXRlcm5pb24oIHgsIHksIHosIHcgKSB7XG5cblx0dGhpcy5feCA9IHggfHwgMDtcblx0dGhpcy5feSA9IHkgfHwgMDtcblx0dGhpcy5feiA9IHogfHwgMDtcblx0dGhpcy5fdyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcblxufVxuXG5PYmplY3QuYXNzaWduKCBRdWF0ZXJuaW9uLCB7XG5cblx0c2xlcnA6IGZ1bmN0aW9uICggcWEsIHFiLCBxbSwgdCApIHtcblxuXHRcdHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xuXG5cdH0sXG5cblx0c2xlcnBGbGF0OiBmdW5jdGlvbiAoIGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxLCB0ICkge1xuXG5cdFx0Ly8gZnV6ei1mcmVlLCBhcnJheS1iYXNlZCBRdWF0ZXJuaW9uIFNMRVJQIG9wZXJhdGlvblxuXG5cdFx0dmFyIHgwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDAgXSxcblx0XHRcdHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXSxcblx0XHRcdHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXSxcblx0XHRcdHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXSxcblxuXHRcdFx0eDEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMCBdLFxuXHRcdFx0eTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdLFxuXHRcdFx0ejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdLFxuXHRcdFx0dzEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMyBdO1xuXG5cdFx0aWYgKCB3MCAhPT0gdzEgfHwgeDAgIT09IHgxIHx8IHkwICE9PSB5MSB8fCB6MCAhPT0gejEgKSB7XG5cblx0XHRcdHZhciBzID0gMSAtIHQsXG5cblx0XHRcdFx0Y29zID0geDAgKiB4MSArIHkwICogeTEgKyB6MCAqIHoxICsgdzAgKiB3MSxcblxuXHRcdFx0XHRkaXIgPSAoIGNvcyA+PSAwID8gMSA6IC0gMSApLFxuXHRcdFx0XHRzcXJTaW4gPSAxIC0gY29zICogY29zO1xuXG5cdFx0XHQvLyBTa2lwIHRoZSBTbGVycCBmb3IgdGlueSBzdGVwcyB0byBhdm9pZCBudW1lcmljIHByb2JsZW1zOlxuXHRcdFx0aWYgKCBzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHR2YXIgc2luID0gTWF0aC5zcXJ0KCBzcXJTaW4gKSxcblx0XHRcdFx0XHRsZW4gPSBNYXRoLmF0YW4yKCBzaW4sIGNvcyAqIGRpciApO1xuXG5cdFx0XHRcdHMgPSBNYXRoLnNpbiggcyAqIGxlbiApIC8gc2luO1xuXHRcdFx0XHR0ID0gTWF0aC5zaW4oIHQgKiBsZW4gKSAvIHNpbjtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdERpciA9IHQgKiBkaXI7XG5cblx0XHRcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xuXHRcdFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XG5cdFx0XHR6MCA9IHowICogcyArIHoxICogdERpcjtcblx0XHRcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyO1xuXG5cdFx0XHQvLyBOb3JtYWxpemUgaW4gY2FzZSB3ZSBqdXN0IGRpZCBhIGxlcnA6XG5cdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xuXG5cdFx0XHRcdHZhciBmID0gMSAvIE1hdGguc3FydCggeDAgKiB4MCArIHkwICogeTAgKyB6MCAqIHowICsgdzAgKiB3MCApO1xuXG5cdFx0XHRcdHgwICo9IGY7XG5cdFx0XHRcdHkwICo9IGY7XG5cdFx0XHRcdHowICo9IGY7XG5cdFx0XHRcdHcwICo9IGY7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcblxuXHR9XG5cbn0gKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFF1YXRlcm5pb24ucHJvdG90eXBlLCB7XG5cblx0eDoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl94O1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5feCA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0eToge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl95O1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5feSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0ejoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl96O1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5feiA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0dzoge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl93O1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5fdyA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0fVxuXG5cdH1cblxufSApO1xuXG5PYmplY3QuYXNzaWduKCBRdWF0ZXJuaW9uLnByb3RvdHlwZSwge1xuXG5cdGlzUXVhdGVybmlvbjogdHJ1ZSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX3cgPSB3O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93ICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XG5cblx0XHR0aGlzLl94ID0gcXVhdGVybmlvbi54O1xuXHRcdHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XG5cdFx0dGhpcy5feiA9IHF1YXRlcm5pb24uejtcblx0XHR0aGlzLl93ID0gcXVhdGVybmlvbi53O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIsIHVwZGF0ZSApIHtcblxuXHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHggPSBldWxlci5feCwgeSA9IGV1bGVyLl95LCB6ID0gZXVsZXIuX3osIG9yZGVyID0gZXVsZXIub3JkZXI7XG5cblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG5cdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cblx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cblx0XHR2YXIgY29zID0gTWF0aC5jb3M7XG5cdFx0dmFyIHNpbiA9IE1hdGguc2luO1xuXG5cdFx0dmFyIGMxID0gY29zKCB4IC8gMiApO1xuXHRcdHZhciBjMiA9IGNvcyggeSAvIDIgKTtcblx0XHR2YXIgYzMgPSBjb3MoIHogLyAyICk7XG5cblx0XHR2YXIgczEgPSBzaW4oIHggLyAyICk7XG5cdFx0dmFyIHMyID0gc2luKCB5IC8gMiApO1xuXHRcdHZhciBzMyA9IHNpbiggeiAvIDIgKTtcblxuXHRcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLl94ID0gYXhpcy54ICogcztcblx0XHR0aGlzLl95ID0gYXhpcy55ICogcztcblx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcblx0XHR0aGlzLl93ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dmFyIHRlID0gbS5lbGVtZW50cyxcblxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcblx0XHRcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXG5cdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXSxcblxuXHRcdFx0dHJhY2UgPSBtMTEgKyBtMjIgKyBtMzMsXG5cdFx0XHRzO1xuXG5cdFx0aWYgKCB0cmFjZSA+IDAgKSB7XG5cblx0XHRcdHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XG5cblx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcblx0XHRcdHRoaXMuX3kgPSAoIG0xMyAtIG0zMSApICogcztcblx0XHRcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcblxuXHRcdH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XG5cblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XG5cblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl95ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTIzICsgbTMyICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uICggdkZyb20sIHZUbyApIHtcblxuXHRcdC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG5cdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xuXG5cdFx0dmFyIHIgPSB2RnJvbS5kb3QoIHZUbyApICsgMTtcblxuXHRcdGlmICggciA8IEVQUyApIHtcblxuXHRcdFx0ciA9IDA7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIHZGcm9tLnggKSA+IE1hdGguYWJzKCB2RnJvbS56ICkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IC0gdkZyb20ueTtcblx0XHRcdFx0dGhpcy5feSA9IHZGcm9tLng7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0dGhpcy5feSA9IC0gdkZyb20uejtcblx0XHRcdFx0dGhpcy5feiA9IHZGcm9tLnk7XG5cdFx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBjcm9zc1ZlY3RvcnMoIHZGcm9tLCB2VG8gKTsgLy8gaW5saW5lZCB0byBhdm9pZCBjeWNsaWMgZGVwZW5kZW5jeSBvbiBWZWN0b3IzXG5cblx0XHRcdHRoaXMuX3ggPSB2RnJvbS55ICogdlRvLnogLSB2RnJvbS56ICogdlRvLnk7XG5cdFx0XHR0aGlzLl95ID0gdkZyb20ueiAqIHZUby54IC0gdkZyb20ueCAqIHZUby56O1xuXHRcdFx0dGhpcy5feiA9IHZGcm9tLnggKiB2VG8ueSAtIHZGcm9tLnkgKiB2VG8ueDtcblx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cblx0fSxcblxuXHRhbmdsZVRvOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHRyZXR1cm4gMiAqIE1hdGguYWNvcyggTWF0aC5hYnMoIF9NYXRoLmNsYW1wKCB0aGlzLmRvdCggcSApLCAtIDEsIDEgKSApICk7XG5cblx0fSxcblxuXHRyb3RhdGVUb3dhcmRzOiBmdW5jdGlvbiAoIHEsIHN0ZXAgKSB7XG5cblx0XHR2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlVG8oIHEgKTtcblxuXHRcdGlmICggYW5nbGUgPT09IDAgKSByZXR1cm4gdGhpcztcblxuXHRcdHZhciB0ID0gTWF0aC5taW4oIDEsIHN0ZXAgLyBhbmdsZSApO1xuXG5cdFx0dGhpcy5zbGVycCggcSwgdCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBxdWF0ZXJuaW9uIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0cmV0dXJuIHRoaXMuY29uanVnYXRlKCk7XG5cblx0fSxcblxuXHRjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuX3ggKj0gLSAxO1xuXHRcdHRoaXMuX3kgKj0gLSAxO1xuXHRcdHRoaXMuX3ogKj0gLSAxO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcblxuXHR9LFxuXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XG5cblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdGlmICggbCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0dGhpcy5fdyA9IDE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRsID0gMSAvIGw7XG5cblx0XHRcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcblx0XHRcdHRoaXMuX3kgPSB0aGlzLl95ICogbDtcblx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcblx0XHRcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcblxuXHRcdH1cblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggcSwgcCApIHtcblxuXHRcdGlmICggcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCBxLCBwICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG5cblx0fSxcblxuXHRwcmVtdWx0aXBseTogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgdGhpcyApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cblx0XHR2YXIgcWF4ID0gYS5feCwgcWF5ID0gYS5feSwgcWF6ID0gYS5feiwgcWF3ID0gYS5fdztcblx0XHR2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcblxuXHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG5cdFx0dGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcblx0XHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuXHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xuXG5cdFx0aWYgKCB0ID09PSAwICkgcmV0dXJuIHRoaXM7XG5cdFx0aWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcblxuXHRcdHZhciB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cblx0XHR2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG5cdFx0XHR0aGlzLl93ID0gLSBxYi5fdztcblx0XHRcdHRoaXMuX3ggPSAtIHFiLl94O1xuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XG5cdFx0XHR0aGlzLl96ID0gLSBxYi5fejtcblxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSB3O1xuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdHZhciBzcXJTaW5IYWxmVGhldGEgPSAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGE7XG5cblx0XHRpZiAoIHNxclNpbkhhbGZUaGV0YSA8PSBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0dmFyIHMgPSAxIC0gdDtcblx0XHRcdHRoaXMuX3cgPSBzICogdyArIHQgKiB0aGlzLl93O1xuXHRcdFx0dGhpcy5feCA9IHMgKiB4ICsgdCAqIHRoaXMuX3g7XG5cdFx0XHR0aGlzLl95ID0gcyAqIHkgKyB0ICogdGhpcy5feTtcblx0XHRcdHRoaXMuX3ogPSBzICogeiArIHQgKiB0aGlzLl96O1xuXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdHZhciBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIHNxclNpbkhhbGZUaGV0YSApO1xuXHRcdHZhciBoYWxmVGhldGEgPSBNYXRoLmF0YW4yKCBzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSApO1xuXHRcdHZhciByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXG5cdFx0XHRyYXRpb0IgPSBNYXRoLnNpbiggdCAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xuXG5cdFx0dGhpcy5fdyA9ICggdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0IgKTtcblx0XHR0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feiA9ICggeiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0IgKTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XG5cblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX3c7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRfb25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdF9vbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxuXG59ICk7XG5cblxuZXhwb3J0IHsgUXVhdGVybmlvbiB9O1xuIiwiaW1wb3J0IHsgX01hdGggfSBmcm9tICcuL01hdGguanMnO1xuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vUXVhdGVybmlvbi5qcyc7XG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3Iga2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cbnZhciBfdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbnZhciBfcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmZ1bmN0aW9uIFZlY3RvcjMoIHgsIHksIHogKSB7XG5cblx0dGhpcy54ID0geCB8fCAwO1xuXHR0aGlzLnkgPSB5IHx8IDA7XG5cdHRoaXMueiA9IHogfHwgMDtcblxufVxuXG5PYmplY3QuYXNzaWduKCBWZWN0b3IzLnByb3RvdHlwZSwge1xuXG5cdGlzVmVjdG9yMzogdHJ1ZSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdHRoaXMueSA9IHNjYWxhcjtcblx0XHR0aGlzLnogPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcblxuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblx0XHR0aGlzLnogKz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXHRcdHRoaXMueiArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXHRcdHRoaXMueiA9IGEueiArIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHR0aGlzLnkgKz0gdi55ICogcztcblx0XHR0aGlzLnogKz0gdi56ICogcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCAtPSBzO1xuXHRcdHRoaXMueSAtPSBzO1xuXHRcdHRoaXMueiAtPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICo9IHYueDtcblx0XHR0aGlzLnkgKj0gdi55O1xuXHRcdHRoaXMueiAqPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICogYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0aWYgKCAhICggZXVsZXIgJiYgZXVsZXIuaXNFdWxlciApICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cblx0fSxcblxuXHRhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xuXG5cdH0sXG5cblx0YXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF0gKiB6O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXBwbHlOb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4MyggbSApLm5vcm1hbGl6ZSgpO1xuXG5cdH0sXG5cblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR2YXIgdyA9IDEgLyAoIGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICk7XG5cblx0XHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKSAqIHc7XG5cdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICkgKiB3O1xuXHRcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0dmFyIHF4ID0gcS54LCBxeSA9IHEueSwgcXogPSBxLnosIHF3ID0gcS53O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuXHRcdHZhciBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcblx0XHR2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG5cdFx0dmFyIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuXHRcdHZhciBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG5cdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcblx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xuXHRcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHByb2plY3Q6IGZ1bmN0aW9uICggY2FtZXJhICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdH0sXG5cblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHR9LFxuXG5cdHRyYW5zZm9ybURpcmVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXHRcdC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCAvPSB2Lng7XG5cdFx0dGhpcy55IC89IHYueTtcblx0XHR0aGlzLnogLz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuXHR9LFxuXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCBtaW5WYWwsIG1heFZhbCApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy55ICkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnogKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCBsZW5ndGggfHwgMSApLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApICk7XG5cblx0fSxcblxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXG5cdH0sXG5cblx0Ly8gVE9ETyBsZW5ndGhTcXVhcmVkP1xuXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xuXG5cdH0sXG5cblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcblxuXHR9LFxuXG5cdG1hbmhhdHRhbkxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcblxuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcblxuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XG5cblx0fSxcblxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cblx0fSxcblxuXHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5jcm9zcygpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmNyb3NzVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHRoaXMsIHYgKTtcblxuXHR9LFxuXG5cdGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dmFyIGF4ID0gYS54LCBheSA9IGEueSwgYXogPSBhLno7XG5cdFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XG5cblx0XHR0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcblx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcblx0XHR0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cHJvamVjdE9uVmVjdG9yOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHQvLyB2IGNhbm5vdCBiZSB0aGUgemVybyB2XG5cblx0XHR2YXIgc2NhbGFyID0gdi5kb3QoIHRoaXMgKSAvIHYubGVuZ3RoU3EoKTtcblxuXHRcdHJldHVybiB0aGlzLmNvcHkoIHYgKS5tdWx0aXBseVNjYWxhciggc2NhbGFyICk7XG5cblx0fSxcblxuXHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCBwbGFuZU5vcm1hbCApIHtcblxuXHRcdF92ZWN0b3IuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcblxuXHRcdHJldHVybiB0aGlzLnN1YiggX3ZlY3RvciApO1xuXG5cdH0sXG5cblx0cmVmbGVjdDogZnVuY3Rpb24gKCBub3JtYWwgKSB7XG5cblx0XHQvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcblx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG5cblx0XHRyZXR1cm4gdGhpcy5zdWIoIF92ZWN0b3IuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xuXG5cdH0sXG5cblx0YW5nbGVUbzogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIGRlbm9taW5hdG9yID0gTWF0aC5zcXJ0KCB0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkgKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSBjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogYW5nbGVUbygpIGNhblxcJ3QgaGFuZGxlIHplcm8gbGVuZ3RoIHZlY3RvcnMuJyApO1xuXG5cdFx0dmFyIHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdHJldHVybiBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2LnksIGR6ID0gdGhpcy56IC0gdi56O1xuXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblxuXHR9LFxuXG5cdG1hbmhhdHRhbkRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICkgKyBNYXRoLmFicyggdGhpcy56IC0gdi56ICk7XG5cblx0fSxcblxuXHRzZXRGcm9tU3BoZXJpY2FsOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tU3BoZXJpY2FsQ29vcmRzKCBzLnJhZGl1cywgcy5waGksIHMudGhldGEgKTtcblxuXHR9LFxuXG5cdHNldEZyb21TcGhlcmljYWxDb29yZHM6IGZ1bmN0aW9uICggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG5cdFx0dmFyIHNpblBoaVJhZGl1cyA9IE1hdGguc2luKCBwaGkgKSAqIHJhZGl1cztcblxuXHRcdHRoaXMueCA9IHNpblBoaVJhZGl1cyAqIE1hdGguc2luKCB0aGV0YSApO1xuXHRcdHRoaXMueSA9IE1hdGguY29zKCBwaGkgKSAqIHJhZGl1cztcblx0XHR0aGlzLnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUN5bGluZHJpY2FsOiBmdW5jdGlvbiAoIGMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoIGMucmFkaXVzLCBjLnRoZXRhLCBjLnkgKTtcblxuXHR9LFxuXG5cdHNldEZyb21DeWxpbmRyaWNhbENvb3JkczogZnVuY3Rpb24gKCByYWRpdXMsIHRoZXRhLCB5ICkge1xuXG5cdFx0dGhpcy54ID0gcmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbU1hdHJpeFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAxMiBdO1xuXHRcdHRoaXMueSA9IGVbIDEzIF07XG5cdFx0dGhpcy56ID0gZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbU1hdHJpeFNjYWxlOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgc3ggPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcblx0XHR2YXIgc3kgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcblx0XHR2YXIgc3ogPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcblxuXHRcdHRoaXMueCA9IHN4O1xuXHRcdHRoaXMueSA9IHN5O1xuXHRcdHRoaXMueiA9IHN6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiAoIG0sIGluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZnJvbUFycmF5KCBtLmVsZW1lbnRzLCBpbmRleCAqIDQgKTtcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgKTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9LFxuXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59ICk7XG5cblxuZXhwb3J0IHsgVmVjdG9yMyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQnKTtcblxuV2ViU29ja2V0LmNyZWF0ZVdlYlNvY2tldFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3N0cmVhbScpO1xuV2ViU29ja2V0LlNlcnZlciA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXInKTtcbldlYlNvY2tldC5SZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3JlY2VpdmVyJyk7XG5XZWJTb2NrZXQuU2VuZGVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgYnVmZmVycyBpbnRvIGEgbmV3IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBhcnJheSBvZiBidWZmZXJzIHRvIGNvbmNhdFxuICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoIFRoZSB0b3RhbCBsZW5ndGggb2YgYnVmZmVycyBpbiB0aGUgbGlzdFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgcmVzdWx0aW5nIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjb25jYXQobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHJldHVybiBsaXN0WzBdO1xuXG4gIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJ1ZiA9IGxpc3RbaV07XG4gICAgdGFyZ2V0LnNldChidWYsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGJ1Zi5sZW5ndGg7XG4gIH1cblxuICBpZiAob2Zmc2V0IDwgdG90YWxMZW5ndGgpIHJldHVybiB0YXJnZXQuc2xpY2UoMCwgb2Zmc2V0KTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIE1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBzb3VyY2UgVGhlIGJ1ZmZlciB0byBtYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBvdXRwdXQgVGhlIGJ1ZmZlciB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgd3JpdGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIG1hc2suXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0W29mZnNldCArIGldID0gc291cmNlW2ldIF4gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBVbm1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byB1bm1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfdW5tYXNrKGJ1ZmZlciwgbWFzaykge1xuICAvLyBSZXF1aXJlZCB1bnRpbCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzkwMDYgaXMgcmVzb2x2ZWQuXG4gIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBidWZmZXJbaV0gXj0gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhbiBgQXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gQ29udmVydGVkIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ1Zikge1xuICBpZiAoYnVmLmJ5dGVMZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBkYXRhYCB0byBhIGBCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBidWZmZXJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9CdWZmZXIoZGF0YSkge1xuICB0b0J1ZmZlci5yZWFkT25seSA9IHRydWU7XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgcmV0dXJuIGRhdGE7XG5cbiAgbGV0IGJ1ZjtcblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICB0b0J1ZmZlci5yZWFkT25seSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn1cblxudHJ5IHtcbiAgY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJ2J1ZmZlcnV0aWwnKTtcbiAgY29uc3QgYnUgPSBidWZmZXJVdGlsLkJ1ZmZlclV0aWwgfHwgYnVmZmVyVXRpbDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25jYXQsXG4gICAgbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPCA0OCkgX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGVsc2UgYnUubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH0sXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgICBlbHNlIGJ1LnVubWFzayhidWZmZXIsIG1hc2spO1xuICAgIH1cbiAgfTtcbn0gY2F0Y2ggKGUpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29uY2F0LFxuICAgIG1hc2s6IF9tYXNrLFxuICAgIHRvQXJyYXlCdWZmZXIsXG4gICAgdG9CdWZmZXIsXG4gICAgdW5tYXNrOiBfdW5tYXNrXG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCSU5BUllfVFlQRVM6IFsnbm9kZWJ1ZmZlcicsICdhcnJheWJ1ZmZlcicsICdmcmFnbWVudHMnXSxcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXG4gIGtTdGF0dXNDb2RlOiBTeW1ib2woJ3N0YXR1cy1jb2RlJyksXG4gIGtXZWJTb2NrZXQ6IFN5bWJvbCgnd2Vic29ja2V0JyksXG4gIEVNUFRZX0JVRkZFUjogQnVmZmVyLmFsbG9jKDApLFxuICBOT09QOiAoKSA9PiB7fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgcmVjZWl2ZWQgZGF0YVxuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhLCB0YXJnZXQpIHtcbiAgICBzdXBlcignbWVzc2FnZScsIHRhcmdldCk7XG5cbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2xvc2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENsb3NlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgYmVpbmcgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb24gQSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2RlLCByZWFzb24sIHRhcmdldCkge1xuICAgIHN1cGVyKCdjbG9zZScsIHRhcmdldCk7XG5cbiAgICB0aGlzLndhc0NsZWFuID0gdGFyZ2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGFyZ2V0Ll9jbG9zZUZyYW1lU2VudDtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIG9wZW4gZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIE9wZW5FdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgT3BlbkV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXMgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgc3VwZXIoJ29wZW4nLCB0YXJnZXQpO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFcnJvckV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yIFRoZSBlcnJvciB0aGF0IGdlbmVyYXRlZCB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7V2ViU29ja2V0fSB0YXJnZXQgQSByZWZlcmVuY2UgdG8gdGhlIHRhcmdldCB0byB3aGljaCB0aGUgZXZlbnQgd2FzIGRpc3BhdGNoZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVycm9yLCB0YXJnZXQpIHtcbiAgICBzdXBlcignZXJyb3InLCB0YXJnZXQpO1xuXG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcbiAgICogICAgIHRoZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMub25jZSBBIGBCb29sZWFuYGAgaW5kaWNhdGluZyB0aGF0IHRoZSBsaXN0ZW5lclxuICAgKiAgICAgc2hvdWxkIGJlIGludm9rZWQgYXQgbW9zdCBvbmNlIGFmdGVyIGJlaW5nIGFkZGVkLiBJZiBgdHJ1ZWAsIHRoZVxuICAgKiAgICAgbGlzdGVuZXIgd291bGQgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIHdoZW4gaW52b2tlZC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIG5ldyBNZXNzYWdlRXZlbnQoZGF0YSwgdGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgQ2xvc2VFdmVudChjb2RlLCBtZXNzYWdlLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgRXJyb3JFdmVudChlcnJvciwgdGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgbmV3IE9wZW5FdmVudCh0aGlzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0aG9kID0gb3B0aW9ucyAmJiBvcHRpb25zLm9uY2UgPyAnb25jZScgOiAnb24nO1xuXG4gICAgaWYgKHR5cGUgPT09ICdtZXNzYWdlJykge1xuICAgICAgb25NZXNzYWdlLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpc1ttZXRob2RdKHR5cGUsIG9uTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2xvc2UnKSB7XG4gICAgICBvbkNsb3NlLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpc1ttZXRob2RdKHR5cGUsIG9uQ2xvc2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgb25FcnJvci5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXNbbWV0aG9kXSh0eXBlLCBvbkVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgb25PcGVuLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpc1ttZXRob2RdKHR5cGUsIG9uT3Blbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbWV0aG9kXSh0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnModHlwZSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdGVuZXJzW2ldLl9saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy9cbi8vIEFsbG93ZWQgdG9rZW4gY2hhcmFjdGVyczpcbi8vXG4vLyAnIScsICcjJywgJyQnLCAnJScsICcmJywgJycnLCAnKicsICcrJywgJy0nLFxuLy8gJy4nLCAwLTksIEEtWiwgJ14nLCAnXycsICdgJywgYS16LCAnfCcsICd+J1xuLy9cbi8vIHRva2VuQ2hhcnNbMzJdID09PSAwIC8vICcgJ1xuLy8gdG9rZW5DaGFyc1szM10gPT09IDEgLy8gJyEnXG4vLyB0b2tlbkNoYXJzWzM0XSA9PT0gMCAvLyAnXCInXG4vLyAuLi5cbi8vXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHRva2VuQ2hhcnMgPSBbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAgLSAxNVxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXG4gIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDAsIC8vIDMyIC0gNDdcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gNDggLSA2M1xuICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIC8vIDgwIC0gOTVcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gOTYgLSAxMTFcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcbl07XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBpZiAoaGVhZGVyID09PSB1bmRlZmluZWQgfHwgaGVhZGVyID09PSAnJykgcmV0dXJuIG9mZmVycztcblxuICBsZXQgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG11c3RVbmVzY2FwZSA9IGZhbHNlO1xuICBsZXQgaXNFc2NhcGluZyA9IGZhbHNlO1xuICBsZXQgaW5RdW90ZXMgPSBmYWxzZTtcbiAgbGV0IGV4dGVuc2lvbk5hbWU7XG4gIGxldCBwYXJhbU5hbWU7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKDsgaSA8IGhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5IC8qICdcXHQnICovKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiAvKiAnOycgKi8gfHwgY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBwdXNoKHBhcmFtcywgaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNkIC8qICc9JyAqLyAmJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xuICAgICAgICBwYXJhbU5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgdmFsdWUgb2YgYSBxdW90ZWQtc3RyaW5nIGFmdGVyIHVuZXNjYXBpbmcgbXVzdCBjb25mb3JtIHRvIHRoZVxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICAgIC8vXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZSBpZiAoIW11c3RVbmVzY2FwZSkgbXVzdFVuZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyIC8qICdcIicgKi8gJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NWMgLyogJ1xcJyAqLykge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSAweDNkKSB7XG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgIT09IC0xICYmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgaW5RdW90ZXMpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xuY29uc3Qga1J1biA9IFN5bWJvbCgna1J1bicpO1xuXG4vKipcbiAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU1RSTUwvYXN5bmMtbGltaXRlclxuICovXG5jbGFzcyBMaW1pdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uY3VycmVuY3kgVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZCB0byBydW5cbiAgICogICAgIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZChqb2IpIHtcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xuICAgIHRoaXNba1J1bl0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW2tSdW5dKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcgPT09IHRoaXMuY29uY3VycmVuY3kpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBqb2IgPSB0aGlzLmpvYnMuc2hpZnQoKTtcblxuICAgICAgdGhpcy5wZW5kaW5nKys7XG4gICAgICBqb2IodGhpc1trRG9uZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnLi9saW1pdGVyJyk7XG5jb25zdCB7IGtTdGF0dXNDb2RlLCBOT09QIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKTtcbmNvbnN0IGtQZXJNZXNzYWdlRGVmbGF0ZSA9IFN5bWJvbCgncGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xuY29uc3Qga0J1ZmZlcnMgPSBTeW1ib2woJ2J1ZmZlcnMnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcblxuLy9cbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxuLy8gYXMgZG9jdW1lbnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg4NzEjaXNzdWVjb21tZW50LTI1MDkxNTkxM1xuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xMjAyXG4vL1xuLy8gSW50ZW50aW9uYWxseSBnbG9iYWw7IGl0J3MgdGhlIGdsb2JhbCB0aHJlYWQgcG9vbCB0aGF0J3MgYW4gaXNzdWUuXG4vL1xubGV0IHpsaWJMaW1pdGVyO1xuXG4vKipcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyIFJlcXVlc3QvYWNjZXB0IGRpc2FibGluZ1xuICAgKiAgICAgb2Ygc2VydmVyIGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyIEFkdmVydGlzZS9hY2tub3dsZWRnZVxuICAgKiAgICAgZGlzYWJsaW5nIG9mIGNsaWVudCBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzIFJlcXVlc3QvY29uZmlybSB0aGVcbiAgICogICAgIHVzZSBvZiBhIGN1c3RvbSBzZXJ2ZXIgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgQWR2ZXJ0aXNlIHN1cHBvcnRcbiAgICogICAgIGZvciwgb3IgcmVxdWVzdCwgYSBjdXN0b20gY2xpZW50IHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvbiBkZWZsYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvbiBpbmZsYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnRocmVzaG9sZCBTaXplIChpbiBieXRlcykgYmVsb3cgd2hpY2ggbWVzc2FnZXNcbiAgICogICAgIHNob3VsZCBub3QgYmUgY29tcHJlc3NlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0IFRoZSBudW1iZXIgb2YgY29uY3VycmVudCBjYWxscyB0b1xuICAgKiAgICAgemxpYlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzU2VydmVyIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvciBjbGllbnRcbiAgICogICAgIG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFBheWxvYWQgVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaXNTZXJ2ZXIsIG1heFBheWxvYWQpIHtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fdGhyZXNob2xkID1cbiAgICAgIHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xuICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuXG4gICAgaWYgKCF6bGliTGltaXRlcikge1xuICAgICAgY29uc3QgY29uY3VycmVuY3kgPVxuICAgICAgICB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0XG4gICAgICAgICAgOiAxMDtcbiAgICAgIHpsaWJMaW1pdGVyID0gbmV3IExpbWl0ZXIoY29uY3VycmVuY3kpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBleHRlbnNpb25OYW1lKCkge1xuICAgIHJldHVybiAncGVybWVzc2FnZS1kZWZsYXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG9mZmVyKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT0gbnVsbCkge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci9yZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWNjZXB0KGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucyk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMuX2lzU2VydmVyXG4gICAgICA/IHRoaXMuYWNjZXB0QXNTZXJ2ZXIoY29uZmlndXJhdGlvbnMpXG4gICAgICA6IHRoaXMuYWNjZXB0QXNDbGllbnQoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXMucGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFsbCByZXNvdXJjZXMgdXNlZCBieSB0aGUgZXh0ZW5zaW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLl9pbmZsYXRlKSB7XG4gICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZCdcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvZmZlcnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc1NlcnZlcihvZmZlcnMpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCBhY2NlcHRlZCA9IG9mZmVycy5maW5kKChwYXJhbXMpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyKSB8fFxuICAgICAgICAocGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgJiZcbiAgICAgICAgICAob3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA+IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzKSkpIHx8XG4gICAgICAgICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFhY2NlcHRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIHRoZSBleHRlbnNpb24gb2ZmZXJzIGNhbiBiZSBhY2NlcHRlZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IG9wdHMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID09PSB0cnVlIHx8XG4gICAgICBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlXG4gICAgKSB7XG4gICAgICBkZWxldGUgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cztcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjZXB0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IHRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3BvbnNlIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc0NsaWVudChyZXNwb25zZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJlc3BvbnNlWzBdO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhcmFtZXRlciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA+IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgb3IgaW52YWxpZCBwYXJhbWV0ZXIgXCJjbGllbnRfbWF4X3dpbmRvd19iaXRzXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvZmZlcnMvcmVzcG9uc2Ugd2l0aCBub3JtYWxpemVkIHBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zLmZvckVhY2goKHBhcmFtcykgPT4ge1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGllbnRfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1NlcnZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcicgfHxcbiAgICAgICAgICBrZXkgPT09ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29uZmlndXJhdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9jb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG5cbiAgICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2luZmxhdGVba1Blck1lc3NhZ2VEZWZsYXRlXSA9IHRoaXM7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2Vycm9yJywgaW5mbGF0ZU9uRXJyb3IpO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2luZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcbiAgICBpZiAoZmluKSB0aGlzLl9pbmZsYXRlLndyaXRlKFRSQUlMRVIpO1xuXG4gICAgdGhpcy5faW5mbGF0ZS5mbHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl9pbmZsYXRlW2tFcnJvcl07XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ3NlcnZlcicgOiAnY2xpZW50JztcblxuICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgLy9cbiAgICAgIC8vIEFuIGAnZXJyb3InYCBldmVudCBpcyBlbWl0dGVkLCBvbmx5IG9uIE5vZGUuanMgPCAxMC4wLjAsIGlmIHRoZVxuICAgICAgLy8gYHpsaWIuRGVmbGF0ZVJhd2AgaW5zdGFuY2UgaXMgY2xvc2VkIHdoaWxlIGRhdGEgaXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgIGlzIGNhbGxlZCBhdCB0aGUgd3JvbmdcbiAgICAgIC8vIHRpbWUgZHVlIHRvIGFuIGFibm9ybWFsIFdlYlNvY2tldCBjbG9zdXJlLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2Vycm9yJywgTk9PUCk7XG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdkYXRhJywgZGVmbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xuICAgIHRoaXMuX2RlZmxhdGUuZmx1c2goemxpYi5aX1NZTkNfRkxVU0gsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbikgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSA0KTtcblxuICAgICAgLy9cbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW4gaW5cbiAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IG51bGw7XG5cbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZXJNZXNzYWdlRGVmbGF0ZTtcblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkRlZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcblxuICBpZiAoXG4gICAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkIDwgMSB8fFxuICAgIHRoaXNba1RvdGFsTGVuZ3RoXSA8PSB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWRcbiAgKSB7XG4gICAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpc1trRXJyb3JdID0gbmV3IFJhbmdlRXJyb3IoJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKTtcbiAgdGhpc1trRXJyb3JdW2tTdGF0dXNDb2RlXSA9IDEwMDk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgdGhpcy5yZXNldCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkVycm9yKGVycikge1xuICAvL1xuICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYFpsaWIjY2xvc2UoKWAgYXMgdGhlIGhhbmRsZSBpcyBhdXRvbWF0aWNhbGx5XG4gIC8vIGNsb3NlZCB3aGVuIGFuIGVycm9yIGlzIGVtaXR0ZWQuXG4gIC8vXG4gIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5faW5mbGF0ZSA9IG51bGw7XG4gIGVycltrU3RhdHVzQ29kZV0gPSAxMDA3O1xuICB0aGlzW2tDYWxsYmFja10oZXJyKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgY29uY2F0LCB0b0FycmF5QnVmZmVyLCB1bm1hc2sgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUsIGlzVmFsaWRVVEY4IH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3QgR0VUX0lORk8gPSAwO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzE2ID0gMTtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XG5jb25zdCBHRVRfTUFTSyA9IDM7XG5jb25zdCBHRVRfREFUQSA9IDQ7XG5jb25zdCBJTkZMQVRJTkcgPSA1O1xuXG4vKipcbiAqIEh5QmkgUmVjZWl2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgc3RyZWFtLldyaXRhYmxlXG4gKi9cbmNsYXNzIFJlY2VpdmVyIGV4dGVuZHMgV3JpdGFibGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlY2VpdmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYmluYXJ5VHlwZSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzU2VydmVyIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW4gY2xpZW50IG9yIHNlcnZlclxuICAgKiAgICAgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4UGF5bG9hZCBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihiaW5hcnlUeXBlLCBleHRlbnNpb25zLCBpc1NlcnZlciwgbWF4UGF5bG9hZCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhaXNTZXJ2ZXI7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fYnVmZmVycyA9IFtdO1xuXG4gICAgdGhpcy5fY29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21hc2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgdGhpcy5fbWFza2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZmluID0gZmFsc2U7XG4gICAgdGhpcy5fb3Bjb2RlID0gMDtcblxuICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGBXcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlKClgLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgVGhlIGNodW5rIG9mIGRhdGEgdG8gd3JpdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIFRoZSBjaGFyYWN0ZXIgZW5jb2Rpbmcgb2YgYGNodW5rYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKi9cbiAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3N0YXRlID09IEdFVF9JTkZPKSByZXR1cm4gY2IoKTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWVzIGBuYCBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGNvbnN1bWVcbiAgICogQHJldHVybiB7QnVmZmVyfSBUaGUgY29uc3VtZWQgYnl0ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN1bWUobikge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gbjtcblxuICAgIGlmIChuID09PSB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2J1ZmZlcnMuc2hpZnQoKTtcblxuICAgIGlmIChuIDwgdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICB0aGlzLl9idWZmZXJzWzBdID0gYnVmLnNsaWNlKG4pO1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwLCBuKTtcbiAgICB9XG5cbiAgICBjb25zdCBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG5cbiAgICBkbyB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XG5cbiAgICAgIGlmIChuID49IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgZHN0LnNldCh0aGlzLl9idWZmZXJzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkc3Quc2V0KG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IGJ1Zi5zbGljZShuKTtcbiAgICAgIH1cblxuICAgICAgbiAtPSBidWYubGVuZ3RoO1xuICAgIH0gd2hpbGUgKG4gPiAwKTtcblxuICAgIHJldHVybiBkc3Q7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBwYXJzaW5nIGxvb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydExvb3AoY2IpIHtcbiAgICBsZXQgZXJyO1xuICAgIHRoaXMuX2xvb3AgPSB0cnVlO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICBjYXNlIEdFVF9JTkZPOlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0SW5mbygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF8xNjpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldFBheWxvYWRMZW5ndGgxNigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldFBheWxvYWRMZW5ndGg2NCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9NQVNLOlxuICAgICAgICAgIHRoaXMuZ2V0TWFzaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9EQVRBOlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0RGF0YShjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gYElORkxBVElOR2BcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRoaXMuX2xvb3ApO1xuXG4gICAgY2IoZXJyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEluZm8oKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdSU1YyIGFuZCBSU1YzIG11c3QgYmUgY2xlYXInLCB0cnVlLCAxMDAyKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xuXG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnUlNWMSBtdXN0IGJlIGNsZWFyJywgdHJ1ZSwgMTAwMik7XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnUlNWMSBtdXN0IGJlIGNsZWFyJywgdHJ1ZSwgMTAwMik7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnaW52YWxpZCBvcGNvZGUgMCcsIHRydWUsIDEwMDIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcGNvZGUgPSB0aGlzLl9mcmFnbWVudGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsIHRydWUsIDEwMDIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcgJiYgdGhpcy5fb3Bjb2RlIDwgMHgwYikge1xuICAgICAgaWYgKCF0aGlzLl9maW4pIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ0ZJTiBtdXN0IGJlIHNldCcsIHRydWUsIDEwMDIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihSYW5nZUVycm9yLCAnUlNWMSBtdXN0IGJlIGNsZWFyJywgdHJ1ZSwgMTAwMik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID4gMHg3ZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsIHRydWUsIDEwMDIpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAweDgwKSA9PT0gMHg4MDtcblxuICAgIGlmICh0aGlzLl9pc1NlcnZlcikge1xuICAgICAgaWYgKCF0aGlzLl9tYXNrZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ01BU0sgbXVzdCBiZSBzZXQnLCB0cnVlLCAxMDAyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdNQVNLIG11c3QgYmUgY2xlYXInLCB0cnVlLCAxMDAyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2UgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrMTYpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoMTYoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMuY29uc3VtZSgyKS5yZWFkVUludDE2QkUoMCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrNjQpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDgpO1xuICAgIGNvbnN0IG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMCk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBtYXhpbXVtIHNhZmUgaW50ZWdlciBpbiBKYXZhU2NyaXB0IGlzIDJeNTMgLSAxLiBBbiBlcnJvciBpcyByZXR1cm5lZFxuICAgIC8vIGlmIHBheWxvYWQgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIG51bWJlci5cbiAgICAvL1xuICAgIGlmIChudW0gPiBNYXRoLnBvdygyLCA1MyAtIDMyKSAtIDEpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIFdlYlNvY2tldCBmcmFtZTogcGF5bG9hZCBsZW5ndGggPiAyXjUzIC0gMScsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAxMDA5XG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBudW0gKiBNYXRoLnBvdygyLCAzMikgKyBidWYucmVhZFVJbnQzMkJFKDQpO1xuICAgIHJldHVybiB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXlsb2FkIGxlbmd0aCBoYXMgYmVlbiByZWFkLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKCkge1xuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoICYmIHRoaXMuX29wY29kZSA8IDB4MDgpIHtcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArPSB0aGlzLl9wYXlsb2FkTGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoUmFuZ2VFcnJvciwgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLCBmYWxzZSwgMTAwOSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2tlZCkgdGhpcy5fc3RhdGUgPSBHRVRfTUFTSztcbiAgICBlbHNlIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgbWFzayBieXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1hc2soKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA0KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbWFzayA9IHRoaXMuY29uc3VtZSg0KTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGRhdGEgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERhdGEoY2IpIHtcbiAgICBsZXQgZGF0YSA9IEVNUFRZX0JVRkZFUjtcblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN1bWUodGhpcy5fcGF5bG9hZExlbmd0aCk7XG4gICAgICBpZiAodGhpcy5fbWFza2VkKSB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHJldHVybiB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEpO1xuXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmdodCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKFxuICAgICAgICAgICAgZXJyb3IoUmFuZ2VFcnJvciwgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLCBmYWxzZSwgMTAwOSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goYnVmKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXIgPSB0aGlzLmRhdGFNZXNzYWdlKCk7XG4gICAgICBpZiAoZXIpIHJldHVybiBjYihlcik7XG5cbiAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0YU1lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2Zpbikge1xuICAgICAgY29uc3QgbWVzc2FnZUxlbmd0aCA9IHRoaXMuX21lc3NhZ2VMZW5ndGg7XG4gICAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLl9mcmFnbWVudHM7XG5cbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDIpIHtcbiAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdub2RlYnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgZGF0YSA9IHRvQXJyYXlCdWZmZXIoY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoRXJyb3IsICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJywgdHJ1ZSwgMTAwNyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgY29udHJvbCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGhhbmRsZVxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb250cm9sTWVzc2FnZShkYXRhKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIDEwMDUsICcnKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsICdpbnZhbGlkIHBheWxvYWQgbGVuZ3RoIDEnLCB0cnVlLCAxMDAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBkYXRhLnJlYWRVSW50MTZCRSgwKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFJhbmdlRXJyb3IsIGBpbnZhbGlkIHN0YXR1cyBjb2RlICR7Y29kZX1gLCB0cnVlLCAxMDAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGEuc2xpY2UoMik7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKEVycm9yLCAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsIHRydWUsIDEwMDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIGNvZGUsIGJ1Zi50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOSkge1xuICAgICAgdGhpcy5lbWl0KCdwaW5nJywgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCgncG9uZycsIGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWNlaXZlcjtcblxuLyoqXG4gKiBCdWlsZHMgYW4gZXJyb3Igb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7KEVycm9yfFJhbmdlRXJyb3IpfSBFcnJvckN0b3IgVGhlIGVycm9yIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtCb29sZWFufSBwcmVmaXggU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGFkZCBhIGRlZmF1bHQgcHJlZml4IHRvXG4gKiAgICAgYG1lc3NhZ2VgXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzQ29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yKX0gVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSkge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxuICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICk7XG5cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBlcnJvcik7XG4gIGVycltrU3RhdHVzQ29kZV0gPSBzdGF0dXNDb2RlO1xuICByZXR1cm4gZXJyO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHJhbmRvbUZpbGxTeW5jIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgeyBFTVBUWV9CVUZGRVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGlzVmFsaWRTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcbmNvbnN0IHsgbWFzazogYXBwbHlNYXNrLCB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBtYXNrID0gQnVmZmVyLmFsbG9jKDQpO1xuXG4vKipcbiAqIEh5QmkgU2VuZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBTZW5kZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFNlbmRlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvY2tldCwgZXh0ZW5zaW9ucykge1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbXByZXNzID0gZmFsc2U7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9kZWZsYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhIHBpZWNlIG9mIGRhdGEgYWNjb3JkaW5nIHRvIHRoZSBIeUJpIFdlYlNvY2tldCBwcm90b2NvbC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgdG8gZnJhbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnJlYWRPbmx5IFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmUgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZSBGSU4gYml0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5tYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucnN2MSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZSBSU1YxIGJpdFxuICAgKiBAcmV0dXJuIHtCdWZmZXJbXX0gVGhlIGZyYW1lZCBkYXRhIGFzIGEgbGlzdCBvZiBgQnVmZmVyYCBpbnN0YW5jZXNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc3RhdGljIGZyYW1lKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZXJnZSA9IG9wdGlvbnMubWFzayAmJiBvcHRpb25zLnJlYWRPbmx5O1xuICAgIGxldCBvZmZzZXQgPSBvcHRpb25zLm1hc2sgPyA2IDogMjtcbiAgICBsZXQgcGF5bG9hZExlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDY1NTM2KSB7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XG4gICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCA+IDEyNSkge1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2O1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXJnZSA/IGRhdGEubGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0KTtcblxuICAgIHRhcmdldFswXSA9IG9wdGlvbnMuZmluID8gb3B0aW9ucy5vcGNvZGUgfCAweDgwIDogb3B0aW9ucy5vcGNvZGU7XG4gICAgaWYgKG9wdGlvbnMucnN2MSkgdGFyZ2V0WzBdIHw9IDB4NDA7XG5cbiAgICB0YXJnZXRbMV0gPSBwYXlsb2FkTGVuZ3RoO1xuXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDE2QkUoZGF0YS5sZW5ndGgsIDIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MzJCRSgwLCAyKTtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQzMkJFKGRhdGEubGVuZ3RoLCA2KTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMubWFzaykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuXG4gICAgcmFuZG9tRmlsbFN5bmMobWFzaywgMCwgNCk7XG5cbiAgICB0YXJnZXRbMV0gfD0gMHg4MDtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gNF0gPSBtYXNrWzBdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMV0gPSBtYXNrWzNdO1xuXG4gICAgaWYgKG1lcmdlKSB7XG4gICAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgdGFyZ2V0LCBvZmZzZXQsIGRhdGEubGVuZ3RoKTtcbiAgICAgIHJldHVybiBbdGFyZ2V0XTtcbiAgICB9XG5cbiAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgZGF0YSwgMCwgZGF0YS5sZW5ndGgpO1xuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7KE51bWJlcnx1bmRlZmluZWQpfSBjb2RlIFRoZSBzdGF0dXMgY29kZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgVGhlIG1lc3NhZ2UgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBidWY7XG5cbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWYgPSBFTVBUWV9CVUZGRVI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdmFsaWQgZXJyb3IgY29kZSBudW1iZXInKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCB8fCBkYXRhID09PSAnJykge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgbWVzc2FnZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTIzIGJ5dGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgbGVuZ3RoKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgICAgYnVmLndyaXRlKGRhdGEsIDIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kb0Nsb3NlLCBidWYsIG1hc2ssIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9DbG9zZShidWYsIG1hc2ssIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIGNsb3NlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZG9DbG9zZShkYXRhLCBtYXNrLCBjYikge1xuICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgICAgZmluOiB0cnVlLFxuICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgb3Bjb2RlOiAweDA4LFxuICAgICAgICBtYXNrLFxuICAgICAgICByZWFkT25seTogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgY2JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGluZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBjb25zdCBidWYgPSB0b0J1ZmZlcihkYXRhKTtcblxuICAgIGlmIChidWYubGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRvUGluZywgYnVmLCBtYXNrLCB0b0J1ZmZlci5yZWFkT25seSwgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb1BpbmcoYnVmLCBtYXNrLCB0b0J1ZmZlci5yZWFkT25seSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYW5kIHNlbmRzIGEgcGluZyBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVhZE9ubHkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZSBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZG9QaW5nKGRhdGEsIG1hc2ssIHJlYWRPbmx5LCBjYikge1xuICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgICAgZmluOiB0cnVlLFxuICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgb3Bjb2RlOiAweDA5LFxuICAgICAgICBtYXNrLFxuICAgICAgICByZWFkT25seVxuICAgICAgfSksXG4gICAgICBjYlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwb25nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGRhdGEpO1xuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9Qb25nLCBidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvUG9uZyhidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhbmQgc2VuZHMgYSBwb25nIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSByZWFkT25seSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkb1BvbmcoZGF0YSwgbWFzaywgcmVhZE9ubHksIGNiKSB7XG4gICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICBTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICBmaW46IHRydWUsXG4gICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICBvcGNvZGU6IDB4MGEsXG4gICAgICAgIG1hc2ssXG4gICAgICAgIHJlYWRPbmx5XG4gICAgICB9KSxcbiAgICAgIGNiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGRhdGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNvbXByZXNzIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmJpbmFyeSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZpbiBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5tYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgY29uc3QgYnVmID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcblxuICAgIGlmICh0aGlzLl9maXJzdEZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XG4gICAgICBpZiAocnN2MSAmJiBwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICByc3YxID0gYnVmLmxlbmd0aCA+PSBwZXJNZXNzYWdlRGVmbGF0ZS5fdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3YxID0gZmFsc2U7XG4gICAgICBvcGNvZGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZpbikgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG5cbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgIHJzdjEsXG4gICAgICAgIG9wY29kZSxcbiAgICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgICByZWFkT25seTogdG9CdWZmZXIucmVhZE9ubHlcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBidWYsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChidWYsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgICBTZW5kZXIuZnJhbWUoYnVmLCB7XG4gICAgICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgICBvcGNvZGUsXG4gICAgICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgICAgIHJlYWRPbmx5OiB0b0J1ZmZlci5yZWFkT25seVxuICAgICAgICB9KSxcbiAgICAgICAgY2JcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBjb21wcmVzcyBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yZWFkT25seSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5maW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnJzdjEgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHRoaXMuX2RlZmxhdGluZyA9IHRydWU7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoZXJyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9xdWV1ZVtpXVs0XTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHdoaWxlICghdGhpcy5fZGVmbGF0aW5nICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBwYXJhbXNbMV0ubGVuZ3RoO1xuICAgICAgUmVmbGVjdC5hcHBseShwYXJhbXNbMF0sIHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1sxXS5sZW5ndGg7XG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc29ja2V0LmNvcmsoKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgICB0aGlzLl9zb2NrZXQudW5jb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qKlxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmVhbS5EdXBsZXh9IFRoZSBzdHJlYW0uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVuZCgpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVycm9yKGVycikge1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd3MgVGhlIGBXZWJTb2NrZXRgIHRvIHdyYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgYER1cGxleGAgY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge3N0cmVhbS5EdXBsZXh9IFRoZSBkdXBsZXggc3RyZWFtXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldFN0cmVhbSh3cywgb3B0aW9ucykge1xuICBsZXQgcmVzdW1lT25SZWNlaXZlckRyYWluID0gdHJ1ZTtcblxuICBmdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gICAgaWYgKHJlc3VtZU9uUmVjZWl2ZXJEcmFpbikgd3MuX3NvY2tldC5yZXN1bWUoKTtcbiAgfVxuXG4gIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICB3cy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCdkcmFpbicpO1xuICAgICAgd3MuX3JlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd3MuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygnZHJhaW4nKTtcbiAgICB3cy5fcmVjZWl2ZXIub24oJ2RyYWluJywgcmVjZWl2ZXJPbkRyYWluKTtcbiAgfVxuXG4gIGNvbnN0IGR1cGxleCA9IG5ldyBEdXBsZXgoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgYXV0b0Rlc3Ryb3k6IGZhbHNlLFxuICAgIGVtaXRDbG9zZTogZmFsc2UsXG4gICAgb2JqZWN0TW9kZTogZmFsc2UsXG4gICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICB9KTtcblxuICB3cy5vbignbWVzc2FnZScsIGZ1bmN0aW9uIG1lc3NhZ2UobXNnKSB7XG4gICAgaWYgKCFkdXBsZXgucHVzaChtc2cpKSB7XG4gICAgICByZXN1bWVPblJlY2VpdmVyRHJhaW4gPSBmYWxzZTtcbiAgICAgIHdzLl9zb2NrZXQucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIGR1cGxleC5kZXN0cm95KGVycik7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIGR1cGxleC5wdXNoKG51bGwpO1xuICB9KTtcblxuICBkdXBsZXguX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgIH0pO1xuICAgIHdzLnRlcm1pbmF0ZSgpO1xuICB9O1xuXG4gIGR1cGxleC5fZmluYWwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIGBfc29ja2V0YCBwcm9wZXJ0eSBpcyBgbnVsbGAgaXQgbWVhbnMgdGhhdCBgd3NgIGlzIGFcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxuICAgIC8vIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSB3ZWJzb2NrZXQuXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBlbWl0dGVkIG9uIGBkdXBsZXhgIGFmdGVyIHRoaXMgYCdmaW5pc2gnYCBldmVudC4gVGhlIEVPRiBzaWduYWxpbmdcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLk9QRU4gJiYgIXJlc3VtZU9uUmVjZWl2ZXJEcmFpbikge1xuICAgICAgcmVzdW1lT25SZWNlaXZlckRyYWluID0gdHJ1ZTtcbiAgICAgIGlmICghd3MuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpbikgd3MuX3NvY2tldC5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cy5zZW5kKGNodW5rLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgZHVwbGV4Lm9uKCdlbmQnLCBkdXBsZXhPbkVuZCk7XG4gIGR1cGxleC5vbignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgcmV0dXJuIGR1cGxleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXZWJTb2NrZXRTdHJlYW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnRyeSB7XG4gIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICBleHBvcnRzLmlzVmFsaWRVVEY4ID1cbiAgICB0eXBlb2YgaXNWYWxpZFVURjggPT09ICdvYmplY3QnXG4gICAgICA/IGlzVmFsaWRVVEY4LlZhbGlkYXRpb24uaXNWYWxpZFVURjggLy8gdXRmLTgtdmFsaWRhdGVAPDMuMC4wXG4gICAgICA6IGlzVmFsaWRVVEY4O1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICBleHBvcnRzLmlzVmFsaWRVVEY4ID0gKCkgPT4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGF0dXMgY29kZSBpcyBhbGxvd2VkIGluIGEgY2xvc2UgZnJhbWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN0YXR1cyBjb2RlIGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5pc1ZhbGlkU3RhdHVzQ29kZSA9IChjb2RlKSA9PiB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxuICAgICAgY29kZSA8PSAxMDE0ICYmXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXG4gICAgICBjb2RlICE9PSAxMDA2KSB8fFxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxuICApO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCB7IGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBjcmVhdGVTZXJ2ZXIsIFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnaHR0cCcpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyBHVUlELCBrV2ViU29ja2V0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrZXlSZWdleCA9IC9eWysvMC05QS1aYS16XXsyMn09PSQvO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmJhY2tsb2cgVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZiBwZW5kaW5nXG4gICAqICAgICBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuY2xpZW50VHJhY2tpbmcgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHRyYWNrXG4gICAqICAgICBjbGllbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmhvc3QgVGhlIGhvc3RuYW1lIHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5tYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5ub1NlcnZlciBFbmFibGUgbm8gc2VydmVyIG1vZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucGF0aCBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucG9ydCBUaGUgcG9ydCB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtodHRwLlNlcnZlcn0gb3B0aW9ucy5zZXJ2ZXIgQSBwcmUtY3JlYXRlZCBIVFRQL1Mgc2VydmVyIHRvIHVzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnZlcmlmeUNsaWVudCBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgbGlzdGVuZXIgZm9yIHRoZSBgbGlzdGVuaW5nYCBldmVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ09uZSBvZiB0aGUgXCJwb3J0XCIsIFwic2VydmVyXCIsIG9yIFwibm9TZXJ2ZXJcIiBvcHRpb25zIG11c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGNyZWF0ZVNlcnZlcigocmVxLCByZXMpID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9IFNUQVRVU19DT0RFU1s0MjZdO1xuXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsICh3cykgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uJywgd3MsIHJlcSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID09PSB0cnVlKSBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50VHJhY2tpbmcpIHRoaXMuY2xpZW50cyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kIGFkZHJlc3MsIHRoZSBhZGRyZXNzIGZhbWlseSBuYW1lLCBhbmQgcG9ydCBvZiB0aGUgc2VydmVyXG4gICAqIGFzIHJlcG9ydGVkIGJ5IHRoZSBvcGVyYXRpbmcgc3lzdGVtIGlmIGxpc3RlbmluZyBvbiBhbiBJUCBzb2NrZXQuXG4gICAqIElmIHRoZSBzZXJ2ZXIgaXMgbGlzdGVuaW5nIG9uIGEgcGlwZSBvciBVTklYIGRvbWFpbiBzb2NrZXQsIHRoZSBuYW1lIGlzXG4gICAqIHJldHVybmVkIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoT2JqZWN0fFN0cmluZ3xudWxsKX0gVGhlIGFkZHJlc3Mgb2YgdGhlIHNlcnZlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRyZXNzKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBvcGVyYXRpbmcgaW4gXCJub1NlcnZlclwiIG1vZGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3NlcnZlcikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuX3NlcnZlci5hZGRyZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICAvL1xuICAgIC8vIFRlcm1pbmF0ZSBhbGwgYXNzb2NpYXRlZCBjbGllbnRzLlxuICAgIC8vXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpcy5jbGllbnRzKSBjbGllbnQudGVybWluYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgaWYgKHNlcnZlcikge1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gQ2xvc2UgdGhlIGh0dHAgc2VydmVyIGlmIGl0IHdhcyBpbnRlcm5hbGx5IGNyZWF0ZWQuXG4gICAgICAvL1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHRoaXMuZW1pdCgnY2xvc2UnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogU2VlIGlmIGEgZ2l2ZW4gcmVxdWVzdCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGlzIHNlcnZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFJlcXVlc3Qgb2JqZWN0IHRvIGluc3BlY3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSByZXF1ZXN0IGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2hvdWxkSGFuZGxlKHJlcSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGF0aCkge1xuICAgICAgY29uc3QgaW5kZXggPSByZXEudXJsLmluZGV4T2YoJz8nKTtcbiAgICAgIGNvbnN0IHBhdGhuYW1lID0gaW5kZXggIT09IC0xID8gcmVxLnVybC5zbGljZSgwLCBpbmRleCkgOiByZXEudXJsO1xuXG4gICAgICBpZiAocGF0aG5hbWUgIT09IHRoaXMub3B0aW9ucy5wYXRoKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgSFRUUCBVcGdyYWRlIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIGNvbnN0IGtleSA9XG4gICAgICByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10udHJpbSgpXG4gICAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgdmVyc2lvbiA9ICtyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgcmVxLm1ldGhvZCAhPT0gJ0dFVCcgfHxcbiAgICAgIHJlcS5oZWFkZXJzLnVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcgfHxcbiAgICAgICFrZXkgfHxcbiAgICAgICFrZXlSZWdleC50ZXN0KGtleSkgfHxcbiAgICAgICh2ZXJzaW9uICE9PSA4ICYmIHZlcnNpb24gIT09IDEzKSB8fFxuICAgICAgIXRoaXMuc2hvdWxkSGFuZGxlKHJlcSlcbiAgICApIHtcbiAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdGhpcy5vcHRpb25zLm1heFBheWxvYWRcbiAgICAgICk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9mZmVycyA9IHBhcnNlKHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXSk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5jb25uZWN0aW9uLmF1dGhvcml6ZWQgfHwgcmVxLmNvbm5lY3Rpb24uZW5jcnlwdGVkKSxcbiAgICAgICAgcmVxXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvLCAodmVyaWZpZWQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpID0+IHtcbiAgICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlIHx8IDQwMSwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoa2V5LCBleHRlbnNpb25zLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoa2V5LCBleHRlbnNpb25zLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZ3JhZGUgdGhlIGNvbm5lY3Rpb24gdG8gV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSB2YWx1ZSBvZiB0aGUgYFNlYy1XZWJTb2NrZXQtS2V5YCBoZWFkZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSBzb2NrZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbXBsZXRlVXBncmFkZShrZXksIGV4dGVuc2lvbnMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lICcgK1xuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBjb25zdCBoZWFkZXJzID0gW1xuICAgICAgJ0hUVFAvMS4xIDEwMSBTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcbiAgICAgICdVcGdyYWRlOiB3ZWJzb2NrZXQnLFxuICAgICAgJ0Nvbm5lY3Rpb246IFVwZ3JhZGUnLFxuICAgICAgYFNlYy1XZWJTb2NrZXQtQWNjZXB0OiAke2RpZ2VzdH1gXG4gICAgXTtcblxuICAgIGNvbnN0IHdzID0gbmV3IFdlYlNvY2tldChudWxsKTtcbiAgICBsZXQgcHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuXG4gICAgaWYgKHByb3RvY29sKSB7XG4gICAgICBwcm90b2NvbCA9IHByb3RvY29sLnRyaW0oKS5zcGxpdCgvICosICovKTtcblxuICAgICAgLy9cbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAgIC8vXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scykge1xuICAgICAgICBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMocHJvdG9jb2wsIHJlcSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm90b2NvbCA9IHByb3RvY29sWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LVByb3RvY29sOiAke3Byb3RvY29sfWApO1xuICAgICAgICB3cy5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0KHtcbiAgICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBbcGFyYW1zXVxuICAgICAgfSk7XG4gICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcbiAgICAgIHdzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IGV4dGVybmFsIG1vZGlmaWNhdGlvbi9pbnNwZWN0aW9uIG9mIGhhbmRzaGFrZSBoZWFkZXJzLlxuICAgIC8vXG4gICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgaGVhZGVycywgcmVxKTtcblxuICAgIHNvY2tldC53cml0ZShoZWFkZXJzLmNvbmNhdCgnXFxyXFxuJykuam9pbignXFxyXFxuJykpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHdzLnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkKTtcblxuICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgIHRoaXMuY2xpZW50cy5hZGQod3MpO1xuICAgICAgd3Mub24oJ2Nsb3NlJywgKCkgPT4gdGhpcy5jbGllbnRzLmRlbGV0ZSh3cykpO1xuICAgIH1cblxuICAgIGNiKHdzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXJzIHdoZW4gY2FsbGVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnMoc2VydmVyLCBtYXApIHtcbiAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyhtYXApKSBzZXJ2ZXIub24oZXZlbnQsIG1hcFtldmVudF0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyhtYXApKSB7XG4gICAgICBzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIG1hcFtldmVudF0pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBFbWl0IGEgYCdjbG9zZSdgIGV2ZW50IG9uIGFuIGBFdmVudEVtaXR0ZXJgLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRDbG9zZShzZXJ2ZXIpIHtcbiAgc2VydmVyLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbi8qKlxuICogSGFuZGxlIHByZW1hdHVyZSBzb2NrZXQgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIHRoaXMuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cbiAqXG4gKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICBpZiAoc29ja2V0LndyaXRhYmxlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgU1RBVFVTX0NPREVTW2NvZGVdO1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBDb25uZWN0aW9uOiAnY2xvc2UnLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnLFxuICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogQnVmZmVyLmJ5dGVMZW5ndGgobWVzc2FnZSksXG4gICAgICAuLi5oZWFkZXJzXG4gICAgfTtcblxuICAgIHNvY2tldC53cml0ZShcbiAgICAgIGBIVFRQLzEuMSAke2NvZGV9ICR7U1RBVFVTX0NPREVTW2NvZGVdfVxcclxcbmAgK1xuICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgICAuam9pbignXFxyXFxuJykgK1xuICAgICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICAgIG1lc3NhZ2VcbiAgICApO1xuICB9XG5cbiAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICBzb2NrZXQuZGVzdHJveSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21CeXRlcywgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xuY29uc3QgU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIEdVSUQsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0LFxuICBOT09QXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9ldmVudC10YXJnZXQnKTtcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IHsgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBXZWJTb2NrZXRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8dXJsLlVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xTdHJpbmdbXSl9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgIHRoaXMucHJvdG9jb2wgPSAnJztcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZU1lc3NhZ2UgPSAnJztcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICAgIHByb3RvY29scyA9IHByb3RvY29scy5qb2luKCcsICcpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHByb3RvY29scztcbiAgICAgICAgcHJvdG9jb2xzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQodGhpcywgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBDT05ORUNUSU5HKCkge1xuICAgIHJldHVybiBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgfVxuICBnZXQgQ0xPU0lORygpIHtcbiAgICByZXR1cm4gV2ViU29ja2V0LkNMT1NJTkc7XG4gIH1cbiAgZ2V0IENMT1NFRCgpIHtcbiAgICByZXR1cm4gV2ViU29ja2V0LkNMT1NFRDtcbiAgfVxuICBnZXQgT1BFTigpIHtcbiAgICByZXR1cm4gV2ViU29ja2V0Lk9QRU47XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBkZXZpYXRlcyBmcm9tIHRoZSBXSEFUV0cgaW50ZXJmYWNlIHNpbmNlIHdzIGRvZXNuJ3Qgc3VwcG9ydCB0aGVcbiAgICogcmVxdWlyZWQgZGVmYXVsdCBcImJsb2JcIiB0eXBlIChpbnN0ZWFkIHdlIGRlZmluZSBhIGN1c3RvbSBcIm5vZGVidWZmZXJcIlxuICAgKiB0eXBlKS5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBiaW5hcnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xuXG4gICAgLy9cbiAgICAvLyBgc29ja2V0LmJ1ZmZlclNpemVgIGlzIGB1bmRlZmluZWRgIGlmIHRoZSBzb2NrZXQgaXMgY2xvc2VkLlxuICAgIC8vXG4gICAgcmV0dXJuICh0aGlzLl9zb2NrZXQuYnVmZmVyU2l6ZSB8fCAwKSArIHRoaXMuX3NlbmRlci5fYnVmZmVyZWRCeXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGV4dGVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2V4dGVuc2lvbnMpLmpvaW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIHNvY2tldCBhbmQgdGhlIGludGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4UGF5bG9hZCBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgbWF4UGF5bG9hZCkge1xuICAgIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKFxuICAgICAgdGhpcy5fYmluYXJ5VHlwZSxcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnMsXG4gICAgICB0aGlzLl9pc1NlcnZlcixcbiAgICAgIG1heFBheWxvYWRcbiAgICApO1xuXG4gICAgdGhpcy5fc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMpO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlci5vbigncGluZycsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuICAgIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIHNvY2tldC5zZXROb0RlbGF5KCk7XG5cbiAgICBpZiAoaGVhZC5sZW5ndGggPiAwKSBzb2NrZXQudW5zaGlmdChoZWFkKTtcblxuICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgICBzb2NrZXQub24oJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgdGhlIGAnY2xvc2UnYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRDbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgKlxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXG4gICAqICAgICAtIC0gLXx3cy5jbG9zZSgpfC0tPnxjbG9zZSBmcmFtZXwtLT58d3MuY2xvc2UoKXwtIC0gLVxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XG4gICAqIENMT1NJTkcgIHx3cy5jbG9zZSgpfDwtLXxjbG9zZSBmcmFtZXw8LS0rLS0tLS0rICAgICAgIENMT1NJTkdcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcbiAgICogICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tPnxmaW58IC0gLSAtIC1cbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xuICAgKiAgICAgLSAtIC0gLSAtfGZpbnw8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgKy0tLStcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgU3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBBIHN0cmluZyBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcpIHtcbiAgICAgIGlmICh0aGlzLl9jbG9zZUZyYW1lU2VudCAmJiB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQpIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLl9zZW5kZXIuY2xvc2UoY29kZSwgZGF0YSwgIXRoaXMuX2lzU2VydmVyLCAoZXJyKSA9PiB7XG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyBoYW5kbGVkIGJ5IHRoZSBgJ2Vycm9yJ2AgbGlzdGVuZXIgb24gdGhlIHNvY2tldC4gV2Ugb25seVxuICAgICAgLy8gd2FudCB0byBrbm93IGlmIHRoZSBjbG9zZSBmcmFtZSBoYXMgYmVlbiBzZW50IGhlcmUuXG4gICAgICAvL1xuICAgICAgaWYgKGVycikgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkKSB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgfSk7XG5cbiAgICAvL1xuICAgIC8vIFNwZWNpZnkgYSB0aW1lb3V0IGZvciB0aGUgY2xvc2luZyBoYW5kc2hha2UgdG8gY29tcGxldGUuXG4gICAgLy9cbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gc2V0VGltZW91dChcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95LmJpbmQodGhpcy5fc29ja2V0KSxcbiAgICAgIGNsb3NlVGltZW91dFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFzayBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuY29tcHJlc3MgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmJpbmFyeSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZpbiBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5tYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIGRhdGEgaXMgd3JpdHRlbiBvdXRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBiaW5hcnk6IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyxcbiAgICAgIG1hc2s6ICF0aGlzLl9pc1NlcnZlcixcbiAgICAgIGNvbXByZXNzOiB0cnVlLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZW5kZXIuc2VuZChkYXRhIHx8IEVNUFRZX0JVRkZFUiwgb3B0cywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNpYmx5IGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cblxucmVhZHlTdGF0ZXMuZm9yRWFjaCgocmVhZHlTdGF0ZSwgaSkgPT4ge1xuICBXZWJTb2NrZXRbcmVhZHlTdGF0ZV0gPSBpO1xufSk7XG5cbi8vXG4vLyBBZGQgdGhlIGBvbm9wZW5gLCBgb25lcnJvcmAsIGBvbmNsb3NlYCwgYW5kIGBvbm1lc3NhZ2VgIGF0dHJpYnV0ZXMuXG4vLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuLy9cblsnb3BlbicsICdlcnJvcicsICdjbG9zZScsICdtZXNzYWdlJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBsaXN0ZW5lciBvZiB0aGUgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsoRnVuY3Rpb258dW5kZWZpbmVkKX0gVGhlIGV2ZW50IGxpc3RlbmVyIG9yIGB1bmRlZmluZWRgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKG1ldGhvZCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldLl9saXN0ZW5lcikgcmV0dXJuIGxpc3RlbmVyc1tpXS5fbGlzdGVuZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXQobGlzdGVuZXIpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKG1ldGhvZCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvL1xuICAgICAgICAvLyBSZW1vdmUgb25seSB0aGUgbGlzdGVuZXJzIGFkZGVkIHZpYSBgYWRkRXZlbnRMaXN0ZW5lcmAuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyKSB0aGlzLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbldlYlNvY2tldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5XZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgV2ViU29ja2V0IGNsaWVudC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBjbGllbnQgdG8gaW5pdGlhbGl6ZVxuICogQHBhcmFtIHsoU3RyaW5nfHVybC5VUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSBFbmFibGUvZGlzYWJsZVxuICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuaGFuZHNoYWtlVGltZW91dCBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlXG4gKiAgICAgaGFuZHNoYWtlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnByb3RvY29sVmVyc2lvbiBWYWx1ZSBvZiB0aGUgYFNlYy1XZWJTb2NrZXQtVmVyc2lvbmBcbiAqICAgICBoZWFkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLm9yaWdpbiBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3JcbiAqICAgICBgU2VjLVdlYlNvY2tldC1PcmlnaW5gIGhlYWRlclxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWF4UGF5bG9hZCBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZvbGxvd1JlZGlyZWN0cyBXaGV0aGVyIG9yIG5vdCB0byBmb2xsb3cgcmVkaXJlY3RzXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5tYXhSZWRpcmVjdHMgVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlZGlyZWN0cyBhbGxvd2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBwcm90b2NvbFZlcnNpb246IHByb3RvY29sVmVyc2lvbnNbMV0sXG4gICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXG4gICAgZm9sbG93UmVkaXJlY3RzOiBmYWxzZSxcbiAgICBtYXhSZWRpcmVjdHM6IDEwLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgY3JlYXRlQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogdW5kZWZpbmVkLFxuICAgIGhvc3Q6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgcG9ydDogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKCFwcm90b2NvbFZlcnNpb25zLmluY2x1ZGVzKG9wdHMucHJvdG9jb2xWZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgYFVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7b3B0cy5wcm90b2NvbFZlcnNpb259IGAgK1xuICAgICAgICBgKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oJywgJyl9KWBcbiAgICApO1xuICB9XG5cbiAgbGV0IHBhcnNlZFVybDtcblxuICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHBhcnNlZFVybCA9IGFkZHJlc3M7XG4gICAgd2Vic29ja2V0LnVybCA9IGFkZHJlc3MuaHJlZjtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZWRVcmwgPSBuZXcgVVJMKGFkZHJlc3MpO1xuICAgIHdlYnNvY2tldC51cmwgPSBhZGRyZXNzO1xuICB9XG5cbiAgY29uc3QgaXNVbml4U29ja2V0ID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xuXG4gIGlmICghcGFyc2VkVXJsLmhvc3QgJiYgKCFpc1VuaXhTb2NrZXQgfHwgIXBhcnNlZFVybC5wYXRobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVVJMOiAke3dlYnNvY2tldC51cmx9YCk7XG4gIH1cblxuICBjb25zdCBpc1NlY3VyZSA9XG4gICAgcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOicgfHwgcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgY29uc3QgZGVmYXVsdFBvcnQgPSBpc1NlY3VyZSA/IDQ0MyA6IDgwO1xuICBjb25zdCBrZXkgPSByYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICBjb25zdCBnZXQgPSBpc1NlY3VyZSA/IGh0dHBzLmdldCA6IGh0dHAuZ2V0O1xuICBsZXQgcGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID0gaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdDtcbiAgb3B0cy5kZWZhdWx0UG9ydCA9IG9wdHMuZGVmYXVsdFBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMucG9ydCA9IHBhcnNlZFVybC5wb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLmhvc3QgPSBwYXJzZWRVcmwuaG9zdG5hbWUuc3RhcnRzV2l0aCgnWycpXG4gICAgPyBwYXJzZWRVcmwuaG9zdG5hbWUuc2xpY2UoMSwgLTEpXG4gICAgOiBwYXJzZWRVcmwuaG9zdG5hbWU7XG4gIG9wdHMuaGVhZGVycyA9IHtcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXG4gICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxuICAgIENvbm5lY3Rpb246ICdVcGdyYWRlJyxcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0JyxcbiAgICAuLi5vcHRzLmhlYWRlcnNcbiAgfTtcbiAgb3B0cy5wYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lICsgcGFyc2VkVXJsLnNlYXJjaDtcbiAgb3B0cy50aW1lb3V0ID0gb3B0cy5oYW5kc2hha2VUaW1lb3V0O1xuXG4gIGlmIChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlICE9PSB0cnVlID8gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA6IHt9LFxuICAgICAgZmFsc2UsXG4gICAgICBvcHRzLm1heFBheWxvYWRcbiAgICApO1xuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJ10gPSBmb3JtYXQoe1xuICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBwZXJNZXNzYWdlRGVmbGF0ZS5vZmZlcigpXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb3RvY29scykge1xuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1Qcm90b2NvbCddID0gcHJvdG9jb2xzO1xuICB9XG4gIGlmIChvcHRzLm9yaWdpbikge1xuICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSBvcHRzLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgIG9wdHMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgfVxuXG4gIGlmIChpc1VuaXhTb2NrZXQpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG9wdHMucGF0aC5zcGxpdCgnOicpO1xuXG4gICAgb3B0cy5zb2NrZXRQYXRoID0gcGFydHNbMF07XG4gICAgb3B0cy5wYXRoID0gcGFydHNbMV07XG4gIH1cblxuICBsZXQgcmVxID0gKHdlYnNvY2tldC5fcmVxID0gZ2V0KG9wdHMpKTtcblxuICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgcmVxLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdPcGVuaW5nIGhhbmRzaGFrZSBoYXMgdGltZWQgb3V0Jyk7XG4gICAgfSk7XG4gIH1cblxuICByZXEub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgIGlmICh3ZWJzb2NrZXQuX3JlcS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG4gICAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbiAgfSk7XG5cbiAgcmVxLm9uKCdyZXNwb25zZScsIChyZXMpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmxvY2F0aW9uO1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcblxuICAgIGlmIChcbiAgICAgIGxvY2F0aW9uICYmXG4gICAgICBvcHRzLmZvbGxvd1JlZGlyZWN0cyAmJlxuICAgICAgc3RhdHVzQ29kZSA+PSAzMDAgJiZcbiAgICAgIHN0YXR1c0NvZGUgPCA0MDBcbiAgICApIHtcbiAgICAgIGlmICgrK3dlYnNvY2tldC5fcmVkaXJlY3RzID4gb3B0cy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdNYXhpbXVtIHJlZGlyZWN0cyBleGNlZWRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcS5hYm9ydCgpO1xuXG4gICAgICBjb25zdCBhZGRyID0gbmV3IFVSTChsb2NhdGlvbiwgYWRkcmVzcyk7XG5cbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICghd2Vic29ja2V0LmVtaXQoJ3VuZXhwZWN0ZWQtcmVzcG9uc2UnLCByZXEsIHJlcykpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgIHJlcSxcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXEub24oJ3VwZ3JhZGUnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlIGB1cGdyYWRlYFxuICAgIC8vIGV2ZW50LlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgY29uc3QgcHJvdExpc3QgPSAocHJvdG9jb2xzIHx8ICcnKS5zcGxpdCgvLCAqLyk7XG4gICAgbGV0IHByb3RFcnJvcjtcblxuICAgIGlmICghcHJvdG9jb2xzICYmIHNlcnZlclByb3QpIHtcbiAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhIHN1YnByb3RvY29sIGJ1dCBub25lIHdhcyByZXF1ZXN0ZWQnO1xuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xzICYmICFzZXJ2ZXJQcm90KSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xuICAgIH0gZWxzZSBpZiAoc2VydmVyUHJvdCAmJiAhcHJvdExpc3QuaW5jbHVkZXMoc2VydmVyUHJvdCkpIHtcbiAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhbiBpbnZhbGlkIHN1YnByb3RvY29sJztcbiAgICB9XG5cbiAgICBpZiAocHJvdEVycm9yKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0LnByb3RvY29sID0gc2VydmVyUHJvdDtcblxuICAgIGlmIChwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHBhcnNlKHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXSk7XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1xuICAgICAgICAgICAgUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxuICAgICAgICAgIF0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICAgIHdlYnNvY2tldCxcbiAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdlYnNvY2tldC5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCBvcHRzLm1heFBheWxvYWQpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgbmV0LlNvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge25ldC5Tb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZXRDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gb3B0aW9ucy5zb2NrZXRQYXRoO1xuICByZXR1cm4gbmV0LmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYHRscy5UTFNTb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHt0bHMuVExTU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGxzQ29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IHVuZGVmaW5lZDtcblxuICBpZiAoIW9wdGlvbnMuc2VydmVybmFtZSAmJiBvcHRpb25zLnNlcnZlcm5hbWUgIT09ICcnKSB7XG4gICAgb3B0aW9ucy5zZXJ2ZXJuYW1lID0gb3B0aW9ucy5ob3N0O1xuICB9XG5cbiAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEFib3J0IHRoZSBoYW5kc2hha2UgYW5kIGVtaXQgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyhodHRwLkNsaWVudFJlcXVlc3R8bmV0LlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0byBhYm9ydCBvciB0aGVcbiAqICAgICBzb2NrZXQgdG8gZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc3RyZWFtLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldC5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFib3J0SGFuZHNoYWtlKTtcblxuICBpZiAoc3RyZWFtLnNldEhlYWRlcikge1xuICAgIHN0cmVhbS5hYm9ydCgpO1xuICAgIHN0cmVhbS5vbmNlKCdhYm9ydCcsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgd2Vic29ja2V0LmVtaXQuYmluZCh3ZWJzb2NrZXQsICdlcnJvcicpKTtcbiAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgY2FzZXMgd2hlcmUgdGhlIGBwaW5nKClgLCBgcG9uZygpYCwgb3IgYHNlbmQoKWAgbWV0aG9kcyBhcmUgY2FsbGVkXG4gKiB3aGVuIHRoZSBgcmVhZHlTdGF0ZWAgYXR0cmlidXRlIGlzIGBDTE9TSU5HYCBvciBgQ0xPU0VEYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZEFmdGVyQ2xvc2Uod2Vic29ja2V0LCBkYXRhLCBjYikge1xuICBpZiAoZGF0YSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRvQnVmZmVyKGRhdGEpLmxlbmd0aDtcblxuICAgIC8vXG4gICAgLy8gVGhlIGBfYnVmZmVyZWRBbW91bnRgIHByb3BlcnR5IGlzIHVzZWQgb25seSB3aGVuIHRoZSBwZWVyIGlzIGEgY2xpZW50IGFuZFxuICAgIC8vIHRoZSBvcGVuaW5nIGhhbmRzaGFrZSBmYWlscy4gVW5kZXIgdGhlc2UgY2lyY3Vtc3RhbmNlcywgaW4gZmFjdCwgdGhlXG4gICAgLy8gYHNldFNvY2tldCgpYCBtZXRob2QgaXMgbm90IGNhbGxlZCwgc28gdGhlIGBfc29ja2V0YCBhbmQgYF9zZW5kZXJgXG4gICAgLy8gcHJvcGVydGllcyBhcmUgc2V0IHRvIGBudWxsYC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQuX3NvY2tldCkgd2Vic29ja2V0Ll9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXMgKz0gbGVuZ3RoO1xuICAgIGVsc2Ugd2Vic29ja2V0Ll9idWZmZXJlZEFtb3VudCArPSBsZW5ndGg7XG4gIH1cblxuICBpZiAoY2IpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7d2Vic29ja2V0LnJlYWR5U3RhdGV9IGAgK1xuICAgICAgICBgKCR7cmVhZHlTdGF0ZXNbd2Vic29ja2V0LnJlYWR5U3RhdGVdfSlgXG4gICAgKTtcbiAgICBjYihlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnY29uY2x1ZGUnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb24gVGhlIHJlYXNvbiBmb3IgY2xvc2luZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkNvbmNsdWRlKGNvZGUsIHJlYXNvbikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgd2Vic29ja2V0Ll9zb2NrZXQucmVzdW1lKCk7XG5cbiAgd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgPSB0cnVlO1xuICB3ZWJzb2NrZXQuX2Nsb3NlTWVzc2FnZSA9IHJlYXNvbjtcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBjb2RlO1xuXG4gIGlmIChjb2RlID09PSAxMDA1KSB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgZWxzZSB3ZWJzb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdkcmFpbidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25EcmFpbigpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5fc29ja2V0LnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoUmFuZ2VFcnJvcnxFcnJvcil9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcblxuICB3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICB3ZWJzb2NrZXQuX2Nsb3NlQ29kZSA9IGVycltrU3RhdHVzQ29kZV07XG4gIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIHdlYnNvY2tldC5fc29ja2V0LmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdmaW5pc2gnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRmluaXNoKCkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ21lc3NhZ2UnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgbWVzc2FnZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbk1lc3NhZ2UoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwaW5nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBpbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25QaW5nKGRhdGEpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQucG9uZyhkYXRhLCAhd2Vic29ja2V0Ll9pc1NlcnZlciwgTk9PUCk7XG4gIHdlYnNvY2tldC5lbWl0KCdwaW5nJywgZGF0YSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncG9uZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwb25nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUG9uZyhkYXRhKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgncG9uZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnY2xvc2UnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkNsb3NlKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHNvY2tldE9uRW5kKTtcblxuICB3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIC8vXG4gIC8vIFRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgaGF2ZSBiZWVuIHJlY2VpdmVkIG9yIHRoZSBgJ2VuZCdgIGV2ZW50IGVtaXR0ZWQsXG4gIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgc29ja2V0IHdhcyBkZXN0cm95ZWQgZHVlIHRvIGFuIGVycm9yLiBFbnN1cmUgdGhhdCB0aGVcbiAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXG4gIC8vIGl0LiBJZiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgc29ja2V0IGlzIGluIGZsb3dpbmcgbW9kZSB0aGVuIHRoZXJlIGlzIG5vXG4gIC8vIGJ1ZmZlcmVkIGRhdGEgYXMgZXZlcnl0aGluZyBoYXMgYmVlbiBhbHJlYWR5IHdyaXR0ZW4gYW5kIGByZWFkYWJsZS5yZWFkKClgXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYC4gSWYgaW5zdGVhZCwgdGhlIHNvY2tldCBpcyBwYXVzZWQsIGFueSBwb3NzaWJsZSBidWZmZXJlZFxuICAvLyBkYXRhIHdpbGwgYmUgcmVhZCBhcyBhIHNpbmdsZSBjaHVuayBhbmQgZW1pdHRlZCBzeW5jaHJvbm91c2x5IGluIGEgc2luZ2xlXG4gIC8vIGAnZGF0YSdgIGV2ZW50LlxuICAvL1xuICB3ZWJzb2NrZXQuX3NvY2tldC5yZWFkKCk7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0LnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcbiAgdGhpcy5lbmQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICB0aGlzLm9uKCdlcnJvcicsIE5PT1ApO1xuXG4gIGlmICh3ZWJzb2NrZXQpIHtcbiAgICB3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAndGhyZWUvc3JjL21hdGgvVmVjdG9yMyc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAndGhyZWUvc3JjL21hdGgvUXVhdGVybmlvbic7XG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJ3RocmVlL3NyYy9jb3JlL09iamVjdDNEJztcblxuZ2xvYmFsLmRlYnVnID0gKC4uLnBhcmFtcykgPT4gY29uc29sZS5sb2coYFskeyhuZXcgRGF0ZSkudG9Mb2NhbGVUaW1lU3RyaW5nKCl9XWAsIC4uLnBhcmFtcyk7XG5cbmNsYXNzIE9iajNEIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRjb25zdHJ1Y3RvciguLi5wcm9wcykge1xuXHRcdHN1cGVyKC4uLnByb3BzKTtcblx0XHR0aGlzLnNjZW5lID0gdGhpcztcblx0fVxufVxuXG5nbG9iYWwuVEhSRUUgPSB7XG5cdFZlY3RvcjMsXG5cdFF1YXRlcm5pb24sXG5cdE9iamVjdDNEOiBPYmozRCxcblx0V2ViR0xSZW5kZXJlcjogKCkgPT4gKHtcblx0XHRyZW5kZXI6ICgpID0+ICh7fSksXG5cdFx0c2V0U2l6ZTogKCkgPT4gKHt9KSxcblx0XHRnZXRDb250ZXh0OiAoKSA9PiAoe1xuXHRcdFx0Y2FudmFzOiB7XG5cdFx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0XHRoZWlnaHQ6IDBcblx0XHRcdH0sXG5cdFx0fSksXG5cdFx0c2hhZG93TWFwOiB7fSxcblx0fSksXG5cdFNjZW5lOiBPYmozRCxcblx0Q2FjaGU6IHt9LFxuXHRDbG9jazogKCkgPT4gKHt9KSxcblx0QW5pbWF0aW9uTWl4ZXI6ICgpID0+ICh7XG5cdFx0dXBkYXRlOiAoKSA9PiAoe30pLFxuXHRcdGNsaXBBY3Rpb246ICgpID0+ICh7XG5cdFx0XHRzdG9wOiAoKSA9PiAoe30pLFxuXHRcdH0pLFxuXHR9KSxcblx0UENGU29mdFNoYWRvd01hcDogKCkgPT4gKHt9KSxcblx0UGVyc3BlY3RpdmVDYW1lcmE6IE9iajNELFxuXHRSYXljYXN0ZXI6ICgpID0+ICh7fSksXG5cdFRleHR1cmVMb2FkZXI6ICgpID0+ICh7XG5cdFx0bG9hZDogKCkgPT4gKHt9KSxcblx0fSksXG5cdEZvZzogKCkgPT4gKHt9KSxcblx0UmVwZWF0V3JhcHBpbmc6ICgpID0+ICh7fSksXG5cdENvbG9yOiAoKSA9PiAoe30pLFxuXHRNZXNoOiBPYmozRCxcblx0Q3ViZUdlb21ldHJ5OiAoKSA9PiAoe30pLFxuXHRNZXNoTGFtYmVydE1hdGVyaWFsOiAoKSA9PiAoe30pLFxuXHROb3JtYWxCbGVuZGluZzogKCkgPT4gKHt9KSxcblx0QWRkaXRpdmVCbGVuZGluZzogKCkgPT4gKHt9KSxcblx0R2VvbWV0cnk6ICgpID0+ICh7fSksXG5cdFBvaW50Q2xvdWRNYXRlcmlhbDogKCkgPT4gKHt9KSxcblx0UG9pbnRDbG91ZDogKCkgPT4gKHt9KSxcblx0QW1iaWVudExpZ2h0OiAoKSA9PiAoe30pLFxuXHREaXJlY3Rpb25hbExpZ2h0OiAoKSA9PiB7XG5cdFx0Y29uc3QgbGlnaHQgPSBuZXcgT2JqM0QoKTtcblx0XHRsaWdodC5zaGFkb3cgPSB7XG5cdFx0XHRjYW1lcmE6IHt9LFxuXHRcdFx0bWFwU2l6ZToge30sXG5cdFx0fTtcblx0XHRyZXR1cm4gbGlnaHQ7XG5cdH0sXG5cdE1lc2hCYXNpY01hdGVyaWFsOiAoKSA9PiAoe30pLFxuXHRCYWNrU2lkZTogKCkgPT4gKHt9KSxcblx0TWVzaEZhY2VNYXRlcmlhbDogKCkgPT4gKHt9KSxcbn07XG5cbmdsb2JhbC5HTFRGTG9hZGVyID0gKCkgPT4gKHtcblx0bG9hZDogKHVybCwgY2FsbGJhY2spID0+IGNhbGxiYWNrKG5ldyBPYmozRCgpKSxcbn0pO1xuXG5nbG9iYWwud2luZG93ID0ge1xuXHRpbm5lcldpZHRoOiAwLFxuXHRpbm5lckhlaWdodDogMCxcblx0Y2xlYXJUaW1lb3V0OiAwLFxuXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZuID0+IHNldFRpbWVvdXQoZm4sIDEwMDAgLyA2MCksXG5cdGxvY2F0aW9uOiB7XG5cdFx0cmVsb2FkOiAoKSA9PiBkZWJ1ZygncmVsb2FkIHBhZ2UnKSxcblx0fSxcblx0YWRkRXZlbnRMaXN0ZW5lcjogKC4uLnBhcmFtcykgPT4gZGVidWcoJ3dpbmRvdy5hZGRFdmVudExpc3RlbmVyJywgLi4ucGFyYW1zKSxcblx0c2V0VGltZW91dDogc2V0VGltZW91dCxcblx0V2ViU29ja2V0OiAoKSA9PiAoe1xuXHRcdG9ub3BlbjogKC4uLnBhcmFtcykgPT4gZGVidWcoJ3dpbmRvdy5XZWJTb2NrZXQub25vcGVuJywgLi4ucGFyYW1zKSxcblx0XHRvbmVycm9yOiAoLi4ucGFyYW1zKSA9PiBkZWJ1Zygnd2luZG93LldlYlNvY2tldC5vbmVycm9yJywgLi4ucGFyYW1zKSxcblx0XHRvbm1lc3NhZ2U6ICguLi5wYXJhbXMpID0+IGRlYnVnKCd3aW5kb3cuV2ViU29ja2V0Lm9ubWVzc2FnZScsIC4uLnBhcmFtcyksXG5cdH0pLFxufTtcblxuZ2xvYmFsLmRvY3VtZW50ID0ge1xuXHRib2R5OiB7XG5cdFx0YWRkRXZlbnRMaXN0ZW5lcjogKC4uLnBhcmFtcykgPT4gZGVidWcoJ2RvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcicsIC4uLnBhcmFtcyksXG5cdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogKC4uLnBhcmFtcykgPT4gZGVidWcoJ2RvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcicsIC4uLnBhcmFtcyksXG5cdH0sXG5cdGRpc3BhdGNoRXZlbnQ6ICguLi5wYXJhbXMpID0+IGRlYnVnKCdkb2N1bWVudC5kaXNwYXRjaEV2ZW50JywgLi4ucGFyYW1zKSxcblx0Z2V0RWxlbWVudEJ5SWQ6ICguLi5wYXJhbXMpID0+IGRlYnVnKCdkb2N1bWVudC5nZXRFbGVtZW50QnlJZCcsIC4uLnBhcmFtcyksXG5cdGFkZEV2ZW50TGlzdGVuZXI6ICguLi5wYXJhbXMpID0+IGRlYnVnKCdkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyJywgLi4ucGFyYW1zKSxcblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogKC4uLnBhcmFtcykgPT4gZGVidWcoJ2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXInLCAuLi5wYXJhbXMpLFxufTtcblxuZXhwb3J0IGNvbnN0IE1vY2tHVUkgPSB7XG5cdFx0aXNTZXJ2ZXI6IHRydWUsXG5cdFx0c2V0UmVzdGFydEJ1dHRvblZpc2libGU6ICgpID0+IG51bGwsXG5cdFx0c2V0UGF1c2U6ICgpID0+IG51bGwsXG5cdFx0cmVzdGFydEdhbWU6ICgpID0+IG51bGwsXG5cdFx0aXNQYXVzZTogKCkgPT4gZmFsc2UsXG5cdFx0aXNUaGlyZFBlcnNvbjogKCkgPT4gZmFsc2UsXG5cdFx0dXBkYXRlOiAoKSA9PiBudWxsLFxuXHRcdHNldENvbm5lY3Rpb25Sb2xlOiBkZWJ1Zyxcblx0XHR1cGRhdGVQbGF5ZXJQYXJhbXM6ICgpID0+IG51bGwsXG5cdFx0Y2xlYXJIcEJhcnM6ICgpID0+IG51bGwsXG5cdFx0c3dpdGNoQ2FtZXJhOiAoKSA9PiBudWxsLFxuXHRcdHNldEZwczogKCkgPT4gbnVsbCxcblx0XHRzZXRQaW5nOiAoKSA9PiBudWxsLFxuXHRcdG5vdGlmeTogZGVidWcsXG5cdFx0c2V0TG9hZGluZzogKCkgPT4gbnVsbCxcbn07XG5cbmV4cG9ydCBjb25zdCBNb2NrUmVuZGVyZXIgPSB7XG5cdGZwczogMSxcblx0XHR0YXJnZXRGcHM6IDEsXG5cdFx0cmVuZGVyZXI6IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCksXG5cdFx0cmVuZGVyOiAoKSA9PiAoe30pLFxufTtcbiIsImltcG9ydCAqIGFzIHdzIGZyb20gJ3dzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbmNvbnN0IFdlYlNvY2tldFNlcnZlciA9IHdzLlNlcnZlcjtcblxuY2xhc3MgU29ja2V0U2VydmVyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5jcmVhdGVXZWJTZXJ2ZXIgPSB0aGlzLmNyZWF0ZVdlYlNlcnZlci5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuY3JlYXRlU29ja2V0U2VydmVyID0gdGhpcy5jcmVhdGVTb2NrZXRTZXJ2ZXIuYmluZCh0aGlzKTtcblx0XHR0aGlzLnNhdmVVc2VyRGF0YSA9IHRoaXMuc2F2ZVVzZXJEYXRhLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5sb2FkVXNlckRhdGEgPSB0aGlzLmxvYWRVc2VyRGF0YS5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuc3RhcnRTb2NrZXRTZXJ2ZXIgPSB0aGlzLnN0YXJ0U29ja2V0U2VydmVyLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5nZXRDb25uZWN0aW9uSWQgPSB0aGlzLmdldENvbm5lY3Rpb25JZC5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuc2VuZFRvQ29ubmVjdGlvbiA9IHRoaXMuc2VuZFRvQ29ubmVjdGlvbi5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuc2VuZCA9IHRoaXMuc2VuZC5iaW5kKHRoaXMpO1xuXG5cdFx0Y29uc3QgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcblxuXHRcdHRoaXMuY29uZmlnID0ge1xuXHRcdFx0c3NsOiBpc1Byb2R1Y3Rpb24sXG5cdFx0XHRwb3J0OiAxMzM3LFxuXHRcdFx0c3NsS2V5OiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi9wcml2YXRlLnBlbScpLFxuXHRcdFx0c3NsQ2VydGlmaWNhdGU6IHBhdGguam9pbihfX2Rpcm5hbWUsICcuL2Z1bGxjaGFpbi5wZW0nKSxcblx0XHRcdHNlc3Npb25zUGF0aDogcGF0aC5qb2luKF9fZGlybmFtZSwgJy4vc2Vzc2lvbnMvJyksXG5cdFx0XHRkZWJ1ZzogZmFsc2Vcblx0XHR9O1xuXG5cdFx0dGhpcy5kYiA9IHtcblx0XHRcdHNlcXVlbmNlSWQ6IDAsXG5cdFx0XHRob3N0SWQ6IG51bGwsXG5cdFx0XHRjb25uZWN0aW9uczoge30sXG5cdFx0XHRwbGF5ZXJzOiB7fSxcblx0XHRcdGdhbWVPYmplY3RzOiBbXSxcblx0XHR9O1xuXG5cdFx0Y29uc3Qgc29ja2V0U2VydmVyID0gdGhpcy5jcmVhdGVTb2NrZXRTZXJ2ZXIodGhpcy5jb25maWcpO1xuXHRcdHRoaXMuc3RhcnRTb2NrZXRTZXJ2ZXIoc29ja2V0U2VydmVyKTtcblx0fVxuXG5cdGNyZWF0ZVdlYlNlcnZlcihjb25maWcpIHtcblx0XHRjb25zdCBwcm9jZXNzUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcSwgcmVzKSB7XG5cdFx0XHRyZXMud3JpdGVIZWFkKDIwMCk7XG5cdFx0XHRyZXMuZW5kKFwiQWxsIGdsb3J5IHRvIFdlYlNvY2tldHMhXFxuXCIpO1xuXHRcdH07XG5cblx0XHRpZiAoY29uZmlnLnNzbCkge1xuXHRcdFx0Y29uc3Qgc3NsUGFyYW1zID0ge1xuXHRcdFx0XHRrZXk6IGZzLnJlYWRGaWxlU3luYyhjb25maWcuc3NsS2V5KSxcblx0XHRcdFx0Y2VydDogZnMucmVhZEZpbGVTeW5jKGNvbmZpZy5zc2xDZXJ0aWZpY2F0ZSksXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gcmVxdWlyZSgnaHR0cHMnKS5jcmVhdGVTZXJ2ZXIoc3NsUGFyYW1zLCBwcm9jZXNzUmVxdWVzdCkubGlzdGVuKGNvbmZpZy5wb3J0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHJlcXVpcmUoJ2h0dHAnKS5jcmVhdGVTZXJ2ZXIocHJvY2Vzc1JlcXVlc3QpLmxpc3Rlbihjb25maWcucG9ydCk7XG5cdFx0fVxuXHR9XG5cblx0Y3JlYXRlU29ja2V0U2VydmVyKGNvbmZpZykge1xuXHRcdGNvbnN0IHNlcnZlciA9IHRoaXMuY3JlYXRlV2ViU2VydmVyKGNvbmZpZyk7XG5cdFx0Y29uc3Qgd2ViU29ja2V0U2VydmVyID0gbmV3IFdlYlNvY2tldFNlcnZlcih7IHNlcnZlciB9KTtcblxuXHRcdGRlYnVnKGBTZXJ2ZXIgaXMgcnVubmluZyBvbiBwb3J0ICR7Y29uZmlnLnBvcnR9LiBTU0wgaXMgJHtjb25maWcuc3NsID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJ30uYCk7XG5cblx0XHRyZXR1cm4gd2ViU29ja2V0U2VydmVyO1xuXHR9XG5cblx0c2F2ZVVzZXJEYXRhKHRva2VuLCBkYXRhKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghZnMuZXhpc3RzU3luYyh0aGlzLmNvbmZpZy5zZXNzaW9uc1BhdGgpKSB7XG5cdFx0XHRcdGZzLm1rZGlyU3luYyh0aGlzLmNvbmZpZy5zZXNzaW9uc1BhdGgpO1xuXHRcdFx0fVxuXG5cdFx0XHRmcy53cml0ZUZpbGVTeW5jKGAke3RoaXMuY29uZmlnLnNlc3Npb25zUGF0aH0vJHt0b2tlbn1gLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRkZWJ1ZygnU2F2ZSB1c2VyIGRhdGEgZXJyb3InLCBlKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRsb2FkVXNlckRhdGEodG9rZW4pIHtcblx0XHRjb25zdCB0b2tlblBhdGggPSBgJHt0aGlzLmNvbmZpZy5zZXNzaW9uc1BhdGh9LyR7dG9rZW59YDtcblxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoZnMuZXhpc3RzU3luYyh0b2tlblBhdGgpKSB7XG5cdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyh0b2tlblBhdGgsICd1dGY4JykpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGRlYnVnKCdMb2FkIHVzZXIgZGF0YSBlcnJvcicsIGUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGdldENvbm5lY3Rpb25JZChjKSB7XG5cdFx0cmV0dXJuIGMuX2lkO1xuXHR9XG5cblx0c2VuZFRvQ29ubmVjdGlvbihjb25uZWN0aW9uSWQpIHtcblx0XHRjb25zdCBwbGF5ZXJzID0gdGhpcy5kYi5wbGF5ZXJzO1xuXHRcdGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmRiLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb25JZF07XG5cblx0XHRjb25zdCBnYW1lT2JqZWN0cyA9IHRoaXMuZGIuZ2FtZU9iamVjdHNcblx0XHRcdC5maWx0ZXIoZ2FtZU9iamVjdCA9PiBnYW1lT2JqZWN0LnR5cGUgIT09ICdwbGF5ZXInKTtcblxuXHRcdGNvbnN0IG5ldHdvcmtQbGF5ZXJzID0gT2JqZWN0LmtleXMocGxheWVycylcblx0XHRcdC5maWx0ZXIocGxheWVyQ29ubmVjdGlvbklkID0+IHBsYXllckNvbm5lY3Rpb25JZCAhPT0gU3RyaW5nKGNvbm5lY3Rpb25JZCkpXG5cdFx0XHQubWFwKHBsYXllckNvbm5lY3Rpb25JZCA9PiBwbGF5ZXJzW3BsYXllckNvbm5lY3Rpb25JZF0pO1xuXG5cdFx0dGhpcy5zZW5kKGNvbm5lY3Rpb24sICd1cGRhdGVHYW1lT2JqZWN0cycsIFtdLmNvbmNhdChnYW1lT2JqZWN0cywgbmV0d29ya1BsYXllcnMpKTtcblx0fVxuXG5cdHNlbmQoY29ubmVjdGlvbiwgbWVzc2FnZVR5cGUsIGRhdGEpIHtcblx0XHRjb25uZWN0aW9uLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0bWV0YToge1xuXHRcdFx0XHRzZXJ2ZXI6IHsgdmVyc2lvbjogMSB9LFxuXHRcdFx0XHRyb2xlOiB0aGlzLmdldENvbm5lY3Rpb25JZChjb25uZWN0aW9uKSA9PT0gdGhpcy5kYi5ob3N0SWQgPyAnaG9zdCcgOiAnY2xpZW50Jyxcblx0XHRcdFx0aWQ6IHRoaXMuZ2V0Q29ubmVjdGlvbklkKGNvbm5lY3Rpb24pLFxuXHRcdFx0XHR0b2tlbjogY29ubmVjdGlvbi5fbWV0YS50b2tlbixcblx0XHRcdFx0ZGVidWc6IHRoaXMuY29uZmlnLmRlYnVnLFxuXHRcdFx0fSxcblx0XHRcdGRhdGEsXG5cdFx0XHRtZXNzYWdlVHlwZSxcblx0XHR9KSk7XG5cdH1cblxuXHRzdGFydFNvY2tldFNlcnZlcihzb2NrZXRTZXJ2ZXIpIHtcblx0XHRjb25zdCBkYiA9IHRoaXMuZGI7XG5cdFx0Y29uc3QgbG9hZFVzZXJEYXRhID0gdGhpcy5sb2FkVXNlckRhdGE7XG5cdFx0Y29uc3QgZ2V0Q29ubmVjdGlvbklkID0gdGhpcy5nZXRDb25uZWN0aW9uSWQ7XG5cdFx0Y29uc3Qgc2VuZCA9IHRoaXMuc2VuZDtcblx0XHRjb25zdCBzZW5kVG9Db25uZWN0aW9uID0gdGhpcy5zZW5kVG9Db25uZWN0aW9uO1xuXHRcdGNvbnN0IGdldENvbm5lY3Rpb25Ub2tlbiA9IGMgPT4gYy5fbWV0YS50b2tlbjtcblxuXHRcdHNldEludGVydmFsKCgpID0+IHtcblx0XHRcdE9iamVjdC52YWx1ZXMoZGIuY29ubmVjdGlvbnMpLmZvckVhY2goKGNvbm5lY3Rpb24pID0+IHtcblx0XHRcdFx0Y29uc3QgY29ubmVjdGlvblBsYXllciA9IGRiLnBsYXllcnNbZ2V0Q29ubmVjdGlvbklkKGNvbm5lY3Rpb24pXTtcblx0XHRcdFx0Y29uc3QgdG9rZW4gPSBnZXRDb25uZWN0aW9uVG9rZW4oY29ubmVjdGlvbik7XG5cblx0XHRcdFx0aWYgKGNvbm5lY3Rpb25QbGF5ZXIgJiYgdG9rZW4pIHtcblx0XHRcdFx0XHR0aGlzLnNhdmVVc2VyRGF0YSh0b2tlbiwgY29ubmVjdGlvblBsYXllcik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sIDEwMDAwKTtcblxuXHRcdHNvY2tldFNlcnZlci5vbignY29ubmVjdGlvbicsIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcblx0XHRcdGNvbnN0IGlkID0gKytkYi5zZXF1ZW5jZUlkO1xuXG5cdFx0XHRkZWJ1ZygnTmV3IGNvbm5lY3Rpb24sIGlkOicsIGlkKTtcblxuXHRcdFx0ZGIuY29ubmVjdGlvbnNbaWRdID0gY29ubmVjdGlvbjtcblx0XHRcdGNvbm5lY3Rpb24uX21ldGEgPSB7IGlkIH07XG5cdFx0XHRjb25uZWN0aW9uLl9pZCA9IGlkO1xuXG5cdFx0XHRjb25zdCBvblNvY2tldENsb3NlID0gKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBpZCA9IGdldENvbm5lY3Rpb25JZChjb25uZWN0aW9uKTtcblx0XHRcdFx0ZGVidWcoJ0Nvbm5lY3Rpb24gY2xvc2VkLCBpZDonLCBpZCk7XG5cblx0XHRcdFx0T2JqZWN0LnZhbHVlcyhkYi5jb25uZWN0aW9ucykuZm9yRWFjaCgoYykgPT4ge1xuXHRcdFx0XHRcdHNlbmQoYywgJ2Rpc2Nvbm5lY3RlZCcsIHsgY29ubmVjdGlvbklkOiBpZCB9KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0ZGVsZXRlIGRiLmNvbm5lY3Rpb25zW2lkXTtcblx0XHRcdFx0ZGVsZXRlIGRiLnBsYXllcnNbaWRdO1xuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3Qgb25Tb2NrZXRNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcblx0XHRcdFx0Y29uc3QgeyBkYXRhLCBtZXNzYWdlVHlwZSwgbWV0YSB9ID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcblx0XHRcdFx0Y29uc3QgY29ubmVjdGlvbklkID0gZ2V0Q29ubmVjdGlvbklkKGNvbm5lY3Rpb24pO1xuXG5cdFx0XHRcdGlmIChtZXRhICYmIG1ldGEudG9rZW4gJiYgbWV0YS50b2tlbiAhPT0gY29ubmVjdGlvbi5fbWV0YS50b2tlbikge1xuXHRcdFx0XHRcdGRlYnVnKGBVc2VyICMke2Nvbm5lY3Rpb25JZH0gdG9rZW4gY2hhbmdlZCBmcm9tICR7Y29ubmVjdGlvbi5fbWV0YS50b2tlbn0gdG8gJHttZXRhLnRva2VufWApO1xuXHRcdFx0XHRcdGNvbm5lY3Rpb24uX21ldGEudG9rZW4gPSBtZXRhLnRva2VuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgc2VuZFVzZXJEYXRhID0gKCkgPT4ge1xuXHRcdFx0XHRcdHNlbmQoY29ubmVjdGlvbiwgJ3NldFVzZXJQbGF5ZXInLCBsb2FkVXNlckRhdGEoY29ubmVjdGlvbi5fbWV0YS50b2tlbikpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZVBsYXllckRhdGEgPSAocGxheWVyKSA9PiB7XG5cdFx0XHRcdFx0ZGIucGxheWVyc1tjb25uZWN0aW9uSWRdID0gcGxheWVyO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHN3aXRjaCAobWVzc2FnZVR5cGUpIHtcblx0XHRcdFx0XHRjYXNlICdsb2FkQ3VycmVudFVzZXInOiB7XG5cdFx0XHRcdFx0XHRzZW5kVXNlckRhdGEoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ3VwZGF0ZVBsYXllcic6IHtcblx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgcmVxdWVzdFxuXHRcdFx0XHRcdFx0dXBkYXRlUGxheWVyRGF0YShkYXRhKTtcblx0XHRcdFx0XHRcdC8vIFNlbmQgcmVzcG9uc2Vcblx0XHRcdFx0XHRcdHNlbmRUb0Nvbm5lY3Rpb24oY29ubmVjdGlvbklkKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhc2UgJ3Jlc3RhcnRTZXJ2ZXInOiB7XG5cdFx0XHRcdFx0XHQvLyByZXN0YXJ0U2VydmVyKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGNvbm5lY3Rpb24ub24oJ21lc3NhZ2UnLCBvblNvY2tldE1lc3NhZ2UpO1xuXHRcdFx0Y29ubmVjdGlvbi5vbignY2xvc2UnLCBvblNvY2tldENsb3NlKTtcblxuXHRcdFx0c2VuZChjb25uZWN0aW9uLCAnaGFuZHNoYWtlJyk7XG5cdFx0fSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU29ja2V0U2VydmVyO1xuIiwiaW1wb3J0IHsgTW9ja0dVSSwgTW9ja1JlbmRlcmVyIH0gZnJvbSAnLi9zcmMvTW9ja0RlcGVuZGVuY2llcyc7XG5pbXBvcnQgU29ja2V0U2VydmVyIGZyb20gJy4vc3JjL1NvY2tldFNlcnZlcic7XG5pbXBvcnQgU2NlbmUgZnJvbSAnLi4vY2xpZW50L3NyYy9qcy9TY2VuZSc7XG5pbXBvcnQgQ29ubmVjdGlvbiBmcm9tICcuLi9jbGllbnQvc3JjL2pzL0Nvbm5lY3Rpb24nO1xuaW1wb3J0IHsgUGxheWVyIH0gZnJvbSAnLi4vY2xpZW50L3NyYy9qcy9HYW1lT2JqZWN0cyc7XG5cbmZ1bmN0aW9uIFNlcnZlcigpIHtcblx0ZGVidWcoJ1N0YXJ0aW5nIHNlcnZlciBzY2VuZSBpbml0aWFsaXphdGlvbiAuLi4nKTtcblxuXHRjb25zdCBzY2VuZSA9IG5ldyBTY2VuZShNb2NrUmVuZGVyZXIsIE1vY2tHVUkpO1xuXG5cdGRlYnVnKCdTY2VuZSBpcyBsb2FkZWQnLCB7XG5cdFx0VEhSRUU6IEJvb2xlYW4oVEhSRUUpLFxuXHRcdGRvY3VtZW50OiBCb29sZWFuKGRvY3VtZW50KSxcblx0XHR3aW5kb3c6IEJvb2xlYW4od2luZG93KSxcblx0XHRHTFRGTG9hZGVyOiBCb29sZWFuKEdMVEZMb2FkZXIpLFxuXHRcdHNjZW5lOiBCb29sZWFuKHNjZW5lKSxcblx0XHRzY2VuZUxvY2F0aW9uOiBCb29sZWFuKHNjZW5lLmxvY2F0aW9uKSxcblx0XHRzY2VuZUNvbGxpZGVyczogc2NlbmUuY29sbGlkZXJzLmNvbGxpZGVycy5sZW5ndGgsXG5cdFx0c2NlbmVBcmVhczogc2NlbmUucGF0aEZpbmRlci5hcmVhcy5sZW5ndGgsXG5cdFx0YWxpdmVVbml0czogc2NlbmUudW5pdHMuZ2V0QWxpdmVVbml0cygpLmxlbmd0aCxcblx0fSk7XG5cblx0Y29uc3QgcGxheWVyID0gc2NlbmUuZ2V0UGxheWVyKCk7XG5cblx0aWYgKHBsYXllcikge1xuXHRcdHBsYXllci5wYXJhbXMuaHAgPSAwO1xuXHR9XG5cblx0ZGVidWcoJ1N0YXJ0aW5nIHNvY2tldCBzZXJ2ZXIgLi4uJyk7XG5cdGNvbnN0IHNvY2tldFNlcnZlciA9IG5ldyBTb2NrZXRTZXJ2ZXIoKTtcblxuXHRjb25zdCB1cGRhdGVHYW1lT2JqZWN0cyA9ICgpID0+IHtcblx0XHRjb25zdCBkYXRhID0gW107XG5cblx0XHRzY2VuZS51bml0cy5nZXRBbGl2ZVVuaXRzKCkuZm9yRWFjaCgodW5pdCkgPT4ge1xuXHRcdFx0aWYgKCEodW5pdCBpbnN0YW5jZW9mIFBsYXllcikpIHtcblx0XHRcdFx0Y29uc3QgdW5pdERhdGEgPSBDb25uZWN0aW9uLnVuaXRUb05ldHdvcmsodW5pdCwgbnVsbCwgJ2RyZWFtLXRvd24nKTtcblxuXHRcdFx0XHRpZiAodW5pdERhdGEpIHtcblx0XHRcdFx0XHRkYXRhLnB1c2godW5pdERhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRzb2NrZXRTZXJ2ZXIuZGIuZ2FtZU9iamVjdHMgPSBkYXRhO1xuXG5cdFx0T2JqZWN0LnZhbHVlcyhzb2NrZXRTZXJ2ZXIuZGIucGxheWVycylcblx0XHRcdC5mb3JFYWNoKHNjZW5lLmNvbm5lY3Rpb24udXBkYXRlTmV0d29ya1BsYXllcik7XG5cdH07XG5cblx0c2V0SW50ZXJ2YWwodXBkYXRlR2FtZU9iamVjdHMsIDEwMCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlcnZlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW1cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidGxzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ6bGliXCIpOyJdLCJzb3VyY2VSb290IjoiIn0=